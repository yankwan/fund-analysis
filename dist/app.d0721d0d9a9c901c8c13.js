webpackJsonp([0],[function(module,exports,__webpack_require__){"use strict";eval('/* WEBPACK VAR INJECTION */(function(global) {\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * Random utility functions used in the UI-Router code\n *\n * These functions are exported, but are subject to change without notice.\n *\n * @preferred\n * @module common\n */\n/** for typedoc */\nvar predicates_1 = __webpack_require__(/*! ./predicates */ 1);\nvar hof_1 = __webpack_require__(/*! ./hof */ 2);\nvar coreservices_1 = __webpack_require__(/*! ./coreservices */ 3);\nexports.root = (typeof self === \'object\' && self.self === self && self) ||\n    (typeof global === \'object\' && global.global === global && global) || this;\nvar angular = exports.root.angular || {};\nexports.fromJson = angular.fromJson || JSON.parse.bind(JSON);\nexports.toJson = angular.toJson || JSON.stringify.bind(JSON);\nexports.forEach = angular.forEach || _forEach;\nexports.extend = Object.assign || _extend;\nexports.equals = angular.equals || _equals;\nfunction identity(x) { return x; }\nexports.identity = identity;\nfunction noop() { }\nexports.noop = noop;\n/**\n * Builds proxy functions on the `to` object which pass through to the `from` object.\n *\n * For each key in `fnNames`, creates a proxy function on the `to` object.\n * The proxy function calls the real function on the `from` object.\n *\n *\n * #### Example:\n * This example creates an new class instance whose functions are prebound to the new\'d object.\n * ```js\n * class Foo {\n *   constructor(data) {\n *     // Binds all functions from Foo.prototype to \'this\',\n *     // then copies them to \'this\'\n *     bindFunctions(Foo.prototype, this, this);\n *     this.data = data;\n *   }\n *\n *   log() {\n *     console.log(this.data);\n *   }\n * }\n *\n * let myFoo = new Foo([1,2,3]);\n * var logit = myFoo.log;\n * logit(); // logs [1, 2, 3] from the myFoo \'this\' instance\n * ```\n *\n * #### Example:\n * This example creates a bound version of a service function, and copies it to another object\n * ```\n *\n * var SomeService = {\n *   this.data = [3, 4, 5];\n *   this.log = function() {\n *     console.log(this.data);\n *   }\n * }\n *\n * // Constructor fn\n * function OtherThing() {\n *   // Binds all functions from SomeService to SomeService,\n *   // then copies them to \'this\'\n *   bindFunctions(SomeService, this, SomeService);\n * }\n *\n * let myOtherThing = new OtherThing();\n * myOtherThing.log(); // logs [3, 4, 5] from SomeService\'s \'this\'\n * ```\n *\n * @param source A function that returns the source object which contains the original functions to be bound\n * @param target A function that returns the target object which will receive the bound functions\n * @param bind A function that returns the object which the functions will be bound to\n * @param fnNames The function names which will be bound (Defaults to all the functions found on the \'from\' object)\n * @param latebind If true, the binding of the function is delayed until the first time it\'s invoked\n */\nfunction createProxyFunctions(source, target, bind, fnNames, latebind) {\n    if (latebind === void 0) { latebind = false; }\n    var bindFunction = function (fnName) {\n        return source()[fnName].bind(bind());\n    };\n    var makeLateRebindFn = function (fnName) { return function lateRebindFunction() {\n        target[fnName] = bindFunction(fnName);\n        return target[fnName].apply(null, arguments);\n    }; };\n    fnNames = fnNames || Object.keys(source());\n    return fnNames.reduce(function (acc, name) {\n        acc[name] = latebind ? makeLateRebindFn(name) : bindFunction(name);\n        return acc;\n    }, target);\n}\nexports.createProxyFunctions = createProxyFunctions;\n/**\n * prototypal inheritance helper.\n * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it\n */\nexports.inherit = function (parent, extra) {\n    return exports.extend(Object.create(parent), extra);\n};\n/** Given an array, returns true if the object is found in the array, (using indexOf) */\nexports.inArray = hof_1.curry(_inArray);\nfunction _inArray(array, obj) {\n    return array.indexOf(obj) !== -1;\n}\nexports._inArray = _inArray;\n/**\n * Given an array, and an item, if the item is found in the array, it removes it (in-place).\n * The same array is returned\n */\nexports.removeFrom = hof_1.curry(_removeFrom);\nfunction _removeFrom(array, obj) {\n    var idx = array.indexOf(obj);\n    if (idx >= 0)\n        array.splice(idx, 1);\n    return array;\n}\nexports._removeFrom = _removeFrom;\n/** pushes a values to an array and returns the value */\nexports.pushTo = hof_1.curry(_pushTo);\nfunction _pushTo(arr, val) {\n    return (arr.push(val), val);\n}\nexports._pushTo = _pushTo;\n/** Given an array of (deregistration) functions, calls all functions and removes each one from the source array */\nexports.deregAll = function (functions) {\n    return functions.slice().forEach(function (fn) {\n        typeof fn === \'function\' && fn();\n        exports.removeFrom(functions, fn);\n    });\n};\n/**\n * Applies a set of defaults to an options object.  The options object is filtered\n * to only those properties of the objects in the defaultsList.\n * Earlier objects in the defaultsList take precedence when applying defaults.\n */\nfunction defaults(opts) {\n    var defaultsList = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        defaultsList[_i - 1] = arguments[_i];\n    }\n    var _defaultsList = defaultsList.concat({}).reverse();\n    var defaultVals = exports.extend.apply(null, _defaultsList);\n    return exports.extend({}, defaultVals, pick(opts || {}, Object.keys(defaultVals)));\n}\nexports.defaults = defaults;\n/** Reduce function that merges each element of the list into a single object, using extend */\nexports.mergeR = function (memo, item) { return exports.extend(memo, item); };\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n    var path = [];\n    for (var n in first.path) {\n        if (first.path[n] !== second.path[n])\n            break;\n        path.push(first.path[n]);\n    }\n    return path;\n}\nexports.ancestors = ancestors;\n/**\n * Return a copy of the object only containing the whitelisted properties.\n *\n * #### Example:\n * ```\n * var foo = { a: 1, b: 2, c: 3 };\n * var ab = pick(foo, [\'a\', \'b\']); // { a: 1, b: 2 }\n * ```\n * @param obj the source object\n * @param propNames an Array of strings, which are the whitelisted property names\n */\nfunction pick(obj, propNames) {\n    var objCopy = {};\n    for (var prop_1 in obj) {\n        if (propNames.indexOf(prop_1) !== -1) {\n            objCopy[prop_1] = obj[prop_1];\n        }\n    }\n    return objCopy;\n}\nexports.pick = pick;\n/**\n * Return a copy of the object omitting the blacklisted properties.\n *\n * @example\n * ```\n *\n * var foo = { a: 1, b: 2, c: 3 };\n * var ab = omit(foo, [\'a\', \'b\']); // { c: 3 }\n * ```\n * @param obj the source object\n * @param propNames an Array of strings, which are the blacklisted property names\n */\nfunction omit(obj, propNames) {\n    return Object.keys(obj)\n        .filter(hof_1.not(exports.inArray(propNames)))\n        .reduce(function (acc, key) { return (acc[key] = obj[key], acc); }, {});\n}\nexports.omit = omit;\n/**\n * Maps an array, or object to a property (by name)\n */\nfunction pluck(collection, propName) {\n    return map(collection, hof_1.prop(propName));\n}\nexports.pluck = pluck;\n/** Filters an Array or an Object\'s properties based on a predicate */\nfunction filter(collection, callback) {\n    var arr = predicates_1.isArray(collection), result = arr ? [] : {};\n    var accept = arr ? function (x) { return result.push(x); } : function (x, key) { return result[key] = x; };\n    exports.forEach(collection, function (item, i) {\n        if (callback(item, i))\n            accept(item, i);\n    });\n    return result;\n}\nexports.filter = filter;\n/** Finds an object from an array, or a property of an object, that matches a predicate */\nfunction find(collection, callback) {\n    var result;\n    exports.forEach(collection, function (item, i) {\n        if (result)\n            return;\n        if (callback(item, i))\n            result = item;\n    });\n    return result;\n}\nexports.find = find;\n/** Given an object, returns a new object, where each property is transformed by the callback function */\nexports.mapObj = map;\n/** Maps an array or object properties using a callback function */\nfunction map(collection, callback) {\n    var result = predicates_1.isArray(collection) ? [] : {};\n    exports.forEach(collection, function (item, i) { return result[i] = callback(item, i); });\n    return result;\n}\nexports.map = map;\n/**\n * Given an object, return its enumerable property values\n *\n * @example\n * ```\n *\n * let foo = { a: 1, b: 2, c: 3 }\n * let vals = values(foo); // [ 1, 2, 3 ]\n * ```\n */\nexports.values = function (obj) {\n    return Object.keys(obj).map(function (key) { return obj[key]; });\n};\n/**\n * Reduce function that returns true if all of the values are truthy.\n *\n * @example\n * ```\n *\n * let vals = [ 1, true, {}, "hello world"];\n * vals.reduce(allTrueR, true); // true\n *\n * vals.push(0);\n * vals.reduce(allTrueR, true); // false\n * ```\n */\nexports.allTrueR = function (memo, elem) { return memo && elem; };\n/**\n * Reduce function that returns true if any of the values are truthy.\n *\n *  * @example\n * ```\n *\n * let vals = [ 0, null, undefined ];\n * vals.reduce(anyTrueR, true); // false\n *\n * vals.push("hello world");\n * vals.reduce(anyTrueR, true); // true\n * ```\n */\nexports.anyTrueR = function (memo, elem) { return memo || elem; };\n/**\n * Reduce function which un-nests a single level of arrays\n * @example\n * ```\n *\n * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];\n * input.reduce(unnestR, []) // [ "a", "b", "c", "d", [ "double, "nested" ] ]\n * ```\n */\nexports.unnestR = function (memo, elem) { return memo.concat(elem); };\n/**\n * Reduce function which recursively un-nests all arrays\n *\n * @example\n * ```\n *\n * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];\n * input.reduce(unnestR, []) // [ "a", "b", "c", "d", "double, "nested" ]\n * ```\n */\nexports.flattenR = function (memo, elem) {\n    return predicates_1.isArray(elem) ? memo.concat(elem.reduce(exports.flattenR, [])) : pushR(memo, elem);\n};\n/**\n * Reduce function that pushes an object to an array, then returns the array.\n * Mostly just for [[flattenR]] and [[uniqR]]\n */\nfunction pushR(arr, obj) {\n    arr.push(obj);\n    return arr;\n}\nexports.pushR = pushR;\n/** Reduce function that filters out duplicates */\nexports.uniqR = function (acc, token) {\n    return exports.inArray(acc, token) ? acc : pushR(acc, token);\n};\n/**\n * Return a new array with a single level of arrays unnested.\n *\n * @example\n * ```\n *\n * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];\n * unnest(input) // [ "a", "b", "c", "d", [ "double, "nested" ] ]\n * ```\n */\nexports.unnest = function (arr) { return arr.reduce(exports.unnestR, []); };\n/**\n * Return a completely flattened version of an array.\n *\n * @example\n * ```\n *\n * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];\n * flatten(input) // [ "a", "b", "c", "d", "double, "nested" ]\n * ```\n */\nexports.flatten = function (arr) { return arr.reduce(exports.flattenR, []); };\n/**\n * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.\n * @example\n * ```\n *\n * let isNumber = (obj) => typeof(obj) === \'number\';\n * let allNumbers = [ 1, 2, 3, 4, 5 ];\n * allNumbers.filter(assertPredicate(isNumber)); //OK\n *\n * let oneString = [ 1, 2, 3, 4, "5" ];\n * oneString.filter(assertPredicate(isNumber, "Not all numbers")); // throws Error(""Not all numbers"");\n * ```\n */\nexports.assertPredicate = assertFn;\n/**\n * Given a .map function, builds a .map function which throws an error if any mapped elements do not pass a truthyness test.\n * @example\n * ```\n *\n * var data = { foo: 1, bar: 2 };\n *\n * let keys = [ \'foo\', \'bar\' ]\n * let values = keys.map(assertMap(key => data[key], "Key not found"));\n * // values is [1, 2]\n *\n * let keys = [ \'foo\', \'bar\', \'baz\' ]\n * let values = keys.map(assertMap(key => data[key], "Key not found"));\n * // throws Error("Key not found")\n * ```\n */\nexports.assertMap = assertFn;\nfunction assertFn(predicateOrMap, errMsg) {\n    if (errMsg === void 0) { errMsg = "assert failure"; }\n    return function (obj) {\n        var result = predicateOrMap(obj);\n        if (!result) {\n            throw new Error(predicates_1.isFunction(errMsg) ? errMsg(obj) : errMsg);\n        }\n        return result;\n    };\n}\nexports.assertFn = assertFn;\n/**\n * Like _.pairs: Given an object, returns an array of key/value pairs\n *\n * @example\n * ```\n *\n * pairs({ foo: "FOO", bar: "BAR }) // [ [ "foo", "FOO" ], [ "bar": "BAR" ] ]\n * ```\n */\nexports.pairs = function (obj) {\n    return Object.keys(obj).map(function (key) { return [key, obj[key]]; });\n};\n/**\n * Given two or more parallel arrays, returns an array of tuples where\n * each tuple is composed of [ a[i], b[i], ... z[i] ]\n *\n * @example\n * ```\n *\n * let foo = [ 0, 2, 4, 6 ];\n * let bar = [ 1, 3, 5, 7 ];\n * let baz = [ 10, 30, 50, 70 ];\n * arrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]\n * arrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]\n * ```\n */\nfunction arrayTuples() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 0)\n        return [];\n    var maxArrayLen = args.reduce(function (min, arr) { return Math.min(arr.length, min); }, 9007199254740991); // aka 2^53 − 1 aka Number.MAX_SAFE_INTEGER\n    var i, result = [];\n    for (i = 0; i < maxArrayLen; i++) {\n        // This is a hot function\n        // Unroll when there are 1-4 arguments\n        switch (args.length) {\n            case 1:\n                result.push([args[0][i]]);\n                break;\n            case 2:\n                result.push([args[0][i], args[1][i]]);\n                break;\n            case 3:\n                result.push([args[0][i], args[1][i], args[2][i]]);\n                break;\n            case 4:\n                result.push([args[0][i], args[1][i], args[2][i], args[3][i]]);\n                break;\n            default:\n                result.push(args.map(function (array) { return array[i]; }));\n                break;\n        }\n    }\n    return result;\n}\nexports.arrayTuples = arrayTuples;\n/**\n * Reduce function which builds an object from an array of [key, value] pairs.\n *\n * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.\n *\n * Each keyValueTuple should be an array with values [ key: string, value: any ]\n *\n * @example\n * ```\n *\n * var pairs = [ ["fookey", "fooval"], ["barkey", "barval"] ]\n *\n * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})\n * // pairsToObj == { fookey: "fooval", barkey: "barval" }\n *\n * // Or, more simply:\n * var pairsToObj = pairs.reduce(applyPairs, {})\n * // pairsToObj == { fookey: "fooval", barkey: "barval" }\n * ```\n */\nfunction applyPairs(memo, keyValTuple) {\n    var key, value;\n    if (predicates_1.isArray(keyValTuple))\n        key = keyValTuple[0], value = keyValTuple[1];\n    if (!predicates_1.isString(key))\n        throw new Error("invalid parameters to applyPairs");\n    memo[key] = value;\n    return memo;\n}\nexports.applyPairs = applyPairs;\n/** Get the last element of an array */\nfunction tail(arr) {\n    return arr.length && arr[arr.length - 1] || undefined;\n}\nexports.tail = tail;\n/**\n * shallow copy from src to dest\n */\nfunction copy(src, dest) {\n    if (dest)\n        Object.keys(dest).forEach(function (key) { return delete dest[key]; });\n    if (!dest)\n        dest = {};\n    return exports.extend(dest, src);\n}\nexports.copy = copy;\n/** Naive forEach implementation works with Objects or Arrays */\nfunction _forEach(obj, cb, _this) {\n    if (predicates_1.isArray(obj))\n        return obj.forEach(cb, _this);\n    Object.keys(obj).forEach(function (key) { return cb(obj[key], key); });\n}\nfunction _extend(toObj) {\n    for (var i = 1; i < arguments.length; i++) {\n        var obj = arguments[i];\n        if (!obj)\n            continue;\n        var keys = Object.keys(obj);\n        for (var j = 0; j < keys.length; j++) {\n            toObj[keys[j]] = obj[keys[j]];\n        }\n    }\n    return toObj;\n}\nexports._extend = _extend;\nfunction _equals(o1, o2) {\n    if (o1 === o2)\n        return true;\n    if (o1 === null || o2 === null)\n        return false;\n    if (o1 !== o1 && o2 !== o2)\n        return true; // NaN === NaN\n    var t1 = typeof o1, t2 = typeof o2;\n    if (t1 !== t2 || t1 !== \'object\')\n        return false;\n    var tup = [o1, o2];\n    if (hof_1.all(predicates_1.isArray)(tup))\n        return _arraysEq(o1, o2);\n    if (hof_1.all(predicates_1.isDate)(tup))\n        return o1.getTime() === o2.getTime();\n    if (hof_1.all(predicates_1.isRegExp)(tup))\n        return o1.toString() === o2.toString();\n    if (hof_1.all(predicates_1.isFunction)(tup))\n        return true; // meh\n    var predicates = [predicates_1.isFunction, predicates_1.isArray, predicates_1.isDate, predicates_1.isRegExp];\n    if (predicates.map(hof_1.any).reduce(function (b, fn) { return b || !!fn(tup); }, false))\n        return false;\n    var key, keys = {};\n    for (key in o1) {\n        if (!_equals(o1[key], o2[key]))\n            return false;\n        keys[key] = true;\n    }\n    for (key in o2) {\n        if (!keys[key])\n            return false;\n    }\n    return true;\n}\nfunction _arraysEq(a1, a2) {\n    if (a1.length !== a2.length)\n        return false;\n    return arrayTuples(a1, a2).reduce(function (b, t) { return b && _equals(t[0], t[1]); }, true);\n}\n// issue #2676\nexports.silenceUncaughtInPromise = function (promise) {\n    return promise.catch(function (e) { return 0; }) && promise;\n};\nexports.silentRejection = function (error) {\n    return exports.silenceUncaughtInPromise(coreservices_1.services.$q.reject(error));\n};\n//# sourceMappingURL=common.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ 110)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9jb21tb24uanM/ODhhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogUmFuZG9tIHV0aWxpdHkgZnVuY3Rpb25zIHVzZWQgaW4gdGhlIFVJLVJvdXRlciBjb2RlXG4gKlxuICogVGhlc2UgZnVuY3Rpb25zIGFyZSBleHBvcnRlZCwgYnV0IGFyZSBzdWJqZWN0IHRvIGNoYW5nZSB3aXRob3V0IG5vdGljZS5cbiAqXG4gKiBAcHJlZmVycmVkXG4gKiBAbW9kdWxlIGNvbW1vblxuICovXG4vKiogZm9yIHR5cGVkb2MgKi9cbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi9wcmVkaWNhdGVzXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4vaG9mXCIpO1xudmFyIGNvcmVzZXJ2aWNlc18xID0gcmVxdWlyZShcIi4vY29yZXNlcnZpY2VzXCIpO1xuZXhwb3J0cy5yb290ID0gKHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JyAmJiBzZWxmLnNlbGYgPT09IHNlbGYgJiYgc2VsZikgfHxcbiAgICAodHlwZW9mIGdsb2JhbCA9PT0gJ29iamVjdCcgJiYgZ2xvYmFsLmdsb2JhbCA9PT0gZ2xvYmFsICYmIGdsb2JhbCkgfHwgdGhpcztcbnZhciBhbmd1bGFyID0gZXhwb3J0cy5yb290LmFuZ3VsYXIgfHwge307XG5leHBvcnRzLmZyb21Kc29uID0gYW5ndWxhci5mcm9tSnNvbiB8fCBKU09OLnBhcnNlLmJpbmQoSlNPTik7XG5leHBvcnRzLnRvSnNvbiA9IGFuZ3VsYXIudG9Kc29uIHx8IEpTT04uc3RyaW5naWZ5LmJpbmQoSlNPTik7XG5leHBvcnRzLmZvckVhY2ggPSBhbmd1bGFyLmZvckVhY2ggfHwgX2ZvckVhY2g7XG5leHBvcnRzLmV4dGVuZCA9IE9iamVjdC5hc3NpZ24gfHwgX2V4dGVuZDtcbmV4cG9ydHMuZXF1YWxzID0gYW5ndWxhci5lcXVhbHMgfHwgX2VxdWFscztcbmZ1bmN0aW9uIGlkZW50aXR5KHgpIHsgcmV0dXJuIHg7IH1cbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbmV4cG9ydHMubm9vcCA9IG5vb3A7XG4vKipcbiAqIEJ1aWxkcyBwcm94eSBmdW5jdGlvbnMgb24gdGhlIGB0b2Agb2JqZWN0IHdoaWNoIHBhc3MgdGhyb3VnaCB0byB0aGUgYGZyb21gIG9iamVjdC5cbiAqXG4gKiBGb3IgZWFjaCBrZXkgaW4gYGZuTmFtZXNgLCBjcmVhdGVzIGEgcHJveHkgZnVuY3Rpb24gb24gdGhlIGB0b2Agb2JqZWN0LlxuICogVGhlIHByb3h5IGZ1bmN0aW9uIGNhbGxzIHRoZSByZWFsIGZ1bmN0aW9uIG9uIHRoZSBgZnJvbWAgb2JqZWN0LlxuICpcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBUaGlzIGV4YW1wbGUgY3JlYXRlcyBhbiBuZXcgY2xhc3MgaW5zdGFuY2Ugd2hvc2UgZnVuY3Rpb25zIGFyZSBwcmVib3VuZCB0byB0aGUgbmV3J2Qgb2JqZWN0LlxuICogYGBganNcbiAqIGNsYXNzIEZvbyB7XG4gKiAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAqICAgICAvLyBCaW5kcyBhbGwgZnVuY3Rpb25zIGZyb20gRm9vLnByb3RvdHlwZSB0byAndGhpcycsXG4gKiAgICAgLy8gdGhlbiBjb3BpZXMgdGhlbSB0byAndGhpcydcbiAqICAgICBiaW5kRnVuY3Rpb25zKEZvby5wcm90b3R5cGUsIHRoaXMsIHRoaXMpO1xuICogICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gKiAgIH1cbiAqXG4gKiAgIGxvZygpIHtcbiAqICAgICBjb25zb2xlLmxvZyh0aGlzLmRhdGEpO1xuICogICB9XG4gKiB9XG4gKlxuICogbGV0IG15Rm9vID0gbmV3IEZvbyhbMSwyLDNdKTtcbiAqIHZhciBsb2dpdCA9IG15Rm9vLmxvZztcbiAqIGxvZ2l0KCk7IC8vIGxvZ3MgWzEsIDIsIDNdIGZyb20gdGhlIG15Rm9vICd0aGlzJyBpbnN0YW5jZVxuICogYGBgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogVGhpcyBleGFtcGxlIGNyZWF0ZXMgYSBib3VuZCB2ZXJzaW9uIG9mIGEgc2VydmljZSBmdW5jdGlvbiwgYW5kIGNvcGllcyBpdCB0byBhbm90aGVyIG9iamVjdFxuICogYGBgXG4gKlxuICogdmFyIFNvbWVTZXJ2aWNlID0ge1xuICogICB0aGlzLmRhdGEgPSBbMywgNCwgNV07XG4gKiAgIHRoaXMubG9nID0gZnVuY3Rpb24oKSB7XG4gKiAgICAgY29uc29sZS5sb2codGhpcy5kYXRhKTtcbiAqICAgfVxuICogfVxuICpcbiAqIC8vIENvbnN0cnVjdG9yIGZuXG4gKiBmdW5jdGlvbiBPdGhlclRoaW5nKCkge1xuICogICAvLyBCaW5kcyBhbGwgZnVuY3Rpb25zIGZyb20gU29tZVNlcnZpY2UgdG8gU29tZVNlcnZpY2UsXG4gKiAgIC8vIHRoZW4gY29waWVzIHRoZW0gdG8gJ3RoaXMnXG4gKiAgIGJpbmRGdW5jdGlvbnMoU29tZVNlcnZpY2UsIHRoaXMsIFNvbWVTZXJ2aWNlKTtcbiAqIH1cbiAqXG4gKiBsZXQgbXlPdGhlclRoaW5nID0gbmV3IE90aGVyVGhpbmcoKTtcbiAqIG15T3RoZXJUaGluZy5sb2coKTsgLy8gbG9ncyBbMywgNCwgNV0gZnJvbSBTb21lU2VydmljZSdzICd0aGlzJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHNvdXJjZSBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgc291cmNlIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgb3JpZ2luYWwgZnVuY3Rpb25zIHRvIGJlIGJvdW5kXG4gKiBAcGFyYW0gdGFyZ2V0IEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB0YXJnZXQgb2JqZWN0IHdoaWNoIHdpbGwgcmVjZWl2ZSB0aGUgYm91bmQgZnVuY3Rpb25zXG4gKiBAcGFyYW0gYmluZCBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgb2JqZWN0IHdoaWNoIHRoZSBmdW5jdGlvbnMgd2lsbCBiZSBib3VuZCB0b1xuICogQHBhcmFtIGZuTmFtZXMgVGhlIGZ1bmN0aW9uIG5hbWVzIHdoaWNoIHdpbGwgYmUgYm91bmQgKERlZmF1bHRzIHRvIGFsbCB0aGUgZnVuY3Rpb25zIGZvdW5kIG9uIHRoZSAnZnJvbScgb2JqZWN0KVxuICogQHBhcmFtIGxhdGViaW5kIElmIHRydWUsIHRoZSBiaW5kaW5nIG9mIHRoZSBmdW5jdGlvbiBpcyBkZWxheWVkIHVudGlsIHRoZSBmaXJzdCB0aW1lIGl0J3MgaW52b2tlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVQcm94eUZ1bmN0aW9ucyhzb3VyY2UsIHRhcmdldCwgYmluZCwgZm5OYW1lcywgbGF0ZWJpbmQpIHtcbiAgICBpZiAobGF0ZWJpbmQgPT09IHZvaWQgMCkgeyBsYXRlYmluZCA9IGZhbHNlOyB9XG4gICAgdmFyIGJpbmRGdW5jdGlvbiA9IGZ1bmN0aW9uIChmbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZSgpW2ZuTmFtZV0uYmluZChiaW5kKCkpO1xuICAgIH07XG4gICAgdmFyIG1ha2VMYXRlUmViaW5kRm4gPSBmdW5jdGlvbiAoZm5OYW1lKSB7IHJldHVybiBmdW5jdGlvbiBsYXRlUmViaW5kRnVuY3Rpb24oKSB7XG4gICAgICAgIHRhcmdldFtmbk5hbWVdID0gYmluZEZ1bmN0aW9uKGZuTmFtZSk7XG4gICAgICAgIHJldHVybiB0YXJnZXRbZm5OYW1lXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH07IH07XG4gICAgZm5OYW1lcyA9IGZuTmFtZXMgfHwgT2JqZWN0LmtleXMoc291cmNlKCkpO1xuICAgIHJldHVybiBmbk5hbWVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBuYW1lKSB7XG4gICAgICAgIGFjY1tuYW1lXSA9IGxhdGViaW5kID8gbWFrZUxhdGVSZWJpbmRGbihuYW1lKSA6IGJpbmRGdW5jdGlvbihuYW1lKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB0YXJnZXQpO1xufVxuZXhwb3J0cy5jcmVhdGVQcm94eUZ1bmN0aW9ucyA9IGNyZWF0ZVByb3h5RnVuY3Rpb25zO1xuLyoqXG4gKiBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGhlbHBlci5cbiAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHdoaWNoIGhhcyBgcGFyZW50YCBvYmplY3QgYXMgaXRzIHByb3RvdHlwZSwgYW5kIHRoZW4gY29waWVzIHRoZSBwcm9wZXJ0aWVzIGZyb20gYGV4dHJhYCBvbnRvIGl0XG4gKi9cbmV4cG9ydHMuaW5oZXJpdCA9IGZ1bmN0aW9uIChwYXJlbnQsIGV4dHJhKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZXh0ZW5kKE9iamVjdC5jcmVhdGUocGFyZW50KSwgZXh0cmEpO1xufTtcbi8qKiBHaXZlbiBhbiBhcnJheSwgcmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgZm91bmQgaW4gdGhlIGFycmF5LCAodXNpbmcgaW5kZXhPZikgKi9cbmV4cG9ydHMuaW5BcnJheSA9IGhvZl8xLmN1cnJ5KF9pbkFycmF5KTtcbmZ1bmN0aW9uIF9pbkFycmF5KGFycmF5LCBvYmopIHtcbiAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihvYmopICE9PSAtMTtcbn1cbmV4cG9ydHMuX2luQXJyYXkgPSBfaW5BcnJheTtcbi8qKlxuICogR2l2ZW4gYW4gYXJyYXksIGFuZCBhbiBpdGVtLCBpZiB0aGUgaXRlbSBpcyBmb3VuZCBpbiB0aGUgYXJyYXksIGl0IHJlbW92ZXMgaXQgKGluLXBsYWNlKS5cbiAqIFRoZSBzYW1lIGFycmF5IGlzIHJldHVybmVkXG4gKi9cbmV4cG9ydHMucmVtb3ZlRnJvbSA9IGhvZl8xLmN1cnJ5KF9yZW1vdmVGcm9tKTtcbmZ1bmN0aW9uIF9yZW1vdmVGcm9tKGFycmF5LCBvYmopIHtcbiAgICB2YXIgaWR4ID0gYXJyYXkuaW5kZXhPZihvYmopO1xuICAgIGlmIChpZHggPj0gMClcbiAgICAgICAgYXJyYXkuc3BsaWNlKGlkeCwgMSk7XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZXhwb3J0cy5fcmVtb3ZlRnJvbSA9IF9yZW1vdmVGcm9tO1xuLyoqIHB1c2hlcyBhIHZhbHVlcyB0byBhbiBhcnJheSBhbmQgcmV0dXJucyB0aGUgdmFsdWUgKi9cbmV4cG9ydHMucHVzaFRvID0gaG9mXzEuY3VycnkoX3B1c2hUbyk7XG5mdW5jdGlvbiBfcHVzaFRvKGFyciwgdmFsKSB7XG4gICAgcmV0dXJuIChhcnIucHVzaCh2YWwpLCB2YWwpO1xufVxuZXhwb3J0cy5fcHVzaFRvID0gX3B1c2hUbztcbi8qKiBHaXZlbiBhbiBhcnJheSBvZiAoZGVyZWdpc3RyYXRpb24pIGZ1bmN0aW9ucywgY2FsbHMgYWxsIGZ1bmN0aW9ucyBhbmQgcmVtb3ZlcyBlYWNoIG9uZSBmcm9tIHRoZSBzb3VyY2UgYXJyYXkgKi9cbmV4cG9ydHMuZGVyZWdBbGwgPSBmdW5jdGlvbiAoZnVuY3Rpb25zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9ucy5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiBmbigpO1xuICAgICAgICBleHBvcnRzLnJlbW92ZUZyb20oZnVuY3Rpb25zLCBmbik7XG4gICAgfSk7XG59O1xuLyoqXG4gKiBBcHBsaWVzIGEgc2V0IG9mIGRlZmF1bHRzIHRvIGFuIG9wdGlvbnMgb2JqZWN0LiAgVGhlIG9wdGlvbnMgb2JqZWN0IGlzIGZpbHRlcmVkXG4gKiB0byBvbmx5IHRob3NlIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdHMgaW4gdGhlIGRlZmF1bHRzTGlzdC5cbiAqIEVhcmxpZXIgb2JqZWN0cyBpbiB0aGUgZGVmYXVsdHNMaXN0IHRha2UgcHJlY2VkZW5jZSB3aGVuIGFwcGx5aW5nIGRlZmF1bHRzLlxuICovXG5mdW5jdGlvbiBkZWZhdWx0cyhvcHRzKSB7XG4gICAgdmFyIGRlZmF1bHRzTGlzdCA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGRlZmF1bHRzTGlzdFtfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIF9kZWZhdWx0c0xpc3QgPSBkZWZhdWx0c0xpc3QuY29uY2F0KHt9KS5yZXZlcnNlKCk7XG4gICAgdmFyIGRlZmF1bHRWYWxzID0gZXhwb3J0cy5leHRlbmQuYXBwbHkobnVsbCwgX2RlZmF1bHRzTGlzdCk7XG4gICAgcmV0dXJuIGV4cG9ydHMuZXh0ZW5kKHt9LCBkZWZhdWx0VmFscywgcGljayhvcHRzIHx8IHt9LCBPYmplY3Qua2V5cyhkZWZhdWx0VmFscykpKTtcbn1cbmV4cG9ydHMuZGVmYXVsdHMgPSBkZWZhdWx0cztcbi8qKiBSZWR1Y2UgZnVuY3Rpb24gdGhhdCBtZXJnZXMgZWFjaCBlbGVtZW50IG9mIHRoZSBsaXN0IGludG8gYSBzaW5nbGUgb2JqZWN0LCB1c2luZyBleHRlbmQgKi9cbmV4cG9ydHMubWVyZ2VSID0gZnVuY3Rpb24gKG1lbW8sIGl0ZW0pIHsgcmV0dXJuIGV4cG9ydHMuZXh0ZW5kKG1lbW8sIGl0ZW0pOyB9O1xuLyoqXG4gKiBGaW5kcyB0aGUgY29tbW9uIGFuY2VzdG9yIHBhdGggYmV0d2VlbiB0d28gc3RhdGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaXJzdCBUaGUgZmlyc3Qgc3RhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gc2Vjb25kIFRoZSBzZWNvbmQgc3RhdGUuXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBzdGF0ZSBuYW1lcyBpbiBkZXNjZW5kaW5nIG9yZGVyLCBub3QgaW5jbHVkaW5nIHRoZSByb290LlxuICovXG5mdW5jdGlvbiBhbmNlc3RvcnMoZmlyc3QsIHNlY29uZCkge1xuICAgIHZhciBwYXRoID0gW107XG4gICAgZm9yICh2YXIgbiBpbiBmaXJzdC5wYXRoKSB7XG4gICAgICAgIGlmIChmaXJzdC5wYXRoW25dICE9PSBzZWNvbmQucGF0aFtuXSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBwYXRoLnB1c2goZmlyc3QucGF0aFtuXSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuZXhwb3J0cy5hbmNlc3RvcnMgPSBhbmNlc3RvcnM7XG4vKipcbiAqIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogYGBgXG4gKiB2YXIgZm9vID0geyBhOiAxLCBiOiAyLCBjOiAzIH07XG4gKiB2YXIgYWIgPSBwaWNrKGZvbywgWydhJywgJ2InXSk7IC8vIHsgYTogMSwgYjogMiB9XG4gKiBgYGBcbiAqIEBwYXJhbSBvYmogdGhlIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSBwcm9wTmFtZXMgYW4gQXJyYXkgb2Ygc3RyaW5ncywgd2hpY2ggYXJlIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0eSBuYW1lc1xuICovXG5mdW5jdGlvbiBwaWNrKG9iaiwgcHJvcE5hbWVzKSB7XG4gICAgdmFyIG9iakNvcHkgPSB7fTtcbiAgICBmb3IgKHZhciBwcm9wXzEgaW4gb2JqKSB7XG4gICAgICAgIGlmIChwcm9wTmFtZXMuaW5kZXhPZihwcm9wXzEpICE9PSAtMSkge1xuICAgICAgICAgICAgb2JqQ29weVtwcm9wXzFdID0gb2JqW3Byb3BfMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iakNvcHk7XG59XG5leHBvcnRzLnBpY2sgPSBwaWNrO1xuLyoqXG4gKiBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb21pdHRpbmcgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICpcbiAqIHZhciBmb28gPSB7IGE6IDEsIGI6IDIsIGM6IDMgfTtcbiAqIHZhciBhYiA9IG9taXQoZm9vLCBbJ2EnLCAnYiddKTsgLy8geyBjOiAzIH1cbiAqIGBgYFxuICogQHBhcmFtIG9iaiB0aGUgc291cmNlIG9iamVjdFxuICogQHBhcmFtIHByb3BOYW1lcyBhbiBBcnJheSBvZiBzdHJpbmdzLCB3aGljaCBhcmUgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnR5IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIG9taXQob2JqLCBwcm9wTmFtZXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKVxuICAgICAgICAuZmlsdGVyKGhvZl8xLm5vdChleHBvcnRzLmluQXJyYXkocHJvcE5hbWVzKSkpXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7IHJldHVybiAoYWNjW2tleV0gPSBvYmpba2V5XSwgYWNjKTsgfSwge30pO1xufVxuZXhwb3J0cy5vbWl0ID0gb21pdDtcbi8qKlxuICogTWFwcyBhbiBhcnJheSwgb3Igb2JqZWN0IHRvIGEgcHJvcGVydHkgKGJ5IG5hbWUpXG4gKi9cbmZ1bmN0aW9uIHBsdWNrKGNvbGxlY3Rpb24sIHByb3BOYW1lKSB7XG4gICAgcmV0dXJuIG1hcChjb2xsZWN0aW9uLCBob2ZfMS5wcm9wKHByb3BOYW1lKSk7XG59XG5leHBvcnRzLnBsdWNrID0gcGx1Y2s7XG4vKiogRmlsdGVycyBhbiBBcnJheSBvciBhbiBPYmplY3QncyBwcm9wZXJ0aWVzIGJhc2VkIG9uIGEgcHJlZGljYXRlICovXG5mdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgY2FsbGJhY2spIHtcbiAgICB2YXIgYXJyID0gcHJlZGljYXRlc18xLmlzQXJyYXkoY29sbGVjdGlvbiksIHJlc3VsdCA9IGFyciA/IFtdIDoge307XG4gICAgdmFyIGFjY2VwdCA9IGFyciA/IGZ1bmN0aW9uICh4KSB7IHJldHVybiByZXN1bHQucHVzaCh4KTsgfSA6IGZ1bmN0aW9uICh4LCBrZXkpIHsgcmV0dXJuIHJlc3VsdFtrZXldID0geDsgfTtcbiAgICBleHBvcnRzLmZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKGl0ZW0sIGkpKVxuICAgICAgICAgICAgYWNjZXB0KGl0ZW0sIGkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcbi8qKiBGaW5kcyBhbiBvYmplY3QgZnJvbSBhbiBhcnJheSwgb3IgYSBwcm9wZXJ0eSBvZiBhbiBvYmplY3QsIHRoYXQgbWF0Y2hlcyBhIHByZWRpY2F0ZSAqL1xuZnVuY3Rpb24gZmluZChjb2xsZWN0aW9uLCBjYWxsYmFjaykge1xuICAgIHZhciByZXN1bHQ7XG4gICAgZXhwb3J0cy5mb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChjYWxsYmFjayhpdGVtLCBpKSlcbiAgICAgICAgICAgIHJlc3VsdCA9IGl0ZW07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZmluZCA9IGZpbmQ7XG4vKiogR2l2ZW4gYW4gb2JqZWN0LCByZXR1cm5zIGEgbmV3IG9iamVjdCwgd2hlcmUgZWFjaCBwcm9wZXJ0eSBpcyB0cmFuc2Zvcm1lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gKi9cbmV4cG9ydHMubWFwT2JqID0gbWFwO1xuLyoqIE1hcHMgYW4gYXJyYXkgb3Igb2JqZWN0IHByb3BlcnRpZXMgdXNpbmcgYSBjYWxsYmFjayBmdW5jdGlvbiAqL1xuZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlc3VsdCA9IHByZWRpY2F0ZXNfMS5pc0FycmF5KGNvbGxlY3Rpb24pID8gW10gOiB7fTtcbiAgICBleHBvcnRzLmZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24gKGl0ZW0sIGkpIHsgcmV0dXJuIHJlc3VsdFtpXSA9IGNhbGxiYWNrKGl0ZW0sIGkpOyB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5tYXAgPSBtYXA7XG4vKipcbiAqIEdpdmVuIGFuIG9iamVjdCwgcmV0dXJuIGl0cyBlbnVtZXJhYmxlIHByb3BlcnR5IHZhbHVlc1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiBsZXQgZm9vID0geyBhOiAxLCBiOiAyLCBjOiAzIH1cbiAqIGxldCB2YWxzID0gdmFsdWVzKGZvbyk7IC8vIFsgMSwgMiwgMyBdXG4gKiBgYGBcbiAqL1xuZXhwb3J0cy52YWx1ZXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIG9ialtrZXldOyB9KTtcbn07XG4vKipcbiAqIFJlZHVjZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiBhbGwgb2YgdGhlIHZhbHVlcyBhcmUgdHJ1dGh5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiBsZXQgdmFscyA9IFsgMSwgdHJ1ZSwge30sIFwiaGVsbG8gd29ybGRcIl07XG4gKiB2YWxzLnJlZHVjZShhbGxUcnVlUiwgdHJ1ZSk7IC8vIHRydWVcbiAqXG4gKiB2YWxzLnB1c2goMCk7XG4gKiB2YWxzLnJlZHVjZShhbGxUcnVlUiwgdHJ1ZSk7IC8vIGZhbHNlXG4gKiBgYGBcbiAqL1xuZXhwb3J0cy5hbGxUcnVlUiA9IGZ1bmN0aW9uIChtZW1vLCBlbGVtKSB7IHJldHVybiBtZW1vICYmIGVsZW07IH07XG4vKipcbiAqIFJlZHVjZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiBhbnkgb2YgdGhlIHZhbHVlcyBhcmUgdHJ1dGh5LlxuICpcbiAqICAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiBsZXQgdmFscyA9IFsgMCwgbnVsbCwgdW5kZWZpbmVkIF07XG4gKiB2YWxzLnJlZHVjZShhbnlUcnVlUiwgdHJ1ZSk7IC8vIGZhbHNlXG4gKlxuICogdmFscy5wdXNoKFwiaGVsbG8gd29ybGRcIik7XG4gKiB2YWxzLnJlZHVjZShhbnlUcnVlUiwgdHJ1ZSk7IC8vIHRydWVcbiAqIGBgYFxuICovXG5leHBvcnRzLmFueVRydWVSID0gZnVuY3Rpb24gKG1lbW8sIGVsZW0pIHsgcmV0dXJuIG1lbW8gfHwgZWxlbTsgfTtcbi8qKlxuICogUmVkdWNlIGZ1bmN0aW9uIHdoaWNoIHVuLW5lc3RzIGEgc2luZ2xlIGxldmVsIG9mIGFycmF5c1xuICogQGV4YW1wbGVcbiAqIGBgYFxuICpcbiAqIGxldCBpbnB1dCA9IFsgWyBcImFcIiwgXCJiXCIgXSwgWyBcImNcIiwgXCJkXCIgXSwgWyBbIFwiZG91YmxlXCIsIFwibmVzdGVkXCIgXSBdIF07XG4gKiBpbnB1dC5yZWR1Y2UodW5uZXN0UiwgW10pIC8vIFsgXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFsgXCJkb3VibGUsIFwibmVzdGVkXCIgXSBdXG4gKiBgYGBcbiAqL1xuZXhwb3J0cy51bm5lc3RSID0gZnVuY3Rpb24gKG1lbW8sIGVsZW0pIHsgcmV0dXJuIG1lbW8uY29uY2F0KGVsZW0pOyB9O1xuLyoqXG4gKiBSZWR1Y2UgZnVuY3Rpb24gd2hpY2ggcmVjdXJzaXZlbHkgdW4tbmVzdHMgYWxsIGFycmF5c1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiBsZXQgaW5wdXQgPSBbIFsgXCJhXCIsIFwiYlwiIF0sIFsgXCJjXCIsIFwiZFwiIF0sIFsgWyBcImRvdWJsZVwiLCBcIm5lc3RlZFwiIF0gXSBdO1xuICogaW5wdXQucmVkdWNlKHVubmVzdFIsIFtdKSAvLyBbIFwiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBcImRvdWJsZSwgXCJuZXN0ZWRcIiBdXG4gKiBgYGBcbiAqL1xuZXhwb3J0cy5mbGF0dGVuUiA9IGZ1bmN0aW9uIChtZW1vLCBlbGVtKSB7XG4gICAgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc0FycmF5KGVsZW0pID8gbWVtby5jb25jYXQoZWxlbS5yZWR1Y2UoZXhwb3J0cy5mbGF0dGVuUiwgW10pKSA6IHB1c2hSKG1lbW8sIGVsZW0pO1xufTtcbi8qKlxuICogUmVkdWNlIGZ1bmN0aW9uIHRoYXQgcHVzaGVzIGFuIG9iamVjdCB0byBhbiBhcnJheSwgdGhlbiByZXR1cm5zIHRoZSBhcnJheS5cbiAqIE1vc3RseSBqdXN0IGZvciBbW2ZsYXR0ZW5SXV0gYW5kIFtbdW5pcVJdXVxuICovXG5mdW5jdGlvbiBwdXNoUihhcnIsIG9iaikge1xuICAgIGFyci5wdXNoKG9iaik7XG4gICAgcmV0dXJuIGFycjtcbn1cbmV4cG9ydHMucHVzaFIgPSBwdXNoUjtcbi8qKiBSZWR1Y2UgZnVuY3Rpb24gdGhhdCBmaWx0ZXJzIG91dCBkdXBsaWNhdGVzICovXG5leHBvcnRzLnVuaXFSID0gZnVuY3Rpb24gKGFjYywgdG9rZW4pIHtcbiAgICByZXR1cm4gZXhwb3J0cy5pbkFycmF5KGFjYywgdG9rZW4pID8gYWNjIDogcHVzaFIoYWNjLCB0b2tlbik7XG59O1xuLyoqXG4gKiBSZXR1cm4gYSBuZXcgYXJyYXkgd2l0aCBhIHNpbmdsZSBsZXZlbCBvZiBhcnJheXMgdW5uZXN0ZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICpcbiAqIGxldCBpbnB1dCA9IFsgWyBcImFcIiwgXCJiXCIgXSwgWyBcImNcIiwgXCJkXCIgXSwgWyBbIFwiZG91YmxlXCIsIFwibmVzdGVkXCIgXSBdIF07XG4gKiB1bm5lc3QoaW5wdXQpIC8vIFsgXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFsgXCJkb3VibGUsIFwibmVzdGVkXCIgXSBdXG4gKiBgYGBcbiAqL1xuZXhwb3J0cy51bm5lc3QgPSBmdW5jdGlvbiAoYXJyKSB7IHJldHVybiBhcnIucmVkdWNlKGV4cG9ydHMudW5uZXN0UiwgW10pOyB9O1xuLyoqXG4gKiBSZXR1cm4gYSBjb21wbGV0ZWx5IGZsYXR0ZW5lZCB2ZXJzaW9uIG9mIGFuIGFycmF5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiBsZXQgaW5wdXQgPSBbIFsgXCJhXCIsIFwiYlwiIF0sIFsgXCJjXCIsIFwiZFwiIF0sIFsgWyBcImRvdWJsZVwiLCBcIm5lc3RlZFwiIF0gXSBdO1xuICogZmxhdHRlbihpbnB1dCkgLy8gWyBcImFcIiwgXCJiXCIsIFwiY1wiLCBcImRcIiwgXCJkb3VibGUsIFwibmVzdGVkXCIgXVxuICogYGBgXG4gKi9cbmV4cG9ydHMuZmxhdHRlbiA9IGZ1bmN0aW9uIChhcnIpIHsgcmV0dXJuIGFyci5yZWR1Y2UoZXhwb3J0cy5mbGF0dGVuUiwgW10pOyB9O1xuLyoqXG4gKiBHaXZlbiBhIC5maWx0ZXIgUHJlZGljYXRlLCBidWlsZHMgYSAuZmlsdGVyIFByZWRpY2F0ZSB3aGljaCB0aHJvd3MgYW4gZXJyb3IgaWYgYW55IGVsZW1lbnRzIGRvIG5vdCBwYXNzLlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICpcbiAqIGxldCBpc051bWJlciA9IChvYmopID0+IHR5cGVvZihvYmopID09PSAnbnVtYmVyJztcbiAqIGxldCBhbGxOdW1iZXJzID0gWyAxLCAyLCAzLCA0LCA1IF07XG4gKiBhbGxOdW1iZXJzLmZpbHRlcihhc3NlcnRQcmVkaWNhdGUoaXNOdW1iZXIpKTsgLy9PS1xuICpcbiAqIGxldCBvbmVTdHJpbmcgPSBbIDEsIDIsIDMsIDQsIFwiNVwiIF07XG4gKiBvbmVTdHJpbmcuZmlsdGVyKGFzc2VydFByZWRpY2F0ZShpc051bWJlciwgXCJOb3QgYWxsIG51bWJlcnNcIikpOyAvLyB0aHJvd3MgRXJyb3IoXCJcIk5vdCBhbGwgbnVtYmVyc1wiXCIpO1xuICogYGBgXG4gKi9cbmV4cG9ydHMuYXNzZXJ0UHJlZGljYXRlID0gYXNzZXJ0Rm47XG4vKipcbiAqIEdpdmVuIGEgLm1hcCBmdW5jdGlvbiwgYnVpbGRzIGEgLm1hcCBmdW5jdGlvbiB3aGljaCB0aHJvd3MgYW4gZXJyb3IgaWYgYW55IG1hcHBlZCBlbGVtZW50cyBkbyBub3QgcGFzcyBhIHRydXRoeW5lc3MgdGVzdC5cbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiB2YXIgZGF0YSA9IHsgZm9vOiAxLCBiYXI6IDIgfTtcbiAqXG4gKiBsZXQga2V5cyA9IFsgJ2ZvbycsICdiYXInIF1cbiAqIGxldCB2YWx1ZXMgPSBrZXlzLm1hcChhc3NlcnRNYXAoa2V5ID0+IGRhdGFba2V5XSwgXCJLZXkgbm90IGZvdW5kXCIpKTtcbiAqIC8vIHZhbHVlcyBpcyBbMSwgMl1cbiAqXG4gKiBsZXQga2V5cyA9IFsgJ2ZvbycsICdiYXInLCAnYmF6JyBdXG4gKiBsZXQgdmFsdWVzID0ga2V5cy5tYXAoYXNzZXJ0TWFwKGtleSA9PiBkYXRhW2tleV0sIFwiS2V5IG5vdCBmb3VuZFwiKSk7XG4gKiAvLyB0aHJvd3MgRXJyb3IoXCJLZXkgbm90IGZvdW5kXCIpXG4gKiBgYGBcbiAqL1xuZXhwb3J0cy5hc3NlcnRNYXAgPSBhc3NlcnRGbjtcbmZ1bmN0aW9uIGFzc2VydEZuKHByZWRpY2F0ZU9yTWFwLCBlcnJNc2cpIHtcbiAgICBpZiAoZXJyTXNnID09PSB2b2lkIDApIHsgZXJyTXNnID0gXCJhc3NlcnQgZmFpbHVyZVwiOyB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHByZWRpY2F0ZU9yTWFwKG9iaik7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJlZGljYXRlc18xLmlzRnVuY3Rpb24oZXJyTXNnKSA/IGVyck1zZyhvYmopIDogZXJyTXNnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG5leHBvcnRzLmFzc2VydEZuID0gYXNzZXJ0Rm47XG4vKipcbiAqIExpa2UgXy5wYWlyczogR2l2ZW4gYW4gb2JqZWN0LCByZXR1cm5zIGFuIGFycmF5IG9mIGtleS92YWx1ZSBwYWlyc1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiBwYWlycyh7IGZvbzogXCJGT09cIiwgYmFyOiBcIkJBUiB9KSAvLyBbIFsgXCJmb29cIiwgXCJGT09cIiBdLCBbIFwiYmFyXCI6IFwiQkFSXCIgXSBdXG4gKiBgYGBcbiAqL1xuZXhwb3J0cy5wYWlycyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gW2tleSwgb2JqW2tleV1dOyB9KTtcbn07XG4vKipcbiAqIEdpdmVuIHR3byBvciBtb3JlIHBhcmFsbGVsIGFycmF5cywgcmV0dXJucyBhbiBhcnJheSBvZiB0dXBsZXMgd2hlcmVcbiAqIGVhY2ggdHVwbGUgaXMgY29tcG9zZWQgb2YgWyBhW2ldLCBiW2ldLCAuLi4geltpXSBdXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICpcbiAqIGxldCBmb28gPSBbIDAsIDIsIDQsIDYgXTtcbiAqIGxldCBiYXIgPSBbIDEsIDMsIDUsIDcgXTtcbiAqIGxldCBiYXogPSBbIDEwLCAzMCwgNTAsIDcwIF07XG4gKiBhcnJheVR1cGxlcyhmb28sIGJhcik7ICAgICAgIC8vIFsgWzAsIDFdLCBbMiwgM10sIFs0LCA1XSwgWzYsIDddIF1cbiAqIGFycmF5VHVwbGVzKGZvbywgYmFyLCBiYXopOyAgLy8gWyBbMCwgMSwgMTBdLCBbMiwgMywgMzBdLCBbNCwgNSwgNTBdLCBbNiwgNywgNzBdIF1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBhcnJheVR1cGxlcygpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gW107XG4gICAgdmFyIG1heEFycmF5TGVuID0gYXJncy5yZWR1Y2UoZnVuY3Rpb24gKG1pbiwgYXJyKSB7IHJldHVybiBNYXRoLm1pbihhcnIubGVuZ3RoLCBtaW4pOyB9LCA5MDA3MTk5MjU0NzQwOTkxKTsgLy8gYWthIDJeNTMg4oiSIDEgYWthIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gICAgdmFyIGksIHJlc3VsdCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtYXhBcnJheUxlbjsgaSsrKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBob3QgZnVuY3Rpb25cbiAgICAgICAgLy8gVW5yb2xsIHdoZW4gdGhlcmUgYXJlIDEtNCBhcmd1bWVudHNcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFthcmdzWzBdW2ldXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goW2FyZ3NbMF1baV0sIGFyZ3NbMV1baV1dKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChbYXJnc1swXVtpXSwgYXJnc1sxXVtpXSwgYXJnc1syXVtpXV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFthcmdzWzBdW2ldLCBhcmdzWzFdW2ldLCBhcmdzWzJdW2ldLCBhcmdzWzNdW2ldXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFyZ3MubWFwKGZ1bmN0aW9uIChhcnJheSkgeyByZXR1cm4gYXJyYXlbaV07IH0pKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5hcnJheVR1cGxlcyA9IGFycmF5VHVwbGVzO1xuLyoqXG4gKiBSZWR1Y2UgZnVuY3Rpb24gd2hpY2ggYnVpbGRzIGFuIG9iamVjdCBmcm9tIGFuIGFycmF5IG9mIFtrZXksIHZhbHVlXSBwYWlycy5cbiAqXG4gKiBFYWNoIGl0ZXJhdGlvbiBzZXRzIHRoZSBrZXkvdmFsIHBhaXIgb24gdGhlIG1lbW8gb2JqZWN0LCB0aGVuIHJldHVybnMgdGhlIG1lbW8gZm9yIHRoZSBuZXh0IGl0ZXJhdGlvbi5cbiAqXG4gKiBFYWNoIGtleVZhbHVlVHVwbGUgc2hvdWxkIGJlIGFuIGFycmF5IHdpdGggdmFsdWVzIFsga2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkgXVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiB2YXIgcGFpcnMgPSBbIFtcImZvb2tleVwiLCBcImZvb3ZhbFwiXSwgW1wiYmFya2V5XCIsIFwiYmFydmFsXCJdIF1cbiAqXG4gKiB2YXIgcGFpcnNUb09iaiA9IHBhaXJzLnJlZHVjZSgobWVtbywgcGFpcikgPT4gYXBwbHlQYWlycyhtZW1vLCBwYWlyKSwge30pXG4gKiAvLyBwYWlyc1RvT2JqID09IHsgZm9va2V5OiBcImZvb3ZhbFwiLCBiYXJrZXk6IFwiYmFydmFsXCIgfVxuICpcbiAqIC8vIE9yLCBtb3JlIHNpbXBseTpcbiAqIHZhciBwYWlyc1RvT2JqID0gcGFpcnMucmVkdWNlKGFwcGx5UGFpcnMsIHt9KVxuICogLy8gcGFpcnNUb09iaiA9PSB7IGZvb2tleTogXCJmb292YWxcIiwgYmFya2V5OiBcImJhcnZhbFwiIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBhcHBseVBhaXJzKG1lbW8sIGtleVZhbFR1cGxlKSB7XG4gICAgdmFyIGtleSwgdmFsdWU7XG4gICAgaWYgKHByZWRpY2F0ZXNfMS5pc0FycmF5KGtleVZhbFR1cGxlKSlcbiAgICAgICAga2V5ID0ga2V5VmFsVHVwbGVbMF0sIHZhbHVlID0ga2V5VmFsVHVwbGVbMV07XG4gICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNTdHJpbmcoa2V5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYXJhbWV0ZXJzIHRvIGFwcGx5UGFpcnNcIik7XG4gICAgbWVtb1trZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIG1lbW87XG59XG5leHBvcnRzLmFwcGx5UGFpcnMgPSBhcHBseVBhaXJzO1xuLyoqIEdldCB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5ICovXG5mdW5jdGlvbiB0YWlsKGFycikge1xuICAgIHJldHVybiBhcnIubGVuZ3RoICYmIGFyclthcnIubGVuZ3RoIC0gMV0gfHwgdW5kZWZpbmVkO1xufVxuZXhwb3J0cy50YWlsID0gdGFpbDtcbi8qKlxuICogc2hhbGxvdyBjb3B5IGZyb20gc3JjIHRvIGRlc3RcbiAqL1xuZnVuY3Rpb24gY29weShzcmMsIGRlc3QpIHtcbiAgICBpZiAoZGVzdClcbiAgICAgICAgT2JqZWN0LmtleXMoZGVzdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBkZWxldGUgZGVzdFtrZXldOyB9KTtcbiAgICBpZiAoIWRlc3QpXG4gICAgICAgIGRlc3QgPSB7fTtcbiAgICByZXR1cm4gZXhwb3J0cy5leHRlbmQoZGVzdCwgc3JjKTtcbn1cbmV4cG9ydHMuY29weSA9IGNvcHk7XG4vKiogTmFpdmUgZm9yRWFjaCBpbXBsZW1lbnRhdGlvbiB3b3JrcyB3aXRoIE9iamVjdHMgb3IgQXJyYXlzICovXG5mdW5jdGlvbiBfZm9yRWFjaChvYmosIGNiLCBfdGhpcykge1xuICAgIGlmIChwcmVkaWNhdGVzXzEuaXNBcnJheShvYmopKVxuICAgICAgICByZXR1cm4gb2JqLmZvckVhY2goY2IsIF90aGlzKTtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY2Iob2JqW2tleV0sIGtleSk7IH0pO1xufVxuZnVuY3Rpb24gX2V4dGVuZCh0b09iaikge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvYmogPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGlmICghb2JqKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB0b09ialtrZXlzW2pdXSA9IG9ialtrZXlzW2pdXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9PYmo7XG59XG5leHBvcnRzLl9leHRlbmQgPSBfZXh0ZW5kO1xuZnVuY3Rpb24gX2VxdWFscyhvMSwgbzIpIHtcbiAgICBpZiAobzEgPT09IG8yKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAobzEgPT09IG51bGwgfHwgbzIgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAobzEgIT09IG8xICYmIG8yICE9PSBvMilcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5hTiA9PT0gTmFOXG4gICAgdmFyIHQxID0gdHlwZW9mIG8xLCB0MiA9IHR5cGVvZiBvMjtcbiAgICBpZiAodDEgIT09IHQyIHx8IHQxICE9PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZhciB0dXAgPSBbbzEsIG8yXTtcbiAgICBpZiAoaG9mXzEuYWxsKHByZWRpY2F0ZXNfMS5pc0FycmF5KSh0dXApKVxuICAgICAgICByZXR1cm4gX2FycmF5c0VxKG8xLCBvMik7XG4gICAgaWYgKGhvZl8xLmFsbChwcmVkaWNhdGVzXzEuaXNEYXRlKSh0dXApKVxuICAgICAgICByZXR1cm4gbzEuZ2V0VGltZSgpID09PSBvMi5nZXRUaW1lKCk7XG4gICAgaWYgKGhvZl8xLmFsbChwcmVkaWNhdGVzXzEuaXNSZWdFeHApKHR1cCkpXG4gICAgICAgIHJldHVybiBvMS50b1N0cmluZygpID09PSBvMi50b1N0cmluZygpO1xuICAgIGlmIChob2ZfMS5hbGwocHJlZGljYXRlc18xLmlzRnVuY3Rpb24pKHR1cCkpXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBtZWhcbiAgICB2YXIgcHJlZGljYXRlcyA9IFtwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbiwgcHJlZGljYXRlc18xLmlzQXJyYXksIHByZWRpY2F0ZXNfMS5pc0RhdGUsIHByZWRpY2F0ZXNfMS5pc1JlZ0V4cF07XG4gICAgaWYgKHByZWRpY2F0ZXMubWFwKGhvZl8xLmFueSkucmVkdWNlKGZ1bmN0aW9uIChiLCBmbikgeyByZXR1cm4gYiB8fCAhIWZuKHR1cCk7IH0sIGZhbHNlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBrZXksIGtleXMgPSB7fTtcbiAgICBmb3IgKGtleSBpbiBvMSkge1xuICAgICAgICBpZiAoIV9lcXVhbHMobzFba2V5XSwgbzJba2V5XSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGtleXNba2V5XSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAoa2V5IGluIG8yKSB7XG4gICAgICAgIGlmICgha2V5c1trZXldKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIF9hcnJheXNFcShhMSwgYTIpIHtcbiAgICBpZiAoYTEubGVuZ3RoICE9PSBhMi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gYXJyYXlUdXBsZXMoYTEsIGEyKS5yZWR1Y2UoZnVuY3Rpb24gKGIsIHQpIHsgcmV0dXJuIGIgJiYgX2VxdWFscyh0WzBdLCB0WzFdKTsgfSwgdHJ1ZSk7XG59XG4vLyBpc3N1ZSAjMjY3NlxuZXhwb3J0cy5zaWxlbmNlVW5jYXVnaHRJblByb21pc2UgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgIHJldHVybiBwcm9taXNlLmNhdGNoKGZ1bmN0aW9uIChlKSB7IHJldHVybiAwOyB9KSAmJiBwcm9taXNlO1xufTtcbmV4cG9ydHMuc2lsZW50UmVqZWN0aW9uID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuc2lsZW5jZVVuY2F1Z2h0SW5Qcm9taXNlKGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLnJlamVjdChlcnJvcikpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9jb21tb24uanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n')},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** Predicates\n *\n * These predicates return true/false based on the input.\n * Although these functions are exported, they are subject to change without notice.\n *\n * @module common_predicates\n */\n/** */\nvar hof_1 = __webpack_require__(/*! ./hof */ 2);\nvar stateObject_1 = __webpack_require__(/*! ../state/stateObject */ 24);\nvar toStr = Object.prototype.toString;\nvar tis = function (t) { return function (x) { return typeof (x) === t; }; };\nexports.isUndefined = tis('undefined');\nexports.isDefined = hof_1.not(exports.isUndefined);\nexports.isNull = function (o) { return o === null; };\nexports.isNullOrUndefined = hof_1.or(exports.isNull, exports.isUndefined);\nexports.isFunction = tis('function');\nexports.isNumber = tis('number');\nexports.isString = tis('string');\nexports.isObject = function (x) { return x !== null && typeof x === 'object'; };\nexports.isArray = Array.isArray;\nexports.isDate = (function (x) { return toStr.call(x) === '[object Date]'; });\nexports.isRegExp = (function (x) { return toStr.call(x) === '[object RegExp]'; });\nexports.isState = stateObject_1.StateObject.isState;\n/**\n * Predicate which checks if a value is injectable\n *\n * A value is \"injectable\" if it is a function, or if it is an ng1 array-notation-style array\n * where all the elements in the array are Strings, except the last one, which is a Function\n */\nfunction isInjectable(val) {\n    if (exports.isArray(val) && val.length) {\n        var head = val.slice(0, -1), tail = val.slice(-1);\n        return !(head.filter(hof_1.not(exports.isString)).length || tail.filter(hof_1.not(exports.isFunction)).length);\n    }\n    return exports.isFunction(val);\n}\nexports.isInjectable = isInjectable;\n/**\n * Predicate which checks if a value looks like a Promise\n *\n * It is probably a Promise if it's an object, and it has a `then` property which is a Function\n */\nexports.isPromise = hof_1.and(exports.isObject, hof_1.pipe(hof_1.prop('then'), exports.isFunction));\n//# sourceMappingURL=predicates.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9wcmVkaWNhdGVzLmpzP2VmMzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogUHJlZGljYXRlc1xuICpcbiAqIFRoZXNlIHByZWRpY2F0ZXMgcmV0dXJuIHRydWUvZmFsc2UgYmFzZWQgb24gdGhlIGlucHV0LlxuICogQWx0aG91Z2ggdGhlc2UgZnVuY3Rpb25zIGFyZSBleHBvcnRlZCwgdGhleSBhcmUgc3ViamVjdCB0byBjaGFuZ2Ugd2l0aG91dCBub3RpY2UuXG4gKlxuICogQG1vZHVsZSBjb21tb25fcHJlZGljYXRlc1xuICovXG4vKiogKi9cbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuL2hvZlwiKTtcbnZhciBzdGF0ZU9iamVjdF8xID0gcmVxdWlyZShcIi4uL3N0YXRlL3N0YXRlT2JqZWN0XCIpO1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciB0aXMgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHR5cGVvZiAoeCkgPT09IHQ7IH07IH07XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gdGlzKCd1bmRlZmluZWQnKTtcbmV4cG9ydHMuaXNEZWZpbmVkID0gaG9mXzEubm90KGV4cG9ydHMuaXNVbmRlZmluZWQpO1xuZXhwb3J0cy5pc051bGwgPSBmdW5jdGlvbiAobykgeyByZXR1cm4gbyA9PT0gbnVsbDsgfTtcbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBob2ZfMS5vcihleHBvcnRzLmlzTnVsbCwgZXhwb3J0cy5pc1VuZGVmaW5lZCk7XG5leHBvcnRzLmlzRnVuY3Rpb24gPSB0aXMoJ2Z1bmN0aW9uJyk7XG5leHBvcnRzLmlzTnVtYmVyID0gdGlzKCdudW1iZXInKTtcbmV4cG9ydHMuaXNTdHJpbmcgPSB0aXMoJ3N0cmluZycpO1xuZXhwb3J0cy5pc09iamVjdCA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICE9PSBudWxsICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0JzsgfTtcbmV4cG9ydHMuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5leHBvcnRzLmlzRGF0ZSA9IChmdW5jdGlvbiAoeCkgeyByZXR1cm4gdG9TdHIuY2FsbCh4KSA9PT0gJ1tvYmplY3QgRGF0ZV0nOyB9KTtcbmV4cG9ydHMuaXNSZWdFeHAgPSAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHRvU3RyLmNhbGwoeCkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nOyB9KTtcbmV4cG9ydHMuaXNTdGF0ZSA9IHN0YXRlT2JqZWN0XzEuU3RhdGVPYmplY3QuaXNTdGF0ZTtcbi8qKlxuICogUHJlZGljYXRlIHdoaWNoIGNoZWNrcyBpZiBhIHZhbHVlIGlzIGluamVjdGFibGVcbiAqXG4gKiBBIHZhbHVlIGlzIFwiaW5qZWN0YWJsZVwiIGlmIGl0IGlzIGEgZnVuY3Rpb24sIG9yIGlmIGl0IGlzIGFuIG5nMSBhcnJheS1ub3RhdGlvbi1zdHlsZSBhcnJheVxuICogd2hlcmUgYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgYXJyYXkgYXJlIFN0cmluZ3MsIGV4Y2VwdCB0aGUgbGFzdCBvbmUsIHdoaWNoIGlzIGEgRnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gaXNJbmplY3RhYmxlKHZhbCkge1xuICAgIGlmIChleHBvcnRzLmlzQXJyYXkodmFsKSAmJiB2YWwubGVuZ3RoKSB7XG4gICAgICAgIHZhciBoZWFkID0gdmFsLnNsaWNlKDAsIC0xKSwgdGFpbCA9IHZhbC5zbGljZSgtMSk7XG4gICAgICAgIHJldHVybiAhKGhlYWQuZmlsdGVyKGhvZl8xLm5vdChleHBvcnRzLmlzU3RyaW5nKSkubGVuZ3RoIHx8IHRhaWwuZmlsdGVyKGhvZl8xLm5vdChleHBvcnRzLmlzRnVuY3Rpb24pKS5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gZXhwb3J0cy5pc0Z1bmN0aW9uKHZhbCk7XG59XG5leHBvcnRzLmlzSW5qZWN0YWJsZSA9IGlzSW5qZWN0YWJsZTtcbi8qKlxuICogUHJlZGljYXRlIHdoaWNoIGNoZWNrcyBpZiBhIHZhbHVlIGxvb2tzIGxpa2UgYSBQcm9taXNlXG4gKlxuICogSXQgaXMgcHJvYmFibHkgYSBQcm9taXNlIGlmIGl0J3MgYW4gb2JqZWN0LCBhbmQgaXQgaGFzIGEgYHRoZW5gIHByb3BlcnR5IHdoaWNoIGlzIGEgRnVuY3Rpb25cbiAqL1xuZXhwb3J0cy5pc1Byb21pc2UgPSBob2ZfMS5hbmQoZXhwb3J0cy5pc09iamVjdCwgaG9mXzEucGlwZShob2ZfMS5wcm9wKCd0aGVuJyksIGV4cG9ydHMuaXNGdW5jdGlvbikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlZGljYXRlcy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9wcmVkaWNhdGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n")},function(module,exports,__webpack_require__){"use strict";eval('\n/**\n * Higher order functions\n *\n * These utility functions are exported, but are subject to change without notice.\n *\n * @module common_hof\n */ /** */\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.\n *\n * Given a function with N parameters, returns a new function that supports partial application.\n * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,\n * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to\n * accept more parameters until all N parameters have been supplied.\n *\n *\n * This contrived example uses a partially applied function as an predicate, which returns true\n * if an object is found in both arrays.\n * @example\n * ```\n * // returns true if an object is in both of the two arrays\n * function inBoth(array1, array2, object) {\n *   return array1.indexOf(object) !== -1 &&\n *          array2.indexOf(object) !== 1;\n * }\n * let obj1, obj2, obj3, obj4, obj5, obj6, obj7\n * let foos = [obj1, obj3]\n * let bars = [obj3, obj4, obj5]\n *\n * // A curried "copy" of inBoth\n * let curriedInBoth = curry(inBoth);\n * // Partially apply both the array1 and array2\n * let inFoosAndBars = curriedInBoth(foos, bars);\n *\n * // Supply the final argument; since all arguments are\n * // supplied, the original inBoth function is then called.\n * let obj1InBoth = inFoosAndBars(obj1); // false\n *\n * // Use the inFoosAndBars as a predicate.\n * // Filter, on each iteration, supplies the final argument\n * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];\n * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]\n *\n * ```\n *\n * Stolen from: http://stackoverflow.com/questions/4394747/javascript-curry-function\n *\n * @param fn\n * @returns {*|function(): (*|any)}\n */\nfunction curry(fn) {\n    var initial_args = [].slice.apply(arguments, [1]);\n    var func_args_length = fn.length;\n    function curried(args) {\n        if (args.length >= func_args_length)\n            return fn.apply(null, args);\n        return function () {\n            return curried(args.concat([].slice.apply(arguments)));\n        };\n    }\n    return curried(initial_args);\n}\nexports.curry = curry;\n/**\n * Given a varargs list of functions, returns a function that composes the argument functions, right-to-left\n * given: f(x), g(x), h(x)\n * let composed = compose(f,g,h)\n * then, composed is: f(g(h(x)))\n */\nfunction compose() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function () {\n        var i = start, result = args[start].apply(this, arguments);\n        while (i--)\n            result = args[i].call(this, result);\n        return result;\n    };\n}\nexports.compose = compose;\n/**\n * Given a varargs list of functions, returns a function that is composes the argument functions, left-to-right\n * given: f(x), g(x), h(x)\n * let piped = pipe(f,g,h);\n * then, piped is: h(g(f(x)))\n */\nfunction pipe() {\n    var funcs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        funcs[_i] = arguments[_i];\n    }\n    return compose.apply(null, [].slice.call(arguments).reverse());\n}\nexports.pipe = pipe;\n/**\n * Given a property name, returns a function that returns that property from an object\n * let obj = { foo: 1, name: "blarg" };\n * let getName = prop("name");\n * getName(obj) === "blarg"\n */\nexports.prop = function (name) {\n    return function (obj) { return obj && obj[name]; };\n};\n/**\n * Given a property name and a value, returns a function that returns a boolean based on whether\n * the passed object has a property that matches the value\n * let obj = { foo: 1, name: "blarg" };\n * let getName = propEq("name", "blarg");\n * getName(obj) === true\n */\nexports.propEq = curry(function (name, val, obj) { return obj && obj[name] === val; });\n/**\n * Given a dotted property name, returns a function that returns a nested property from an object, or undefined\n * let obj = { id: 1, nestedObj: { foo: 1, name: "blarg" }, };\n * let getName = prop("nestedObj.name");\n * getName(obj) === "blarg"\n * let propNotFound = prop("this.property.doesnt.exist");\n * propNotFound(obj) === undefined\n */\nexports.parse = function (name) {\n    return pipe.apply(null, name.split(".").map(exports.prop));\n};\n/**\n * Given a function that returns a truthy or falsey value, returns a\n * function that returns the opposite (falsey or truthy) value given the same inputs\n */\nexports.not = function (fn) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return !fn.apply(null, args);\n    };\n};\n/**\n * Given two functions that return truthy or falsey values, returns a function that returns truthy\n * if both functions return truthy for the given arguments\n */\nfunction and(fn1, fn2) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return fn1.apply(null, args) && fn2.apply(null, args);\n    };\n}\nexports.and = and;\n/**\n * Given two functions that return truthy or falsey values, returns a function that returns truthy\n * if at least one of the functions returns truthy for the given arguments\n */\nfunction or(fn1, fn2) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return fn1.apply(null, args) || fn2.apply(null, args);\n    };\n}\nexports.or = or;\n/**\n * Check if all the elements of an array match a predicate function\n *\n * @param fn1 a predicate function `fn1`\n * @returns a function which takes an array and returns true if `fn1` is true for all elements of the array\n */\nexports.all = function (fn1) {\n    return function (arr) { return arr.reduce(function (b, x) { return b && !!fn1(x); }, true); };\n};\nexports.any = function (fn1) {\n    return function (arr) { return arr.reduce(function (b, x) { return b || !!fn1(x); }, false); };\n};\n/** Given a class, returns a Predicate function that returns true if the object is of that class */\nexports.is = function (ctor) {\n    return function (obj) {\n        return (obj != null && obj.constructor === ctor || obj instanceof ctor);\n    };\n};\n/** Given a value, returns a Predicate function that returns true if another value is === equal to the original value */\nexports.eq = function (val) { return function (other) {\n    return val === other;\n}; };\n/** Given a value, returns a function which returns the value */\nexports.val = function (v) { return function () { return v; }; };\nfunction invoke(fnName, args) {\n    return function (obj) {\n        return obj[fnName].apply(obj, args);\n    };\n}\nexports.invoke = invoke;\n/**\n * Sorta like Pattern Matching (a functional programming conditional construct)\n *\n * See http://c2.com/cgi/wiki?PatternMatching\n *\n * This is a conditional construct which allows a series of predicates and output functions\n * to be checked and then applied.  Each predicate receives the input.  If the predicate\n * returns truthy, then its matching output function (mapping function) is provided with\n * the input and, then the result is returned.\n *\n * Each combination (2-tuple) of predicate + output function should be placed in an array\n * of size 2: [ predicate, mapFn ]\n *\n * These 2-tuples should be put in an outer array.\n *\n * @example\n * ```\n *\n * // Here\'s a 2-tuple where the first element is the isString predicate\n * // and the second element is a function that returns a description of the input\n * let firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];\n *\n * // Second tuple: predicate "isNumber", mapfn returns a description\n * let secondTuple = [ angular.isNumber, (input) => `(${input}) That\'s a number!` ];\n *\n * let third = [ (input) => input === null,  (input) => `Oh, null...` ];\n *\n * let fourth = [ (input) => input === undefined,  (input) => `notdefined` ];\n *\n * let descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);\n *\n * console.log(descriptionOf(undefined)); // \'notdefined\'\n * console.log(descriptionOf(55)); // \'(55) That\'s a number!\'\n * console.log(descriptionOf("foo")); // \'Here\'s your string foo\'\n * ```\n *\n * @param struct A 2D array.  Each element of the array should be an array, a 2-tuple,\n * with a Predicate and a mapping/output function\n * @returns {function(any): *}\n */\nfunction pattern(struct) {\n    return function (x) {\n        for (var i = 0; i < struct.length; i++) {\n            if (struct[i][0](x))\n                return struct[i][1](x);\n        }\n    };\n}\nexports.pattern = pattern;\n//# sourceMappingURL=hof.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9ob2YuanM/OWZhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogSGlnaGVyIG9yZGVyIGZ1bmN0aW9uc1xuICpcbiAqIFRoZXNlIHV0aWxpdHkgZnVuY3Rpb25zIGFyZSBleHBvcnRlZCwgYnV0IGFyZSBzdWJqZWN0IHRvIGNoYW5nZSB3aXRob3V0IG5vdGljZS5cbiAqXG4gKiBAbW9kdWxlIGNvbW1vbl9ob2ZcbiAqLyAvKiogKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogUmV0dXJucyBhIG5ldyBmdW5jdGlvbiBmb3IgW1BhcnRpYWwgQXBwbGljYXRpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BhcnRpYWxfYXBwbGljYXRpb24pIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAqXG4gKiBHaXZlbiBhIGZ1bmN0aW9uIHdpdGggTiBwYXJhbWV0ZXJzLCByZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIHRoYXQgc3VwcG9ydHMgcGFydGlhbCBhcHBsaWNhdGlvbi5cbiAqIFRoZSBuZXcgZnVuY3Rpb24gYWNjZXB0cyBhbnl3aGVyZSBmcm9tIDEgdG8gTiBwYXJhbWV0ZXJzLiAgV2hlbiB0aGF0IGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIE0gcGFyYW1ldGVycyxcbiAqIHdoZXJlIE0gaXMgbGVzcyB0aGFuIE4sIGl0IHJldHVybnMgYSBuZXcgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRoZSByZW1haW5pbmcgcGFyYW1ldGVycy4gIEl0IGNvbnRpbnVlcyB0b1xuICogYWNjZXB0IG1vcmUgcGFyYW1ldGVycyB1bnRpbCBhbGwgTiBwYXJhbWV0ZXJzIGhhdmUgYmVlbiBzdXBwbGllZC5cbiAqXG4gKlxuICogVGhpcyBjb250cml2ZWQgZXhhbXBsZSB1c2VzIGEgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24gYXMgYW4gcHJlZGljYXRlLCB3aGljaCByZXR1cm5zIHRydWVcbiAqIGlmIGFuIG9iamVjdCBpcyBmb3VuZCBpbiBib3RoIGFycmF5cy5cbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIC8vIHJldHVybnMgdHJ1ZSBpZiBhbiBvYmplY3QgaXMgaW4gYm90aCBvZiB0aGUgdHdvIGFycmF5c1xuICogZnVuY3Rpb24gaW5Cb3RoKGFycmF5MSwgYXJyYXkyLCBvYmplY3QpIHtcbiAqICAgcmV0dXJuIGFycmF5MS5pbmRleE9mKG9iamVjdCkgIT09IC0xICYmXG4gKiAgICAgICAgICBhcnJheTIuaW5kZXhPZihvYmplY3QpICE9PSAxO1xuICogfVxuICogbGV0IG9iajEsIG9iajIsIG9iajMsIG9iajQsIG9iajUsIG9iajYsIG9iajdcbiAqIGxldCBmb29zID0gW29iajEsIG9iajNdXG4gKiBsZXQgYmFycyA9IFtvYmozLCBvYmo0LCBvYmo1XVxuICpcbiAqIC8vIEEgY3VycmllZCBcImNvcHlcIiBvZiBpbkJvdGhcbiAqIGxldCBjdXJyaWVkSW5Cb3RoID0gY3VycnkoaW5Cb3RoKTtcbiAqIC8vIFBhcnRpYWxseSBhcHBseSBib3RoIHRoZSBhcnJheTEgYW5kIGFycmF5MlxuICogbGV0IGluRm9vc0FuZEJhcnMgPSBjdXJyaWVkSW5Cb3RoKGZvb3MsIGJhcnMpO1xuICpcbiAqIC8vIFN1cHBseSB0aGUgZmluYWwgYXJndW1lbnQ7IHNpbmNlIGFsbCBhcmd1bWVudHMgYXJlXG4gKiAvLyBzdXBwbGllZCwgdGhlIG9yaWdpbmFsIGluQm90aCBmdW5jdGlvbiBpcyB0aGVuIGNhbGxlZC5cbiAqIGxldCBvYmoxSW5Cb3RoID0gaW5Gb29zQW5kQmFycyhvYmoxKTsgLy8gZmFsc2VcbiAqXG4gKiAvLyBVc2UgdGhlIGluRm9vc0FuZEJhcnMgYXMgYSBwcmVkaWNhdGUuXG4gKiAvLyBGaWx0ZXIsIG9uIGVhY2ggaXRlcmF0aW9uLCBzdXBwbGllcyB0aGUgZmluYWwgYXJndW1lbnRcbiAqIGxldCBhbGxPYmpzID0gWyBvYmoxLCBvYmoyLCBvYmozLCBvYmo0LCBvYmo1LCBvYmo2LCBvYmo3IF07XG4gKiBsZXQgZm91bmRJbkJvdGggPSBhbGxPYmpzLmZpbHRlcihpbkZvb3NBbmRCYXJzKTsgLy8gWyBvYmozIF1cbiAqXG4gKiBgYGBcbiAqXG4gKiBTdG9sZW4gZnJvbTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80Mzk0NzQ3L2phdmFzY3JpcHQtY3VycnktZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0gZm5cbiAqIEByZXR1cm5zIHsqfGZ1bmN0aW9uKCk6ICgqfGFueSl9XG4gKi9cbmZ1bmN0aW9uIGN1cnJ5KGZuKSB7XG4gICAgdmFyIGluaXRpYWxfYXJncyA9IFtdLnNsaWNlLmFwcGx5KGFyZ3VtZW50cywgWzFdKTtcbiAgICB2YXIgZnVuY19hcmdzX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgICBmdW5jdGlvbiBjdXJyaWVkKGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID49IGZ1bmNfYXJnc19sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmllZChhcmdzLmNvbmNhdChbXS5zbGljZS5hcHBseShhcmd1bWVudHMpKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBjdXJyaWVkKGluaXRpYWxfYXJncyk7XG59XG5leHBvcnRzLmN1cnJ5ID0gY3Vycnk7XG4vKipcbiAqIEdpdmVuIGEgdmFyYXJncyBsaXN0IG9mIGZ1bmN0aW9ucywgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY29tcG9zZXMgdGhlIGFyZ3VtZW50IGZ1bmN0aW9ucywgcmlnaHQtdG8tbGVmdFxuICogZ2l2ZW46IGYoeCksIGcoeCksIGgoeClcbiAqIGxldCBjb21wb3NlZCA9IGNvbXBvc2UoZixnLGgpXG4gKiB0aGVuLCBjb21wb3NlZCBpczogZihnKGgoeCkpKVxuICovXG5mdW5jdGlvbiBjb21wb3NlKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBzdGFydCA9IGFyZ3MubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSA9IHN0YXJ0LCByZXN1bHQgPSBhcmdzW3N0YXJ0XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgcmVzdWx0ID0gYXJnc1tpXS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbmV4cG9ydHMuY29tcG9zZSA9IGNvbXBvc2U7XG4vKipcbiAqIEdpdmVuIGEgdmFyYXJncyBsaXN0IG9mIGZ1bmN0aW9ucywgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgY29tcG9zZXMgdGhlIGFyZ3VtZW50IGZ1bmN0aW9ucywgbGVmdC10by1yaWdodFxuICogZ2l2ZW46IGYoeCksIGcoeCksIGgoeClcbiAqIGxldCBwaXBlZCA9IHBpcGUoZixnLGgpO1xuICogdGhlbiwgcGlwZWQgaXM6IGgoZyhmKHgpKSlcbiAqL1xuZnVuY3Rpb24gcGlwZSgpIHtcbiAgICB2YXIgZnVuY3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBmdW5jc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9zZS5hcHBseShudWxsLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykucmV2ZXJzZSgpKTtcbn1cbmV4cG9ydHMucGlwZSA9IHBpcGU7XG4vKipcbiAqIEdpdmVuIGEgcHJvcGVydHkgbmFtZSwgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGF0IHByb3BlcnR5IGZyb20gYW4gb2JqZWN0XG4gKiBsZXQgb2JqID0geyBmb286IDEsIG5hbWU6IFwiYmxhcmdcIiB9O1xuICogbGV0IGdldE5hbWUgPSBwcm9wKFwibmFtZVwiKTtcbiAqIGdldE5hbWUob2JqKSA9PT0gXCJibGFyZ1wiXG4gKi9cbmV4cG9ydHMucHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmpbbmFtZV07IH07XG59O1xuLyoqXG4gKiBHaXZlbiBhIHByb3BlcnR5IG5hbWUgYW5kIGEgdmFsdWUsIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBib29sZWFuIGJhc2VkIG9uIHdoZXRoZXJcbiAqIHRoZSBwYXNzZWQgb2JqZWN0IGhhcyBhIHByb3BlcnR5IHRoYXQgbWF0Y2hlcyB0aGUgdmFsdWVcbiAqIGxldCBvYmogPSB7IGZvbzogMSwgbmFtZTogXCJibGFyZ1wiIH07XG4gKiBsZXQgZ2V0TmFtZSA9IHByb3BFcShcIm5hbWVcIiwgXCJibGFyZ1wiKTtcbiAqIGdldE5hbWUob2JqKSA9PT0gdHJ1ZVxuICovXG5leHBvcnRzLnByb3BFcSA9IGN1cnJ5KGZ1bmN0aW9uIChuYW1lLCB2YWwsIG9iaikgeyByZXR1cm4gb2JqICYmIG9ialtuYW1lXSA9PT0gdmFsOyB9KTtcbi8qKlxuICogR2l2ZW4gYSBkb3R0ZWQgcHJvcGVydHkgbmFtZSwgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIG5lc3RlZCBwcm9wZXJ0eSBmcm9tIGFuIG9iamVjdCwgb3IgdW5kZWZpbmVkXG4gKiBsZXQgb2JqID0geyBpZDogMSwgbmVzdGVkT2JqOiB7IGZvbzogMSwgbmFtZTogXCJibGFyZ1wiIH0sIH07XG4gKiBsZXQgZ2V0TmFtZSA9IHByb3AoXCJuZXN0ZWRPYmoubmFtZVwiKTtcbiAqIGdldE5hbWUob2JqKSA9PT0gXCJibGFyZ1wiXG4gKiBsZXQgcHJvcE5vdEZvdW5kID0gcHJvcChcInRoaXMucHJvcGVydHkuZG9lc250LmV4aXN0XCIpO1xuICogcHJvcE5vdEZvdW5kKG9iaikgPT09IHVuZGVmaW5lZFxuICovXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gcGlwZS5hcHBseShudWxsLCBuYW1lLnNwbGl0KFwiLlwiKS5tYXAoZXhwb3J0cy5wcm9wKSk7XG59O1xuLyoqXG4gKiBHaXZlbiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHRydXRoeSBvciBmYWxzZXkgdmFsdWUsIHJldHVybnMgYVxuICogZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBvcHBvc2l0ZSAoZmFsc2V5IG9yIHRydXRoeSkgdmFsdWUgZ2l2ZW4gdGhlIHNhbWUgaW5wdXRzXG4gKi9cbmV4cG9ydHMubm90ID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH07XG59O1xuLyoqXG4gKiBHaXZlbiB0d28gZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHRydXRoeSBvciBmYWxzZXkgdmFsdWVzLCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydXRoeVxuICogaWYgYm90aCBmdW5jdGlvbnMgcmV0dXJuIHRydXRoeSBmb3IgdGhlIGdpdmVuIGFyZ3VtZW50c1xuICovXG5mdW5jdGlvbiBhbmQoZm4xLCBmbjIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbjEuYXBwbHkobnVsbCwgYXJncykgJiYgZm4yLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH07XG59XG5leHBvcnRzLmFuZCA9IGFuZDtcbi8qKlxuICogR2l2ZW4gdHdvIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB0cnV0aHkgb3IgZmFsc2V5IHZhbHVlcywgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnV0aHlcbiAqIGlmIGF0IGxlYXN0IG9uZSBvZiB0aGUgZnVuY3Rpb25zIHJldHVybnMgdHJ1dGh5IGZvciB0aGUgZ2l2ZW4gYXJndW1lbnRzXG4gKi9cbmZ1bmN0aW9uIG9yKGZuMSwgZm4yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4xLmFwcGx5KG51bGwsIGFyZ3MpIHx8IGZuMi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9O1xufVxuZXhwb3J0cy5vciA9IG9yO1xuLyoqXG4gKiBDaGVjayBpZiBhbGwgdGhlIGVsZW1lbnRzIG9mIGFuIGFycmF5IG1hdGNoIGEgcHJlZGljYXRlIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIGZuMSBhIHByZWRpY2F0ZSBmdW5jdGlvbiBgZm4xYFxuICogQHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCB0YWtlcyBhbiBhcnJheSBhbmQgcmV0dXJucyB0cnVlIGlmIGBmbjFgIGlzIHRydWUgZm9yIGFsbCBlbGVtZW50cyBvZiB0aGUgYXJyYXlcbiAqL1xuZXhwb3J0cy5hbGwgPSBmdW5jdGlvbiAoZm4xKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcnIpIHsgcmV0dXJuIGFyci5yZWR1Y2UoZnVuY3Rpb24gKGIsIHgpIHsgcmV0dXJuIGIgJiYgISFmbjEoeCk7IH0sIHRydWUpOyB9O1xufTtcbmV4cG9ydHMuYW55ID0gZnVuY3Rpb24gKGZuMSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJyKSB7IHJldHVybiBhcnIucmVkdWNlKGZ1bmN0aW9uIChiLCB4KSB7IHJldHVybiBiIHx8ICEhZm4xKHgpOyB9LCBmYWxzZSk7IH07XG59O1xuLyoqIEdpdmVuIGEgY2xhc3MsIHJldHVybnMgYSBQcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBvZiB0aGF0IGNsYXNzICovXG5leHBvcnRzLmlzID0gZnVuY3Rpb24gKGN0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gY3RvciB8fCBvYmogaW5zdGFuY2VvZiBjdG9yKTtcbiAgICB9O1xufTtcbi8qKiBHaXZlbiBhIHZhbHVlLCByZXR1cm5zIGEgUHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIGFub3RoZXIgdmFsdWUgaXMgPT09IGVxdWFsIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZSAqL1xuZXhwb3J0cy5lcSA9IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHJldHVybiB2YWwgPT09IG90aGVyO1xufTsgfTtcbi8qKiBHaXZlbiBhIHZhbHVlLCByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGUgdmFsdWUgKi9cbmV4cG9ydHMudmFsID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHY7IH07IH07XG5mdW5jdGlvbiBpbnZva2UoZm5OYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9ialtmbk5hbWVdLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgfTtcbn1cbmV4cG9ydHMuaW52b2tlID0gaW52b2tlO1xuLyoqXG4gKiBTb3J0YSBsaWtlIFBhdHRlcm4gTWF0Y2hpbmcgKGEgZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBjb25kaXRpb25hbCBjb25zdHJ1Y3QpXG4gKlxuICogU2VlIGh0dHA6Ly9jMi5jb20vY2dpL3dpa2k/UGF0dGVybk1hdGNoaW5nXG4gKlxuICogVGhpcyBpcyBhIGNvbmRpdGlvbmFsIGNvbnN0cnVjdCB3aGljaCBhbGxvd3MgYSBzZXJpZXMgb2YgcHJlZGljYXRlcyBhbmQgb3V0cHV0IGZ1bmN0aW9uc1xuICogdG8gYmUgY2hlY2tlZCBhbmQgdGhlbiBhcHBsaWVkLiAgRWFjaCBwcmVkaWNhdGUgcmVjZWl2ZXMgdGhlIGlucHV0LiAgSWYgdGhlIHByZWRpY2F0ZVxuICogcmV0dXJucyB0cnV0aHksIHRoZW4gaXRzIG1hdGNoaW5nIG91dHB1dCBmdW5jdGlvbiAobWFwcGluZyBmdW5jdGlvbikgaXMgcHJvdmlkZWQgd2l0aFxuICogdGhlIGlucHV0IGFuZCwgdGhlbiB0aGUgcmVzdWx0IGlzIHJldHVybmVkLlxuICpcbiAqIEVhY2ggY29tYmluYXRpb24gKDItdHVwbGUpIG9mIHByZWRpY2F0ZSArIG91dHB1dCBmdW5jdGlvbiBzaG91bGQgYmUgcGxhY2VkIGluIGFuIGFycmF5XG4gKiBvZiBzaXplIDI6IFsgcHJlZGljYXRlLCBtYXBGbiBdXG4gKlxuICogVGhlc2UgMi10dXBsZXMgc2hvdWxkIGJlIHB1dCBpbiBhbiBvdXRlciBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogLy8gSGVyZSdzIGEgMi10dXBsZSB3aGVyZSB0aGUgZmlyc3QgZWxlbWVudCBpcyB0aGUgaXNTdHJpbmcgcHJlZGljYXRlXG4gKiAvLyBhbmQgdGhlIHNlY29uZCBlbGVtZW50IGlzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZGVzY3JpcHRpb24gb2YgdGhlIGlucHV0XG4gKiBsZXQgZmlyc3RUdXBsZSA9IFsgYW5ndWxhci5pc1N0cmluZywgKGlucHV0KSA9PiBgSGVyZXMgeW91ciBzdHJpbmcgJHtpbnB1dH1gIF07XG4gKlxuICogLy8gU2Vjb25kIHR1cGxlOiBwcmVkaWNhdGUgXCJpc051bWJlclwiLCBtYXBmbiByZXR1cm5zIGEgZGVzY3JpcHRpb25cbiAqIGxldCBzZWNvbmRUdXBsZSA9IFsgYW5ndWxhci5pc051bWJlciwgKGlucHV0KSA9PiBgKCR7aW5wdXR9KSBUaGF0J3MgYSBudW1iZXIhYCBdO1xuICpcbiAqIGxldCB0aGlyZCA9IFsgKGlucHV0KSA9PiBpbnB1dCA9PT0gbnVsbCwgIChpbnB1dCkgPT4gYE9oLCBudWxsLi4uYCBdO1xuICpcbiAqIGxldCBmb3VydGggPSBbIChpbnB1dCkgPT4gaW5wdXQgPT09IHVuZGVmaW5lZCwgIChpbnB1dCkgPT4gYG5vdGRlZmluZWRgIF07XG4gKlxuICogbGV0IGRlc2NyaXB0aW9uT2YgPSBwYXR0ZXJuKFsgZmlyc3RUdXBsZSwgc2Vjb25kVHVwbGUsIHRoaXJkLCBmb3VydGggXSk7XG4gKlxuICogY29uc29sZS5sb2coZGVzY3JpcHRpb25PZih1bmRlZmluZWQpKTsgLy8gJ25vdGRlZmluZWQnXG4gKiBjb25zb2xlLmxvZyhkZXNjcmlwdGlvbk9mKDU1KSk7IC8vICcoNTUpIFRoYXQncyBhIG51bWJlciEnXG4gKiBjb25zb2xlLmxvZyhkZXNjcmlwdGlvbk9mKFwiZm9vXCIpKTsgLy8gJ0hlcmUncyB5b3VyIHN0cmluZyBmb28nXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc3RydWN0IEEgMkQgYXJyYXkuICBFYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5IHNob3VsZCBiZSBhbiBhcnJheSwgYSAyLXR1cGxlLFxuICogd2l0aCBhIFByZWRpY2F0ZSBhbmQgYSBtYXBwaW5nL291dHB1dCBmdW5jdGlvblxuICogQHJldHVybnMge2Z1bmN0aW9uKGFueSk6ICp9XG4gKi9cbmZ1bmN0aW9uIHBhdHRlcm4oc3RydWN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RydWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc3RydWN0W2ldWzBdKHgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3RbaV1bMV0oeCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0cy5wYXR0ZXJuID0gcGF0dGVybjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvZi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9ob2YuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.notImplemented = function (fnname) { return function () {\n    throw new Error(fnname + "(): No coreservices implementation for UI-Router is loaded.");\n}; };\nvar services = {\n    $q: undefined,\n    $injector: undefined,\n};\nexports.services = services;\n//# sourceMappingURL=coreservices.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9jb3Jlc2VydmljZXMuanM/NjQxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubm90SW1wbGVtZW50ZWQgPSBmdW5jdGlvbiAoZm5uYW1lKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGZubmFtZSArIFwiKCk6IE5vIGNvcmVzZXJ2aWNlcyBpbXBsZW1lbnRhdGlvbiBmb3IgVUktUm91dGVyIGlzIGxvYWRlZC5cIik7XG59OyB9O1xudmFyIHNlcnZpY2VzID0ge1xuICAgICRxOiB1bmRlZmluZWQsXG4gICAgJGluamVjdG9yOiB1bmRlZmluZWQsXG59O1xuZXhwb3J0cy5zZXJ2aWNlcyA9IHNlcnZpY2VzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29yZXNlcnZpY2VzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL2NvcmVzZXJ2aWNlcy5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n')},,function(module,exports,__webpack_require__){"use strict";eval('\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, "__esModule", { value: true });\n/** @module common */ /** for typedoc */\n__export(__webpack_require__(/*! ./common */ 0));\n__export(__webpack_require__(/*! ./coreservices */ 3));\n__export(__webpack_require__(/*! ./glob */ 15));\n__export(__webpack_require__(/*! ./hof */ 2));\n__export(__webpack_require__(/*! ./predicates */ 1));\n__export(__webpack_require__(/*! ./queue */ 21));\n__export(__webpack_require__(/*! ./strings */ 6));\n__export(__webpack_require__(/*! ./trace */ 7));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9pbmRleC5qcz8xODFkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBAbW9kdWxlIGNvbW1vbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbW1vblwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb3Jlc2VydmljZXNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vZ2xvYlwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9ob2ZcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcHJlZGljYXRlc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9xdWV1ZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdHJpbmdzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3RyYWNlXCIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n')},function(module,exports,__webpack_require__){"use strict";eval('\n/**\n * Functions that manipulate strings\n *\n * Although these functions are exported, they are subject to change without notice.\n *\n * @module common_strings\n */ /** */\nObject.defineProperty(exports, "__esModule", { value: true });\nvar predicates_1 = __webpack_require__(/*! ./predicates */ 1);\nvar rejectFactory_1 = __webpack_require__(/*! ../transition/rejectFactory */ 12);\nvar common_1 = __webpack_require__(/*! ./common */ 0);\nvar hof_1 = __webpack_require__(/*! ./hof */ 2);\nvar transition_1 = __webpack_require__(/*! ../transition/transition */ 18);\nvar resolvable_1 = __webpack_require__(/*! ../resolve/resolvable */ 11);\n/**\n * Returns a string shortened to a maximum length\n *\n * If the string is already less than the `max` length, return the string.\n * Else return the string, shortened to `max - 3` and append three dots ("...").\n *\n * @param max the maximum length of the string to return\n * @param str the input string\n */\nfunction maxLength(max, str) {\n    if (str.length <= max)\n        return str;\n    return str.substr(0, max - 3) + "...";\n}\nexports.maxLength = maxLength;\n/**\n * Returns a string, with spaces added to the end, up to a desired str length\n *\n * If the string is already longer than the desired length, return the string.\n * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.\n *\n * @param length the desired length of the string to return\n * @param str the input string\n */\nfunction padString(length, str) {\n    while (str.length < length)\n        str += " ";\n    return str;\n}\nexports.padString = padString;\nfunction kebobString(camelCase) {\n    return camelCase\n        .replace(/^([A-Z])/, function ($1) { return $1.toLowerCase(); }) // replace first char\n        .replace(/([A-Z])/g, function ($1) { return "-" + $1.toLowerCase(); }); // replace rest\n}\nexports.kebobString = kebobString;\nfunction _toJson(obj) {\n    return JSON.stringify(obj);\n}\nfunction _fromJson(json) {\n    return predicates_1.isString(json) ? JSON.parse(json) : json;\n}\nfunction promiseToString(p) {\n    return "Promise(" + JSON.stringify(p) + ")";\n}\nfunction functionToString(fn) {\n    var fnStr = fnToString(fn);\n    var namedFunctionMatch = fnStr.match(/^(function [^ ]+\\([^)]*\\))/);\n    var toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;\n    var fnName = fn[\'name\'] || "";\n    if (fnName && toStr.match(/function \\(/)) {\n        return \'function \' + fnName + toStr.substr(9);\n    }\n    return toStr;\n}\nexports.functionToString = functionToString;\nfunction fnToString(fn) {\n    var _fn = predicates_1.isArray(fn) ? fn.slice(-1)[0] : fn;\n    return _fn && _fn.toString() || "undefined";\n}\nexports.fnToString = fnToString;\nvar stringifyPatternFn = null;\nvar stringifyPattern = function (value) {\n    var isRejection = rejectFactory_1.Rejection.isRejectionPromise;\n    stringifyPatternFn = stringifyPatternFn || hof_1.pattern([\n        [hof_1.not(predicates_1.isDefined), hof_1.val("undefined")],\n        [predicates_1.isNull, hof_1.val("null")],\n        [predicates_1.isPromise, hof_1.val("[Promise]")],\n        [isRejection, function (x) { return x._transitionRejection.toString(); }],\n        [hof_1.is(rejectFactory_1.Rejection), hof_1.invoke("toString")],\n        [hof_1.is(transition_1.Transition), hof_1.invoke("toString")],\n        [hof_1.is(resolvable_1.Resolvable), hof_1.invoke("toString")],\n        [predicates_1.isInjectable, functionToString],\n        [hof_1.val(true), common_1.identity]\n    ]);\n    return stringifyPatternFn(value);\n};\nfunction stringify(o) {\n    var seen = [];\n    function format(val) {\n        if (predicates_1.isObject(val)) {\n            if (seen.indexOf(val) !== -1)\n                return \'[circular ref]\';\n            seen.push(val);\n        }\n        return stringifyPattern(val);\n    }\n    return JSON.stringify(o, function (key, val) { return format(val); }).replace(/\\\\"/g, \'"\');\n}\nexports.stringify = stringify;\n/** Returns a function that splits a string on a character or substring */\nexports.beforeAfterSubstr = function (char) { return function (str) {\n    if (!str)\n        return ["", ""];\n    var idx = str.indexOf(char);\n    if (idx === -1)\n        return [str, ""];\n    return [str.substr(0, idx), str.substr(idx + 1)];\n}; };\nexports.hostRegex = new RegExp(\'^(?:[a-z]+:)?//[^/]+/\');\nexports.stripFile = function (str) { return str.replace(/\\/[^/]*$/, \'\'); };\nexports.splitHash = exports.beforeAfterSubstr("#");\nexports.splitQuery = exports.beforeAfterSubstr("?");\nexports.splitEqual = exports.beforeAfterSubstr("=");\nexports.trimHashVal = function (str) { return str ? str.replace(/^#/, "") : ""; };\n/**\n * Splits on a delimiter, but returns the delimiters in the array\n *\n * #### Example:\n * ```js\n * var splitOnSlashes = splitOnDelim(\'/\');\n * splitOnSlashes("/foo"); // ["/", "foo"]\n * splitOnSlashes("/foo/"); // ["/", "foo", "/"]\n * ```\n */\nfunction splitOnDelim(delim) {\n    var re = new RegExp("(" + delim + ")", "g");\n    return function (str) {\n        return str.split(re).filter(common_1.identity);\n    };\n}\nexports.splitOnDelim = splitOnDelim;\n;\n/**\n * Reduce fn that joins neighboring strings\n *\n * Given an array of strings, returns a new array\n * where all neighboring strings have been joined.\n *\n * #### Example:\n * ```js\n * let arr = ["foo", "bar", 1, "baz", "", "qux" ];\n * arr.reduce(joinNeighborsR, []) // ["foobar", 1, "bazqux" ]\n * ```\n */\nfunction joinNeighborsR(acc, x) {\n    if (predicates_1.isString(common_1.tail(acc)) && predicates_1.isString(x))\n        return acc.slice(0, -1).concat(common_1.tail(acc) + x);\n    return common_1.pushR(acc, x);\n}\nexports.joinNeighborsR = joinNeighborsR;\n;\n//# sourceMappingURL=strings.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9zdHJpbmdzLmpzPzk3NjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEZ1bmN0aW9ucyB0aGF0IG1hbmlwdWxhdGUgc3RyaW5nc1xuICpcbiAqIEFsdGhvdWdoIHRoZXNlIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQsIHRoZXkgYXJlIHN1YmplY3QgdG8gY2hhbmdlIHdpdGhvdXQgbm90aWNlLlxuICpcbiAqIEBtb2R1bGUgY29tbW9uX3N0cmluZ3NcbiAqLyAvKiogKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi9wcmVkaWNhdGVzXCIpO1xudmFyIHJlamVjdEZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2l0aW9uL3JlamVjdEZhY3RvcnlcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi9ob2ZcIik7XG52YXIgdHJhbnNpdGlvbl8xID0gcmVxdWlyZShcIi4uL3RyYW5zaXRpb24vdHJhbnNpdGlvblwiKTtcbnZhciByZXNvbHZhYmxlXzEgPSByZXF1aXJlKFwiLi4vcmVzb2x2ZS9yZXNvbHZhYmxlXCIpO1xuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHNob3J0ZW5lZCB0byBhIG1heGltdW0gbGVuZ3RoXG4gKlxuICogSWYgdGhlIHN0cmluZyBpcyBhbHJlYWR5IGxlc3MgdGhhbiB0aGUgYG1heGAgbGVuZ3RoLCByZXR1cm4gdGhlIHN0cmluZy5cbiAqIEVsc2UgcmV0dXJuIHRoZSBzdHJpbmcsIHNob3J0ZW5lZCB0byBgbWF4IC0gM2AgYW5kIGFwcGVuZCB0aHJlZSBkb3RzIChcIi4uLlwiKS5cbiAqXG4gKiBAcGFyYW0gbWF4IHRoZSBtYXhpbXVtIGxlbmd0aCBvZiB0aGUgc3RyaW5nIHRvIHJldHVyblxuICogQHBhcmFtIHN0ciB0aGUgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIG1heExlbmd0aChtYXgsIHN0cikge1xuICAgIGlmIChzdHIubGVuZ3RoIDw9IG1heClcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICByZXR1cm4gc3RyLnN1YnN0cigwLCBtYXggLSAzKSArIFwiLi4uXCI7XG59XG5leHBvcnRzLm1heExlbmd0aCA9IG1heExlbmd0aDtcbi8qKlxuICogUmV0dXJucyBhIHN0cmluZywgd2l0aCBzcGFjZXMgYWRkZWQgdG8gdGhlIGVuZCwgdXAgdG8gYSBkZXNpcmVkIHN0ciBsZW5ndGhcbiAqXG4gKiBJZiB0aGUgc3RyaW5nIGlzIGFscmVhZHkgbG9uZ2VyIHRoYW4gdGhlIGRlc2lyZWQgbGVuZ3RoLCByZXR1cm4gdGhlIHN0cmluZy5cbiAqIEVsc2UgcmV0dXJucyB0aGUgc3RyaW5nLCB3aXRoIGV4dHJhIHNwYWNlcyBvbiB0aGUgZW5kLCBzdWNoIHRoYXQgaXQgcmVhY2hlcyBgbGVuZ3RoYCBjaGFyYWN0ZXJzLlxuICpcbiAqIEBwYXJhbSBsZW5ndGggdGhlIGRlc2lyZWQgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgdG8gcmV0dXJuXG4gKiBAcGFyYW0gc3RyIHRoZSBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gcGFkU3RyaW5nKGxlbmd0aCwgc3RyKSB7XG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPCBsZW5ndGgpXG4gICAgICAgIHN0ciArPSBcIiBcIjtcbiAgICByZXR1cm4gc3RyO1xufVxuZXhwb3J0cy5wYWRTdHJpbmcgPSBwYWRTdHJpbmc7XG5mdW5jdGlvbiBrZWJvYlN0cmluZyhjYW1lbENhc2UpIHtcbiAgICByZXR1cm4gY2FtZWxDYXNlXG4gICAgICAgIC5yZXBsYWNlKC9eKFtBLVpdKS8sIGZ1bmN0aW9uICgkMSkgeyByZXR1cm4gJDEudG9Mb3dlckNhc2UoKTsgfSkgLy8gcmVwbGFjZSBmaXJzdCBjaGFyXG4gICAgICAgIC5yZXBsYWNlKC8oW0EtWl0pL2csIGZ1bmN0aW9uICgkMSkgeyByZXR1cm4gXCItXCIgKyAkMS50b0xvd2VyQ2FzZSgpOyB9KTsgLy8gcmVwbGFjZSByZXN0XG59XG5leHBvcnRzLmtlYm9iU3RyaW5nID0ga2Vib2JTdHJpbmc7XG5mdW5jdGlvbiBfdG9Kc29uKG9iaikge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xufVxuZnVuY3Rpb24gX2Zyb21Kc29uKGpzb24pIHtcbiAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzU3RyaW5nKGpzb24pID8gSlNPTi5wYXJzZShqc29uKSA6IGpzb247XG59XG5mdW5jdGlvbiBwcm9taXNlVG9TdHJpbmcocCkge1xuICAgIHJldHVybiBcIlByb21pc2UoXCIgKyBKU09OLnN0cmluZ2lmeShwKSArIFwiKVwiO1xufVxuZnVuY3Rpb24gZnVuY3Rpb25Ub1N0cmluZyhmbikge1xuICAgIHZhciBmblN0ciA9IGZuVG9TdHJpbmcoZm4pO1xuICAgIHZhciBuYW1lZEZ1bmN0aW9uTWF0Y2ggPSBmblN0ci5tYXRjaCgvXihmdW5jdGlvbiBbXiBdK1xcKFteKV0qXFwpKS8pO1xuICAgIHZhciB0b1N0ciA9IG5hbWVkRnVuY3Rpb25NYXRjaCA/IG5hbWVkRnVuY3Rpb25NYXRjaFsxXSA6IGZuU3RyO1xuICAgIHZhciBmbk5hbWUgPSBmblsnbmFtZSddIHx8IFwiXCI7XG4gICAgaWYgKGZuTmFtZSAmJiB0b1N0ci5tYXRjaCgvZnVuY3Rpb24gXFwoLykpIHtcbiAgICAgICAgcmV0dXJuICdmdW5jdGlvbiAnICsgZm5OYW1lICsgdG9TdHIuc3Vic3RyKDkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9TdHI7XG59XG5leHBvcnRzLmZ1bmN0aW9uVG9TdHJpbmcgPSBmdW5jdGlvblRvU3RyaW5nO1xuZnVuY3Rpb24gZm5Ub1N0cmluZyhmbikge1xuICAgIHZhciBfZm4gPSBwcmVkaWNhdGVzXzEuaXNBcnJheShmbikgPyBmbi5zbGljZSgtMSlbMF0gOiBmbjtcbiAgICByZXR1cm4gX2ZuICYmIF9mbi50b1N0cmluZygpIHx8IFwidW5kZWZpbmVkXCI7XG59XG5leHBvcnRzLmZuVG9TdHJpbmcgPSBmblRvU3RyaW5nO1xudmFyIHN0cmluZ2lmeVBhdHRlcm5GbiA9IG51bGw7XG52YXIgc3RyaW5naWZ5UGF0dGVybiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBpc1JlamVjdGlvbiA9IHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24uaXNSZWplY3Rpb25Qcm9taXNlO1xuICAgIHN0cmluZ2lmeVBhdHRlcm5GbiA9IHN0cmluZ2lmeVBhdHRlcm5GbiB8fCBob2ZfMS5wYXR0ZXJuKFtcbiAgICAgICAgW2hvZl8xLm5vdChwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKSwgaG9mXzEudmFsKFwidW5kZWZpbmVkXCIpXSxcbiAgICAgICAgW3ByZWRpY2F0ZXNfMS5pc051bGwsIGhvZl8xLnZhbChcIm51bGxcIildLFxuICAgICAgICBbcHJlZGljYXRlc18xLmlzUHJvbWlzZSwgaG9mXzEudmFsKFwiW1Byb21pc2VdXCIpXSxcbiAgICAgICAgW2lzUmVqZWN0aW9uLCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5fdHJhbnNpdGlvblJlamVjdGlvbi50b1N0cmluZygpOyB9XSxcbiAgICAgICAgW2hvZl8xLmlzKHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24pLCBob2ZfMS5pbnZva2UoXCJ0b1N0cmluZ1wiKV0sXG4gICAgICAgIFtob2ZfMS5pcyh0cmFuc2l0aW9uXzEuVHJhbnNpdGlvbiksIGhvZl8xLmludm9rZShcInRvU3RyaW5nXCIpXSxcbiAgICAgICAgW2hvZl8xLmlzKHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKSwgaG9mXzEuaW52b2tlKFwidG9TdHJpbmdcIildLFxuICAgICAgICBbcHJlZGljYXRlc18xLmlzSW5qZWN0YWJsZSwgZnVuY3Rpb25Ub1N0cmluZ10sXG4gICAgICAgIFtob2ZfMS52YWwodHJ1ZSksIGNvbW1vbl8xLmlkZW50aXR5XVxuICAgIF0pO1xuICAgIHJldHVybiBzdHJpbmdpZnlQYXR0ZXJuRm4odmFsdWUpO1xufTtcbmZ1bmN0aW9uIHN0cmluZ2lmeShvKSB7XG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICBmdW5jdGlvbiBmb3JtYXQodmFsKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNPYmplY3QodmFsKSkge1xuICAgICAgICAgICAgaWYgKHNlZW4uaW5kZXhPZih2YWwpICE9PSAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1tjaXJjdWxhciByZWZdJztcbiAgICAgICAgICAgIHNlZW4ucHVzaCh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlQYXR0ZXJuKHZhbCk7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvLCBmdW5jdGlvbiAoa2V5LCB2YWwpIHsgcmV0dXJuIGZvcm1hdCh2YWwpOyB9KS5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJyk7XG59XG5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbi8qKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBzcGxpdHMgYSBzdHJpbmcgb24gYSBjaGFyYWN0ZXIgb3Igc3Vic3RyaW5nICovXG5leHBvcnRzLmJlZm9yZUFmdGVyU3Vic3RyID0gZnVuY3Rpb24gKGNoYXIpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAoIXN0cilcbiAgICAgICAgcmV0dXJuIFtcIlwiLCBcIlwiXTtcbiAgICB2YXIgaWR4ID0gc3RyLmluZGV4T2YoY2hhcik7XG4gICAgaWYgKGlkeCA9PT0gLTEpXG4gICAgICAgIHJldHVybiBbc3RyLCBcIlwiXTtcbiAgICByZXR1cm4gW3N0ci5zdWJzdHIoMCwgaWR4KSwgc3RyLnN1YnN0cihpZHggKyAxKV07XG59OyB9O1xuZXhwb3J0cy5ob3N0UmVnZXggPSBuZXcgUmVnRXhwKCdeKD86W2Etel0rOik/Ly9bXi9dKy8nKTtcbmV4cG9ydHMuc3RyaXBGaWxlID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyLnJlcGxhY2UoL1xcL1teL10qJC8sICcnKTsgfTtcbmV4cG9ydHMuc3BsaXRIYXNoID0gZXhwb3J0cy5iZWZvcmVBZnRlclN1YnN0cihcIiNcIik7XG5leHBvcnRzLnNwbGl0UXVlcnkgPSBleHBvcnRzLmJlZm9yZUFmdGVyU3Vic3RyKFwiP1wiKTtcbmV4cG9ydHMuc3BsaXRFcXVhbCA9IGV4cG9ydHMuYmVmb3JlQWZ0ZXJTdWJzdHIoXCI9XCIpO1xuZXhwb3J0cy50cmltSGFzaFZhbCA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0ciA/IHN0ci5yZXBsYWNlKC9eIy8sIFwiXCIpIDogXCJcIjsgfTtcbi8qKlxuICogU3BsaXRzIG9uIGEgZGVsaW1pdGVyLCBidXQgcmV0dXJucyB0aGUgZGVsaW1pdGVycyBpbiB0aGUgYXJyYXlcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBqc1xuICogdmFyIHNwbGl0T25TbGFzaGVzID0gc3BsaXRPbkRlbGltKCcvJyk7XG4gKiBzcGxpdE9uU2xhc2hlcyhcIi9mb29cIik7IC8vIFtcIi9cIiwgXCJmb29cIl1cbiAqIHNwbGl0T25TbGFzaGVzKFwiL2Zvby9cIik7IC8vIFtcIi9cIiwgXCJmb29cIiwgXCIvXCJdXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gc3BsaXRPbkRlbGltKGRlbGltKSB7XG4gICAgdmFyIHJlID0gbmV3IFJlZ0V4cChcIihcIiArIGRlbGltICsgXCIpXCIsIFwiZ1wiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnNwbGl0KHJlKS5maWx0ZXIoY29tbW9uXzEuaWRlbnRpdHkpO1xuICAgIH07XG59XG5leHBvcnRzLnNwbGl0T25EZWxpbSA9IHNwbGl0T25EZWxpbTtcbjtcbi8qKlxuICogUmVkdWNlIGZuIHRoYXQgam9pbnMgbmVpZ2hib3Jpbmcgc3RyaW5nc1xuICpcbiAqIEdpdmVuIGFuIGFycmF5IG9mIHN0cmluZ3MsIHJldHVybnMgYSBuZXcgYXJyYXlcbiAqIHdoZXJlIGFsbCBuZWlnaGJvcmluZyBzdHJpbmdzIGhhdmUgYmVlbiBqb2luZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogYGBganNcbiAqIGxldCBhcnIgPSBbXCJmb29cIiwgXCJiYXJcIiwgMSwgXCJiYXpcIiwgXCJcIiwgXCJxdXhcIiBdO1xuICogYXJyLnJlZHVjZShqb2luTmVpZ2hib3JzUiwgW10pIC8vIFtcImZvb2JhclwiLCAxLCBcImJhenF1eFwiIF1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBqb2luTmVpZ2hib3JzUihhY2MsIHgpIHtcbiAgICBpZiAocHJlZGljYXRlc18xLmlzU3RyaW5nKGNvbW1vbl8xLnRhaWwoYWNjKSkgJiYgcHJlZGljYXRlc18xLmlzU3RyaW5nKHgpKVxuICAgICAgICByZXR1cm4gYWNjLnNsaWNlKDAsIC0xKS5jb25jYXQoY29tbW9uXzEudGFpbChhY2MpICsgeCk7XG4gICAgcmV0dXJuIGNvbW1vbl8xLnB1c2hSKGFjYywgeCk7XG59XG5leHBvcnRzLmpvaW5OZWlnaGJvcnNSID0gam9pbk5laWdoYm9yc1I7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmdzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL3N0cmluZ3MuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * # Transition tracing (debug)\n *\n * Enable transition tracing to print transition information to the console,\n * in order to help debug your application.\n * Tracing logs detailed information about each Transition to your console.\n *\n * To enable tracing, import the [[Trace]] singleton and enable one or more categories.\n *\n * ### ES6\n * ```js\n * import {trace} from "ui-router-ng2"; // or "angular-ui-router"\n * trace.enable(1, 5); // TRANSITION and VIEWCONFIG\n * ```\n *\n * ### CJS\n * ```js\n * let trace = require("angular-ui-router").trace; // or "ui-router-ng2"\n * trace.enable("TRANSITION", "VIEWCONFIG");\n * ```\n *\n * ### Globals\n * ```js\n * let trace = window["angular-ui-router"].trace; // or "ui-router-ng2"\n * trace.enable(); // Trace everything (very verbose)\n * ```\n *\n * ### Angular 1:\n * ```js\n * app.run($trace => $trace.enable());\n * ```\n *\n * @coreapi\n * @module trace\n */ /** for typedoc */\nvar hof_1 = __webpack_require__(/*! ../common/hof */ 2);\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ 1);\nvar strings_1 = __webpack_require__(/*! ./strings */ 6);\n/** @hidden */\nfunction uiViewString(uiview) {\n    if (!uiview)\n        return \'ui-view (defunct)\';\n    var state = uiview.creationContext ? uiview.creationContext.name || \'(root)\' : \'(none)\';\n    return "[ui-view#" + uiview.id + " " + uiview.$type + ":" + uiview.fqn + " (" + uiview.name + "@" + state + ")]";\n}\n/** @hidden */\nvar viewConfigString = function (viewConfig) {\n    var view = viewConfig.viewDecl;\n    var state = view.$context.name || \'(root)\';\n    return "[View#" + viewConfig.$id + " from \'" + state + "\' state]: target ui-view: \'" + view.$uiViewName + "@" + view.$uiViewContextAnchor + "\'";\n};\n/** @hidden */\nfunction normalizedCat(input) {\n    return predicates_1.isNumber(input) ? Category[input] : Category[Category[input]];\n}\n/** @hidden */\nvar consoleLog = Function.prototype.bind.call(console.log, console);\n/** @hidden */\nvar consoletable = predicates_1.isFunction(console.table) ? console.table.bind(console) : consoleLog.bind(console);\n/**\n * Trace categories Enum\n *\n * Enable or disable a category using [[Trace.enable]] or [[Trace.disable]]\n *\n * `trace.enable(Category.TRANSITION)`\n *\n * These can also be provided using a matching string, or position ordinal\n *\n * `trace.enable("TRANSITION")`\n *\n * `trace.enable(1)`\n */\nvar Category;\n(function (Category) {\n    Category[Category["RESOLVE"] = 0] = "RESOLVE";\n    Category[Category["TRANSITION"] = 1] = "TRANSITION";\n    Category[Category["HOOK"] = 2] = "HOOK";\n    Category[Category["UIVIEW"] = 3] = "UIVIEW";\n    Category[Category["VIEWCONFIG"] = 4] = "VIEWCONFIG";\n})(Category = exports.Category || (exports.Category = {}));\n/** @hidden */ var _tid = hof_1.parse("$id");\n/** @hidden */ var _rid = hof_1.parse("router.$id");\n/** @hidden */ var transLbl = function (trans) { return "Transition #" + _tid(trans) + "-" + _rid(trans); };\n/**\n * Prints UI-Router Transition trace information to the console.\n */\nvar Trace = /** @class */ (function () {\n    /** @hidden */\n    function Trace() {\n        /** @hidden */\n        this._enabled = {};\n        this.approximateDigests = 0;\n    }\n    /** @hidden */\n    Trace.prototype._set = function (enabled, categories) {\n        var _this = this;\n        if (!categories.length) {\n            categories = Object.keys(Category)\n                .map(function (k) { return parseInt(k, 10); })\n                .filter(function (k) { return !isNaN(k); })\n                .map(function (key) { return Category[key]; });\n        }\n        categories.map(normalizedCat).forEach(function (category) { return _this._enabled[category] = enabled; });\n    };\n    Trace.prototype.enable = function () {\n        var categories = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            categories[_i] = arguments[_i];\n        }\n        this._set(true, categories);\n    };\n    Trace.prototype.disable = function () {\n        var categories = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            categories[_i] = arguments[_i];\n        }\n        this._set(false, categories);\n    };\n    /**\n     * Retrieves the enabled stateus of a [[Category]]\n     *\n     * ```js\n     * trace.enabled("VIEWCONFIG"); // true or false\n     * ```\n     *\n     * @returns boolean true if the category is enabled\n     */\n    Trace.prototype.enabled = function (category) {\n        return !!this._enabled[normalizedCat(category)];\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceTransitionStart = function (trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        console.log(transLbl(trans) + ": Started  -> " + strings_1.stringify(trans));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceTransitionIgnored = function (trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        console.log(transLbl(trans) + ": Ignored  <> " + strings_1.stringify(trans));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceHookInvocation = function (step, trans, options) {\n        if (!this.enabled(Category.HOOK))\n            return;\n        var event = hof_1.parse("traceData.hookType")(options) || "internal", context = hof_1.parse("traceData.context.state.name")(options) || hof_1.parse("traceData.context")(options) || "unknown", name = strings_1.functionToString(step.registeredHook.callback);\n        console.log(transLbl(trans) + ":   Hook -> " + event + " context: " + context + ", " + strings_1.maxLength(200, name));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceHookResult = function (hookResult, trans, transitionOptions) {\n        if (!this.enabled(Category.HOOK))\n            return;\n        console.log(transLbl(trans) + ":   <- Hook returned: " + strings_1.maxLength(200, strings_1.stringify(hookResult)));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceResolvePath = function (path, when, trans) {\n        if (!this.enabled(Category.RESOLVE))\n            return;\n        console.log(transLbl(trans) + ":         Resolving " + path + " (" + when + ")");\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceResolvableResolved = function (resolvable, trans) {\n        if (!this.enabled(Category.RESOLVE))\n            return;\n        console.log(transLbl(trans) + ":               <- Resolved  " + resolvable + " to: " + strings_1.maxLength(200, strings_1.stringify(resolvable.data)));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceError = function (reason, trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        console.log(transLbl(trans) + ": <- Rejected " + strings_1.stringify(trans) + ", reason: " + reason);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceSuccess = function (finalState, trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        console.log(transLbl(trans) + ": <- Success  " + strings_1.stringify(trans) + ", final state: " + finalState.name);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewEvent = function (event, viewData, extra) {\n        if (extra === void 0) { extra = ""; }\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        console.log("ui-view: " + strings_1.padString(30, event) + " " + uiViewString(viewData) + extra);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewConfigUpdated = function (viewData, context) {\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        this.traceUIViewEvent("Updating", viewData, " with ViewConfig from context=\'" + context + "\'");\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewFill = function (viewData, html) {\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        this.traceUIViewEvent("Fill", viewData, " with: " + strings_1.maxLength(200, html));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceViewSync = function (pairs) {\n        if (!this.enabled(Category.VIEWCONFIG))\n            return;\n        var mapping = pairs.map(function (_a) {\n            var uiViewData = _a[0], config = _a[1];\n            var uiView = uiViewData.$type + ":" + uiViewData.fqn;\n            var view = config && config.viewDecl.$context.name + ": " + config.viewDecl.$name + " (" + config.viewDecl.$type + ")";\n            return { \'ui-view fqn\': uiView, \'state: view name\': view };\n        }).sort(function (a, b) { return a[\'ui-view fqn\'].localeCompare(b[\'ui-view fqn\']); });\n        consoletable(mapping);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceViewServiceEvent = function (event, viewConfig) {\n        if (!this.enabled(Category.VIEWCONFIG))\n            return;\n        console.log("VIEWCONFIG: " + event + " " + viewConfigString(viewConfig));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceViewServiceUIViewEvent = function (event, viewData) {\n        if (!this.enabled(Category.VIEWCONFIG))\n            return;\n        console.log("VIEWCONFIG: " + event + " " + uiViewString(viewData));\n    };\n    return Trace;\n}());\nexports.Trace = Trace;\n/**\n * The [[Trace]] singleton\n *\n * #### Example:\n * ```js\n * import {trace} from "angular-ui-router";\n * trace.enable(1, 5);\n * ```\n */\nvar trace = new Trace();\nexports.trace = trace;\n//# sourceMappingURL=trace.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi90cmFjZS5qcz9mYjQxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiAjIFRyYW5zaXRpb24gdHJhY2luZyAoZGVidWcpXG4gKlxuICogRW5hYmxlIHRyYW5zaXRpb24gdHJhY2luZyB0byBwcmludCB0cmFuc2l0aW9uIGluZm9ybWF0aW9uIHRvIHRoZSBjb25zb2xlLFxuICogaW4gb3JkZXIgdG8gaGVscCBkZWJ1ZyB5b3VyIGFwcGxpY2F0aW9uLlxuICogVHJhY2luZyBsb2dzIGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IGVhY2ggVHJhbnNpdGlvbiB0byB5b3VyIGNvbnNvbGUuXG4gKlxuICogVG8gZW5hYmxlIHRyYWNpbmcsIGltcG9ydCB0aGUgW1tUcmFjZV1dIHNpbmdsZXRvbiBhbmQgZW5hYmxlIG9uZSBvciBtb3JlIGNhdGVnb3JpZXMuXG4gKlxuICogIyMjIEVTNlxuICogYGBganNcbiAqIGltcG9ydCB7dHJhY2V9IGZyb20gXCJ1aS1yb3V0ZXItbmcyXCI7IC8vIG9yIFwiYW5ndWxhci11aS1yb3V0ZXJcIlxuICogdHJhY2UuZW5hYmxlKDEsIDUpOyAvLyBUUkFOU0lUSU9OIGFuZCBWSUVXQ09ORklHXG4gKiBgYGBcbiAqXG4gKiAjIyMgQ0pTXG4gKiBgYGBqc1xuICogbGV0IHRyYWNlID0gcmVxdWlyZShcImFuZ3VsYXItdWktcm91dGVyXCIpLnRyYWNlOyAvLyBvciBcInVpLXJvdXRlci1uZzJcIlxuICogdHJhY2UuZW5hYmxlKFwiVFJBTlNJVElPTlwiLCBcIlZJRVdDT05GSUdcIik7XG4gKiBgYGBcbiAqXG4gKiAjIyMgR2xvYmFsc1xuICogYGBganNcbiAqIGxldCB0cmFjZSA9IHdpbmRvd1tcImFuZ3VsYXItdWktcm91dGVyXCJdLnRyYWNlOyAvLyBvciBcInVpLXJvdXRlci1uZzJcIlxuICogdHJhY2UuZW5hYmxlKCk7IC8vIFRyYWNlIGV2ZXJ5dGhpbmcgKHZlcnkgdmVyYm9zZSlcbiAqIGBgYFxuICpcbiAqICMjIyBBbmd1bGFyIDE6XG4gKiBgYGBqc1xuICogYXBwLnJ1bigkdHJhY2UgPT4gJHRyYWNlLmVuYWJsZSgpKTtcbiAqIGBgYFxuICpcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHRyYWNlXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgc3RyaW5nc18xID0gcmVxdWlyZShcIi4vc3RyaW5nc1wiKTtcbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiB1aVZpZXdTdHJpbmcodWl2aWV3KSB7XG4gICAgaWYgKCF1aXZpZXcpXG4gICAgICAgIHJldHVybiAndWktdmlldyAoZGVmdW5jdCknO1xuICAgIHZhciBzdGF0ZSA9IHVpdmlldy5jcmVhdGlvbkNvbnRleHQgPyB1aXZpZXcuY3JlYXRpb25Db250ZXh0Lm5hbWUgfHwgJyhyb290KScgOiAnKG5vbmUpJztcbiAgICByZXR1cm4gXCJbdWktdmlldyNcIiArIHVpdmlldy5pZCArIFwiIFwiICsgdWl2aWV3LiR0eXBlICsgXCI6XCIgKyB1aXZpZXcuZnFuICsgXCIgKFwiICsgdWl2aWV3Lm5hbWUgKyBcIkBcIiArIHN0YXRlICsgXCIpXVwiO1xufVxuLyoqIEBoaWRkZW4gKi9cbnZhciB2aWV3Q29uZmlnU3RyaW5nID0gZnVuY3Rpb24gKHZpZXdDb25maWcpIHtcbiAgICB2YXIgdmlldyA9IHZpZXdDb25maWcudmlld0RlY2w7XG4gICAgdmFyIHN0YXRlID0gdmlldy4kY29udGV4dC5uYW1lIHx8ICcocm9vdCknO1xuICAgIHJldHVybiBcIltWaWV3I1wiICsgdmlld0NvbmZpZy4kaWQgKyBcIiBmcm9tICdcIiArIHN0YXRlICsgXCInIHN0YXRlXTogdGFyZ2V0IHVpLXZpZXc6ICdcIiArIHZpZXcuJHVpVmlld05hbWUgKyBcIkBcIiArIHZpZXcuJHVpVmlld0NvbnRleHRBbmNob3IgKyBcIidcIjtcbn07XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplZENhdChpbnB1dCkge1xuICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNOdW1iZXIoaW5wdXQpID8gQ2F0ZWdvcnlbaW5wdXRdIDogQ2F0ZWdvcnlbQ2F0ZWdvcnlbaW5wdXRdXTtcbn1cbi8qKiBAaGlkZGVuICovXG52YXIgY29uc29sZUxvZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUpO1xuLyoqIEBoaWRkZW4gKi9cbnZhciBjb25zb2xldGFibGUgPSBwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihjb25zb2xlLnRhYmxlKSA/IGNvbnNvbGUudGFibGUuYmluZChjb25zb2xlKSA6IGNvbnNvbGVMb2cuYmluZChjb25zb2xlKTtcbi8qKlxuICogVHJhY2UgY2F0ZWdvcmllcyBFbnVtXG4gKlxuICogRW5hYmxlIG9yIGRpc2FibGUgYSBjYXRlZ29yeSB1c2luZyBbW1RyYWNlLmVuYWJsZV1dIG9yIFtbVHJhY2UuZGlzYWJsZV1dXG4gKlxuICogYHRyYWNlLmVuYWJsZShDYXRlZ29yeS5UUkFOU0lUSU9OKWBcbiAqXG4gKiBUaGVzZSBjYW4gYWxzbyBiZSBwcm92aWRlZCB1c2luZyBhIG1hdGNoaW5nIHN0cmluZywgb3IgcG9zaXRpb24gb3JkaW5hbFxuICpcbiAqIGB0cmFjZS5lbmFibGUoXCJUUkFOU0lUSU9OXCIpYFxuICpcbiAqIGB0cmFjZS5lbmFibGUoMSlgXG4gKi9cbnZhciBDYXRlZ29yeTtcbihmdW5jdGlvbiAoQ2F0ZWdvcnkpIHtcbiAgICBDYXRlZ29yeVtDYXRlZ29yeVtcIlJFU09MVkVcIl0gPSAwXSA9IFwiUkVTT0xWRVwiO1xuICAgIENhdGVnb3J5W0NhdGVnb3J5W1wiVFJBTlNJVElPTlwiXSA9IDFdID0gXCJUUkFOU0lUSU9OXCI7XG4gICAgQ2F0ZWdvcnlbQ2F0ZWdvcnlbXCJIT09LXCJdID0gMl0gPSBcIkhPT0tcIjtcbiAgICBDYXRlZ29yeVtDYXRlZ29yeVtcIlVJVklFV1wiXSA9IDNdID0gXCJVSVZJRVdcIjtcbiAgICBDYXRlZ29yeVtDYXRlZ29yeVtcIlZJRVdDT05GSUdcIl0gPSA0XSA9IFwiVklFV0NPTkZJR1wiO1xufSkoQ2F0ZWdvcnkgPSBleHBvcnRzLkNhdGVnb3J5IHx8IChleHBvcnRzLkNhdGVnb3J5ID0ge30pKTtcbi8qKiBAaGlkZGVuICovIHZhciBfdGlkID0gaG9mXzEucGFyc2UoXCIkaWRcIik7XG4vKiogQGhpZGRlbiAqLyB2YXIgX3JpZCA9IGhvZl8xLnBhcnNlKFwicm91dGVyLiRpZFwiKTtcbi8qKiBAaGlkZGVuICovIHZhciB0cmFuc0xibCA9IGZ1bmN0aW9uICh0cmFucykgeyByZXR1cm4gXCJUcmFuc2l0aW9uICNcIiArIF90aWQodHJhbnMpICsgXCItXCIgKyBfcmlkKHRyYW5zKTsgfTtcbi8qKlxuICogUHJpbnRzIFVJLVJvdXRlciBUcmFuc2l0aW9uIHRyYWNlIGluZm9ybWF0aW9uIHRvIHRoZSBjb25zb2xlLlxuICovXG52YXIgVHJhY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBmdW5jdGlvbiBUcmFjZSgpIHtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHt9O1xuICAgICAgICB0aGlzLmFwcHJveGltYXRlRGlnZXN0cyA9IDA7XG4gICAgfVxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVHJhY2UucHJvdG90eXBlLl9zZXQgPSBmdW5jdGlvbiAoZW5hYmxlZCwgY2F0ZWdvcmllcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWNhdGVnb3JpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzID0gT2JqZWN0LmtleXMoQ2F0ZWdvcnkpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gcGFyc2VJbnQoaywgMTApOyB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGspIHsgcmV0dXJuICFpc05hTihrKTsgfSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIENhdGVnb3J5W2tleV07IH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGVnb3JpZXMubWFwKG5vcm1hbGl6ZWRDYXQpLmZvckVhY2goZnVuY3Rpb24gKGNhdGVnb3J5KSB7IHJldHVybiBfdGhpcy5fZW5hYmxlZFtjYXRlZ29yeV0gPSBlbmFibGVkOyB9KTtcbiAgICB9O1xuICAgIFRyYWNlLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0KHRydWUsIGNhdGVnb3JpZXMpO1xuICAgIH07XG4gICAgVHJhY2UucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0KGZhbHNlLCBjYXRlZ29yaWVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZW5hYmxlZCBzdGF0ZXVzIG9mIGEgW1tDYXRlZ29yeV1dXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIHRyYWNlLmVuYWJsZWQoXCJWSUVXQ09ORklHXCIpOyAvLyB0cnVlIG9yIGZhbHNlXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBib29sZWFuIHRydWUgaWYgdGhlIGNhdGVnb3J5IGlzIGVuYWJsZWRcbiAgICAgKi9cbiAgICBUcmFjZS5wcm90b3R5cGUuZW5hYmxlZCA9IGZ1bmN0aW9uIChjYXRlZ29yeSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9lbmFibGVkW25vcm1hbGl6ZWRDYXQoY2F0ZWdvcnkpXTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVHJhbnNpdGlvblN0YXJ0ID0gZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlRSQU5TSVRJT04pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlLmxvZyh0cmFuc0xibCh0cmFucykgKyBcIjogU3RhcnRlZCAgLT4gXCIgKyBzdHJpbmdzXzEuc3RyaW5naWZ5KHRyYW5zKSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZVRyYW5zaXRpb25JZ25vcmVkID0gZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlRSQU5TSVRJT04pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlLmxvZyh0cmFuc0xibCh0cmFucykgKyBcIjogSWdub3JlZCAgPD4gXCIgKyBzdHJpbmdzXzEuc3RyaW5naWZ5KHRyYW5zKSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZUhvb2tJbnZvY2F0aW9uID0gZnVuY3Rpb24gKHN0ZXAsIHRyYW5zLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LkhPT0spKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgZXZlbnQgPSBob2ZfMS5wYXJzZShcInRyYWNlRGF0YS5ob29rVHlwZVwiKShvcHRpb25zKSB8fCBcImludGVybmFsXCIsIGNvbnRleHQgPSBob2ZfMS5wYXJzZShcInRyYWNlRGF0YS5jb250ZXh0LnN0YXRlLm5hbWVcIikob3B0aW9ucykgfHwgaG9mXzEucGFyc2UoXCJ0cmFjZURhdGEuY29udGV4dFwiKShvcHRpb25zKSB8fCBcInVua25vd25cIiwgbmFtZSA9IHN0cmluZ3NfMS5mdW5jdGlvblRvU3RyaW5nKHN0ZXAucmVnaXN0ZXJlZEhvb2suY2FsbGJhY2spO1xuICAgICAgICBjb25zb2xlLmxvZyh0cmFuc0xibCh0cmFucykgKyBcIjogICBIb29rIC0+IFwiICsgZXZlbnQgKyBcIiBjb250ZXh0OiBcIiArIGNvbnRleHQgKyBcIiwgXCIgKyBzdHJpbmdzXzEubWF4TGVuZ3RoKDIwMCwgbmFtZSkpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cbiAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VIb29rUmVzdWx0ID0gZnVuY3Rpb24gKGhvb2tSZXN1bHQsIHRyYW5zLCB0cmFuc2l0aW9uT3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5IT09LKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc29sZS5sb2codHJhbnNMYmwodHJhbnMpICsgXCI6ICAgPC0gSG9vayByZXR1cm5lZDogXCIgKyBzdHJpbmdzXzEubWF4TGVuZ3RoKDIwMCwgc3RyaW5nc18xLnN0cmluZ2lmeShob29rUmVzdWx0KSkpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cbiAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VSZXNvbHZlUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCB3aGVuLCB0cmFucykge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5SRVNPTFZFKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc29sZS5sb2codHJhbnNMYmwodHJhbnMpICsgXCI6ICAgICAgICAgUmVzb2x2aW5nIFwiICsgcGF0aCArIFwiIChcIiArIHdoZW4gKyBcIilcIik7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZVJlc29sdmFibGVSZXNvbHZlZCA9IGZ1bmN0aW9uIChyZXNvbHZhYmxlLCB0cmFucykge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5SRVNPTFZFKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc29sZS5sb2codHJhbnNMYmwodHJhbnMpICsgXCI6ICAgICAgICAgICAgICAgPC0gUmVzb2x2ZWQgIFwiICsgcmVzb2x2YWJsZSArIFwiIHRvOiBcIiArIHN0cmluZ3NfMS5tYXhMZW5ndGgoMjAwLCBzdHJpbmdzXzEuc3RyaW5naWZ5KHJlc29sdmFibGUuZGF0YSkpKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlRXJyb3IgPSBmdW5jdGlvbiAocmVhc29uLCB0cmFucykge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5UUkFOU0lUSU9OKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc29sZS5sb2codHJhbnNMYmwodHJhbnMpICsgXCI6IDwtIFJlamVjdGVkIFwiICsgc3RyaW5nc18xLnN0cmluZ2lmeSh0cmFucykgKyBcIiwgcmVhc29uOiBcIiArIHJlYXNvbik7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZVN1Y2Nlc3MgPSBmdW5jdGlvbiAoZmluYWxTdGF0ZSwgdHJhbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVFJBTlNJVElPTikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnNvbGUubG9nKHRyYW5zTGJsKHRyYW5zKSArIFwiOiA8LSBTdWNjZXNzICBcIiArIHN0cmluZ3NfMS5zdHJpbmdpZnkodHJhbnMpICsgXCIsIGZpbmFsIHN0YXRlOiBcIiArIGZpbmFsU3RhdGUubmFtZSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZVVJVmlld0V2ZW50ID0gZnVuY3Rpb24gKGV2ZW50LCB2aWV3RGF0YSwgZXh0cmEpIHtcbiAgICAgICAgaWYgKGV4dHJhID09PSB2b2lkIDApIHsgZXh0cmEgPSBcIlwiOyB9XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlVJVklFVykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnNvbGUubG9nKFwidWktdmlldzogXCIgKyBzdHJpbmdzXzEucGFkU3RyaW5nKDMwLCBldmVudCkgKyBcIiBcIiArIHVpVmlld1N0cmluZyh2aWV3RGF0YSkgKyBleHRyYSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZVVJVmlld0NvbmZpZ1VwZGF0ZWQgPSBmdW5jdGlvbiAodmlld0RhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVUlWSUVXKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy50cmFjZVVJVmlld0V2ZW50KFwiVXBkYXRpbmdcIiwgdmlld0RhdGEsIFwiIHdpdGggVmlld0NvbmZpZyBmcm9tIGNvbnRleHQ9J1wiICsgY29udGV4dCArIFwiJ1wiKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVUlWaWV3RmlsbCA9IGZ1bmN0aW9uICh2aWV3RGF0YSwgaHRtbCkge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5VSVZJRVcpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnRyYWNlVUlWaWV3RXZlbnQoXCJGaWxsXCIsIHZpZXdEYXRhLCBcIiB3aXRoOiBcIiArIHN0cmluZ3NfMS5tYXhMZW5ndGgoMjAwLCBodG1sKSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZVZpZXdTeW5jID0gZnVuY3Rpb24gKHBhaXJzKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlZJRVdDT05GSUcpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbWFwcGluZyA9IHBhaXJzLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB1aVZpZXdEYXRhID0gX2FbMF0sIGNvbmZpZyA9IF9hWzFdO1xuICAgICAgICAgICAgdmFyIHVpVmlldyA9IHVpVmlld0RhdGEuJHR5cGUgKyBcIjpcIiArIHVpVmlld0RhdGEuZnFuO1xuICAgICAgICAgICAgdmFyIHZpZXcgPSBjb25maWcgJiYgY29uZmlnLnZpZXdEZWNsLiRjb250ZXh0Lm5hbWUgKyBcIjogXCIgKyBjb25maWcudmlld0RlY2wuJG5hbWUgKyBcIiAoXCIgKyBjb25maWcudmlld0RlY2wuJHR5cGUgKyBcIilcIjtcbiAgICAgICAgICAgIHJldHVybiB7ICd1aS12aWV3IGZxbic6IHVpVmlldywgJ3N0YXRlOiB2aWV3IG5hbWUnOiB2aWV3IH07XG4gICAgICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGFbJ3VpLXZpZXcgZnFuJ10ubG9jYWxlQ29tcGFyZShiWyd1aS12aWV3IGZxbiddKTsgfSk7XG4gICAgICAgIGNvbnNvbGV0YWJsZShtYXBwaW5nKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVmlld1NlcnZpY2VFdmVudCA9IGZ1bmN0aW9uIChldmVudCwgdmlld0NvbmZpZykge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5WSUVXQ09ORklHKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc29sZS5sb2coXCJWSUVXQ09ORklHOiBcIiArIGV2ZW50ICsgXCIgXCIgKyB2aWV3Q29uZmlnU3RyaW5nKHZpZXdDb25maWcpKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVmlld1NlcnZpY2VVSVZpZXdFdmVudCA9IGZ1bmN0aW9uIChldmVudCwgdmlld0RhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVklFV0NPTkZJRykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVklFV0NPTkZJRzogXCIgKyBldmVudCArIFwiIFwiICsgdWlWaWV3U3RyaW5nKHZpZXdEYXRhKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVHJhY2U7XG59KCkpO1xuZXhwb3J0cy5UcmFjZSA9IFRyYWNlO1xuLyoqXG4gKiBUaGUgW1tUcmFjZV1dIHNpbmdsZXRvblxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiBpbXBvcnQge3RyYWNlfSBmcm9tIFwiYW5ndWxhci11aS1yb3V0ZXJcIjtcbiAqIHRyYWNlLmVuYWJsZSgxLCA1KTtcbiAqIGBgYFxuICovXG52YXIgdHJhY2UgPSBuZXcgVHJhY2UoKTtcbmV4cG9ydHMudHJhY2UgPSB0cmFjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYWNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL3RyYWNlLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @coreapi\n * @module params\n */ /** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar hof_1 = __webpack_require__(/*! ../common/hof */ 2);\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ 1);\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ 3);\nvar paramType_1 = __webpack_require__(/*! ./paramType */ 22);\n/** @hidden */ var hasOwn = Object.prototype.hasOwnProperty;\n/** @hidden */ var isShorthand = function (cfg) {\n    return ["value", "type", "squash", "array", "dynamic"].filter(hasOwn.bind(cfg || {})).length === 0;\n};\n/** @internalapi */\nvar DefType;\n(function (DefType) {\n    DefType[DefType["PATH"] = 0] = "PATH";\n    DefType[DefType["SEARCH"] = 1] = "SEARCH";\n    DefType[DefType["CONFIG"] = 2] = "CONFIG";\n})(DefType = exports.DefType || (exports.DefType = {}));\n/** @hidden */\nfunction unwrapShorthand(cfg) {\n    cfg = isShorthand(cfg) && { value: cfg } || cfg;\n    getStaticDefaultValue[\'__cacheable\'] = true;\n    function getStaticDefaultValue() {\n        return cfg.value;\n    }\n    return common_1.extend(cfg, {\n        $$fn: predicates_1.isInjectable(cfg.value) ? cfg.value : getStaticDefaultValue,\n    });\n}\n/** @hidden */\nfunction getType(cfg, urlType, location, id, paramTypes) {\n    if (cfg.type && urlType && urlType.name !== \'string\')\n        throw new Error("Param \'" + id + "\' has two type configurations.");\n    if (cfg.type && urlType && urlType.name === \'string\' && paramTypes.type(cfg.type))\n        return paramTypes.type(cfg.type);\n    if (urlType)\n        return urlType;\n    if (!cfg.type) {\n        var type = location === DefType.CONFIG ? "any" :\n            location === DefType.PATH ? "path" :\n                location === DefType.SEARCH ? "query" : "string";\n        return paramTypes.type(type);\n    }\n    return cfg.type instanceof paramType_1.ParamType ? cfg.type : paramTypes.type(cfg.type);\n}\n/**\n * @internalapi\n * returns false, true, or the squash value to indicate the "default parameter url squash policy".\n */\nfunction getSquashPolicy(config, isOptional, defaultPolicy) {\n    var squash = config.squash;\n    if (!isOptional || squash === false)\n        return false;\n    if (!predicates_1.isDefined(squash) || squash == null)\n        return defaultPolicy;\n    if (squash === true || predicates_1.isString(squash))\n        return squash;\n    throw new Error("Invalid squash policy: \'" + squash + "\'. Valid policies: false, true, or arbitrary string");\n}\n/** @internalapi */\nfunction getReplace(config, arrayMode, isOptional, squash) {\n    var replace, configuredKeys, defaultPolicy = [\n        { from: "", to: (isOptional || arrayMode ? undefined : "") },\n        { from: null, to: (isOptional || arrayMode ? undefined : "") },\n    ];\n    replace = predicates_1.isArray(config.replace) ? config.replace : [];\n    if (predicates_1.isString(squash))\n        replace.push({ from: squash, to: undefined });\n    configuredKeys = common_1.map(replace, hof_1.prop("from"));\n    return common_1.filter(defaultPolicy, function (item) { return configuredKeys.indexOf(item.from) === -1; }).concat(replace);\n}\n/** @internalapi */\nvar Param = /** @class */ (function () {\n    function Param(id, type, config, location, urlMatcherFactory) {\n        config = unwrapShorthand(config);\n        type = getType(config, type, location, id, urlMatcherFactory.paramTypes);\n        var arrayMode = getArrayMode();\n        type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;\n        var isOptional = config.value !== undefined || location === DefType.SEARCH;\n        var dynamic = predicates_1.isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;\n        var raw = predicates_1.isDefined(config.raw) ? !!config.raw : !!type.raw;\n        var squash = getSquashPolicy(config, isOptional, urlMatcherFactory.defaultSquashPolicy());\n        var replace = getReplace(config, arrayMode, isOptional, squash);\n        var inherit = predicates_1.isDefined(config.inherit) ? !!config.inherit : !!type.inherit;\n        // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n        function getArrayMode() {\n            var arrayDefaults = { array: (location === DefType.SEARCH ? "auto" : false) };\n            var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n            return common_1.extend(arrayDefaults, arrayParamNomenclature, config).array;\n        }\n        common_1.extend(this, { id: id, type: type, location: location, isOptional: isOptional, dynamic: dynamic, raw: raw, squash: squash, replace: replace, inherit: inherit, array: arrayMode, config: config });\n    }\n    Param.prototype.isDefaultValue = function (value) {\n        return this.isOptional && this.type.equals(this.value(), value);\n    };\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    Param.prototype.value = function (value) {\n        var _this = this;\n        /**\n         * [Internal] Get the default value of a parameter, which may be an injectable function.\n         */\n        var getDefaultValue = function () {\n            if (_this._defaultValueCache)\n                return _this._defaultValueCache.defaultValue;\n            if (!coreservices_1.services.$injector)\n                throw new Error("Injectable functions cannot be called at configuration time");\n            var defaultValue = coreservices_1.services.$injector.invoke(_this.config.$$fn);\n            if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue))\n                throw new Error("Default value (" + defaultValue + ") for parameter \'" + _this.id + "\' is not an instance of ParamType (" + _this.type.name + ")");\n            if (_this.config.$$fn[\'__cacheable\']) {\n                _this._defaultValueCache = { defaultValue: defaultValue };\n            }\n            return defaultValue;\n        };\n        var replaceSpecialValues = function (val) {\n            for (var _i = 0, _a = _this.replace; _i < _a.length; _i++) {\n                var tuple = _a[_i];\n                if (tuple.from === val)\n                    return tuple.to;\n            }\n            return val;\n        };\n        value = replaceSpecialValues(value);\n        return predicates_1.isUndefined(value) ? getDefaultValue() : this.type.$normalize(value);\n    };\n    Param.prototype.isSearch = function () {\n        return this.location === DefType.SEARCH;\n    };\n    Param.prototype.validates = function (value) {\n        // There was no parameter value, but the param is optional\n        if ((predicates_1.isUndefined(value) || value === null) && this.isOptional)\n            return true;\n        // The value was not of the correct ParamType, and could not be decoded to the correct ParamType\n        var normalized = this.type.$normalize(value);\n        if (!this.type.is(normalized))\n            return false;\n        // The value was of the correct type, but when encoded, did not match the ParamType\'s regexp\n        var encoded = this.type.encode(normalized);\n        return !(predicates_1.isString(encoded) && !this.type.pattern.exec(encoded));\n    };\n    Param.prototype.toString = function () {\n        return "{Param:" + this.id + " " + this.type + " squash: \'" + this.squash + "\' optional: " + this.isOptional + "}";\n    };\n    Param.values = function (params, values) {\n        if (values === void 0) { values = {}; }\n        var paramValues = {};\n        for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {\n            var param = params_1[_i];\n            paramValues[param.id] = param.value(values[param.id]);\n        }\n        return paramValues;\n    };\n    /**\n     * Finds [[Param]] objects which have different param values\n     *\n     * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects\n     *\n     * @param params: The list of Param objects to filter\n     * @param values1: The first set of parameter values\n     * @param values2: the second set of parameter values\n     *\n     * @returns any Param objects whose values were different between values1 and values2\n     */\n    Param.changed = function (params, values1, values2) {\n        if (values1 === void 0) { values1 = {}; }\n        if (values2 === void 0) { values2 = {}; }\n        return params.filter(function (param) { return !param.type.equals(values1[param.id], values2[param.id]); });\n    };\n    /**\n     * Checks if two param value objects are equal (for a set of [[Param]] objects)\n     *\n     * @param params The list of [[Param]] objects to check\n     * @param values1 The first set of param values\n     * @param values2 The second set of param values\n     *\n     * @returns true if the param values in values1 and values2 are equal\n     */\n    Param.equals = function (params, values1, values2) {\n        if (values1 === void 0) { values1 = {}; }\n        if (values2 === void 0) { values2 = {}; }\n        return Param.changed(params, values1, values2).length === 0;\n    };\n    /** Returns true if a the parameter values are valid, according to the Param definitions */\n    Param.validates = function (params, values) {\n        if (values === void 0) { values = {}; }\n        return params.map(function (param) { return param.validates(values[param.id]); }).reduce(common_1.allTrueR, true);\n    };\n    return Param;\n}());\nexports.Param = Param;\n//# sourceMappingURL=param.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9wYXJhbS5qcz8wODNkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSBwYXJhbXNcbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIGNvcmVzZXJ2aWNlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb3Jlc2VydmljZXNcIik7XG52YXIgcGFyYW1UeXBlXzEgPSByZXF1aXJlKFwiLi9wYXJhbVR5cGVcIik7XG4vKiogQGhpZGRlbiAqLyB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbi8qKiBAaGlkZGVuICovIHZhciBpc1Nob3J0aGFuZCA9IGZ1bmN0aW9uIChjZmcpIHtcbiAgICByZXR1cm4gW1widmFsdWVcIiwgXCJ0eXBlXCIsIFwic3F1YXNoXCIsIFwiYXJyYXlcIiwgXCJkeW5hbWljXCJdLmZpbHRlcihoYXNPd24uYmluZChjZmcgfHwge30pKS5sZW5ndGggPT09IDA7XG59O1xuLyoqIEBpbnRlcm5hbGFwaSAqL1xudmFyIERlZlR5cGU7XG4oZnVuY3Rpb24gKERlZlR5cGUpIHtcbiAgICBEZWZUeXBlW0RlZlR5cGVbXCJQQVRIXCJdID0gMF0gPSBcIlBBVEhcIjtcbiAgICBEZWZUeXBlW0RlZlR5cGVbXCJTRUFSQ0hcIl0gPSAxXSA9IFwiU0VBUkNIXCI7XG4gICAgRGVmVHlwZVtEZWZUeXBlW1wiQ09ORklHXCJdID0gMl0gPSBcIkNPTkZJR1wiO1xufSkoRGVmVHlwZSA9IGV4cG9ydHMuRGVmVHlwZSB8fCAoZXhwb3J0cy5EZWZUeXBlID0ge30pKTtcbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiB1bndyYXBTaG9ydGhhbmQoY2ZnKSB7XG4gICAgY2ZnID0gaXNTaG9ydGhhbmQoY2ZnKSAmJiB7IHZhbHVlOiBjZmcgfSB8fCBjZmc7XG4gICAgZ2V0U3RhdGljRGVmYXVsdFZhbHVlWydfX2NhY2hlYWJsZSddID0gdHJ1ZTtcbiAgICBmdW5jdGlvbiBnZXRTdGF0aWNEZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBjZmcudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBjb21tb25fMS5leHRlbmQoY2ZnLCB7XG4gICAgICAgICQkZm46IHByZWRpY2F0ZXNfMS5pc0luamVjdGFibGUoY2ZnLnZhbHVlKSA/IGNmZy52YWx1ZSA6IGdldFN0YXRpY0RlZmF1bHRWYWx1ZSxcbiAgICB9KTtcbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBnZXRUeXBlKGNmZywgdXJsVHlwZSwgbG9jYXRpb24sIGlkLCBwYXJhbVR5cGVzKSB7XG4gICAgaWYgKGNmZy50eXBlICYmIHVybFR5cGUgJiYgdXJsVHlwZS5uYW1lICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW0gJ1wiICsgaWQgKyBcIicgaGFzIHR3byB0eXBlIGNvbmZpZ3VyYXRpb25zLlwiKTtcbiAgICBpZiAoY2ZnLnR5cGUgJiYgdXJsVHlwZSAmJiB1cmxUeXBlLm5hbWUgPT09ICdzdHJpbmcnICYmIHBhcmFtVHlwZXMudHlwZShjZmcudHlwZSkpXG4gICAgICAgIHJldHVybiBwYXJhbVR5cGVzLnR5cGUoY2ZnLnR5cGUpO1xuICAgIGlmICh1cmxUeXBlKVxuICAgICAgICByZXR1cm4gdXJsVHlwZTtcbiAgICBpZiAoIWNmZy50eXBlKSB7XG4gICAgICAgIHZhciB0eXBlID0gbG9jYXRpb24gPT09IERlZlR5cGUuQ09ORklHID8gXCJhbnlcIiA6XG4gICAgICAgICAgICBsb2NhdGlvbiA9PT0gRGVmVHlwZS5QQVRIID8gXCJwYXRoXCIgOlxuICAgICAgICAgICAgICAgIGxvY2F0aW9uID09PSBEZWZUeXBlLlNFQVJDSCA/IFwicXVlcnlcIiA6IFwic3RyaW5nXCI7XG4gICAgICAgIHJldHVybiBwYXJhbVR5cGVzLnR5cGUodHlwZSk7XG4gICAgfVxuICAgIHJldHVybiBjZmcudHlwZSBpbnN0YW5jZW9mIHBhcmFtVHlwZV8xLlBhcmFtVHlwZSA/IGNmZy50eXBlIDogcGFyYW1UeXBlcy50eXBlKGNmZy50eXBlKTtcbn1cbi8qKlxuICogQGludGVybmFsYXBpXG4gKiByZXR1cm5zIGZhbHNlLCB0cnVlLCBvciB0aGUgc3F1YXNoIHZhbHVlIHRvIGluZGljYXRlIHRoZSBcImRlZmF1bHQgcGFyYW1ldGVyIHVybCBzcXVhc2ggcG9saWN5XCIuXG4gKi9cbmZ1bmN0aW9uIGdldFNxdWFzaFBvbGljeShjb25maWcsIGlzT3B0aW9uYWwsIGRlZmF1bHRQb2xpY3kpIHtcbiAgICB2YXIgc3F1YXNoID0gY29uZmlnLnNxdWFzaDtcbiAgICBpZiAoIWlzT3B0aW9uYWwgfHwgc3F1YXNoID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghcHJlZGljYXRlc18xLmlzRGVmaW5lZChzcXVhc2gpIHx8IHNxdWFzaCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZGVmYXVsdFBvbGljeTtcbiAgICBpZiAoc3F1YXNoID09PSB0cnVlIHx8IHByZWRpY2F0ZXNfMS5pc1N0cmluZyhzcXVhc2gpKVxuICAgICAgICByZXR1cm4gc3F1YXNoO1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3F1YXNoIHBvbGljeTogJ1wiICsgc3F1YXNoICsgXCInLiBWYWxpZCBwb2xpY2llczogZmFsc2UsIHRydWUsIG9yIGFyYml0cmFyeSBzdHJpbmdcIik7XG59XG4vKiogQGludGVybmFsYXBpICovXG5mdW5jdGlvbiBnZXRSZXBsYWNlKGNvbmZpZywgYXJyYXlNb2RlLCBpc09wdGlvbmFsLCBzcXVhc2gpIHtcbiAgICB2YXIgcmVwbGFjZSwgY29uZmlndXJlZEtleXMsIGRlZmF1bHRQb2xpY3kgPSBbXG4gICAgICAgIHsgZnJvbTogXCJcIiwgdG86IChpc09wdGlvbmFsIHx8IGFycmF5TW9kZSA/IHVuZGVmaW5lZCA6IFwiXCIpIH0sXG4gICAgICAgIHsgZnJvbTogbnVsbCwgdG86IChpc09wdGlvbmFsIHx8IGFycmF5TW9kZSA/IHVuZGVmaW5lZCA6IFwiXCIpIH0sXG4gICAgXTtcbiAgICByZXBsYWNlID0gcHJlZGljYXRlc18xLmlzQXJyYXkoY29uZmlnLnJlcGxhY2UpID8gY29uZmlnLnJlcGxhY2UgOiBbXTtcbiAgICBpZiAocHJlZGljYXRlc18xLmlzU3RyaW5nKHNxdWFzaCkpXG4gICAgICAgIHJlcGxhY2UucHVzaCh7IGZyb206IHNxdWFzaCwgdG86IHVuZGVmaW5lZCB9KTtcbiAgICBjb25maWd1cmVkS2V5cyA9IGNvbW1vbl8xLm1hcChyZXBsYWNlLCBob2ZfMS5wcm9wKFwiZnJvbVwiKSk7XG4gICAgcmV0dXJuIGNvbW1vbl8xLmZpbHRlcihkZWZhdWx0UG9saWN5LCBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gY29uZmlndXJlZEtleXMuaW5kZXhPZihpdGVtLmZyb20pID09PSAtMTsgfSkuY29uY2F0KHJlcGxhY2UpO1xufVxuLyoqIEBpbnRlcm5hbGFwaSAqL1xudmFyIFBhcmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcmFtKGlkLCB0eXBlLCBjb25maWcsIGxvY2F0aW9uLCB1cmxNYXRjaGVyRmFjdG9yeSkge1xuICAgICAgICBjb25maWcgPSB1bndyYXBTaG9ydGhhbmQoY29uZmlnKTtcbiAgICAgICAgdHlwZSA9IGdldFR5cGUoY29uZmlnLCB0eXBlLCBsb2NhdGlvbiwgaWQsIHVybE1hdGNoZXJGYWN0b3J5LnBhcmFtVHlwZXMpO1xuICAgICAgICB2YXIgYXJyYXlNb2RlID0gZ2V0QXJyYXlNb2RlKCk7XG4gICAgICAgIHR5cGUgPSBhcnJheU1vZGUgPyB0eXBlLiRhc0FycmF5KGFycmF5TW9kZSwgbG9jYXRpb24gPT09IERlZlR5cGUuU0VBUkNIKSA6IHR5cGU7XG4gICAgICAgIHZhciBpc09wdGlvbmFsID0gY29uZmlnLnZhbHVlICE9PSB1bmRlZmluZWQgfHwgbG9jYXRpb24gPT09IERlZlR5cGUuU0VBUkNIO1xuICAgICAgICB2YXIgZHluYW1pYyA9IHByZWRpY2F0ZXNfMS5pc0RlZmluZWQoY29uZmlnLmR5bmFtaWMpID8gISFjb25maWcuZHluYW1pYyA6ICEhdHlwZS5keW5hbWljO1xuICAgICAgICB2YXIgcmF3ID0gcHJlZGljYXRlc18xLmlzRGVmaW5lZChjb25maWcucmF3KSA/ICEhY29uZmlnLnJhdyA6ICEhdHlwZS5yYXc7XG4gICAgICAgIHZhciBzcXVhc2ggPSBnZXRTcXVhc2hQb2xpY3koY29uZmlnLCBpc09wdGlvbmFsLCB1cmxNYXRjaGVyRmFjdG9yeS5kZWZhdWx0U3F1YXNoUG9saWN5KCkpO1xuICAgICAgICB2YXIgcmVwbGFjZSA9IGdldFJlcGxhY2UoY29uZmlnLCBhcnJheU1vZGUsIGlzT3B0aW9uYWwsIHNxdWFzaCk7XG4gICAgICAgIHZhciBpbmhlcml0ID0gcHJlZGljYXRlc18xLmlzRGVmaW5lZChjb25maWcuaW5oZXJpdCkgPyAhIWNvbmZpZy5pbmhlcml0IDogISF0eXBlLmluaGVyaXQ7XG4gICAgICAgIC8vIGFycmF5IGNvbmZpZzogcGFyYW0gbmFtZSAocGFyYW1bXSkgb3ZlcnJpZGVzIGRlZmF1bHQgc2V0dGluZ3MuICBleHBsaWNpdCBjb25maWcgb3ZlcnJpZGVzIHBhcmFtIG5hbWUuXG4gICAgICAgIGZ1bmN0aW9uIGdldEFycmF5TW9kZSgpIHtcbiAgICAgICAgICAgIHZhciBhcnJheURlZmF1bHRzID0geyBhcnJheTogKGxvY2F0aW9uID09PSBEZWZUeXBlLlNFQVJDSCA/IFwiYXV0b1wiIDogZmFsc2UpIH07XG4gICAgICAgICAgICB2YXIgYXJyYXlQYXJhbU5vbWVuY2xhdHVyZSA9IGlkLm1hdGNoKC9cXFtcXF0kLykgPyB7IGFycmF5OiB0cnVlIH0gOiB7fTtcbiAgICAgICAgICAgIHJldHVybiBjb21tb25fMS5leHRlbmQoYXJyYXlEZWZhdWx0cywgYXJyYXlQYXJhbU5vbWVuY2xhdHVyZSwgY29uZmlnKS5hcnJheTtcbiAgICAgICAgfVxuICAgICAgICBjb21tb25fMS5leHRlbmQodGhpcywgeyBpZDogaWQsIHR5cGU6IHR5cGUsIGxvY2F0aW9uOiBsb2NhdGlvbiwgaXNPcHRpb25hbDogaXNPcHRpb25hbCwgZHluYW1pYzogZHluYW1pYywgcmF3OiByYXcsIHNxdWFzaDogc3F1YXNoLCByZXBsYWNlOiByZXBsYWNlLCBpbmhlcml0OiBpbmhlcml0LCBhcnJheTogYXJyYXlNb2RlLCBjb25maWc6IGNvbmZpZyB9KTtcbiAgICB9XG4gICAgUGFyYW0ucHJvdG90eXBlLmlzRGVmYXVsdFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzT3B0aW9uYWwgJiYgdGhpcy50eXBlLmVxdWFscyh0aGlzLnZhbHVlKCksIHZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFtJbnRlcm5hbF0gR2V0cyB0aGUgZGVjb2RlZCByZXByZXNlbnRhdGlvbiBvZiBhIHZhbHVlIGlmIHRoZSB2YWx1ZSBpcyBkZWZpbmVkLCBvdGhlcndpc2UsIHJldHVybnMgdGhlXG4gICAgICogZGVmYXVsdCB2YWx1ZSwgd2hpY2ggbWF5IGJlIHRoZSByZXN1bHQgb2YgYW4gaW5qZWN0YWJsZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBQYXJhbS5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFtJbnRlcm5hbF0gR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcGFyYW1ldGVyLCB3aGljaCBtYXkgYmUgYW4gaW5qZWN0YWJsZSBmdW5jdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBnZXREZWZhdWx0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX2RlZmF1bHRWYWx1ZUNhY2hlKVxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZGVmYXVsdFZhbHVlQ2FjaGUuZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgaWYgKCFjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kaW5qZWN0b3IpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5qZWN0YWJsZSBmdW5jdGlvbnMgY2Fubm90IGJlIGNhbGxlZCBhdCBjb25maWd1cmF0aW9uIHRpbWVcIik7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdFZhbHVlID0gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJGluamVjdG9yLmludm9rZShfdGhpcy5jb25maWcuJCRmbik7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSBudWxsICYmIGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFfdGhpcy50eXBlLmlzKGRlZmF1bHRWYWx1ZSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVmYXVsdCB2YWx1ZSAoXCIgKyBkZWZhdWx0VmFsdWUgKyBcIikgZm9yIHBhcmFtZXRlciAnXCIgKyBfdGhpcy5pZCArIFwiJyBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgUGFyYW1UeXBlIChcIiArIF90aGlzLnR5cGUubmFtZSArIFwiKVwiKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5jb25maWcuJCRmblsnX19jYWNoZWFibGUnXSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9kZWZhdWx0VmFsdWVDYWNoZSA9IHsgZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXBsYWNlU3BlY2lhbFZhbHVlcyA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBfdGhpcy5yZXBsYWNlOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciB0dXBsZSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAodHVwbGUuZnJvbSA9PT0gdmFsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHVwbGUudG87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgICB2YWx1ZSA9IHJlcGxhY2VTcGVjaWFsVmFsdWVzKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc1VuZGVmaW5lZCh2YWx1ZSkgPyBnZXREZWZhdWx0VmFsdWUoKSA6IHRoaXMudHlwZS4kbm9ybWFsaXplKHZhbHVlKTtcbiAgICB9O1xuICAgIFBhcmFtLnByb3RvdHlwZS5pc1NlYXJjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb24gPT09IERlZlR5cGUuU0VBUkNIO1xuICAgIH07XG4gICAgUGFyYW0ucHJvdG90eXBlLnZhbGlkYXRlcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBUaGVyZSB3YXMgbm8gcGFyYW1ldGVyIHZhbHVlLCBidXQgdGhlIHBhcmFtIGlzIG9wdGlvbmFsXG4gICAgICAgIGlmICgocHJlZGljYXRlc18xLmlzVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCkgJiYgdGhpcy5pc09wdGlvbmFsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIFRoZSB2YWx1ZSB3YXMgbm90IG9mIHRoZSBjb3JyZWN0IFBhcmFtVHlwZSwgYW5kIGNvdWxkIG5vdCBiZSBkZWNvZGVkIHRvIHRoZSBjb3JyZWN0IFBhcmFtVHlwZVxuICAgICAgICB2YXIgbm9ybWFsaXplZCA9IHRoaXMudHlwZS4kbm9ybWFsaXplKHZhbHVlKTtcbiAgICAgICAgaWYgKCF0aGlzLnR5cGUuaXMobm9ybWFsaXplZCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFRoZSB2YWx1ZSB3YXMgb2YgdGhlIGNvcnJlY3QgdHlwZSwgYnV0IHdoZW4gZW5jb2RlZCwgZGlkIG5vdCBtYXRjaCB0aGUgUGFyYW1UeXBlJ3MgcmVnZXhwXG4gICAgICAgIHZhciBlbmNvZGVkID0gdGhpcy50eXBlLmVuY29kZShub3JtYWxpemVkKTtcbiAgICAgICAgcmV0dXJuICEocHJlZGljYXRlc18xLmlzU3RyaW5nKGVuY29kZWQpICYmICF0aGlzLnR5cGUucGF0dGVybi5leGVjKGVuY29kZWQpKTtcbiAgICB9O1xuICAgIFBhcmFtLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwie1BhcmFtOlwiICsgdGhpcy5pZCArIFwiIFwiICsgdGhpcy50eXBlICsgXCIgc3F1YXNoOiAnXCIgKyB0aGlzLnNxdWFzaCArIFwiJyBvcHRpb25hbDogXCIgKyB0aGlzLmlzT3B0aW9uYWwgKyBcIn1cIjtcbiAgICB9O1xuICAgIFBhcmFtLnZhbHVlcyA9IGZ1bmN0aW9uIChwYXJhbXMsIHZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWVzID09PSB2b2lkIDApIHsgdmFsdWVzID0ge307IH1cbiAgICAgICAgdmFyIHBhcmFtVmFsdWVzID0ge307XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgcGFyYW1zXzEgPSBwYXJhbXM7IF9pIDwgcGFyYW1zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW0gPSBwYXJhbXNfMVtfaV07XG4gICAgICAgICAgICBwYXJhbVZhbHVlc1twYXJhbS5pZF0gPSBwYXJhbS52YWx1ZSh2YWx1ZXNbcGFyYW0uaWRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1WYWx1ZXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaW5kcyBbW1BhcmFtXV0gb2JqZWN0cyB3aGljaCBoYXZlIGRpZmZlcmVudCBwYXJhbSB2YWx1ZXNcbiAgICAgKlxuICAgICAqIEZpbHRlcnMgYSBsaXN0IG9mIFtbUGFyYW1dXSBvYmplY3RzIHRvIG9ubHkgdGhvc2Ugd2hvc2UgcGFyYW1ldGVyIHZhbHVlcyBkaWZmZXIgaW4gdHdvIHBhcmFtIHZhbHVlIG9iamVjdHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXM6IFRoZSBsaXN0IG9mIFBhcmFtIG9iamVjdHMgdG8gZmlsdGVyXG4gICAgICogQHBhcmFtIHZhbHVlczE6IFRoZSBmaXJzdCBzZXQgb2YgcGFyYW1ldGVyIHZhbHVlc1xuICAgICAqIEBwYXJhbSB2YWx1ZXMyOiB0aGUgc2Vjb25kIHNldCBvZiBwYXJhbWV0ZXIgdmFsdWVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhbnkgUGFyYW0gb2JqZWN0cyB3aG9zZSB2YWx1ZXMgd2VyZSBkaWZmZXJlbnQgYmV0d2VlbiB2YWx1ZXMxIGFuZCB2YWx1ZXMyXG4gICAgICovXG4gICAgUGFyYW0uY2hhbmdlZCA9IGZ1bmN0aW9uIChwYXJhbXMsIHZhbHVlczEsIHZhbHVlczIpIHtcbiAgICAgICAgaWYgKHZhbHVlczEgPT09IHZvaWQgMCkgeyB2YWx1ZXMxID0ge307IH1cbiAgICAgICAgaWYgKHZhbHVlczIgPT09IHZvaWQgMCkgeyB2YWx1ZXMyID0ge307IH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcy5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiAhcGFyYW0udHlwZS5lcXVhbHModmFsdWVzMVtwYXJhbS5pZF0sIHZhbHVlczJbcGFyYW0uaWRdKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdHdvIHBhcmFtIHZhbHVlIG9iamVjdHMgYXJlIGVxdWFsIChmb3IgYSBzZXQgb2YgW1tQYXJhbV1dIG9iamVjdHMpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIFRoZSBsaXN0IG9mIFtbUGFyYW1dXSBvYmplY3RzIHRvIGNoZWNrXG4gICAgICogQHBhcmFtIHZhbHVlczEgVGhlIGZpcnN0IHNldCBvZiBwYXJhbSB2YWx1ZXNcbiAgICAgKiBAcGFyYW0gdmFsdWVzMiBUaGUgc2Vjb25kIHNldCBvZiBwYXJhbSB2YWx1ZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHBhcmFtIHZhbHVlcyBpbiB2YWx1ZXMxIGFuZCB2YWx1ZXMyIGFyZSBlcXVhbFxuICAgICAqL1xuICAgIFBhcmFtLmVxdWFscyA9IGZ1bmN0aW9uIChwYXJhbXMsIHZhbHVlczEsIHZhbHVlczIpIHtcbiAgICAgICAgaWYgKHZhbHVlczEgPT09IHZvaWQgMCkgeyB2YWx1ZXMxID0ge307IH1cbiAgICAgICAgaWYgKHZhbHVlczIgPT09IHZvaWQgMCkgeyB2YWx1ZXMyID0ge307IH1cbiAgICAgICAgcmV0dXJuIFBhcmFtLmNoYW5nZWQocGFyYW1zLCB2YWx1ZXMxLCB2YWx1ZXMyKS5sZW5ndGggPT09IDA7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIGEgdGhlIHBhcmFtZXRlciB2YWx1ZXMgYXJlIHZhbGlkLCBhY2NvcmRpbmcgdG8gdGhlIFBhcmFtIGRlZmluaXRpb25zICovXG4gICAgUGFyYW0udmFsaWRhdGVzID0gZnVuY3Rpb24gKHBhcmFtcywgdmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWx1ZXMgPT09IHZvaWQgMCkgeyB2YWx1ZXMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gcGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHBhcmFtLnZhbGlkYXRlcyh2YWx1ZXNbcGFyYW0uaWRdKTsgfSkucmVkdWNlKGNvbW1vbl8xLmFsbFRydWVSLCB0cnVlKTtcbiAgICB9O1xuICAgIHJldHVybiBQYXJhbTtcbn0oKSk7XG5leHBvcnRzLlBhcmFtID0gUGFyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJhbS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9wYXJhbS5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n')},function(module,exports,__webpack_require__){"use strict";eval('\n/**\n * @coreapi\n * @module state\n */ /** for typedoc */\nObject.defineProperty(exports, "__esModule", { value: true });\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ 1);\nvar strings_1 = __webpack_require__(/*! ../common/strings */ 6);\nvar common_1 = __webpack_require__(/*! ../common */ 5);\n/**\n * Encapsulate the target (destination) state/params/options of a [[Transition]].\n *\n * This class is frequently used to redirect a transition to a new destination.\n *\n * See:\n *\n * - [[HookResult]]\n * - [[TransitionHookFn]]\n * - [[TransitionService.onStart]]\n *\n * To create a `TargetState`, use [[StateService.target]].\n *\n * ---\n *\n * This class wraps:\n *\n * 1) an identifier for a state\n * 2) a set of parameters\n * 3) and transition options\n * 4) the registered state object (the [[StateDeclaration]])\n *\n * Many UI-Router APIs such as [[StateService.go]] take a [[StateOrName]] argument which can\n * either be a *state object* (a [[StateDeclaration]] or [[StateObject]]) or a *state name* (a string).\n * The `TargetState` class normalizes those options.\n *\n * A `TargetState` may be valid (the state being targeted exists in the registry)\n * or invalid (the state being targeted is not registered).\n */\nvar TargetState = /** @class */ (function () {\n    /**\n     * The TargetState constructor\n     *\n     * Note: Do not construct a `TargetState` manually.\n     * To create a `TargetState`, use the [[StateService.target]] factory method.\n     *\n     * @param _stateRegistry The StateRegistry to use to look up the _definition\n     * @param _identifier An identifier for a state.\n     *    Either a fully-qualified state name, or the object used to define the state.\n     * @param _params Parameters for the target state\n     * @param _options Transition options.\n     *\n     * @internalapi\n     */\n    function TargetState(_stateRegistry, _identifier, _params, _options) {\n        this._stateRegistry = _stateRegistry;\n        this._identifier = _identifier;\n        this._identifier = _identifier;\n        this._params = common_1.extend({}, _params || {});\n        this._options = common_1.extend({}, _options || {});\n        this._definition = _stateRegistry.matcher.find(_identifier, this._options.relative);\n    }\n    /** The name of the state this object targets */\n    TargetState.prototype.name = function () {\n        return this._definition && this._definition.name || this._identifier;\n    };\n    /** The identifier used when creating this TargetState */\n    TargetState.prototype.identifier = function () {\n        return this._identifier;\n    };\n    /** The target parameter values */\n    TargetState.prototype.params = function () {\n        return this._params;\n    };\n    /** The internal state object (if it was found) */\n    TargetState.prototype.$state = function () {\n        return this._definition;\n    };\n    /** The internal state declaration (if it was found) */\n    TargetState.prototype.state = function () {\n        return this._definition && this._definition.self;\n    };\n    /** The target options */\n    TargetState.prototype.options = function () {\n        return this._options;\n    };\n    /** True if the target state was found */\n    TargetState.prototype.exists = function () {\n        return !!(this._definition && this._definition.self);\n    };\n    /** True if the object is valid */\n    TargetState.prototype.valid = function () {\n        return !this.error();\n    };\n    /** If the object is invalid, returns the reason why */\n    TargetState.prototype.error = function () {\n        var base = this.options().relative;\n        if (!this._definition && !!base) {\n            var stateName = base.name ? base.name : base;\n            return "Could not resolve \'" + this.name() + "\' from state \'" + stateName + "\'";\n        }\n        if (!this._definition)\n            return "No such state \'" + this.name() + "\'";\n        if (!this._definition.self)\n            return "State \'" + this.name() + "\' has an invalid definition";\n    };\n    TargetState.prototype.toString = function () {\n        return "\'" + this.name() + "\'" + strings_1.stringify(this.params());\n    };\n    /**\n     * Returns a copy of this TargetState which targets a different state.\n     * The new TargetState has the same parameter values and transition options.\n     *\n     * @param state The new state that should be targeted\n     */\n    TargetState.prototype.withState = function (state) {\n        return new TargetState(this._stateRegistry, state, this._params, this._options);\n    };\n    /**\n     * Returns a copy of this TargetState, using the specified parameter values.\n     *\n     * @param params the new parameter values to use\n     * @param replace When false (default) the new parameter values will be merged with the current values.\n     *                When true the parameter values will be used instead of the current values.\n     */\n    TargetState.prototype.withParams = function (params, replace) {\n        if (replace === void 0) { replace = false; }\n        var newParams = replace ? params : common_1.extend({}, this._params, params);\n        return new TargetState(this._stateRegistry, this._identifier, newParams, this._options);\n    };\n    /**\n     * Returns a copy of this TargetState, using the specified Transition Options.\n     *\n     * @param options the new options to use\n     * @param replace When false (default) the new options will be merged with the current options.\n     *                When true the options will be used instead of the current options.\n     */\n    TargetState.prototype.withOptions = function (options, replace) {\n        if (replace === void 0) { replace = false; }\n        var newOpts = replace ? options : common_1.extend({}, this._options, options);\n        return new TargetState(this._stateRegistry, this._identifier, this._params, newOpts);\n    };\n    /** Returns true if the object has a state property that might be a state or state name */\n    TargetState.isDef = function (obj) {\n        return obj && obj.state && (predicates_1.isString(obj.state) || predicates_1.isString(obj.state.name));\n    };\n    return TargetState;\n}());\nexports.TargetState = TargetState;\n//# sourceMappingURL=targetState.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3RhcmdldFN0YXRlLmpzP2FkNTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHN0YXRlXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vc3RyaW5nc1wiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG4vKipcbiAqIEVuY2Fwc3VsYXRlIHRoZSB0YXJnZXQgKGRlc3RpbmF0aW9uKSBzdGF0ZS9wYXJhbXMvb3B0aW9ucyBvZiBhIFtbVHJhbnNpdGlvbl1dLlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgZnJlcXVlbnRseSB1c2VkIHRvIHJlZGlyZWN0IGEgdHJhbnNpdGlvbiB0byBhIG5ldyBkZXN0aW5hdGlvbi5cbiAqXG4gKiBTZWU6XG4gKlxuICogLSBbW0hvb2tSZXN1bHRdXVxuICogLSBbW1RyYW5zaXRpb25Ib29rRm5dXVxuICogLSBbW1RyYW5zaXRpb25TZXJ2aWNlLm9uU3RhcnRdXVxuICpcbiAqIFRvIGNyZWF0ZSBhIGBUYXJnZXRTdGF0ZWAsIHVzZSBbW1N0YXRlU2VydmljZS50YXJnZXRdXS5cbiAqXG4gKiAtLS1cbiAqXG4gKiBUaGlzIGNsYXNzIHdyYXBzOlxuICpcbiAqIDEpIGFuIGlkZW50aWZpZXIgZm9yIGEgc3RhdGVcbiAqIDIpIGEgc2V0IG9mIHBhcmFtZXRlcnNcbiAqIDMpIGFuZCB0cmFuc2l0aW9uIG9wdGlvbnNcbiAqIDQpIHRoZSByZWdpc3RlcmVkIHN0YXRlIG9iamVjdCAodGhlIFtbU3RhdGVEZWNsYXJhdGlvbl1dKVxuICpcbiAqIE1hbnkgVUktUm91dGVyIEFQSXMgc3VjaCBhcyBbW1N0YXRlU2VydmljZS5nb11dIHRha2UgYSBbW1N0YXRlT3JOYW1lXV0gYXJndW1lbnQgd2hpY2ggY2FuXG4gKiBlaXRoZXIgYmUgYSAqc3RhdGUgb2JqZWN0KiAoYSBbW1N0YXRlRGVjbGFyYXRpb25dXSBvciBbW1N0YXRlT2JqZWN0XV0pIG9yIGEgKnN0YXRlIG5hbWUqIChhIHN0cmluZykuXG4gKiBUaGUgYFRhcmdldFN0YXRlYCBjbGFzcyBub3JtYWxpemVzIHRob3NlIG9wdGlvbnMuXG4gKlxuICogQSBgVGFyZ2V0U3RhdGVgIG1heSBiZSB2YWxpZCAodGhlIHN0YXRlIGJlaW5nIHRhcmdldGVkIGV4aXN0cyBpbiB0aGUgcmVnaXN0cnkpXG4gKiBvciBpbnZhbGlkICh0aGUgc3RhdGUgYmVpbmcgdGFyZ2V0ZWQgaXMgbm90IHJlZ2lzdGVyZWQpLlxuICovXG52YXIgVGFyZ2V0U3RhdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogVGhlIFRhcmdldFN0YXRlIGNvbnN0cnVjdG9yXG4gICAgICpcbiAgICAgKiBOb3RlOiBEbyBub3QgY29uc3RydWN0IGEgYFRhcmdldFN0YXRlYCBtYW51YWxseS5cbiAgICAgKiBUbyBjcmVhdGUgYSBgVGFyZ2V0U3RhdGVgLCB1c2UgdGhlIFtbU3RhdGVTZXJ2aWNlLnRhcmdldF1dIGZhY3RvcnkgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIF9zdGF0ZVJlZ2lzdHJ5IFRoZSBTdGF0ZVJlZ2lzdHJ5IHRvIHVzZSB0byBsb29rIHVwIHRoZSBfZGVmaW5pdGlvblxuICAgICAqIEBwYXJhbSBfaWRlbnRpZmllciBBbiBpZGVudGlmaWVyIGZvciBhIHN0YXRlLlxuICAgICAqICAgIEVpdGhlciBhIGZ1bGx5LXF1YWxpZmllZCBzdGF0ZSBuYW1lLCBvciB0aGUgb2JqZWN0IHVzZWQgdG8gZGVmaW5lIHRoZSBzdGF0ZS5cbiAgICAgKiBAcGFyYW0gX3BhcmFtcyBQYXJhbWV0ZXJzIGZvciB0aGUgdGFyZ2V0IHN0YXRlXG4gICAgICogQHBhcmFtIF9vcHRpb25zIFRyYW5zaXRpb24gb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbGFwaVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRhcmdldFN0YXRlKF9zdGF0ZVJlZ2lzdHJ5LCBfaWRlbnRpZmllciwgX3BhcmFtcywgX29wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fc3RhdGVSZWdpc3RyeSA9IF9zdGF0ZVJlZ2lzdHJ5O1xuICAgICAgICB0aGlzLl9pZGVudGlmaWVyID0gX2lkZW50aWZpZXI7XG4gICAgICAgIHRoaXMuX2lkZW50aWZpZXIgPSBfaWRlbnRpZmllcjtcbiAgICAgICAgdGhpcy5fcGFyYW1zID0gY29tbW9uXzEuZXh0ZW5kKHt9LCBfcGFyYW1zIHx8IHt9KTtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IGNvbW1vbl8xLmV4dGVuZCh7fSwgX29wdGlvbnMgfHwge30pO1xuICAgICAgICB0aGlzLl9kZWZpbml0aW9uID0gX3N0YXRlUmVnaXN0cnkubWF0Y2hlci5maW5kKF9pZGVudGlmaWVyLCB0aGlzLl9vcHRpb25zLnJlbGF0aXZlKTtcbiAgICB9XG4gICAgLyoqIFRoZSBuYW1lIG9mIHRoZSBzdGF0ZSB0aGlzIG9iamVjdCB0YXJnZXRzICovXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uICYmIHRoaXMuX2RlZmluaXRpb24ubmFtZSB8fCB0aGlzLl9pZGVudGlmaWVyO1xuICAgIH07XG4gICAgLyoqIFRoZSBpZGVudGlmaWVyIHVzZWQgd2hlbiBjcmVhdGluZyB0aGlzIFRhcmdldFN0YXRlICovXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLmlkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZGVudGlmaWVyO1xuICAgIH07XG4gICAgLyoqIFRoZSB0YXJnZXQgcGFyYW1ldGVyIHZhbHVlcyAqL1xuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbXM7XG4gICAgfTtcbiAgICAvKiogVGhlIGludGVybmFsIHN0YXRlIG9iamVjdCAoaWYgaXQgd2FzIGZvdW5kKSAqL1xuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS4kc3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uO1xuICAgIH07XG4gICAgLyoqIFRoZSBpbnRlcm5hbCBzdGF0ZSBkZWNsYXJhdGlvbiAoaWYgaXQgd2FzIGZvdW5kKSAqL1xuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmluaXRpb24gJiYgdGhpcy5fZGVmaW5pdGlvbi5zZWxmO1xuICAgIH07XG4gICAgLyoqIFRoZSB0YXJnZXQgb3B0aW9ucyAqL1xuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5vcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgICB9O1xuICAgIC8qKiBUcnVlIGlmIHRoZSB0YXJnZXQgc3RhdGUgd2FzIGZvdW5kICovXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuX2RlZmluaXRpb24gJiYgdGhpcy5fZGVmaW5pdGlvbi5zZWxmKTtcbiAgICB9O1xuICAgIC8qKiBUcnVlIGlmIHRoZSBvYmplY3QgaXMgdmFsaWQgKi9cbiAgICBUYXJnZXRTdGF0ZS5wcm90b3R5cGUudmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5lcnJvcigpO1xuICAgIH07XG4gICAgLyoqIElmIHRoZSBvYmplY3QgaXMgaW52YWxpZCwgcmV0dXJucyB0aGUgcmVhc29uIHdoeSAqL1xuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJhc2UgPSB0aGlzLm9wdGlvbnMoKS5yZWxhdGl2ZTtcbiAgICAgICAgaWYgKCF0aGlzLl9kZWZpbml0aW9uICYmICEhYmFzZSkge1xuICAgICAgICAgICAgdmFyIHN0YXRlTmFtZSA9IGJhc2UubmFtZSA/IGJhc2UubmFtZSA6IGJhc2U7XG4gICAgICAgICAgICByZXR1cm4gXCJDb3VsZCBub3QgcmVzb2x2ZSAnXCIgKyB0aGlzLm5hbWUoKSArIFwiJyBmcm9tIHN0YXRlICdcIiArIHN0YXRlTmFtZSArIFwiJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZGVmaW5pdGlvbilcbiAgICAgICAgICAgIHJldHVybiBcIk5vIHN1Y2ggc3RhdGUgJ1wiICsgdGhpcy5uYW1lKCkgKyBcIidcIjtcbiAgICAgICAgaWYgKCF0aGlzLl9kZWZpbml0aW9uLnNlbGYpXG4gICAgICAgICAgICByZXR1cm4gXCJTdGF0ZSAnXCIgKyB0aGlzLm5hbWUoKSArIFwiJyBoYXMgYW4gaW52YWxpZCBkZWZpbml0aW9uXCI7XG4gICAgfTtcbiAgICBUYXJnZXRTdGF0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIidcIiArIHRoaXMubmFtZSgpICsgXCInXCIgKyBzdHJpbmdzXzEuc3RyaW5naWZ5KHRoaXMucGFyYW1zKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBUYXJnZXRTdGF0ZSB3aGljaCB0YXJnZXRzIGEgZGlmZmVyZW50IHN0YXRlLlxuICAgICAqIFRoZSBuZXcgVGFyZ2V0U3RhdGUgaGFzIHRoZSBzYW1lIHBhcmFtZXRlciB2YWx1ZXMgYW5kIHRyYW5zaXRpb24gb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgbmV3IHN0YXRlIHRoYXQgc2hvdWxkIGJlIHRhcmdldGVkXG4gICAgICovXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLndpdGhTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRhcmdldFN0YXRlKHRoaXMuX3N0YXRlUmVnaXN0cnksIHN0YXRlLCB0aGlzLl9wYXJhbXMsIHRoaXMuX29wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBUYXJnZXRTdGF0ZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyB0aGUgbmV3IHBhcmFtZXRlciB2YWx1ZXMgdG8gdXNlXG4gICAgICogQHBhcmFtIHJlcGxhY2UgV2hlbiBmYWxzZSAoZGVmYXVsdCkgdGhlIG5ldyBwYXJhbWV0ZXIgdmFsdWVzIHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlIGN1cnJlbnQgdmFsdWVzLlxuICAgICAqICAgICAgICAgICAgICAgIFdoZW4gdHJ1ZSB0aGUgcGFyYW1ldGVyIHZhbHVlcyB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgY3VycmVudCB2YWx1ZXMuXG4gICAgICovXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLndpdGhQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zLCByZXBsYWNlKSB7XG4gICAgICAgIGlmIChyZXBsYWNlID09PSB2b2lkIDApIHsgcmVwbGFjZSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBuZXdQYXJhbXMgPSByZXBsYWNlID8gcGFyYW1zIDogY29tbW9uXzEuZXh0ZW5kKHt9LCB0aGlzLl9wYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0U3RhdGUodGhpcy5fc3RhdGVSZWdpc3RyeSwgdGhpcy5faWRlbnRpZmllciwgbmV3UGFyYW1zLCB0aGlzLl9vcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgVGFyZ2V0U3RhdGUsIHVzaW5nIHRoZSBzcGVjaWZpZWQgVHJhbnNpdGlvbiBPcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgdGhlIG5ldyBvcHRpb25zIHRvIHVzZVxuICAgICAqIEBwYXJhbSByZXBsYWNlIFdoZW4gZmFsc2UgKGRlZmF1bHQpIHRoZSBuZXcgb3B0aW9ucyB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZSBjdXJyZW50IG9wdGlvbnMuXG4gICAgICogICAgICAgICAgICAgICAgV2hlbiB0cnVlIHRoZSBvcHRpb25zIHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IG9wdGlvbnMuXG4gICAgICovXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLndpdGhPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMsIHJlcGxhY2UpIHtcbiAgICAgICAgaWYgKHJlcGxhY2UgPT09IHZvaWQgMCkgeyByZXBsYWNlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIG5ld09wdHMgPSByZXBsYWNlID8gb3B0aW9ucyA6IGNvbW1vbl8xLmV4dGVuZCh7fSwgdGhpcy5fb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0U3RhdGUodGhpcy5fc3RhdGVSZWdpc3RyeSwgdGhpcy5faWRlbnRpZmllciwgdGhpcy5fcGFyYW1zLCBuZXdPcHRzKTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBoYXMgYSBzdGF0ZSBwcm9wZXJ0eSB0aGF0IG1pZ2h0IGJlIGEgc3RhdGUgb3Igc3RhdGUgbmFtZSAqL1xuICAgIFRhcmdldFN0YXRlLmlzRGVmID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIG9iai5zdGF0ZSAmJiAocHJlZGljYXRlc18xLmlzU3RyaW5nKG9iai5zdGF0ZSkgfHwgcHJlZGljYXRlc18xLmlzU3RyaW5nKG9iai5zdGF0ZS5uYW1lKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFyZ2V0U3RhdGU7XG59KCkpO1xuZXhwb3J0cy5UYXJnZXRTdGF0ZSA9IFRhcmdldFN0YXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFyZ2V0U3RhdGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS90YXJnZXRTdGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nvar TransitionHookPhase;\n(function (TransitionHookPhase) {\n    TransitionHookPhase[TransitionHookPhase["CREATE"] = 0] = "CREATE";\n    TransitionHookPhase[TransitionHookPhase["BEFORE"] = 1] = "BEFORE";\n    TransitionHookPhase[TransitionHookPhase["RUN"] = 2] = "RUN";\n    TransitionHookPhase[TransitionHookPhase["SUCCESS"] = 3] = "SUCCESS";\n    TransitionHookPhase[TransitionHookPhase["ERROR"] = 4] = "ERROR";\n})(TransitionHookPhase = exports.TransitionHookPhase || (exports.TransitionHookPhase = {}));\nvar TransitionHookScope;\n(function (TransitionHookScope) {\n    TransitionHookScope[TransitionHookScope["TRANSITION"] = 0] = "TRANSITION";\n    TransitionHookScope[TransitionHookScope["STATE"] = 1] = "STATE";\n})(TransitionHookScope = exports.TransitionHookScope || (exports.TransitionHookScope = {}));\n//# sourceMappingURL=interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL2ludGVyZmFjZS5qcz9lYzg0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFRyYW5zaXRpb25Ib29rUGhhc2U7XG4oZnVuY3Rpb24gKFRyYW5zaXRpb25Ib29rUGhhc2UpIHtcbiAgICBUcmFuc2l0aW9uSG9va1BoYXNlW1RyYW5zaXRpb25Ib29rUGhhc2VbXCJDUkVBVEVcIl0gPSAwXSA9IFwiQ1JFQVRFXCI7XG4gICAgVHJhbnNpdGlvbkhvb2tQaGFzZVtUcmFuc2l0aW9uSG9va1BoYXNlW1wiQkVGT1JFXCJdID0gMV0gPSBcIkJFRk9SRVwiO1xuICAgIFRyYW5zaXRpb25Ib29rUGhhc2VbVHJhbnNpdGlvbkhvb2tQaGFzZVtcIlJVTlwiXSA9IDJdID0gXCJSVU5cIjtcbiAgICBUcmFuc2l0aW9uSG9va1BoYXNlW1RyYW5zaXRpb25Ib29rUGhhc2VbXCJTVUNDRVNTXCJdID0gM10gPSBcIlNVQ0NFU1NcIjtcbiAgICBUcmFuc2l0aW9uSG9va1BoYXNlW1RyYW5zaXRpb25Ib29rUGhhc2VbXCJFUlJPUlwiXSA9IDRdID0gXCJFUlJPUlwiO1xufSkoVHJhbnNpdGlvbkhvb2tQaGFzZSA9IGV4cG9ydHMuVHJhbnNpdGlvbkhvb2tQaGFzZSB8fCAoZXhwb3J0cy5UcmFuc2l0aW9uSG9va1BoYXNlID0ge30pKTtcbnZhciBUcmFuc2l0aW9uSG9va1Njb3BlO1xuKGZ1bmN0aW9uIChUcmFuc2l0aW9uSG9va1Njb3BlKSB7XG4gICAgVHJhbnNpdGlvbkhvb2tTY29wZVtUcmFuc2l0aW9uSG9va1Njb3BlW1wiVFJBTlNJVElPTlwiXSA9IDBdID0gXCJUUkFOU0lUSU9OXCI7XG4gICAgVHJhbnNpdGlvbkhvb2tTY29wZVtUcmFuc2l0aW9uSG9va1Njb3BlW1wiU1RBVEVcIl0gPSAxXSA9IFwiU1RBVEVcIjtcbn0pKFRyYW5zaXRpb25Ib29rU2NvcGUgPSBleHBvcnRzLlRyYW5zaXRpb25Ib29rU2NvcGUgfHwgKGV4cG9ydHMuVHJhbnNpdGlvbkhvb2tTY29wZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmZhY2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL2ludGVyZmFjZS5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @coreapi\n * @module resolve\n */ /** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ 3);\nvar trace_1 = __webpack_require__(/*! ../common/trace */ 7);\nvar strings_1 = __webpack_require__(/*! ../common/strings */ 6);\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ 1);\nvar common_2 = __webpack_require__(/*! ../common */ 5);\n// TODO: explicitly make this user configurable\nexports.defaultResolvePolicy = {\n    when: "LAZY",\n    async: "WAIT"\n};\n/**\n * The basic building block for the resolve system.\n *\n * Resolvables encapsulate a state\'s resolve\'s resolveFn, the resolveFn\'s declared dependencies, the wrapped (.promise),\n * and the unwrapped-when-complete (.data) result of the resolveFn.\n *\n * Resolvable.get() either retrieves the Resolvable\'s existing promise, or else invokes resolve() (which invokes the\n * resolveFn) and returns the resulting promise.\n *\n * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first\n * parameter to those fns.\n */\nvar Resolvable = /** @class */ (function () {\n    function Resolvable(arg1, resolveFn, deps, policy, data) {\n        this.resolved = false;\n        this.promise = undefined;\n        if (arg1 instanceof Resolvable) {\n            common_1.extend(this, arg1);\n        }\n        else if (predicates_1.isFunction(resolveFn)) {\n            if (common_2.isNullOrUndefined(arg1))\n                throw new Error("new Resolvable(): token argument is required");\n            if (!predicates_1.isFunction(resolveFn))\n                throw new Error("new Resolvable(): resolveFn argument must be a function");\n            this.token = arg1;\n            this.policy = policy;\n            this.resolveFn = resolveFn;\n            this.deps = deps || [];\n            this.data = data;\n            this.resolved = data !== undefined;\n            this.promise = this.resolved ? coreservices_1.services.$q.when(this.data) : undefined;\n        }\n        else if (predicates_1.isObject(arg1) && arg1.token && predicates_1.isFunction(arg1.resolveFn)) {\n            var literal = arg1;\n            return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);\n        }\n    }\n    Resolvable.prototype.getPolicy = function (state) {\n        var thisPolicy = this.policy || {};\n        var statePolicy = state && state.resolvePolicy || {};\n        return {\n            when: thisPolicy.when || statePolicy.when || exports.defaultResolvePolicy.when,\n            async: thisPolicy.async || statePolicy.async || exports.defaultResolvePolicy.async,\n        };\n    };\n    /**\n     * Asynchronously resolve this Resolvable\'s data\n     *\n     * Given a ResolveContext that this Resolvable is found in:\n     * Wait for this Resolvable\'s dependencies, then invoke this Resolvable\'s function\n     * and update the Resolvable\'s state\n     */\n    Resolvable.prototype.resolve = function (resolveContext, trans) {\n        var _this = this;\n        var $q = coreservices_1.services.$q;\n        // Gets all dependencies from ResolveContext and wait for them to be resolved\n        var getResolvableDependencies = function () {\n            return $q.all(resolveContext.getDependencies(_this).map(function (resolvable) {\n                return resolvable.get(resolveContext, trans);\n            }));\n        };\n        // Invokes the resolve function passing the resolved dependencies as arguments\n        var invokeResolveFn = function (resolvedDeps) {\n            return _this.resolveFn.apply(null, resolvedDeps);\n        };\n        /**\n         * For RXWAIT policy:\n         *\n         * Given an observable returned from a resolve function:\n         * - enables .cache() mode (this allows multicast subscribers)\n         * - then calls toPromise() (this triggers subscribe() and thus fetches)\n         * - Waits for the promise, then return the cached observable (not the first emitted value).\n         */\n        var waitForRx = function (observable$) {\n            var cached = observable$.cache(1);\n            return cached.take(1).toPromise().then(function () { return cached; });\n        };\n        // If the resolve policy is RXWAIT, wait for the observable to emit something. otherwise pass through.\n        var node = resolveContext.findNode(this);\n        var state = node && node.state;\n        var maybeWaitForRx = this.getPolicy(state).async === "RXWAIT" ? waitForRx : common_1.identity;\n        // After the final value has been resolved, update the state of the Resolvable\n        var applyResolvedValue = function (resolvedValue) {\n            _this.data = resolvedValue;\n            _this.resolved = true;\n            trace_1.trace.traceResolvableResolved(_this, trans);\n            return _this.data;\n        };\n        // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.\n        return this.promise = $q.when()\n            .then(getResolvableDependencies)\n            .then(invokeResolveFn)\n            .then(maybeWaitForRx)\n            .then(applyResolvedValue);\n    };\n    /**\n     * Gets a promise for this Resolvable\'s data.\n     *\n     * Fetches the data and returns a promise.\n     * Returns the existing promise if it has already been fetched once.\n     */\n    Resolvable.prototype.get = function (resolveContext, trans) {\n        return this.promise || this.resolve(resolveContext, trans);\n    };\n    Resolvable.prototype.toString = function () {\n        return "Resolvable(token: " + strings_1.stringify(this.token) + ", requires: [" + this.deps.map(strings_1.stringify) + "])";\n    };\n    Resolvable.prototype.clone = function () {\n        return new Resolvable(this);\n    };\n    Resolvable.fromData = function (token, data) {\n        return new Resolvable(token, function () { return data; }, null, null, data);\n    };\n    return Resolvable;\n}());\nexports.Resolvable = Resolvable;\n//# sourceMappingURL=resolvable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9yZXNvbHZlL3Jlc29sdmFibGUuanM/ZjI2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgcmVzb2x2ZVxuICovIC8qKiBmb3IgdHlwZWRvYyAqL1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgY29yZXNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvcmVzZXJ2aWNlc1wiKTtcbnZhciB0cmFjZV8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi90cmFjZVwiKTtcbnZhciBzdHJpbmdzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3N0cmluZ3NcIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIGNvbW1vbl8yID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbi8vIFRPRE86IGV4cGxpY2l0bHkgbWFrZSB0aGlzIHVzZXIgY29uZmlndXJhYmxlXG5leHBvcnRzLmRlZmF1bHRSZXNvbHZlUG9saWN5ID0ge1xuICAgIHdoZW46IFwiTEFaWVwiLFxuICAgIGFzeW5jOiBcIldBSVRcIlxufTtcbi8qKlxuICogVGhlIGJhc2ljIGJ1aWxkaW5nIGJsb2NrIGZvciB0aGUgcmVzb2x2ZSBzeXN0ZW0uXG4gKlxuICogUmVzb2x2YWJsZXMgZW5jYXBzdWxhdGUgYSBzdGF0ZSdzIHJlc29sdmUncyByZXNvbHZlRm4sIHRoZSByZXNvbHZlRm4ncyBkZWNsYXJlZCBkZXBlbmRlbmNpZXMsIHRoZSB3cmFwcGVkICgucHJvbWlzZSksXG4gKiBhbmQgdGhlIHVud3JhcHBlZC13aGVuLWNvbXBsZXRlICguZGF0YSkgcmVzdWx0IG9mIHRoZSByZXNvbHZlRm4uXG4gKlxuICogUmVzb2x2YWJsZS5nZXQoKSBlaXRoZXIgcmV0cmlldmVzIHRoZSBSZXNvbHZhYmxlJ3MgZXhpc3RpbmcgcHJvbWlzZSwgb3IgZWxzZSBpbnZva2VzIHJlc29sdmUoKSAod2hpY2ggaW52b2tlcyB0aGVcbiAqIHJlc29sdmVGbikgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZyBwcm9taXNlLlxuICpcbiAqIFJlc29sdmFibGUuZ2V0KCkgYW5kIFJlc29sdmFibGUucmVzb2x2ZSgpIGJvdGggZXhlY3V0ZSB3aXRoaW4gYSBjb250ZXh0IHBhdGgsIHdoaWNoIGlzIHBhc3NlZCBhcyB0aGUgZmlyc3RcbiAqIHBhcmFtZXRlciB0byB0aG9zZSBmbnMuXG4gKi9cbnZhciBSZXNvbHZhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc29sdmFibGUoYXJnMSwgcmVzb2x2ZUZuLCBkZXBzLCBwb2xpY3ksIGRhdGEpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChhcmcxIGluc3RhbmNlb2YgUmVzb2x2YWJsZSkge1xuICAgICAgICAgICAgY29tbW9uXzEuZXh0ZW5kKHRoaXMsIGFyZzEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKHJlc29sdmVGbikpIHtcbiAgICAgICAgICAgIGlmIChjb21tb25fMi5pc051bGxPclVuZGVmaW5lZChhcmcxKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuZXcgUmVzb2x2YWJsZSgpOiB0b2tlbiBhcmd1bWVudCBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgICAgIGlmICghcHJlZGljYXRlc18xLmlzRnVuY3Rpb24ocmVzb2x2ZUZuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuZXcgUmVzb2x2YWJsZSgpOiByZXNvbHZlRm4gYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IGFyZzE7XG4gICAgICAgICAgICB0aGlzLnBvbGljeSA9IHBvbGljeTtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZUZuID0gcmVzb2x2ZUZuO1xuICAgICAgICAgICAgdGhpcy5kZXBzID0gZGVwcyB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkID0gZGF0YSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5wcm9taXNlID0gdGhpcy5yZXNvbHZlZCA/IGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLndoZW4odGhpcy5kYXRhKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmVkaWNhdGVzXzEuaXNPYmplY3QoYXJnMSkgJiYgYXJnMS50b2tlbiAmJiBwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihhcmcxLnJlc29sdmVGbikpIHtcbiAgICAgICAgICAgIHZhciBsaXRlcmFsID0gYXJnMTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzb2x2YWJsZShsaXRlcmFsLnRva2VuLCBsaXRlcmFsLnJlc29sdmVGbiwgbGl0ZXJhbC5kZXBzLCBsaXRlcmFsLnBvbGljeSwgbGl0ZXJhbC5kYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBSZXNvbHZhYmxlLnByb3RvdHlwZS5nZXRQb2xpY3kgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIHRoaXNQb2xpY3kgPSB0aGlzLnBvbGljeSB8fCB7fTtcbiAgICAgICAgdmFyIHN0YXRlUG9saWN5ID0gc3RhdGUgJiYgc3RhdGUucmVzb2x2ZVBvbGljeSB8fCB7fTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdoZW46IHRoaXNQb2xpY3kud2hlbiB8fCBzdGF0ZVBvbGljeS53aGVuIHx8IGV4cG9ydHMuZGVmYXVsdFJlc29sdmVQb2xpY3kud2hlbixcbiAgICAgICAgICAgIGFzeW5jOiB0aGlzUG9saWN5LmFzeW5jIHx8IHN0YXRlUG9saWN5LmFzeW5jIHx8IGV4cG9ydHMuZGVmYXVsdFJlc29sdmVQb2xpY3kuYXN5bmMsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBc3luY2hyb25vdXNseSByZXNvbHZlIHRoaXMgUmVzb2x2YWJsZSdzIGRhdGFcbiAgICAgKlxuICAgICAqIEdpdmVuIGEgUmVzb2x2ZUNvbnRleHQgdGhhdCB0aGlzIFJlc29sdmFibGUgaXMgZm91bmQgaW46XG4gICAgICogV2FpdCBmb3IgdGhpcyBSZXNvbHZhYmxlJ3MgZGVwZW5kZW5jaWVzLCB0aGVuIGludm9rZSB0aGlzIFJlc29sdmFibGUncyBmdW5jdGlvblxuICAgICAqIGFuZCB1cGRhdGUgdGhlIFJlc29sdmFibGUncyBzdGF0ZVxuICAgICAqL1xuICAgIFJlc29sdmFibGUucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAocmVzb2x2ZUNvbnRleHQsIHRyYW5zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAkcSA9IGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxO1xuICAgICAgICAvLyBHZXRzIGFsbCBkZXBlbmRlbmNpZXMgZnJvbSBSZXNvbHZlQ29udGV4dCBhbmQgd2FpdCBmb3IgdGhlbSB0byBiZSByZXNvbHZlZFxuICAgICAgICB2YXIgZ2V0UmVzb2x2YWJsZURlcGVuZGVuY2llcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAkcS5hbGwocmVzb2x2ZUNvbnRleHQuZ2V0RGVwZW5kZW5jaWVzKF90aGlzKS5tYXAoZnVuY3Rpb24gKHJlc29sdmFibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2YWJsZS5nZXQocmVzb2x2ZUNvbnRleHQsIHRyYW5zKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSW52b2tlcyB0aGUgcmVzb2x2ZSBmdW5jdGlvbiBwYXNzaW5nIHRoZSByZXNvbHZlZCBkZXBlbmRlbmNpZXMgYXMgYXJndW1lbnRzXG4gICAgICAgIHZhciBpbnZva2VSZXNvbHZlRm4gPSBmdW5jdGlvbiAocmVzb2x2ZWREZXBzKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucmVzb2x2ZUZuLmFwcGx5KG51bGwsIHJlc29sdmVkRGVwcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3IgUlhXQUlUIHBvbGljeTpcbiAgICAgICAgICpcbiAgICAgICAgICogR2l2ZW4gYW4gb2JzZXJ2YWJsZSByZXR1cm5lZCBmcm9tIGEgcmVzb2x2ZSBmdW5jdGlvbjpcbiAgICAgICAgICogLSBlbmFibGVzIC5jYWNoZSgpIG1vZGUgKHRoaXMgYWxsb3dzIG11bHRpY2FzdCBzdWJzY3JpYmVycylcbiAgICAgICAgICogLSB0aGVuIGNhbGxzIHRvUHJvbWlzZSgpICh0aGlzIHRyaWdnZXJzIHN1YnNjcmliZSgpIGFuZCB0aHVzIGZldGNoZXMpXG4gICAgICAgICAqIC0gV2FpdHMgZm9yIHRoZSBwcm9taXNlLCB0aGVuIHJldHVybiB0aGUgY2FjaGVkIG9ic2VydmFibGUgKG5vdCB0aGUgZmlyc3QgZW1pdHRlZCB2YWx1ZSkuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgd2FpdEZvclJ4ID0gZnVuY3Rpb24gKG9ic2VydmFibGUkKSB7XG4gICAgICAgICAgICB2YXIgY2FjaGVkID0gb2JzZXJ2YWJsZSQuY2FjaGUoMSk7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkLnRha2UoMSkudG9Qcm9taXNlKCkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBjYWNoZWQ7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJZiB0aGUgcmVzb2x2ZSBwb2xpY3kgaXMgUlhXQUlULCB3YWl0IGZvciB0aGUgb2JzZXJ2YWJsZSB0byBlbWl0IHNvbWV0aGluZy4gb3RoZXJ3aXNlIHBhc3MgdGhyb3VnaC5cbiAgICAgICAgdmFyIG5vZGUgPSByZXNvbHZlQ29udGV4dC5maW5kTm9kZSh0aGlzKTtcbiAgICAgICAgdmFyIHN0YXRlID0gbm9kZSAmJiBub2RlLnN0YXRlO1xuICAgICAgICB2YXIgbWF5YmVXYWl0Rm9yUnggPSB0aGlzLmdldFBvbGljeShzdGF0ZSkuYXN5bmMgPT09IFwiUlhXQUlUXCIgPyB3YWl0Rm9yUnggOiBjb21tb25fMS5pZGVudGl0eTtcbiAgICAgICAgLy8gQWZ0ZXIgdGhlIGZpbmFsIHZhbHVlIGhhcyBiZWVuIHJlc29sdmVkLCB1cGRhdGUgdGhlIHN0YXRlIG9mIHRoZSBSZXNvbHZhYmxlXG4gICAgICAgIHZhciBhcHBseVJlc29sdmVkVmFsdWUgPSBmdW5jdGlvbiAocmVzb2x2ZWRWYWx1ZSkge1xuICAgICAgICAgICAgX3RoaXMuZGF0YSA9IHJlc29sdmVkVmFsdWU7XG4gICAgICAgICAgICBfdGhpcy5yZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlUmVzb2x2YWJsZVJlc29sdmVkKF90aGlzLCB0cmFucyk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gU2V0cyB0aGUgcHJvbWlzZSBwcm9wZXJ0eSBmaXJzdCwgdGhlbiBnZXRzUmVzb2x2YWJsZURlcGVuZGVuY2llcyBpbiB0aGUgY29udGV4dCBvZiB0aGUgcHJvbWlzZSBjaGFpbi4gQWx3YXlzIHdhaXRzIG9uZSB0aWNrLlxuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlID0gJHEud2hlbigpXG4gICAgICAgICAgICAudGhlbihnZXRSZXNvbHZhYmxlRGVwZW5kZW5jaWVzKVxuICAgICAgICAgICAgLnRoZW4oaW52b2tlUmVzb2x2ZUZuKVxuICAgICAgICAgICAgLnRoZW4obWF5YmVXYWl0Rm9yUngpXG4gICAgICAgICAgICAudGhlbihhcHBseVJlc29sdmVkVmFsdWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyBhIHByb21pc2UgZm9yIHRoaXMgUmVzb2x2YWJsZSdzIGRhdGEuXG4gICAgICpcbiAgICAgKiBGZXRjaGVzIHRoZSBkYXRhIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAgICAgKiBSZXR1cm5zIHRoZSBleGlzdGluZyBwcm9taXNlIGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gZmV0Y2hlZCBvbmNlLlxuICAgICAqL1xuICAgIFJlc29sdmFibGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChyZXNvbHZlQ29udGV4dCwgdHJhbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZSB8fCB0aGlzLnJlc29sdmUocmVzb2x2ZUNvbnRleHQsIHRyYW5zKTtcbiAgICB9O1xuICAgIFJlc29sdmFibGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJSZXNvbHZhYmxlKHRva2VuOiBcIiArIHN0cmluZ3NfMS5zdHJpbmdpZnkodGhpcy50b2tlbikgKyBcIiwgcmVxdWlyZXM6IFtcIiArIHRoaXMuZGVwcy5tYXAoc3RyaW5nc18xLnN0cmluZ2lmeSkgKyBcIl0pXCI7XG4gICAgfTtcbiAgICBSZXNvbHZhYmxlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZhYmxlKHRoaXMpO1xuICAgIH07XG4gICAgUmVzb2x2YWJsZS5mcm9tRGF0YSA9IGZ1bmN0aW9uICh0b2tlbiwgZGF0YSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc29sdmFibGUodG9rZW4sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRhdGE7IH0sIG51bGwsIG51bGwsIGRhdGEpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc29sdmFibGU7XG59KCkpO1xuZXhwb3J0cy5SZXNvbHZhYmxlID0gUmVzb2x2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmFibGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9yZXNvbHZlL3Jlc29sdmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///11\n')},function(module,exports,__webpack_require__){"use strict";eval('/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\n\nObject.defineProperty(exports, "__esModule", { value: true });\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar strings_1 = __webpack_require__(/*! ../common/strings */ 6);\nvar hof_1 = __webpack_require__(/*! ../common/hof */ 2);\nvar RejectType;\n(function (RejectType) {\n    RejectType[RejectType["SUPERSEDED"] = 2] = "SUPERSEDED";\n    RejectType[RejectType["ABORTED"] = 3] = "ABORTED";\n    RejectType[RejectType["INVALID"] = 4] = "INVALID";\n    RejectType[RejectType["IGNORED"] = 5] = "IGNORED";\n    RejectType[RejectType["ERROR"] = 6] = "ERROR";\n})(RejectType = exports.RejectType || (exports.RejectType = {}));\n/** @hidden */ var id = 0;\nvar Rejection = /** @class */ (function () {\n    function Rejection(type, message, detail) {\n        this.$id = id++;\n        this.type = type;\n        this.message = message;\n        this.detail = detail;\n    }\n    Rejection.prototype.toString = function () {\n        var detailString = function (d) {\n            return d && d.toString !== Object.prototype.toString ? d.toString() : strings_1.stringify(d);\n        };\n        var detail = detailString(this.detail);\n        var _a = this, $id = _a.$id, type = _a.type, message = _a.message;\n        return "Transition Rejection($id: " + $id + " type: " + type + ", message: " + message + ", detail: " + detail + ")";\n    };\n    Rejection.prototype.toPromise = function () {\n        return common_1.extend(common_1.silentRejection(this), { _transitionRejection: this });\n    };\n    /** Returns true if the obj is a rejected promise created from the `asPromise` factory */\n    Rejection.isRejectionPromise = function (obj) {\n        return obj && (typeof obj.then === \'function\') && hof_1.is(Rejection)(obj._transitionRejection);\n    };\n    /** Returns a Rejection due to transition superseded */\n    Rejection.superseded = function (detail, options) {\n        var message = "The transition has been superseded by a different transition";\n        var rejection = new Rejection(RejectType.SUPERSEDED, message, detail);\n        if (options && options.redirected) {\n            rejection.redirected = true;\n        }\n        return rejection;\n    };\n    /** Returns a Rejection due to redirected transition */\n    Rejection.redirected = function (detail) {\n        return Rejection.superseded(detail, { redirected: true });\n    };\n    /** Returns a Rejection due to invalid transition */\n    Rejection.invalid = function (detail) {\n        var message = "This transition is invalid";\n        return new Rejection(RejectType.INVALID, message, detail);\n    };\n    /** Returns a Rejection due to ignored transition */\n    Rejection.ignored = function (detail) {\n        var message = "The transition was ignored";\n        return new Rejection(RejectType.IGNORED, message, detail);\n    };\n    /** Returns a Rejection due to aborted transition */\n    Rejection.aborted = function (detail) {\n        var message = "The transition has been aborted";\n        return new Rejection(RejectType.ABORTED, message, detail);\n    };\n    /** Returns a Rejection due to aborted transition */\n    Rejection.errored = function (detail) {\n        var message = "The transition errored";\n        return new Rejection(RejectType.ERROR, message, detail);\n    };\n    /**\n     * Returns a Rejection\n     *\n     * Normalizes a value as a Rejection.\n     * If the value is already a Rejection, returns it.\n     * Otherwise, wraps and returns the value as a Rejection (Rejection type: ERROR).\n     *\n     * @returns `detail` if it is already a `Rejection`, else returns an ERROR Rejection.\n     */\n    Rejection.normalize = function (detail) {\n        return hof_1.is(Rejection)(detail) ? detail : Rejection.errored(detail);\n    };\n    return Rejection;\n}());\nexports.Rejection = Rejection;\n//# sourceMappingURL=rejectFactory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL3JlamVjdEZhY3RvcnkuanM/Y2Q4YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHRyYW5zaXRpb25cbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgc3RyaW5nc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9zdHJpbmdzXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG52YXIgUmVqZWN0VHlwZTtcbihmdW5jdGlvbiAoUmVqZWN0VHlwZSkge1xuICAgIFJlamVjdFR5cGVbUmVqZWN0VHlwZVtcIlNVUEVSU0VERURcIl0gPSAyXSA9IFwiU1VQRVJTRURFRFwiO1xuICAgIFJlamVjdFR5cGVbUmVqZWN0VHlwZVtcIkFCT1JURURcIl0gPSAzXSA9IFwiQUJPUlRFRFwiO1xuICAgIFJlamVjdFR5cGVbUmVqZWN0VHlwZVtcIklOVkFMSURcIl0gPSA0XSA9IFwiSU5WQUxJRFwiO1xuICAgIFJlamVjdFR5cGVbUmVqZWN0VHlwZVtcIklHTk9SRURcIl0gPSA1XSA9IFwiSUdOT1JFRFwiO1xuICAgIFJlamVjdFR5cGVbUmVqZWN0VHlwZVtcIkVSUk9SXCJdID0gNl0gPSBcIkVSUk9SXCI7XG59KShSZWplY3RUeXBlID0gZXhwb3J0cy5SZWplY3RUeXBlIHx8IChleHBvcnRzLlJlamVjdFR5cGUgPSB7fSkpO1xuLyoqIEBoaWRkZW4gKi8gdmFyIGlkID0gMDtcbnZhciBSZWplY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVqZWN0aW9uKHR5cGUsIG1lc3NhZ2UsIGRldGFpbCkge1xuICAgICAgICB0aGlzLiRpZCA9IGlkKys7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuZGV0YWlsID0gZGV0YWlsO1xuICAgIH1cbiAgICBSZWplY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGV0YWlsU3RyaW5nID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkICYmIGQudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgPyBkLnRvU3RyaW5nKCkgOiBzdHJpbmdzXzEuc3RyaW5naWZ5KGQpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZGV0YWlsID0gZGV0YWlsU3RyaW5nKHRoaXMuZGV0YWlsKTtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgJGlkID0gX2EuJGlkLCB0eXBlID0gX2EudHlwZSwgbWVzc2FnZSA9IF9hLm1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBcIlRyYW5zaXRpb24gUmVqZWN0aW9uKCRpZDogXCIgKyAkaWQgKyBcIiB0eXBlOiBcIiArIHR5cGUgKyBcIiwgbWVzc2FnZTogXCIgKyBtZXNzYWdlICsgXCIsIGRldGFpbDogXCIgKyBkZXRhaWwgKyBcIilcIjtcbiAgICB9O1xuICAgIFJlamVjdGlvbi5wcm90b3R5cGUudG9Qcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKGNvbW1vbl8xLnNpbGVudFJlamVjdGlvbih0aGlzKSwgeyBfdHJhbnNpdGlvblJlamVjdGlvbjogdGhpcyB9KTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iaiBpcyBhIHJlamVjdGVkIHByb21pc2UgY3JlYXRlZCBmcm9tIHRoZSBgYXNQcm9taXNlYCBmYWN0b3J5ICovXG4gICAgUmVqZWN0aW9uLmlzUmVqZWN0aW9uUHJvbWlzZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiAodHlwZW9mIG9iai50aGVuID09PSAnZnVuY3Rpb24nKSAmJiBob2ZfMS5pcyhSZWplY3Rpb24pKG9iai5fdHJhbnNpdGlvblJlamVjdGlvbik7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhIFJlamVjdGlvbiBkdWUgdG8gdHJhbnNpdGlvbiBzdXBlcnNlZGVkICovXG4gICAgUmVqZWN0aW9uLnN1cGVyc2VkZWQgPSBmdW5jdGlvbiAoZGV0YWlsLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gXCJUaGUgdHJhbnNpdGlvbiBoYXMgYmVlbiBzdXBlcnNlZGVkIGJ5IGEgZGlmZmVyZW50IHRyYW5zaXRpb25cIjtcbiAgICAgICAgdmFyIHJlamVjdGlvbiA9IG5ldyBSZWplY3Rpb24oUmVqZWN0VHlwZS5TVVBFUlNFREVELCBtZXNzYWdlLCBkZXRhaWwpO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlZGlyZWN0ZWQpIHtcbiAgICAgICAgICAgIHJlamVjdGlvbi5yZWRpcmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVqZWN0aW9uO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYSBSZWplY3Rpb24gZHVlIHRvIHJlZGlyZWN0ZWQgdHJhbnNpdGlvbiAqL1xuICAgIFJlamVjdGlvbi5yZWRpcmVjdGVkID0gZnVuY3Rpb24gKGRldGFpbCkge1xuICAgICAgICByZXR1cm4gUmVqZWN0aW9uLnN1cGVyc2VkZWQoZGV0YWlsLCB7IHJlZGlyZWN0ZWQ6IHRydWUgfSk7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhIFJlamVjdGlvbiBkdWUgdG8gaW52YWxpZCB0cmFuc2l0aW9uICovXG4gICAgUmVqZWN0aW9uLmludmFsaWQgPSBmdW5jdGlvbiAoZGV0YWlsKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gXCJUaGlzIHRyYW5zaXRpb24gaXMgaW52YWxpZFwiO1xuICAgICAgICByZXR1cm4gbmV3IFJlamVjdGlvbihSZWplY3RUeXBlLklOVkFMSUQsIG1lc3NhZ2UsIGRldGFpbCk7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhIFJlamVjdGlvbiBkdWUgdG8gaWdub3JlZCB0cmFuc2l0aW9uICovXG4gICAgUmVqZWN0aW9uLmlnbm9yZWQgPSBmdW5jdGlvbiAoZGV0YWlsKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gXCJUaGUgdHJhbnNpdGlvbiB3YXMgaWdub3JlZFwiO1xuICAgICAgICByZXR1cm4gbmV3IFJlamVjdGlvbihSZWplY3RUeXBlLklHTk9SRUQsIG1lc3NhZ2UsIGRldGFpbCk7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhIFJlamVjdGlvbiBkdWUgdG8gYWJvcnRlZCB0cmFuc2l0aW9uICovXG4gICAgUmVqZWN0aW9uLmFib3J0ZWQgPSBmdW5jdGlvbiAoZGV0YWlsKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gXCJUaGUgdHJhbnNpdGlvbiBoYXMgYmVlbiBhYm9ydGVkXCI7XG4gICAgICAgIHJldHVybiBuZXcgUmVqZWN0aW9uKFJlamVjdFR5cGUuQUJPUlRFRCwgbWVzc2FnZSwgZGV0YWlsKTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGEgUmVqZWN0aW9uIGR1ZSB0byBhYm9ydGVkIHRyYW5zaXRpb24gKi9cbiAgICBSZWplY3Rpb24uZXJyb3JlZCA9IGZ1bmN0aW9uIChkZXRhaWwpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIlRoZSB0cmFuc2l0aW9uIGVycm9yZWRcIjtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWplY3Rpb24oUmVqZWN0VHlwZS5FUlJPUiwgbWVzc2FnZSwgZGV0YWlsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBSZWplY3Rpb25cbiAgICAgKlxuICAgICAqIE5vcm1hbGl6ZXMgYSB2YWx1ZSBhcyBhIFJlamVjdGlvbi5cbiAgICAgKiBJZiB0aGUgdmFsdWUgaXMgYWxyZWFkeSBhIFJlamVjdGlvbiwgcmV0dXJucyBpdC5cbiAgICAgKiBPdGhlcndpc2UsIHdyYXBzIGFuZCByZXR1cm5zIHRoZSB2YWx1ZSBhcyBhIFJlamVjdGlvbiAoUmVqZWN0aW9uIHR5cGU6IEVSUk9SKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGBkZXRhaWxgIGlmIGl0IGlzIGFscmVhZHkgYSBgUmVqZWN0aW9uYCwgZWxzZSByZXR1cm5zIGFuIEVSUk9SIFJlamVjdGlvbi5cbiAgICAgKi9cbiAgICBSZWplY3Rpb24ubm9ybWFsaXplID0gZnVuY3Rpb24gKGRldGFpbCkge1xuICAgICAgICByZXR1cm4gaG9mXzEuaXMoUmVqZWN0aW9uKShkZXRhaWwpID8gZGV0YWlsIDogUmVqZWN0aW9uLmVycm9yZWQoZGV0YWlsKTtcbiAgICB9O1xuICAgIHJldHVybiBSZWplY3Rpb247XG59KCkpO1xuZXhwb3J0cy5SZWplY3Rpb24gPSBSZWplY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWplY3RGYWN0b3J5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi9yZWplY3RGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @coreapi\n * @module transition\n */\n/** for typedoc */\nvar interface_1 = __webpack_require__(/*! ./interface */ 10);\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar strings_1 = __webpack_require__(/*! ../common/strings */ 6);\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ 1);\nvar hof_1 = __webpack_require__(/*! ../common/hof */ 2);\nvar trace_1 = __webpack_require__(/*! ../common/trace */ 7);\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ 3);\nvar rejectFactory_1 = __webpack_require__(/*! ./rejectFactory */ 12);\nvar targetState_1 = __webpack_require__(/*! ../state/targetState */ 9);\nvar defaultOptions = {\n    current: common_1.noop,\n    transition: null,\n    traceData: {},\n    bind: null,\n};\n/** @hidden */\nvar TransitionHook = /** @class */ (function () {\n    function TransitionHook(transition, stateContext, registeredHook, options) {\n        var _this = this;\n        this.transition = transition;\n        this.stateContext = stateContext;\n        this.registeredHook = registeredHook;\n        this.options = options;\n        this.isSuperseded = function () {\n            return _this.type.hookPhase === interface_1.TransitionHookPhase.RUN && !_this.options.transition.isActive();\n        };\n        this.options = common_1.defaults(options, defaultOptions);\n        this.type = registeredHook.eventType;\n    }\n    TransitionHook.prototype.logError = function (err) {\n        this.transition.router.stateService.defaultErrorHandler()(err);\n    };\n    TransitionHook.prototype.invokeHook = function () {\n        var _this = this;\n        var hook = this.registeredHook;\n        if (hook._deregistered)\n            return;\n        var notCurrent = this.getNotCurrentRejection();\n        if (notCurrent)\n            return notCurrent;\n        var options = this.options;\n        trace_1.trace.traceHookInvocation(this, this.transition, options);\n        var invokeCallback = function () {\n            return hook.callback.call(options.bind, _this.transition, _this.stateContext);\n        };\n        var normalizeErr = function (err) {\n            return rejectFactory_1.Rejection.normalize(err).toPromise();\n        };\n        var handleError = function (err) {\n            return hook.eventType.getErrorHandler(_this)(err);\n        };\n        var handleResult = function (result) {\n            return hook.eventType.getResultHandler(_this)(result);\n        };\n        try {\n            var result = invokeCallback();\n            if (!this.type.synchronous && predicates_1.isPromise(result)) {\n                return result.catch(normalizeErr)\n                    .then(handleResult, handleError);\n            }\n            else {\n                return handleResult(result);\n            }\n        }\n        catch (err) {\n            // If callback throws (synchronously)\n            return handleError(rejectFactory_1.Rejection.normalize(err));\n        }\n        finally {\n            if (hook.invokeLimit && ++hook.invokeCount >= hook.invokeLimit) {\n                hook.deregister();\n            }\n        }\n    };\n    /**\n     * This method handles the return value of a Transition Hook.\n     *\n     * A hook can return false (cancel), a TargetState (redirect),\n     * or a promise (which may later resolve to false or a redirect)\n     *\n     * This also handles "transition superseded" -- when a new transition\n     * was started while the hook was still running\n     */\n    TransitionHook.prototype.handleHookResult = function (result) {\n        var _this = this;\n        var notCurrent = this.getNotCurrentRejection();\n        if (notCurrent)\n            return notCurrent;\n        // Hook returned a promise\n        if (predicates_1.isPromise(result)) {\n            // Wait for the promise, then reprocess with the resulting value\n            return result.then(function (val) { return _this.handleHookResult(val); });\n        }\n        trace_1.trace.traceHookResult(result, this.transition, this.options);\n        // Hook returned false\n        if (result === false) {\n            // Abort this Transition\n            return rejectFactory_1.Rejection.aborted("Hook aborted transition").toPromise();\n        }\n        var isTargetState = hof_1.is(targetState_1.TargetState);\n        // hook returned a TargetState\n        if (isTargetState(result)) {\n            // Halt the current Transition and redirect (a new Transition) to the TargetState.\n            return rejectFactory_1.Rejection.redirected(result).toPromise();\n        }\n    };\n    /**\n     * Return a Rejection promise if the transition is no longer current due\n     * to a stopped router (disposed), or a new transition has started and superseded this one.\n     */\n    TransitionHook.prototype.getNotCurrentRejection = function () {\n        var router = this.transition.router;\n        // The router is stopped\n        if (router._disposed) {\n            return rejectFactory_1.Rejection.aborted("UIRouter instance #" + router.$id + " has been stopped (disposed)").toPromise();\n        }\n        if (this.transition._aborted) {\n            return rejectFactory_1.Rejection.aborted().toPromise();\n        }\n        // This transition is no longer current.\n        // Another transition started while this hook was still running.\n        if (this.isSuperseded()) {\n            // Abort this transition\n            return rejectFactory_1.Rejection.superseded(this.options.current()).toPromise();\n        }\n    };\n    TransitionHook.prototype.toString = function () {\n        var _a = this, options = _a.options, registeredHook = _a.registeredHook;\n        var event = hof_1.parse("traceData.hookType")(options) || "internal", context = hof_1.parse("traceData.context.state.name")(options) || hof_1.parse("traceData.context")(options) || "unknown", name = strings_1.fnToString(registeredHook.callback);\n        return event + " context: " + context + ", " + strings_1.maxLength(200, name);\n    };\n    /**\n     * Chains together an array of TransitionHooks.\n     *\n     * Given a list of [[TransitionHook]] objects, chains them together.\n     * Each hook is invoked after the previous one completes.\n     *\n     * #### Example:\n     * ```js\n     * var hooks: TransitionHook[] = getHooks();\n     * let promise: Promise<any> = TransitionHook.chain(hooks);\n     *\n     * promise.then(handleSuccess, handleError);\n     * ```\n     *\n     * @param hooks the list of hooks to chain together\n     * @param waitFor if provided, the chain is `.then()`\'ed off this promise\n     * @returns a `Promise` for sequentially invoking the hooks (in order)\n     */\n    TransitionHook.chain = function (hooks, waitFor) {\n        // Chain the next hook off the previous\n        var createHookChainR = function (prev, nextHook) {\n            return prev.then(function () { return nextHook.invokeHook(); });\n        };\n        return hooks.reduce(createHookChainR, waitFor || coreservices_1.services.$q.when());\n    };\n    /**\n     * Invokes all the provided TransitionHooks, in order.\n     * Each hook\'s return value is checked.\n     * If any hook returns a promise, then the rest of the hooks are chained off that promise, and the promise is returned.\n     * If no hook returns a promise, then all hooks are processed synchronously.\n     *\n     * @param hooks the list of TransitionHooks to invoke\n     * @param doneCallback a callback that is invoked after all the hooks have successfully completed\n     *\n     * @returns a promise for the async result, or the result of the callback\n     */\n    TransitionHook.invokeHooks = function (hooks, doneCallback) {\n        for (var idx = 0; idx < hooks.length; idx++) {\n            var hookResult = hooks[idx].invokeHook();\n            if (predicates_1.isPromise(hookResult)) {\n                var remainingHooks = hooks.slice(idx + 1);\n                return TransitionHook.chain(remainingHooks, hookResult)\n                    .then(doneCallback);\n            }\n        }\n        return doneCallback();\n    };\n    /**\n     * Run all TransitionHooks, ignoring their return value.\n     */\n    TransitionHook.runAllHooks = function (hooks) {\n        hooks.forEach(function (hook) { return hook.invokeHook(); });\n    };\n    /**\n     * These GetResultHandler(s) are used by [[invokeHook]] below\n     * Each HookType chooses a GetResultHandler (See: [[TransitionService._defineCoreEvents]])\n     */\n    TransitionHook.HANDLE_RESULT = function (hook) { return function (result) {\n        return hook.handleHookResult(result);\n    }; };\n    /**\n     * If the result is a promise rejection, log it.\n     * Otherwise, ignore the result.\n     */\n    TransitionHook.LOG_REJECTED_RESULT = function (hook) { return function (result) {\n        predicates_1.isPromise(result) && result.catch(function (err) {\n            return hook.logError(rejectFactory_1.Rejection.normalize(err));\n        });\n        return undefined;\n    }; };\n    /**\n     * These GetErrorHandler(s) are used by [[invokeHook]] below\n     * Each HookType chooses a GetErrorHandler (See: [[TransitionService._defineCoreEvents]])\n     */\n    TransitionHook.LOG_ERROR = function (hook) { return function (error) {\n        return hook.logError(error);\n    }; };\n    TransitionHook.REJECT_ERROR = function (hook) { return function (error) {\n        return common_1.silentRejection(error);\n    }; };\n    TransitionHook.THROW_ERROR = function (hook) { return function (error) {\n        throw error;\n    }; };\n    return TransitionHook;\n}());\nexports.TransitionHook = TransitionHook;\n//# sourceMappingURL=transitionHook.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL3RyYW5zaXRpb25Ib29rLmpzPzlhNTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHRyYW5zaXRpb25cbiAqL1xuLyoqIGZvciB0eXBlZG9jICovXG52YXIgaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9pbnRlcmZhY2VcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBzdHJpbmdzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3N0cmluZ3NcIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG52YXIgdHJhY2VfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vdHJhY2VcIik7XG52YXIgY29yZXNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvcmVzZXJ2aWNlc1wiKTtcbnZhciByZWplY3RGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi9yZWplY3RGYWN0b3J5XCIpO1xudmFyIHRhcmdldFN0YXRlXzEgPSByZXF1aXJlKFwiLi4vc3RhdGUvdGFyZ2V0U3RhdGVcIik7XG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgY3VycmVudDogY29tbW9uXzEubm9vcCxcbiAgICB0cmFuc2l0aW9uOiBudWxsLFxuICAgIHRyYWNlRGF0YToge30sXG4gICAgYmluZDogbnVsbCxcbn07XG4vKiogQGhpZGRlbiAqL1xudmFyIFRyYW5zaXRpb25Ib29rID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25Ib29rKHRyYW5zaXRpb24sIHN0YXRlQ29udGV4dCwgcmVnaXN0ZXJlZEhvb2ssIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcbiAgICAgICAgdGhpcy5zdGF0ZUNvbnRleHQgPSBzdGF0ZUNvbnRleHQ7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEhvb2sgPSByZWdpc3RlcmVkSG9vaztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5pc1N1cGVyc2VkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMudHlwZS5ob29rUGhhc2UgPT09IGludGVyZmFjZV8xLlRyYW5zaXRpb25Ib29rUGhhc2UuUlVOICYmICFfdGhpcy5vcHRpb25zLnRyYW5zaXRpb24uaXNBY3RpdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gY29tbW9uXzEuZGVmYXVsdHMob3B0aW9ucywgZGVmYXVsdE9wdGlvbnMpO1xuICAgICAgICB0aGlzLnR5cGUgPSByZWdpc3RlcmVkSG9vay5ldmVudFR5cGU7XG4gICAgfVxuICAgIFRyYW5zaXRpb25Ib29rLnByb3RvdHlwZS5sb2dFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uLnJvdXRlci5zdGF0ZVNlcnZpY2UuZGVmYXVsdEVycm9ySGFuZGxlcigpKGVycik7XG4gICAgfTtcbiAgICBUcmFuc2l0aW9uSG9vay5wcm90b3R5cGUuaW52b2tlSG9vayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGhvb2sgPSB0aGlzLnJlZ2lzdGVyZWRIb29rO1xuICAgICAgICBpZiAoaG9vay5fZGVyZWdpc3RlcmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbm90Q3VycmVudCA9IHRoaXMuZ2V0Tm90Q3VycmVudFJlamVjdGlvbigpO1xuICAgICAgICBpZiAobm90Q3VycmVudClcbiAgICAgICAgICAgIHJldHVybiBub3RDdXJyZW50O1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdHJhY2VfMS50cmFjZS50cmFjZUhvb2tJbnZvY2F0aW9uKHRoaXMsIHRoaXMudHJhbnNpdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgIHZhciBpbnZva2VDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBob29rLmNhbGxiYWNrLmNhbGwob3B0aW9ucy5iaW5kLCBfdGhpcy50cmFuc2l0aW9uLCBfdGhpcy5zdGF0ZUNvbnRleHQpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbm9ybWFsaXplRXJyID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24ubm9ybWFsaXplKGVycikudG9Qcm9taXNlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBoYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBob29rLmV2ZW50VHlwZS5nZXRFcnJvckhhbmRsZXIoX3RoaXMpKGVycik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBoYW5kbGVSZXN1bHQgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gaG9vay5ldmVudFR5cGUuZ2V0UmVzdWx0SGFuZGxlcihfdGhpcykocmVzdWx0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBpbnZva2VDYWxsYmFjaygpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnR5cGUuc3luY2hyb25vdXMgJiYgcHJlZGljYXRlc18xLmlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jYXRjaChub3JtYWxpemVFcnIpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGhhbmRsZVJlc3VsdCwgaGFuZGxlRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIElmIGNhbGxiYWNrIHRocm93cyAoc3luY2hyb25vdXNseSlcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcihyZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLm5vcm1hbGl6ZShlcnIpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChob29rLmludm9rZUxpbWl0ICYmICsraG9vay5pbnZva2VDb3VudCA+PSBob29rLmludm9rZUxpbWl0KSB7XG4gICAgICAgICAgICAgICAgaG9vay5kZXJlZ2lzdGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGhhbmRsZXMgdGhlIHJldHVybiB2YWx1ZSBvZiBhIFRyYW5zaXRpb24gSG9vay5cbiAgICAgKlxuICAgICAqIEEgaG9vayBjYW4gcmV0dXJuIGZhbHNlIChjYW5jZWwpLCBhIFRhcmdldFN0YXRlIChyZWRpcmVjdCksXG4gICAgICogb3IgYSBwcm9taXNlICh3aGljaCBtYXkgbGF0ZXIgcmVzb2x2ZSB0byBmYWxzZSBvciBhIHJlZGlyZWN0KVxuICAgICAqXG4gICAgICogVGhpcyBhbHNvIGhhbmRsZXMgXCJ0cmFuc2l0aW9uIHN1cGVyc2VkZWRcIiAtLSB3aGVuIGEgbmV3IHRyYW5zaXRpb25cbiAgICAgKiB3YXMgc3RhcnRlZCB3aGlsZSB0aGUgaG9vayB3YXMgc3RpbGwgcnVubmluZ1xuICAgICAqL1xuICAgIFRyYW5zaXRpb25Ib29rLnByb3RvdHlwZS5oYW5kbGVIb29rUmVzdWx0ID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbm90Q3VycmVudCA9IHRoaXMuZ2V0Tm90Q3VycmVudFJlamVjdGlvbigpO1xuICAgICAgICBpZiAobm90Q3VycmVudClcbiAgICAgICAgICAgIHJldHVybiBub3RDdXJyZW50O1xuICAgICAgICAvLyBIb29rIHJldHVybmVkIGEgcHJvbWlzZVxuICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgcHJvbWlzZSwgdGhlbiByZXByb2Nlc3Mgd2l0aCB0aGUgcmVzdWx0aW5nIHZhbHVlXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gX3RoaXMuaGFuZGxlSG9va1Jlc3VsdCh2YWwpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlSG9va1Jlc3VsdChyZXN1bHQsIHRoaXMudHJhbnNpdGlvbiwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgLy8gSG9vayByZXR1cm5lZCBmYWxzZVxuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gQWJvcnQgdGhpcyBUcmFuc2l0aW9uXG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0RmFjdG9yeV8xLlJlamVjdGlvbi5hYm9ydGVkKFwiSG9vayBhYm9ydGVkIHRyYW5zaXRpb25cIikudG9Qcm9taXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzVGFyZ2V0U3RhdGUgPSBob2ZfMS5pcyh0YXJnZXRTdGF0ZV8xLlRhcmdldFN0YXRlKTtcbiAgICAgICAgLy8gaG9vayByZXR1cm5lZCBhIFRhcmdldFN0YXRlXG4gICAgICAgIGlmIChpc1RhcmdldFN0YXRlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIC8vIEhhbHQgdGhlIGN1cnJlbnQgVHJhbnNpdGlvbiBhbmQgcmVkaXJlY3QgKGEgbmV3IFRyYW5zaXRpb24pIHRvIHRoZSBUYXJnZXRTdGF0ZS5cbiAgICAgICAgICAgIHJldHVybiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLnJlZGlyZWN0ZWQocmVzdWx0KS50b1Byb21pc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgUmVqZWN0aW9uIHByb21pc2UgaWYgdGhlIHRyYW5zaXRpb24gaXMgbm8gbG9uZ2VyIGN1cnJlbnQgZHVlXG4gICAgICogdG8gYSBzdG9wcGVkIHJvdXRlciAoZGlzcG9zZWQpLCBvciBhIG5ldyB0cmFuc2l0aW9uIGhhcyBzdGFydGVkIGFuZCBzdXBlcnNlZGVkIHRoaXMgb25lLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb25Ib29rLnByb3RvdHlwZS5nZXROb3RDdXJyZW50UmVqZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm91dGVyID0gdGhpcy50cmFuc2l0aW9uLnJvdXRlcjtcbiAgICAgICAgLy8gVGhlIHJvdXRlciBpcyBzdG9wcGVkXG4gICAgICAgIGlmIChyb3V0ZXIuX2Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0RmFjdG9yeV8xLlJlamVjdGlvbi5hYm9ydGVkKFwiVUlSb3V0ZXIgaW5zdGFuY2UgI1wiICsgcm91dGVyLiRpZCArIFwiIGhhcyBiZWVuIHN0b3BwZWQgKGRpc3Bvc2VkKVwiKS50b1Byb21pc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50cmFuc2l0aW9uLl9hYm9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0RmFjdG9yeV8xLlJlamVjdGlvbi5hYm9ydGVkKCkudG9Qcm9taXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyB0cmFuc2l0aW9uIGlzIG5vIGxvbmdlciBjdXJyZW50LlxuICAgICAgICAvLyBBbm90aGVyIHRyYW5zaXRpb24gc3RhcnRlZCB3aGlsZSB0aGlzIGhvb2sgd2FzIHN0aWxsIHJ1bm5pbmcuXG4gICAgICAgIGlmICh0aGlzLmlzU3VwZXJzZWRlZCgpKSB7XG4gICAgICAgICAgICAvLyBBYm9ydCB0aGlzIHRyYW5zaXRpb25cbiAgICAgICAgICAgIHJldHVybiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLnN1cGVyc2VkZWQodGhpcy5vcHRpb25zLmN1cnJlbnQoKSkudG9Qcm9taXNlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyYW5zaXRpb25Ib29rLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgb3B0aW9ucyA9IF9hLm9wdGlvbnMsIHJlZ2lzdGVyZWRIb29rID0gX2EucmVnaXN0ZXJlZEhvb2s7XG4gICAgICAgIHZhciBldmVudCA9IGhvZl8xLnBhcnNlKFwidHJhY2VEYXRhLmhvb2tUeXBlXCIpKG9wdGlvbnMpIHx8IFwiaW50ZXJuYWxcIiwgY29udGV4dCA9IGhvZl8xLnBhcnNlKFwidHJhY2VEYXRhLmNvbnRleHQuc3RhdGUubmFtZVwiKShvcHRpb25zKSB8fCBob2ZfMS5wYXJzZShcInRyYWNlRGF0YS5jb250ZXh0XCIpKG9wdGlvbnMpIHx8IFwidW5rbm93blwiLCBuYW1lID0gc3RyaW5nc18xLmZuVG9TdHJpbmcocmVnaXN0ZXJlZEhvb2suY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gZXZlbnQgKyBcIiBjb250ZXh0OiBcIiArIGNvbnRleHQgKyBcIiwgXCIgKyBzdHJpbmdzXzEubWF4TGVuZ3RoKDIwMCwgbmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGFpbnMgdG9nZXRoZXIgYW4gYXJyYXkgb2YgVHJhbnNpdGlvbkhvb2tzLlxuICAgICAqXG4gICAgICogR2l2ZW4gYSBsaXN0IG9mIFtbVHJhbnNpdGlvbkhvb2tdXSBvYmplY3RzLCBjaGFpbnMgdGhlbSB0b2dldGhlci5cbiAgICAgKiBFYWNoIGhvb2sgaXMgaW52b2tlZCBhZnRlciB0aGUgcHJldmlvdXMgb25lIGNvbXBsZXRlcy5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIHZhciBob29rczogVHJhbnNpdGlvbkhvb2tbXSA9IGdldEhvb2tzKCk7XG4gICAgICogbGV0IHByb21pc2U6IFByb21pc2U8YW55PiA9IFRyYW5zaXRpb25Ib29rLmNoYWluKGhvb2tzKTtcbiAgICAgKlxuICAgICAqIHByb21pc2UudGhlbihoYW5kbGVTdWNjZXNzLCBoYW5kbGVFcnJvcik7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaG9va3MgdGhlIGxpc3Qgb2YgaG9va3MgdG8gY2hhaW4gdG9nZXRoZXJcbiAgICAgKiBAcGFyYW0gd2FpdEZvciBpZiBwcm92aWRlZCwgdGhlIGNoYWluIGlzIGAudGhlbigpYCdlZCBvZmYgdGhpcyBwcm9taXNlXG4gICAgICogQHJldHVybnMgYSBgUHJvbWlzZWAgZm9yIHNlcXVlbnRpYWxseSBpbnZva2luZyB0aGUgaG9va3MgKGluIG9yZGVyKVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25Ib29rLmNoYWluID0gZnVuY3Rpb24gKGhvb2tzLCB3YWl0Rm9yKSB7XG4gICAgICAgIC8vIENoYWluIHRoZSBuZXh0IGhvb2sgb2ZmIHRoZSBwcmV2aW91c1xuICAgICAgICB2YXIgY3JlYXRlSG9va0NoYWluUiA9IGZ1bmN0aW9uIChwcmV2LCBuZXh0SG9vaykge1xuICAgICAgICAgICAgcmV0dXJuIHByZXYudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBuZXh0SG9vay5pbnZva2VIb29rKCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaG9va3MucmVkdWNlKGNyZWF0ZUhvb2tDaGFpblIsIHdhaXRGb3IgfHwgY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEud2hlbigpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEludm9rZXMgYWxsIHRoZSBwcm92aWRlZCBUcmFuc2l0aW9uSG9va3MsIGluIG9yZGVyLlxuICAgICAqIEVhY2ggaG9vaydzIHJldHVybiB2YWx1ZSBpcyBjaGVja2VkLlxuICAgICAqIElmIGFueSBob29rIHJldHVybnMgYSBwcm9taXNlLCB0aGVuIHRoZSByZXN0IG9mIHRoZSBob29rcyBhcmUgY2hhaW5lZCBvZmYgdGhhdCBwcm9taXNlLCBhbmQgdGhlIHByb21pc2UgaXMgcmV0dXJuZWQuXG4gICAgICogSWYgbm8gaG9vayByZXR1cm5zIGEgcHJvbWlzZSwgdGhlbiBhbGwgaG9va3MgYXJlIHByb2Nlc3NlZCBzeW5jaHJvbm91c2x5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGhvb2tzIHRoZSBsaXN0IG9mIFRyYW5zaXRpb25Ib29rcyB0byBpbnZva2VcbiAgICAgKiBAcGFyYW0gZG9uZUNhbGxiYWNrIGEgY2FsbGJhY2sgdGhhdCBpcyBpbnZva2VkIGFmdGVyIGFsbCB0aGUgaG9va3MgaGF2ZSBzdWNjZXNzZnVsbHkgY29tcGxldGVkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBhc3luYyByZXN1bHQsIG9yIHRoZSByZXN1bHQgb2YgdGhlIGNhbGxiYWNrXG4gICAgICovXG4gICAgVHJhbnNpdGlvbkhvb2suaW52b2tlSG9va3MgPSBmdW5jdGlvbiAoaG9va3MsIGRvbmVDYWxsYmFjaykge1xuICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBob29rcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICB2YXIgaG9va1Jlc3VsdCA9IGhvb2tzW2lkeF0uaW52b2tlSG9vaygpO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc1Byb21pc2UoaG9va1Jlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVtYWluaW5nSG9va3MgPSBob29rcy5zbGljZShpZHggKyAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhbnNpdGlvbkhvb2suY2hhaW4ocmVtYWluaW5nSG9va3MsIGhvb2tSZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGRvbmVDYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbmVDYWxsYmFjaygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUnVuIGFsbCBUcmFuc2l0aW9uSG9va3MsIGlnbm9yaW5nIHRoZWlyIHJldHVybiB2YWx1ZS5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uSG9vay5ydW5BbGxIb29rcyA9IGZ1bmN0aW9uIChob29rcykge1xuICAgICAgICBob29rcy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7IHJldHVybiBob29rLmludm9rZUhvb2soKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGVzZSBHZXRSZXN1bHRIYW5kbGVyKHMpIGFyZSB1c2VkIGJ5IFtbaW52b2tlSG9va11dIGJlbG93XG4gICAgICogRWFjaCBIb29rVHlwZSBjaG9vc2VzIGEgR2V0UmVzdWx0SGFuZGxlciAoU2VlOiBbW1RyYW5zaXRpb25TZXJ2aWNlLl9kZWZpbmVDb3JlRXZlbnRzXV0pXG4gICAgICovXG4gICAgVHJhbnNpdGlvbkhvb2suSEFORExFX1JFU1VMVCA9IGZ1bmN0aW9uIChob29rKSB7IHJldHVybiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBob29rLmhhbmRsZUhvb2tSZXN1bHQocmVzdWx0KTtcbiAgICB9OyB9O1xuICAgIC8qKlxuICAgICAqIElmIHRoZSByZXN1bHQgaXMgYSBwcm9taXNlIHJlamVjdGlvbiwgbG9nIGl0LlxuICAgICAqIE90aGVyd2lzZSwgaWdub3JlIHRoZSByZXN1bHQuXG4gICAgICovXG4gICAgVHJhbnNpdGlvbkhvb2suTE9HX1JFSkVDVEVEX1JFU1VMVCA9IGZ1bmN0aW9uIChob29rKSB7IHJldHVybiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHByZWRpY2F0ZXNfMS5pc1Byb21pc2UocmVzdWx0KSAmJiByZXN1bHQuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGhvb2subG9nRXJyb3IocmVqZWN0RmFjdG9yeV8xLlJlamVjdGlvbi5ub3JtYWxpemUoZXJyKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07IH07XG4gICAgLyoqXG4gICAgICogVGhlc2UgR2V0RXJyb3JIYW5kbGVyKHMpIGFyZSB1c2VkIGJ5IFtbaW52b2tlSG9va11dIGJlbG93XG4gICAgICogRWFjaCBIb29rVHlwZSBjaG9vc2VzIGEgR2V0RXJyb3JIYW5kbGVyIChTZWU6IFtbVHJhbnNpdGlvblNlcnZpY2UuX2RlZmluZUNvcmVFdmVudHNdXSlcbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uSG9vay5MT0dfRVJST1IgPSBmdW5jdGlvbiAoaG9vaykgeyByZXR1cm4gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBob29rLmxvZ0Vycm9yKGVycm9yKTtcbiAgICB9OyB9O1xuICAgIFRyYW5zaXRpb25Ib29rLlJFSkVDVF9FUlJPUiA9IGZ1bmN0aW9uIChob29rKSB7IHJldHVybiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLnNpbGVudFJlamVjdGlvbihlcnJvcik7XG4gICAgfTsgfTtcbiAgICBUcmFuc2l0aW9uSG9vay5USFJPV19FUlJPUiA9IGZ1bmN0aW9uIChob29rKSB7IHJldHVybiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfTsgfTtcbiAgICByZXR1cm4gVHJhbnNpdGlvbkhvb2s7XG59KCkpO1xuZXhwb3J0cy5UcmFuc2l0aW9uSG9vayA9IFRyYW5zaXRpb25Ib29rO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNpdGlvbkhvb2suanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL3RyYW5zaXRpb25Ib29rLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n')},,function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module core\n */\n/**\n * Matches state names using glob-like pattern strings.\n *\n * Globs can be used in specific APIs including:\n *\n * - [[StateService.is]]\n * - [[StateService.includes]]\n * - The first argument to Hook Registration functions like [[TransitionService.onStart]]\n *    - [[HookMatchCriteria]] and [[HookMatchCriterion]]\n *\n * A `Glob` string is a pattern which matches state names.\n * Nested state names are split into segments (separated by a dot) when processing.\n * The state named `foo.bar.baz` is split into three segments ['foo', 'bar', 'baz']\n *\n * Globs work according to the following rules:\n *\n * ### Exact match:\n *\n * The glob `'A.B'` matches the state named exactly `'A.B'`.\n *\n * | Glob        |Matches states named|Does not match state named|\n * |:------------|:--------------------|:---------------------|\n * | `'A'`       | `'A'`               | `'B'` , `'A.C'`      |\n * | `'A.B'`     | `'A.B'`             | `'A'` , `'A.B.C'`    |\n * | `'foo'`     | `'foo'`             | `'FOO'` , `'foo.bar'`|\n *\n * ### Single star (`*`)\n *\n * A single star (`*`) is a wildcard that matches exactly one segment.\n *\n * | Glob        |Matches states named  |Does not match state named |\n * |:------------|:---------------------|:--------------------------|\n * | `'*'`       | `'A'` , `'Z'`        | `'A.B'` , `'Z.Y.X'`       |\n * | `'A.*'`     | `'A.B'` , `'A.C'`    | `'A'` , `'A.B.C'`         |\n * | `'A.*.*'`   | `'A.B.C'` , `'A.X.Y'`| `'A'`, `'A.B'` , `'Z.Y.X'`|\n *\n * ### Double star (`**`)\n *\n * A double star (`'**'`) is a wildcard that matches *zero or more segments*\n *\n * | Glob        |Matches states named                           |Does not match state named         |\n * |:------------|:----------------------------------------------|:----------------------------------|\n * | `'**'`      | `'A'` , `'A.B'`, `'Z.Y.X'`                    | (matches all states)              |\n * | `'A.**'`    | `'A'` , `'A.B'` , `'A.C.X'`                   | `'Z.Y.X'`                         |\n * | `'**.X'`    | `'X'` , `'A.X'` , `'Z.Y.X'`                   | `'A'` , `'A.login.Z'`             |\n * | `'A.**.X'`  | `'A.X'` , `'A.B.X'` , `'A.B.C.X'`             | `'A'` , `'A.B.C'`                 |\n *\n */\nvar Glob = /** @class */ (function () {\n    function Glob(text) {\n        this.text = text;\n        this.glob = text.split('.');\n        var regexpString = this.text.split('.')\n            .map(function (seg) {\n            if (seg === '**')\n                return '(?:|(?:\\\\.[^.]*)*)';\n            if (seg === '*')\n                return '\\\\.[^.]*';\n            return '\\\\.' + seg;\n        }).join('');\n        this.regexp = new RegExp(\"^\" + regexpString + \"$\");\n    }\n    Glob.prototype.matches = function (name) {\n        return this.regexp.test('.' + name);\n    };\n    /** Returns true if the string has glob-like characters in it */\n    Glob.is = function (text) {\n        return !!/[!,*]+/.exec(text);\n    };\n    /** Returns a glob from the string, or null if the string isn't Glob-like */\n    Glob.fromString = function (text) {\n        return Glob.is(text) ? new Glob(text) : null;\n    };\n    return Glob;\n}());\nexports.Glob = Glob;\n//# sourceMappingURL=glob.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9jb21tb24vZ2xvYi5qcz9hOWNlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSBjb3JlXG4gKi9cbi8qKlxuICogTWF0Y2hlcyBzdGF0ZSBuYW1lcyB1c2luZyBnbG9iLWxpa2UgcGF0dGVybiBzdHJpbmdzLlxuICpcbiAqIEdsb2JzIGNhbiBiZSB1c2VkIGluIHNwZWNpZmljIEFQSXMgaW5jbHVkaW5nOlxuICpcbiAqIC0gW1tTdGF0ZVNlcnZpY2UuaXNdXVxuICogLSBbW1N0YXRlU2VydmljZS5pbmNsdWRlc11dXG4gKiAtIFRoZSBmaXJzdCBhcmd1bWVudCB0byBIb29rIFJlZ2lzdHJhdGlvbiBmdW5jdGlvbnMgbGlrZSBbW1RyYW5zaXRpb25TZXJ2aWNlLm9uU3RhcnRdXVxuICogICAgLSBbW0hvb2tNYXRjaENyaXRlcmlhXV0gYW5kIFtbSG9va01hdGNoQ3JpdGVyaW9uXV1cbiAqXG4gKiBBIGBHbG9iYCBzdHJpbmcgaXMgYSBwYXR0ZXJuIHdoaWNoIG1hdGNoZXMgc3RhdGUgbmFtZXMuXG4gKiBOZXN0ZWQgc3RhdGUgbmFtZXMgYXJlIHNwbGl0IGludG8gc2VnbWVudHMgKHNlcGFyYXRlZCBieSBhIGRvdCkgd2hlbiBwcm9jZXNzaW5nLlxuICogVGhlIHN0YXRlIG5hbWVkIGBmb28uYmFyLmJhemAgaXMgc3BsaXQgaW50byB0aHJlZSBzZWdtZW50cyBbJ2ZvbycsICdiYXInLCAnYmF6J11cbiAqXG4gKiBHbG9icyB3b3JrIGFjY29yZGluZyB0byB0aGUgZm9sbG93aW5nIHJ1bGVzOlxuICpcbiAqICMjIyBFeGFjdCBtYXRjaDpcbiAqXG4gKiBUaGUgZ2xvYiBgJ0EuQidgIG1hdGNoZXMgdGhlIHN0YXRlIG5hbWVkIGV4YWN0bHkgYCdBLkInYC5cbiAqXG4gKiB8IEdsb2IgICAgICAgIHxNYXRjaGVzIHN0YXRlcyBuYW1lZHxEb2VzIG5vdCBtYXRjaCBzdGF0ZSBuYW1lZHxcbiAqIHw6LS0tLS0tLS0tLS0tfDotLS0tLS0tLS0tLS0tLS0tLS0tLXw6LS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCBgJ0EnYCAgICAgICB8IGAnQSdgICAgICAgICAgICAgICAgfCBgJ0InYCAsIGAnQS5DJ2AgICAgICB8XG4gKiB8IGAnQS5CJ2AgICAgIHwgYCdBLkInYCAgICAgICAgICAgICB8IGAnQSdgICwgYCdBLkIuQydgICAgIHxcbiAqIHwgYCdmb28nYCAgICAgfCBgJ2ZvbydgICAgICAgICAgICAgIHwgYCdGT08nYCAsIGAnZm9vLmJhcidgfFxuICpcbiAqICMjIyBTaW5nbGUgc3RhciAoYCpgKVxuICpcbiAqIEEgc2luZ2xlIHN0YXIgKGAqYCkgaXMgYSB3aWxkY2FyZCB0aGF0IG1hdGNoZXMgZXhhY3RseSBvbmUgc2VnbWVudC5cbiAqXG4gKiB8IEdsb2IgICAgICAgIHxNYXRjaGVzIHN0YXRlcyBuYW1lZCAgfERvZXMgbm90IG1hdGNoIHN0YXRlIG5hbWVkIHxcbiAqIHw6LS0tLS0tLS0tLS0tfDotLS0tLS0tLS0tLS0tLS0tLS0tLS18Oi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCBgJyonYCAgICAgICB8IGAnQSdgICwgYCdaJ2AgICAgICAgIHwgYCdBLkInYCAsIGAnWi5ZLlgnYCAgICAgICB8XG4gKiB8IGAnQS4qJ2AgICAgIHwgYCdBLkInYCAsIGAnQS5DJ2AgICAgfCBgJ0EnYCAsIGAnQS5CLkMnYCAgICAgICAgIHxcbiAqIHwgYCdBLiouKidgICAgfCBgJ0EuQi5DJ2AgLCBgJ0EuWC5ZJ2B8IGAnQSdgLCBgJ0EuQidgICwgYCdaLlkuWCdgfFxuICpcbiAqICMjIyBEb3VibGUgc3RhciAoYCoqYClcbiAqXG4gKiBBIGRvdWJsZSBzdGFyIChgJyoqJ2ApIGlzIGEgd2lsZGNhcmQgdGhhdCBtYXRjaGVzICp6ZXJvIG9yIG1vcmUgc2VnbWVudHMqXG4gKlxuICogfCBHbG9iICAgICAgICB8TWF0Y2hlcyBzdGF0ZXMgbmFtZWQgICAgICAgICAgICAgICAgICAgICAgICAgICB8RG9lcyBub3QgbWF0Y2ggc3RhdGUgbmFtZWQgICAgICAgICB8XG4gKiB8Oi0tLS0tLS0tLS0tLXw6LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXw6LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgYCcqKidgICAgICAgfCBgJ0EnYCAsIGAnQS5CJ2AsIGAnWi5ZLlgnYCAgICAgICAgICAgICAgICAgICAgfCAobWF0Y2hlcyBhbGwgc3RhdGVzKSAgICAgICAgICAgICAgfFxuICogfCBgJ0EuKionYCAgICB8IGAnQSdgICwgYCdBLkInYCAsIGAnQS5DLlgnYCAgICAgICAgICAgICAgICAgICB8IGAnWi5ZLlgnYCAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IGAnKiouWCdgICAgIHwgYCdYJ2AgLCBgJ0EuWCdgICwgYCdaLlkuWCdgICAgICAgICAgICAgICAgICAgIHwgYCdBJ2AgLCBgJ0EubG9naW4uWidgICAgICAgICAgICAgIHxcbiAqIHwgYCdBLioqLlgnYCAgfCBgJ0EuWCdgICwgYCdBLkIuWCdgICwgYCdBLkIuQy5YJ2AgICAgICAgICAgICAgfCBgJ0EnYCAsIGAnQS5CLkMnYCAgICAgICAgICAgICAgICAgfFxuICpcbiAqL1xudmFyIEdsb2IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR2xvYih0ZXh0KSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMuZ2xvYiA9IHRleHQuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIHJlZ2V4cFN0cmluZyA9IHRoaXMudGV4dC5zcGxpdCgnLicpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzZWcpIHtcbiAgICAgICAgICAgIGlmIChzZWcgPT09ICcqKicpXG4gICAgICAgICAgICAgICAgcmV0dXJuICcoPzp8KD86XFxcXC5bXi5dKikqKSc7XG4gICAgICAgICAgICBpZiAoc2VnID09PSAnKicpXG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXFxcLlteLl0qJztcbiAgICAgICAgICAgIHJldHVybiAnXFxcXC4nICsgc2VnO1xuICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgICAgdGhpcy5yZWdleHAgPSBuZXcgUmVnRXhwKFwiXlwiICsgcmVnZXhwU3RyaW5nICsgXCIkXCIpO1xuICAgIH1cbiAgICBHbG9iLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnZXhwLnRlc3QoJy4nICsgbmFtZSk7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBzdHJpbmcgaGFzIGdsb2ItbGlrZSBjaGFyYWN0ZXJzIGluIGl0ICovXG4gICAgR2xvYi5pcyA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHJldHVybiAhIS9bISwqXSsvLmV4ZWModGV4dCk7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhIGdsb2IgZnJvbSB0aGUgc3RyaW5nLCBvciBudWxsIGlmIHRoZSBzdHJpbmcgaXNuJ3QgR2xvYi1saWtlICovXG4gICAgR2xvYi5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIEdsb2IuaXModGV4dCkgPyBuZXcgR2xvYih0ZXh0KSA6IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gR2xvYjtcbn0oKSk7XG5leHBvcnRzLkdsb2IgPSBHbG9iO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2xvYi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9nbG9iLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15\n")},function(module,exports,__webpack_require__){"use strict";eval('\n/** @module path */ /** for typedoc */\nObject.defineProperty(exports, "__esModule", { value: true });\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar hof_1 = __webpack_require__(/*! ../common/hof */ 2);\nvar targetState_1 = __webpack_require__(/*! ../state/targetState */ 9);\nvar pathNode_1 = __webpack_require__(/*! ./pathNode */ 23);\n/**\n * This class contains functions which convert TargetStates, Nodes and paths from one type to another.\n */\nvar PathUtils = /** @class */ (function () {\n    function PathUtils() {\n    }\n    /** Given a PathNode[], create an TargetState */\n    PathUtils.makeTargetState = function (registry, path) {\n        var state = common_1.tail(path).state;\n        return new targetState_1.TargetState(registry, state, path.map(hof_1.prop("paramValues")).reduce(common_1.mergeR, {}), {});\n    };\n    PathUtils.buildPath = function (targetState) {\n        var toParams = targetState.params();\n        return targetState.$state().path.map(function (state) { return new pathNode_1.PathNode(state).applyRawParams(toParams); });\n    };\n    /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */\n    PathUtils.buildToPath = function (fromPath, targetState) {\n        var toPath = PathUtils.buildPath(targetState);\n        if (targetState.options().inherit) {\n            return PathUtils.inheritParams(fromPath, toPath, Object.keys(targetState.params()));\n        }\n        return toPath;\n    };\n    /**\n     * Creates ViewConfig objects and adds to nodes.\n     *\n     * On each [[PathNode]], creates ViewConfig objects from the views: property of the node\'s state\n     */\n    PathUtils.applyViewConfigs = function ($view, path, states) {\n        // Only apply the viewConfigs to the nodes for the given states\n        path.filter(function (node) { return common_1.inArray(states, node.state); }).forEach(function (node) {\n            var viewDecls = common_1.values(node.state.views || {});\n            var subPath = PathUtils.subPath(path, function (n) { return n === node; });\n            var viewConfigs = viewDecls.map(function (view) { return $view.createViewConfig(subPath, view); });\n            node.views = viewConfigs.reduce(common_1.unnestR, []);\n        });\n    };\n    /**\n     * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath\n     *\n     * For a parameter in a node to be inherited from the from path:\n     * - The toPath\'s node must have a matching node in the fromPath (by state).\n     * - The parameter name must not be found in the toKeys parameter array.\n     *\n     * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some\n     * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,\n     * it is not inherited from the fromPath.\n     */\n    PathUtils.inheritParams = function (fromPath, toPath, toKeys) {\n        if (toKeys === void 0) { toKeys = []; }\n        function nodeParamVals(path, state) {\n            var node = common_1.find(path, hof_1.propEq(\'state\', state));\n            return common_1.extend({}, node && node.paramValues);\n        }\n        var noInherit = fromPath.map(function (node) { return node.paramSchema; })\n            .reduce(common_1.unnestR, [])\n            .filter(function (param) { return !param.inherit; })\n            .map(hof_1.prop(\'id\'));\n        /**\n         * Given an [[PathNode]] "toNode", return a new [[PathNode]] with param values inherited from the\n         * matching node in fromPath.  Only inherit keys that aren\'t found in "toKeys" from the node in "fromPath""\n         */\n        function makeInheritedParamsNode(toNode) {\n            // All param values for the node (may include default key/vals, when key was not found in toParams)\n            var toParamVals = common_1.extend({}, toNode && toNode.paramValues);\n            // limited to only those keys found in toParams\n            var incomingParamVals = common_1.pick(toParamVals, toKeys);\n            toParamVals = common_1.omit(toParamVals, toKeys);\n            var fromParamVals = common_1.omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);\n            // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals\n            var ownParamVals = common_1.extend(toParamVals, fromParamVals, incomingParamVals);\n            return new pathNode_1.PathNode(toNode.state).applyRawParams(ownParamVals);\n        }\n        // The param keys specified by the incoming toParams\n        return toPath.map(makeInheritedParamsNode);\n    };\n    /**\n     * Computes the tree changes (entering, exiting) between a fromPath and toPath.\n     */\n    PathUtils.treeChanges = function (fromPath, toPath, reloadState) {\n        var keep = 0, max = Math.min(fromPath.length, toPath.length);\n        var nodesMatch = function (node1, node2) {\n            return node1.equals(node2, PathUtils.nonDynamicParams);\n        };\n        while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {\n            keep++;\n        }\n        /** Given a retained node, return a new node which uses the to node\'s param values */\n        function applyToParams(retainedNode, idx) {\n            var cloned = pathNode_1.PathNode.clone(retainedNode);\n            cloned.paramValues = toPath[idx].paramValues;\n            return cloned;\n        }\n        var from, retained, exiting, entering, to;\n        from = fromPath;\n        retained = from.slice(0, keep);\n        exiting = from.slice(keep);\n        // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped\n        var retainedWithToParams = retained.map(applyToParams);\n        entering = toPath.slice(keep);\n        to = (retainedWithToParams).concat(entering);\n        return { from: from, to: to, retained: retained, exiting: exiting, entering: entering };\n    };\n    /**\n     * Returns a new path which is: the subpath of the first path which matches the second path.\n     *\n     * The new path starts from root and contains any nodes that match the nodes in the second path.\n     * It stops before the first non-matching node.\n     *\n     * Nodes are compared using their state property and their parameter values.\n     * If a `paramsFn` is provided, only the [[Param]] returned by the function will be considered when comparing nodes.\n     *\n     * @param pathA the first path\n     * @param pathB the second path\n     * @param paramsFn a function which returns the parameters to consider when comparing\n     *\n     * @returns an array of PathNodes from the first path which match the nodes in the second path\n     */\n    PathUtils.matching = function (pathA, pathB, paramsFn) {\n        var done = false;\n        var tuples = common_1.arrayTuples(pathA, pathB);\n        return tuples.reduce(function (matching, _a) {\n            var nodeA = _a[0], nodeB = _a[1];\n            done = done || !nodeA.equals(nodeB, paramsFn);\n            return done ? matching : matching.concat(nodeA);\n        }, []);\n    };\n    /**\n     * Returns true if two paths are identical.\n     *\n     * @param pathA\n     * @param pathB\n     * @param paramsFn a function which returns the parameters to consider when comparing\n     * @returns true if the the states and parameter values for both paths are identical\n     */\n    PathUtils.equals = function (pathA, pathB, paramsFn) {\n        return pathA.length === pathB.length &&\n            PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length;\n    };\n    /**\n     * Return a subpath of a path, which stops at the first matching node\n     *\n     * Given an array of nodes, returns a subset of the array starting from the first node,\n     * stopping when the first node matches the predicate.\n     *\n     * @param path a path of [[PathNode]]s\n     * @param predicate a [[Predicate]] fn that matches [[PathNode]]s\n     * @returns a subpath up to the matching node, or undefined if no match is found\n     */\n    PathUtils.subPath = function (path, predicate) {\n        var node = common_1.find(path, predicate);\n        var elementIdx = path.indexOf(node);\n        return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);\n    };\n    PathUtils.nonDynamicParams = function (node) {\n        return node.state.parameters({ inherit: false })\n            .filter(function (param) { return !param.dynamic; });\n    };\n    /** Gets the raw parameter values from a path */\n    PathUtils.paramValues = function (path) {\n        return path.reduce(function (acc, node) { return common_1.extend(acc, node.paramValues); }, {});\n    };\n    return PathUtils;\n}());\nexports.PathUtils = PathUtils;\n//# sourceMappingURL=pathFactory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9wYXRoL3BhdGhGYWN0b3J5LmpzPzkxMGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiogQG1vZHVsZSBwYXRoICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciB0YXJnZXRTdGF0ZV8xID0gcmVxdWlyZShcIi4uL3N0YXRlL3RhcmdldFN0YXRlXCIpO1xudmFyIHBhdGhOb2RlXzEgPSByZXF1aXJlKFwiLi9wYXRoTm9kZVwiKTtcbi8qKlxuICogVGhpcyBjbGFzcyBjb250YWlucyBmdW5jdGlvbnMgd2hpY2ggY29udmVydCBUYXJnZXRTdGF0ZXMsIE5vZGVzIGFuZCBwYXRocyBmcm9tIG9uZSB0eXBlIHRvIGFub3RoZXIuXG4gKi9cbnZhciBQYXRoVXRpbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGF0aFV0aWxzKCkge1xuICAgIH1cbiAgICAvKiogR2l2ZW4gYSBQYXRoTm9kZVtdLCBjcmVhdGUgYW4gVGFyZ2V0U3RhdGUgKi9cbiAgICBQYXRoVXRpbHMubWFrZVRhcmdldFN0YXRlID0gZnVuY3Rpb24gKHJlZ2lzdHJ5LCBwYXRoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGNvbW1vbl8xLnRhaWwocGF0aCkuc3RhdGU7XG4gICAgICAgIHJldHVybiBuZXcgdGFyZ2V0U3RhdGVfMS5UYXJnZXRTdGF0ZShyZWdpc3RyeSwgc3RhdGUsIHBhdGgubWFwKGhvZl8xLnByb3AoXCJwYXJhbVZhbHVlc1wiKSkucmVkdWNlKGNvbW1vbl8xLm1lcmdlUiwge30pLCB7fSk7XG4gICAgfTtcbiAgICBQYXRoVXRpbHMuYnVpbGRQYXRoID0gZnVuY3Rpb24gKHRhcmdldFN0YXRlKSB7XG4gICAgICAgIHZhciB0b1BhcmFtcyA9IHRhcmdldFN0YXRlLnBhcmFtcygpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0U3RhdGUuJHN0YXRlKCkucGF0aC5tYXAoZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBuZXcgcGF0aE5vZGVfMS5QYXRoTm9kZShzdGF0ZSkuYXBwbHlSYXdQYXJhbXModG9QYXJhbXMpOyB9KTtcbiAgICB9O1xuICAgIC8qKiBHaXZlbiBhIGZyb21QYXRoOiBQYXRoTm9kZVtdIGFuZCBhIFRhcmdldFN0YXRlLCBidWlsZHMgYSB0b1BhdGg6IFBhdGhOb2RlW10gKi9cbiAgICBQYXRoVXRpbHMuYnVpbGRUb1BhdGggPSBmdW5jdGlvbiAoZnJvbVBhdGgsIHRhcmdldFN0YXRlKSB7XG4gICAgICAgIHZhciB0b1BhdGggPSBQYXRoVXRpbHMuYnVpbGRQYXRoKHRhcmdldFN0YXRlKTtcbiAgICAgICAgaWYgKHRhcmdldFN0YXRlLm9wdGlvbnMoKS5pbmhlcml0KSB7XG4gICAgICAgICAgICByZXR1cm4gUGF0aFV0aWxzLmluaGVyaXRQYXJhbXMoZnJvbVBhdGgsIHRvUGF0aCwgT2JqZWN0LmtleXModGFyZ2V0U3RhdGUucGFyYW1zKCkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9QYXRoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBWaWV3Q29uZmlnIG9iamVjdHMgYW5kIGFkZHMgdG8gbm9kZXMuXG4gICAgICpcbiAgICAgKiBPbiBlYWNoIFtbUGF0aE5vZGVdXSwgY3JlYXRlcyBWaWV3Q29uZmlnIG9iamVjdHMgZnJvbSB0aGUgdmlld3M6IHByb3BlcnR5IG9mIHRoZSBub2RlJ3Mgc3RhdGVcbiAgICAgKi9cbiAgICBQYXRoVXRpbHMuYXBwbHlWaWV3Q29uZmlncyA9IGZ1bmN0aW9uICgkdmlldywgcGF0aCwgc3RhdGVzKSB7XG4gICAgICAgIC8vIE9ubHkgYXBwbHkgdGhlIHZpZXdDb25maWdzIHRvIHRoZSBub2RlcyBmb3IgdGhlIGdpdmVuIHN0YXRlc1xuICAgICAgICBwYXRoLmZpbHRlcihmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gY29tbW9uXzEuaW5BcnJheShzdGF0ZXMsIG5vZGUuc3RhdGUpOyB9KS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgdmlld0RlY2xzID0gY29tbW9uXzEudmFsdWVzKG5vZGUuc3RhdGUudmlld3MgfHwge30pO1xuICAgICAgICAgICAgdmFyIHN1YlBhdGggPSBQYXRoVXRpbHMuc3ViUGF0aChwYXRoLCBmdW5jdGlvbiAobikgeyByZXR1cm4gbiA9PT0gbm9kZTsgfSk7XG4gICAgICAgICAgICB2YXIgdmlld0NvbmZpZ3MgPSB2aWV3RGVjbHMubWFwKGZ1bmN0aW9uICh2aWV3KSB7IHJldHVybiAkdmlldy5jcmVhdGVWaWV3Q29uZmlnKHN1YlBhdGgsIHZpZXcpOyB9KTtcbiAgICAgICAgICAgIG5vZGUudmlld3MgPSB2aWV3Q29uZmlncy5yZWR1Y2UoY29tbW9uXzEudW5uZXN0UiwgW10pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgZnJvbVBhdGggYW5kIGEgdG9QYXRoLCByZXR1cm5zIGEgbmV3IHRvIHBhdGggd2hpY2ggaW5oZXJpdHMgcGFyYW1ldGVycyBmcm9tIHRoZSBmcm9tUGF0aFxuICAgICAqXG4gICAgICogRm9yIGEgcGFyYW1ldGVyIGluIGEgbm9kZSB0byBiZSBpbmhlcml0ZWQgZnJvbSB0aGUgZnJvbSBwYXRoOlxuICAgICAqIC0gVGhlIHRvUGF0aCdzIG5vZGUgbXVzdCBoYXZlIGEgbWF0Y2hpbmcgbm9kZSBpbiB0aGUgZnJvbVBhdGggKGJ5IHN0YXRlKS5cbiAgICAgKiAtIFRoZSBwYXJhbWV0ZXIgbmFtZSBtdXN0IG5vdCBiZSBmb3VuZCBpbiB0aGUgdG9LZXlzIHBhcmFtZXRlciBhcnJheS5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoZSBrZXlzIHByb3ZpZGVkIGluIHRvS2V5cyBhcmUgaW50ZW5kZWQgdG8gYmUgdGhvc2UgcGFyYW0ga2V5cyBleHBsaWNpdGx5IHNwZWNpZmllZCBieSBzb21lXG4gICAgICogY2FsbGVyLCBmb3IgaW5zdGFuY2UsICRzdGF0ZS50cmFuc2l0aW9uVG8oLi4uLCB0b1BhcmFtcykuICBJZiBhIGtleSB3YXMgZm91bmQgaW4gdG9QYXJhbXMsXG4gICAgICogaXQgaXMgbm90IGluaGVyaXRlZCBmcm9tIHRoZSBmcm9tUGF0aC5cbiAgICAgKi9cbiAgICBQYXRoVXRpbHMuaW5oZXJpdFBhcmFtcyA9IGZ1bmN0aW9uIChmcm9tUGF0aCwgdG9QYXRoLCB0b0tleXMpIHtcbiAgICAgICAgaWYgKHRvS2V5cyA9PT0gdm9pZCAwKSB7IHRvS2V5cyA9IFtdOyB9XG4gICAgICAgIGZ1bmN0aW9uIG5vZGVQYXJhbVZhbHMocGF0aCwgc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gY29tbW9uXzEuZmluZChwYXRoLCBob2ZfMS5wcm9wRXEoJ3N0YXRlJywgc3RhdGUpKTtcbiAgICAgICAgICAgIHJldHVybiBjb21tb25fMS5leHRlbmQoe30sIG5vZGUgJiYgbm9kZS5wYXJhbVZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vSW5oZXJpdCA9IGZyb21QYXRoLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5wYXJhbVNjaGVtYTsgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoY29tbW9uXzEudW5uZXN0UiwgW10pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gIXBhcmFtLmluaGVyaXQ7IH0pXG4gICAgICAgICAgICAubWFwKGhvZl8xLnByb3AoJ2lkJykpO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYW4gW1tQYXRoTm9kZV1dIFwidG9Ob2RlXCIsIHJldHVybiBhIG5ldyBbW1BhdGhOb2RlXV0gd2l0aCBwYXJhbSB2YWx1ZXMgaW5oZXJpdGVkIGZyb20gdGhlXG4gICAgICAgICAqIG1hdGNoaW5nIG5vZGUgaW4gZnJvbVBhdGguICBPbmx5IGluaGVyaXQga2V5cyB0aGF0IGFyZW4ndCBmb3VuZCBpbiBcInRvS2V5c1wiIGZyb20gdGhlIG5vZGUgaW4gXCJmcm9tUGF0aFwiXCJcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VJbmhlcml0ZWRQYXJhbXNOb2RlKHRvTm9kZSkge1xuICAgICAgICAgICAgLy8gQWxsIHBhcmFtIHZhbHVlcyBmb3IgdGhlIG5vZGUgKG1heSBpbmNsdWRlIGRlZmF1bHQga2V5L3ZhbHMsIHdoZW4ga2V5IHdhcyBub3QgZm91bmQgaW4gdG9QYXJhbXMpXG4gICAgICAgICAgICB2YXIgdG9QYXJhbVZhbHMgPSBjb21tb25fMS5leHRlbmQoe30sIHRvTm9kZSAmJiB0b05vZGUucGFyYW1WYWx1ZXMpO1xuICAgICAgICAgICAgLy8gbGltaXRlZCB0byBvbmx5IHRob3NlIGtleXMgZm91bmQgaW4gdG9QYXJhbXNcbiAgICAgICAgICAgIHZhciBpbmNvbWluZ1BhcmFtVmFscyA9IGNvbW1vbl8xLnBpY2sodG9QYXJhbVZhbHMsIHRvS2V5cyk7XG4gICAgICAgICAgICB0b1BhcmFtVmFscyA9IGNvbW1vbl8xLm9taXQodG9QYXJhbVZhbHMsIHRvS2V5cyk7XG4gICAgICAgICAgICB2YXIgZnJvbVBhcmFtVmFscyA9IGNvbW1vbl8xLm9taXQobm9kZVBhcmFtVmFscyhmcm9tUGF0aCwgdG9Ob2RlLnN0YXRlKSB8fCB7fSwgbm9Jbmhlcml0KTtcbiAgICAgICAgICAgIC8vIGV4dGVuZCB0b1BhcmFtVmFscyB3aXRoIGFueSBmcm9tUGFyYW1WYWxzLCB0aGVuIG92ZXJyaWRlIGFueSBvZiB0aG9zZSB0aG9zZSB3aXRoIGluY29taW5nUGFyYW1WYWxzXG4gICAgICAgICAgICB2YXIgb3duUGFyYW1WYWxzID0gY29tbW9uXzEuZXh0ZW5kKHRvUGFyYW1WYWxzLCBmcm9tUGFyYW1WYWxzLCBpbmNvbWluZ1BhcmFtVmFscyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHBhdGhOb2RlXzEuUGF0aE5vZGUodG9Ob2RlLnN0YXRlKS5hcHBseVJhd1BhcmFtcyhvd25QYXJhbVZhbHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBwYXJhbSBrZXlzIHNwZWNpZmllZCBieSB0aGUgaW5jb21pbmcgdG9QYXJhbXNcbiAgICAgICAgcmV0dXJuIHRvUGF0aC5tYXAobWFrZUluaGVyaXRlZFBhcmFtc05vZGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHRyZWUgY2hhbmdlcyAoZW50ZXJpbmcsIGV4aXRpbmcpIGJldHdlZW4gYSBmcm9tUGF0aCBhbmQgdG9QYXRoLlxuICAgICAqL1xuICAgIFBhdGhVdGlscy50cmVlQ2hhbmdlcyA9IGZ1bmN0aW9uIChmcm9tUGF0aCwgdG9QYXRoLCByZWxvYWRTdGF0ZSkge1xuICAgICAgICB2YXIga2VlcCA9IDAsIG1heCA9IE1hdGgubWluKGZyb21QYXRoLmxlbmd0aCwgdG9QYXRoLmxlbmd0aCk7XG4gICAgICAgIHZhciBub2Rlc01hdGNoID0gZnVuY3Rpb24gKG5vZGUxLCBub2RlMikge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUxLmVxdWFscyhub2RlMiwgUGF0aFV0aWxzLm5vbkR5bmFtaWNQYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICB3aGlsZSAoa2VlcCA8IG1heCAmJiBmcm9tUGF0aFtrZWVwXS5zdGF0ZSAhPT0gcmVsb2FkU3RhdGUgJiYgbm9kZXNNYXRjaChmcm9tUGF0aFtrZWVwXSwgdG9QYXRoW2tlZXBdKSkge1xuICAgICAgICAgICAga2VlcCsrO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBHaXZlbiBhIHJldGFpbmVkIG5vZGUsIHJldHVybiBhIG5ldyBub2RlIHdoaWNoIHVzZXMgdGhlIHRvIG5vZGUncyBwYXJhbSB2YWx1ZXMgKi9cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlUb1BhcmFtcyhyZXRhaW5lZE5vZGUsIGlkeCkge1xuICAgICAgICAgICAgdmFyIGNsb25lZCA9IHBhdGhOb2RlXzEuUGF0aE5vZGUuY2xvbmUocmV0YWluZWROb2RlKTtcbiAgICAgICAgICAgIGNsb25lZC5wYXJhbVZhbHVlcyA9IHRvUGF0aFtpZHhdLnBhcmFtVmFsdWVzO1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnJvbSwgcmV0YWluZWQsIGV4aXRpbmcsIGVudGVyaW5nLCB0bztcbiAgICAgICAgZnJvbSA9IGZyb21QYXRoO1xuICAgICAgICByZXRhaW5lZCA9IGZyb20uc2xpY2UoMCwga2VlcCk7XG4gICAgICAgIGV4aXRpbmcgPSBmcm9tLnNsaWNlKGtlZXApO1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgcmV0YWluZWQgcGF0aCAod2l0aCBzaGFsbG93IGNvcGllcyBvZiBub2Rlcykgd2hpY2ggaGF2ZSB0aGUgcGFyYW1zIG9mIHRoZSB0b1BhdGggbWFwcGVkXG4gICAgICAgIHZhciByZXRhaW5lZFdpdGhUb1BhcmFtcyA9IHJldGFpbmVkLm1hcChhcHBseVRvUGFyYW1zKTtcbiAgICAgICAgZW50ZXJpbmcgPSB0b1BhdGguc2xpY2Uoa2VlcCk7XG4gICAgICAgIHRvID0gKHJldGFpbmVkV2l0aFRvUGFyYW1zKS5jb25jYXQoZW50ZXJpbmcpO1xuICAgICAgICByZXR1cm4geyBmcm9tOiBmcm9tLCB0bzogdG8sIHJldGFpbmVkOiByZXRhaW5lZCwgZXhpdGluZzogZXhpdGluZywgZW50ZXJpbmc6IGVudGVyaW5nIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHBhdGggd2hpY2ggaXM6IHRoZSBzdWJwYXRoIG9mIHRoZSBmaXJzdCBwYXRoIHdoaWNoIG1hdGNoZXMgdGhlIHNlY29uZCBwYXRoLlxuICAgICAqXG4gICAgICogVGhlIG5ldyBwYXRoIHN0YXJ0cyBmcm9tIHJvb3QgYW5kIGNvbnRhaW5zIGFueSBub2RlcyB0aGF0IG1hdGNoIHRoZSBub2RlcyBpbiB0aGUgc2Vjb25kIHBhdGguXG4gICAgICogSXQgc3RvcHMgYmVmb3JlIHRoZSBmaXJzdCBub24tbWF0Y2hpbmcgbm9kZS5cbiAgICAgKlxuICAgICAqIE5vZGVzIGFyZSBjb21wYXJlZCB1c2luZyB0aGVpciBzdGF0ZSBwcm9wZXJ0eSBhbmQgdGhlaXIgcGFyYW1ldGVyIHZhbHVlcy5cbiAgICAgKiBJZiBhIGBwYXJhbXNGbmAgaXMgcHJvdmlkZWQsIG9ubHkgdGhlIFtbUGFyYW1dXSByZXR1cm5lZCBieSB0aGUgZnVuY3Rpb24gd2lsbCBiZSBjb25zaWRlcmVkIHdoZW4gY29tcGFyaW5nIG5vZGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGhBIHRoZSBmaXJzdCBwYXRoXG4gICAgICogQHBhcmFtIHBhdGhCIHRoZSBzZWNvbmQgcGF0aFxuICAgICAqIEBwYXJhbSBwYXJhbXNGbiBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlIHBhcmFtZXRlcnMgdG8gY29uc2lkZXIgd2hlbiBjb21wYXJpbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIFBhdGhOb2RlcyBmcm9tIHRoZSBmaXJzdCBwYXRoIHdoaWNoIG1hdGNoIHRoZSBub2RlcyBpbiB0aGUgc2Vjb25kIHBhdGhcbiAgICAgKi9cbiAgICBQYXRoVXRpbHMubWF0Y2hpbmcgPSBmdW5jdGlvbiAocGF0aEEsIHBhdGhCLCBwYXJhbXNGbikge1xuICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgICB2YXIgdHVwbGVzID0gY29tbW9uXzEuYXJyYXlUdXBsZXMocGF0aEEsIHBhdGhCKTtcbiAgICAgICAgcmV0dXJuIHR1cGxlcy5yZWR1Y2UoZnVuY3Rpb24gKG1hdGNoaW5nLCBfYSkge1xuICAgICAgICAgICAgdmFyIG5vZGVBID0gX2FbMF0sIG5vZGVCID0gX2FbMV07XG4gICAgICAgICAgICBkb25lID0gZG9uZSB8fCAhbm9kZUEuZXF1YWxzKG5vZGVCLCBwYXJhbXNGbik7XG4gICAgICAgICAgICByZXR1cm4gZG9uZSA/IG1hdGNoaW5nIDogbWF0Y2hpbmcuY29uY2F0KG5vZGVBKTtcbiAgICAgICAgfSwgW10pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHR3byBwYXRocyBhcmUgaWRlbnRpY2FsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGhBXG4gICAgICogQHBhcmFtIHBhdGhCXG4gICAgICogQHBhcmFtIHBhcmFtc0ZuIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGUgcGFyYW1ldGVycyB0byBjb25zaWRlciB3aGVuIGNvbXBhcmluZ1xuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHRoZSBzdGF0ZXMgYW5kIHBhcmFtZXRlciB2YWx1ZXMgZm9yIGJvdGggcGF0aHMgYXJlIGlkZW50aWNhbFxuICAgICAqL1xuICAgIFBhdGhVdGlscy5lcXVhbHMgPSBmdW5jdGlvbiAocGF0aEEsIHBhdGhCLCBwYXJhbXNGbikge1xuICAgICAgICByZXR1cm4gcGF0aEEubGVuZ3RoID09PSBwYXRoQi5sZW5ndGggJiZcbiAgICAgICAgICAgIFBhdGhVdGlscy5tYXRjaGluZyhwYXRoQSwgcGF0aEIsIHBhcmFtc0ZuKS5sZW5ndGggPT09IHBhdGhBLmxlbmd0aDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHN1YnBhdGggb2YgYSBwYXRoLCB3aGljaCBzdG9wcyBhdCB0aGUgZmlyc3QgbWF0Y2hpbmcgbm9kZVxuICAgICAqXG4gICAgICogR2l2ZW4gYW4gYXJyYXkgb2Ygbm9kZXMsIHJldHVybnMgYSBzdWJzZXQgb2YgdGhlIGFycmF5IHN0YXJ0aW5nIGZyb20gdGhlIGZpcnN0IG5vZGUsXG4gICAgICogc3RvcHBpbmcgd2hlbiB0aGUgZmlyc3Qgbm9kZSBtYXRjaGVzIHRoZSBwcmVkaWNhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCBhIHBhdGggb2YgW1tQYXRoTm9kZV1dc1xuICAgICAqIEBwYXJhbSBwcmVkaWNhdGUgYSBbW1ByZWRpY2F0ZV1dIGZuIHRoYXQgbWF0Y2hlcyBbW1BhdGhOb2RlXV1zXG4gICAgICogQHJldHVybnMgYSBzdWJwYXRoIHVwIHRvIHRoZSBtYXRjaGluZyBub2RlLCBvciB1bmRlZmluZWQgaWYgbm8gbWF0Y2ggaXMgZm91bmRcbiAgICAgKi9cbiAgICBQYXRoVXRpbHMuc3ViUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBjb21tb25fMS5maW5kKHBhdGgsIHByZWRpY2F0ZSk7XG4gICAgICAgIHZhciBlbGVtZW50SWR4ID0gcGF0aC5pbmRleE9mKG5vZGUpO1xuICAgICAgICByZXR1cm4gZWxlbWVudElkeCA9PT0gLTEgPyB1bmRlZmluZWQgOiBwYXRoLnNsaWNlKDAsIGVsZW1lbnRJZHggKyAxKTtcbiAgICB9O1xuICAgIFBhdGhVdGlscy5ub25EeW5hbWljUGFyYW1zID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuc3RhdGUucGFyYW1ldGVycyh7IGluaGVyaXQ6IGZhbHNlIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gIXBhcmFtLmR5bmFtaWM7IH0pO1xuICAgIH07XG4gICAgLyoqIEdldHMgdGhlIHJhdyBwYXJhbWV0ZXIgdmFsdWVzIGZyb20gYSBwYXRoICovXG4gICAgUGF0aFV0aWxzLnBhcmFtVmFsdWVzID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGgucmVkdWNlKGZ1bmN0aW9uIChhY2MsIG5vZGUpIHsgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZChhY2MsIG5vZGUucGFyYW1WYWx1ZXMpOyB9LCB7fSk7XG4gICAgfTtcbiAgICByZXR1cm4gUGF0aFV0aWxzO1xufSgpKTtcbmV4cG9ydHMuUGF0aFV0aWxzID0gUGF0aFV0aWxzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0aEZhY3RvcnkuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9wYXRoL3BhdGhGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///16\n')},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module resolve */\n/** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar hof_1 = __webpack_require__(/*! ../common/hof */ 2);\nvar trace_1 = __webpack_require__(/*! ../common/trace */ 7);\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ 3);\nvar interface_1 = __webpack_require__(/*! ./interface */ 32);\nvar resolvable_1 = __webpack_require__(/*! ./resolvable */ 11);\nvar pathFactory_1 = __webpack_require__(/*! ../path/pathFactory */ 16);\nvar strings_1 = __webpack_require__(/*! ../common/strings */ 6);\nvar common_2 = __webpack_require__(/*! ../common */ 5);\nvar whens = interface_1.resolvePolicies.when;\nvar ALL_WHENS = [whens.EAGER, whens.LAZY];\nvar EAGER_WHENS = [whens.EAGER];\nexports.NATIVE_INJECTOR_TOKEN = \"Native Injector\";\n/**\n * Encapsulates Dependency Injection for a path of nodes\n *\n * UI-Router states are organized as a tree.\n * A nested state has a path of ancestors to the root of the tree.\n * When a state is being activated, each element in the path is wrapped as a [[PathNode]].\n * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.\n *\n * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.\n */\nvar ResolveContext = /** @class */ (function () {\n    function ResolveContext(_path) {\n        this._path = _path;\n    }\n    /** Gets all the tokens found in the resolve context, de-duplicated */\n    ResolveContext.prototype.getTokens = function () {\n        return this._path.reduce(function (acc, node) { return acc.concat(node.resolvables.map(function (r) { return r.token; })); }, []).reduce(common_1.uniqR, []);\n    };\n    /**\n     * Gets the Resolvable that matches the token\n     *\n     * Gets the last Resolvable that matches the token in this context, or undefined.\n     * Throws an error if it doesn't exist in the ResolveContext\n     */\n    ResolveContext.prototype.getResolvable = function (token) {\n        var matching = this._path.map(function (node) { return node.resolvables; })\n            .reduce(common_1.unnestR, [])\n            .filter(function (r) { return r.token === token; });\n        return common_1.tail(matching);\n    };\n    /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */\n    ResolveContext.prototype.getPolicy = function (resolvable) {\n        var node = this.findNode(resolvable);\n        return resolvable.getPolicy(node.state);\n    };\n    /**\n     * Returns a ResolveContext that includes a portion of this one\n     *\n     * Given a state, this method creates a new ResolveContext from this one.\n     * The new context starts at the first node (root) and stops at the node for the `state` parameter.\n     *\n     * #### Why\n     *\n     * When a transition is created, the nodes in the \"To Path\" are injected from a ResolveContext.\n     * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.\n     * The \"To State\" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).\n     * This method is used to create a narrower context when injecting ancestor nodes.\n     *\n     * @example\n     * `let ABCD = new ResolveContext([A, B, C, D]);`\n     *\n     * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:\n     * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.\n     * However, `B` should only be able to access resolvables from `A`, `B`.\n     *\n     * When resolving for the `B` node, first take the full \"To Path\" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.\n     * `let AB = ABCD.subcontext(a)`\n     */\n    ResolveContext.prototype.subContext = function (state) {\n        return new ResolveContext(pathFactory_1.PathUtils.subPath(this._path, function (node) { return node.state === state; }));\n    };\n    /**\n     * Adds Resolvables to the node that matches the state\n     *\n     * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).\n     * The resolvable is added to the node matching the `state` parameter.\n     *\n     * These new resolvables are not automatically fetched.\n     * The calling code should either fetch them, fetch something that depends on them,\n     * or rely on [[resolvePath]] being called when some state is being entered.\n     *\n     * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.\n     *\n     * @param newResolvables the new Resolvables\n     * @param state Used to find the node to put the resolvable on\n     */\n    ResolveContext.prototype.addResolvables = function (newResolvables, state) {\n        var node = common_1.find(this._path, hof_1.propEq('state', state));\n        var keys = newResolvables.map(function (r) { return r.token; });\n        node.resolvables = node.resolvables.filter(function (r) { return keys.indexOf(r.token) === -1; }).concat(newResolvables);\n    };\n    /**\n     * Returns a promise for an array of resolved path Element promises\n     *\n     * @param when\n     * @param trans\n     * @returns {Promise<any>|any}\n     */\n    ResolveContext.prototype.resolvePath = function (when, trans) {\n        var _this = this;\n        if (when === void 0) { when = \"LAZY\"; }\n        // This option determines which 'when' policy Resolvables we are about to fetch.\n        var whenOption = common_1.inArray(ALL_WHENS, when) ? when : \"LAZY\";\n        // If the caller specified EAGER, only the EAGER Resolvables are fetched.\n        // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`\n        var matchedWhens = whenOption === interface_1.resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;\n        // get the subpath to the state argument, if provided\n        trace_1.trace.traceResolvePath(this._path, when, trans);\n        var matchesPolicy = function (acceptedVals, whenOrAsync) {\n            return function (resolvable) {\n                return common_1.inArray(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync]);\n            };\n        };\n        // Trigger all the (matching) Resolvables in the path\n        // Reduce all the \"WAIT\" Resolvables into an array\n        var promises = this._path.reduce(function (acc, node) {\n            var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));\n            var nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));\n            var wait = nodeResolvables.filter(hof_1.not(matchesPolicy(['NOWAIT'], 'async')));\n            // For the matching Resolvables, start their async fetch process.\n            var subContext = _this.subContext(node.state);\n            var getResult = function (r) { return r.get(subContext, trans)\n                .then(function (value) { return ({ token: r.token, value: value }); }); };\n            nowait.forEach(getResult);\n            return acc.concat(wait.map(getResult));\n        }, []);\n        // Wait for all the \"WAIT\" resolvables\n        return coreservices_1.services.$q.all(promises);\n    };\n    ResolveContext.prototype.injector = function () {\n        return this._injector || (this._injector = new UIInjectorImpl(this));\n    };\n    ResolveContext.prototype.findNode = function (resolvable) {\n        return common_1.find(this._path, function (node) { return common_1.inArray(node.resolvables, resolvable); });\n    };\n    /**\n     * Gets the async dependencies of a Resolvable\n     *\n     * Given a Resolvable, returns its dependencies as a Resolvable[]\n     */\n    ResolveContext.prototype.getDependencies = function (resolvable) {\n        var _this = this;\n        var node = this.findNode(resolvable);\n        // Find which other resolvables are \"visible\" to the `resolvable` argument\n        // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)\n        var subPath = pathFactory_1.PathUtils.subPath(this._path, function (x) { return x === node; }) || this._path;\n        var availableResolvables = subPath\n            .reduce(function (acc, _node) { return acc.concat(_node.resolvables); }, []) //all of subpath's resolvables\n            .filter(function (res) { return res !== resolvable; }); // filter out the `resolvable` argument\n        var getDependency = function (token) {\n            var matching = availableResolvables.filter(function (r) { return r.token === token; });\n            if (matching.length)\n                return common_1.tail(matching);\n            var fromInjector = _this.injector().getNative(token);\n            if (common_2.isUndefined(fromInjector)) {\n                throw new Error(\"Could not find Dependency Injection token: \" + strings_1.stringify(token));\n            }\n            return new resolvable_1.Resolvable(token, function () { return fromInjector; }, [], fromInjector);\n        };\n        return resolvable.deps.map(getDependency);\n    };\n    return ResolveContext;\n}());\nexports.ResolveContext = ResolveContext;\nvar UIInjectorImpl = /** @class */ (function () {\n    function UIInjectorImpl(context) {\n        this.context = context;\n        this.native = this.get(exports.NATIVE_INJECTOR_TOKEN) || coreservices_1.services.$injector;\n    }\n    UIInjectorImpl.prototype.get = function (token) {\n        var resolvable = this.context.getResolvable(token);\n        if (resolvable) {\n            if (this.context.getPolicy(resolvable).async === 'NOWAIT') {\n                return resolvable.get(this.context);\n            }\n            if (!resolvable.resolved) {\n                throw new Error(\"Resolvable async .get() not complete:\" + strings_1.stringify(resolvable.token));\n            }\n            return resolvable.data;\n        }\n        return this.getNative(token);\n    };\n    UIInjectorImpl.prototype.getAsync = function (token) {\n        var resolvable = this.context.getResolvable(token);\n        if (resolvable)\n            return resolvable.get(this.context);\n        return coreservices_1.services.$q.when(this.native.get(token));\n    };\n    UIInjectorImpl.prototype.getNative = function (token) {\n        return this.native && this.native.get(token);\n    };\n    return UIInjectorImpl;\n}());\n//# sourceMappingURL=resolveContext.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9yZXNvbHZlL3Jlc29sdmVDb250ZXh0LmpzPzJhZTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogQG1vZHVsZSByZXNvbHZlICovXG4vKiogZm9yIHR5cGVkb2MgKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG52YXIgdHJhY2VfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vdHJhY2VcIik7XG52YXIgY29yZXNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvcmVzZXJ2aWNlc1wiKTtcbnZhciBpbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL2ludGVyZmFjZVwiKTtcbnZhciByZXNvbHZhYmxlXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZhYmxlXCIpO1xudmFyIHBhdGhGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi4vcGF0aC9wYXRoRmFjdG9yeVwiKTtcbnZhciBzdHJpbmdzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3N0cmluZ3NcIik7XG52YXIgY29tbW9uXzIgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xudmFyIHdoZW5zID0gaW50ZXJmYWNlXzEucmVzb2x2ZVBvbGljaWVzLndoZW47XG52YXIgQUxMX1dIRU5TID0gW3doZW5zLkVBR0VSLCB3aGVucy5MQVpZXTtcbnZhciBFQUdFUl9XSEVOUyA9IFt3aGVucy5FQUdFUl07XG5leHBvcnRzLk5BVElWRV9JTkpFQ1RPUl9UT0tFTiA9IFwiTmF0aXZlIEluamVjdG9yXCI7XG4vKipcbiAqIEVuY2Fwc3VsYXRlcyBEZXBlbmRlbmN5IEluamVjdGlvbiBmb3IgYSBwYXRoIG9mIG5vZGVzXG4gKlxuICogVUktUm91dGVyIHN0YXRlcyBhcmUgb3JnYW5pemVkIGFzIGEgdHJlZS5cbiAqIEEgbmVzdGVkIHN0YXRlIGhhcyBhIHBhdGggb2YgYW5jZXN0b3JzIHRvIHRoZSByb290IG9mIHRoZSB0cmVlLlxuICogV2hlbiBhIHN0YXRlIGlzIGJlaW5nIGFjdGl2YXRlZCwgZWFjaCBlbGVtZW50IGluIHRoZSBwYXRoIGlzIHdyYXBwZWQgYXMgYSBbW1BhdGhOb2RlXV0uXG4gKiBBIGBQYXRoTm9kZWAgaXMgYSBzdGF0ZWZ1bCBvYmplY3QgdGhhdCBob2xkcyB0aGluZ3MgbGlrZSBwYXJhbWV0ZXJzIGFuZCByZXNvbHZhYmxlcyBmb3IgdGhlIHN0YXRlIGJlaW5nIGFjdGl2YXRlZC5cbiAqXG4gKiBUaGUgUmVzb2x2ZUNvbnRleHQgY2xvc2VzIG92ZXIgdGhlIFtbUGF0aE5vZGVdXXMsIGFuZCBwcm92aWRlcyBESSBmb3IgdGhlIGxhc3Qgbm9kZSBpbiB0aGUgcGF0aC5cbiAqL1xudmFyIFJlc29sdmVDb250ZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc29sdmVDb250ZXh0KF9wYXRoKSB7XG4gICAgICAgIHRoaXMuX3BhdGggPSBfcGF0aDtcbiAgICB9XG4gICAgLyoqIEdldHMgYWxsIHRoZSB0b2tlbnMgZm91bmQgaW4gdGhlIHJlc29sdmUgY29udGV4dCwgZGUtZHVwbGljYXRlZCAqL1xuICAgIFJlc29sdmVDb250ZXh0LnByb3RvdHlwZS5nZXRUb2tlbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXRoLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBub2RlKSB7IHJldHVybiBhY2MuY29uY2F0KG5vZGUucmVzb2x2YWJsZXMubWFwKGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnRva2VuOyB9KSk7IH0sIFtdKS5yZWR1Y2UoY29tbW9uXzEudW5pcVIsIFtdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFJlc29sdmFibGUgdGhhdCBtYXRjaGVzIHRoZSB0b2tlblxuICAgICAqXG4gICAgICogR2V0cyB0aGUgbGFzdCBSZXNvbHZhYmxlIHRoYXQgbWF0Y2hlcyB0aGUgdG9rZW4gaW4gdGhpcyBjb250ZXh0LCBvciB1bmRlZmluZWQuXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIGl0IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIFJlc29sdmVDb250ZXh0XG4gICAgICovXG4gICAgUmVzb2x2ZUNvbnRleHQucHJvdG90eXBlLmdldFJlc29sdmFibGUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdmFyIG1hdGNoaW5nID0gdGhpcy5fcGF0aC5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUucmVzb2x2YWJsZXM7IH0pXG4gICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gci50b2tlbiA9PT0gdG9rZW47IH0pO1xuICAgICAgICByZXR1cm4gY29tbW9uXzEudGFpbChtYXRjaGluZyk7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyB0aGUgW1tSZXNvbHZlUG9saWN5XV0gZm9yIHRoZSBnaXZlbiBbW1Jlc29sdmFibGVdXSAqL1xuICAgIFJlc29sdmVDb250ZXh0LnByb3RvdHlwZS5nZXRQb2xpY3kgPSBmdW5jdGlvbiAocmVzb2x2YWJsZSkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZmluZE5vZGUocmVzb2x2YWJsZSk7XG4gICAgICAgIHJldHVybiByZXNvbHZhYmxlLmdldFBvbGljeShub2RlLnN0YXRlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBSZXNvbHZlQ29udGV4dCB0aGF0IGluY2x1ZGVzIGEgcG9ydGlvbiBvZiB0aGlzIG9uZVxuICAgICAqXG4gICAgICogR2l2ZW4gYSBzdGF0ZSwgdGhpcyBtZXRob2QgY3JlYXRlcyBhIG5ldyBSZXNvbHZlQ29udGV4dCBmcm9tIHRoaXMgb25lLlxuICAgICAqIFRoZSBuZXcgY29udGV4dCBzdGFydHMgYXQgdGhlIGZpcnN0IG5vZGUgKHJvb3QpIGFuZCBzdG9wcyBhdCB0aGUgbm9kZSBmb3IgdGhlIGBzdGF0ZWAgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogIyMjIyBXaHlcbiAgICAgKlxuICAgICAqIFdoZW4gYSB0cmFuc2l0aW9uIGlzIGNyZWF0ZWQsIHRoZSBub2RlcyBpbiB0aGUgXCJUbyBQYXRoXCIgYXJlIGluamVjdGVkIGZyb20gYSBSZXNvbHZlQ29udGV4dC5cbiAgICAgKiBBIFJlc29sdmVDb250ZXh0IGNsb3NlcyBvdmVyIGEgcGF0aCBvZiBbW1BhdGhOb2RlXV1zIGFuZCBwcm9jZXNzZXMgdGhlIHJlc29sdmFibGVzLlxuICAgICAqIFRoZSBcIlRvIFN0YXRlXCIgY2FuIGluamVjdCB2YWx1ZXMgZnJvbSBpdHMgb3duIHJlc29sdmFibGVzLCBhcyB3ZWxsIGFzIHRob3NlIGZyb20gYWxsIGl0cyBhbmNlc3RvciBzdGF0ZSdzIChub2RlJ3MpLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gY3JlYXRlIGEgbmFycm93ZXIgY29udGV4dCB3aGVuIGluamVjdGluZyBhbmNlc3RvciBub2Rlcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGxldCBBQkNEID0gbmV3IFJlc29sdmVDb250ZXh0KFtBLCBCLCBDLCBEXSk7YFxuICAgICAqXG4gICAgICogR2l2ZW4gYSBwYXRoIGBbQSwgQiwgQywgRF1gLCB3aGVyZSBgQWAsIGBCYCwgYENgIGFuZCBgRGAgYXJlIG5vZGVzIGZvciBzdGF0ZXMgYGFgLCBgYmAsIGBjYCwgYGRgOlxuICAgICAqIFdoZW4gaW5qZWN0aW5nIGBEYCwgYERgIHNob3VsZCBoYXZlIGFjY2VzcyB0byBhbGwgcmVzb2x2YWJsZXMgZnJvbSBgQWAsIGBCYCwgYENgLCBgRGAuXG4gICAgICogSG93ZXZlciwgYEJgIHNob3VsZCBvbmx5IGJlIGFibGUgdG8gYWNjZXNzIHJlc29sdmFibGVzIGZyb20gYEFgLCBgQmAuXG4gICAgICpcbiAgICAgKiBXaGVuIHJlc29sdmluZyBmb3IgdGhlIGBCYCBub2RlLCBmaXJzdCB0YWtlIHRoZSBmdWxsIFwiVG8gUGF0aFwiIENvbnRleHQgYFtBLEIsQyxEXWAgYW5kIGxpbWl0IHRvIHRoZSBzdWJwYXRoIGBbQSxCXWAuXG4gICAgICogYGxldCBBQiA9IEFCQ0Quc3ViY29udGV4dChhKWBcbiAgICAgKi9cbiAgICBSZXNvbHZlQ29udGV4dC5wcm90b3R5cGUuc3ViQ29udGV4dCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVDb250ZXh0KHBhdGhGYWN0b3J5XzEuUGF0aFV0aWxzLnN1YlBhdGgodGhpcy5fcGF0aCwgZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUuc3RhdGUgPT09IHN0YXRlOyB9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIFJlc29sdmFibGVzIHRvIHRoZSBub2RlIHRoYXQgbWF0Y2hlcyB0aGUgc3RhdGVcbiAgICAgKlxuICAgICAqIFRoaXMgYWRkcyBhIFtbUmVzb2x2YWJsZV1dIChnZW5lcmFsbHkgb25lIGNyZWF0ZWQgb24gdGhlIGZseTsgbm90IGRlY2xhcmVkIG9uIGEgW1tTdGF0ZURlY2xhcmF0aW9uLnJlc29sdmVdXSBibG9jaykuXG4gICAgICogVGhlIHJlc29sdmFibGUgaXMgYWRkZWQgdG8gdGhlIG5vZGUgbWF0Y2hpbmcgdGhlIGBzdGF0ZWAgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogVGhlc2UgbmV3IHJlc29sdmFibGVzIGFyZSBub3QgYXV0b21hdGljYWxseSBmZXRjaGVkLlxuICAgICAqIFRoZSBjYWxsaW5nIGNvZGUgc2hvdWxkIGVpdGhlciBmZXRjaCB0aGVtLCBmZXRjaCBzb21ldGhpbmcgdGhhdCBkZXBlbmRzIG9uIHRoZW0sXG4gICAgICogb3IgcmVseSBvbiBbW3Jlc29sdmVQYXRoXV0gYmVpbmcgY2FsbGVkIHdoZW4gc29tZSBzdGF0ZSBpcyBiZWluZyBlbnRlcmVkLlxuICAgICAqXG4gICAgICogTm90ZTogZWFjaCByZXNvbHZhYmxlJ3MgW1tSZXNvbHZlUG9saWN5XV0gaXMgbWVyZ2VkIHdpdGggdGhlIHN0YXRlJ3MgcG9saWN5LCBhbmQgdGhlIGdsb2JhbCBkZWZhdWx0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld1Jlc29sdmFibGVzIHRoZSBuZXcgUmVzb2x2YWJsZXNcbiAgICAgKiBAcGFyYW0gc3RhdGUgVXNlZCB0byBmaW5kIHRoZSBub2RlIHRvIHB1dCB0aGUgcmVzb2x2YWJsZSBvblxuICAgICAqL1xuICAgIFJlc29sdmVDb250ZXh0LnByb3RvdHlwZS5hZGRSZXNvbHZhYmxlcyA9IGZ1bmN0aW9uIChuZXdSZXNvbHZhYmxlcywgc3RhdGUpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBjb21tb25fMS5maW5kKHRoaXMuX3BhdGgsIGhvZl8xLnByb3BFcSgnc3RhdGUnLCBzdGF0ZSkpO1xuICAgICAgICB2YXIga2V5cyA9IG5ld1Jlc29sdmFibGVzLm1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gci50b2tlbjsgfSk7XG4gICAgICAgIG5vZGUucmVzb2x2YWJsZXMgPSBub2RlLnJlc29sdmFibGVzLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4ga2V5cy5pbmRleE9mKHIudG9rZW4pID09PSAtMTsgfSkuY29uY2F0KG5ld1Jlc29sdmFibGVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIGZvciBhbiBhcnJheSBvZiByZXNvbHZlZCBwYXRoIEVsZW1lbnQgcHJvbWlzZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aGVuXG4gICAgICogQHBhcmFtIHRyYW5zXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pnxhbnl9XG4gICAgICovXG4gICAgUmVzb2x2ZUNvbnRleHQucHJvdG90eXBlLnJlc29sdmVQYXRoID0gZnVuY3Rpb24gKHdoZW4sIHRyYW5zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh3aGVuID09PSB2b2lkIDApIHsgd2hlbiA9IFwiTEFaWVwiOyB9XG4gICAgICAgIC8vIFRoaXMgb3B0aW9uIGRldGVybWluZXMgd2hpY2ggJ3doZW4nIHBvbGljeSBSZXNvbHZhYmxlcyB3ZSBhcmUgYWJvdXQgdG8gZmV0Y2guXG4gICAgICAgIHZhciB3aGVuT3B0aW9uID0gY29tbW9uXzEuaW5BcnJheShBTExfV0hFTlMsIHdoZW4pID8gd2hlbiA6IFwiTEFaWVwiO1xuICAgICAgICAvLyBJZiB0aGUgY2FsbGVyIHNwZWNpZmllZCBFQUdFUiwgb25seSB0aGUgRUFHRVIgUmVzb2x2YWJsZXMgYXJlIGZldGNoZWQuXG4gICAgICAgIC8vIGlmIHRoZSBjYWxsZXIgc3BlY2lmaWVkIExBWlksIGJvdGggRUFHRVIgYW5kIExBWlkgUmVzb2x2YWJsZXMgYXJlIGZldGNoZWQuYFxuICAgICAgICB2YXIgbWF0Y2hlZFdoZW5zID0gd2hlbk9wdGlvbiA9PT0gaW50ZXJmYWNlXzEucmVzb2x2ZVBvbGljaWVzLndoZW4uRUFHRVIgPyBFQUdFUl9XSEVOUyA6IEFMTF9XSEVOUztcbiAgICAgICAgLy8gZ2V0IHRoZSBzdWJwYXRoIHRvIHRoZSBzdGF0ZSBhcmd1bWVudCwgaWYgcHJvdmlkZWRcbiAgICAgICAgdHJhY2VfMS50cmFjZS50cmFjZVJlc29sdmVQYXRoKHRoaXMuX3BhdGgsIHdoZW4sIHRyYW5zKTtcbiAgICAgICAgdmFyIG1hdGNoZXNQb2xpY3kgPSBmdW5jdGlvbiAoYWNjZXB0ZWRWYWxzLCB3aGVuT3JBc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZXNvbHZhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmluQXJyYXkoYWNjZXB0ZWRWYWxzLCBfdGhpcy5nZXRQb2xpY3kocmVzb2x2YWJsZSlbd2hlbk9yQXN5bmNdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRyaWdnZXIgYWxsIHRoZSAobWF0Y2hpbmcpIFJlc29sdmFibGVzIGluIHRoZSBwYXRoXG4gICAgICAgIC8vIFJlZHVjZSBhbGwgdGhlIFwiV0FJVFwiIFJlc29sdmFibGVzIGludG8gYW4gYXJyYXlcbiAgICAgICAgdmFyIHByb21pc2VzID0gdGhpcy5fcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgbm9kZSkge1xuICAgICAgICAgICAgdmFyIG5vZGVSZXNvbHZhYmxlcyA9IG5vZGUucmVzb2x2YWJsZXMuZmlsdGVyKG1hdGNoZXNQb2xpY3kobWF0Y2hlZFdoZW5zLCAnd2hlbicpKTtcbiAgICAgICAgICAgIHZhciBub3dhaXQgPSBub2RlUmVzb2x2YWJsZXMuZmlsdGVyKG1hdGNoZXNQb2xpY3koWydOT1dBSVQnXSwgJ2FzeW5jJykpO1xuICAgICAgICAgICAgdmFyIHdhaXQgPSBub2RlUmVzb2x2YWJsZXMuZmlsdGVyKGhvZl8xLm5vdChtYXRjaGVzUG9saWN5KFsnTk9XQUlUJ10sICdhc3luYycpKSk7XG4gICAgICAgICAgICAvLyBGb3IgdGhlIG1hdGNoaW5nIFJlc29sdmFibGVzLCBzdGFydCB0aGVpciBhc3luYyBmZXRjaCBwcm9jZXNzLlxuICAgICAgICAgICAgdmFyIHN1YkNvbnRleHQgPSBfdGhpcy5zdWJDb250ZXh0KG5vZGUuc3RhdGUpO1xuICAgICAgICAgICAgdmFyIGdldFJlc3VsdCA9IGZ1bmN0aW9uIChyKSB7IHJldHVybiByLmdldChzdWJDb250ZXh0LCB0cmFucylcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICh7IHRva2VuOiByLnRva2VuLCB2YWx1ZTogdmFsdWUgfSk7IH0pOyB9O1xuICAgICAgICAgICAgbm93YWl0LmZvckVhY2goZ2V0UmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiBhY2MuY29uY2F0KHdhaXQubWFwKGdldFJlc3VsdCkpO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIC8vIFdhaXQgZm9yIGFsbCB0aGUgXCJXQUlUXCIgcmVzb2x2YWJsZXNcbiAgICAgICAgcmV0dXJuIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLmFsbChwcm9taXNlcyk7XG4gICAgfTtcbiAgICBSZXNvbHZlQ29udGV4dC5wcm90b3R5cGUuaW5qZWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmplY3RvciB8fCAodGhpcy5faW5qZWN0b3IgPSBuZXcgVUlJbmplY3RvckltcGwodGhpcykpO1xuICAgIH07XG4gICAgUmVzb2x2ZUNvbnRleHQucHJvdG90eXBlLmZpbmROb2RlID0gZnVuY3Rpb24gKHJlc29sdmFibGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmZpbmQodGhpcy5fcGF0aCwgZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIGNvbW1vbl8xLmluQXJyYXkobm9kZS5yZXNvbHZhYmxlcywgcmVzb2x2YWJsZSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXN5bmMgZGVwZW5kZW5jaWVzIG9mIGEgUmVzb2x2YWJsZVxuICAgICAqXG4gICAgICogR2l2ZW4gYSBSZXNvbHZhYmxlLCByZXR1cm5zIGl0cyBkZXBlbmRlbmNpZXMgYXMgYSBSZXNvbHZhYmxlW11cbiAgICAgKi9cbiAgICBSZXNvbHZlQ29udGV4dC5wcm90b3R5cGUuZ2V0RGVwZW5kZW5jaWVzID0gZnVuY3Rpb24gKHJlc29sdmFibGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmZpbmROb2RlKHJlc29sdmFibGUpO1xuICAgICAgICAvLyBGaW5kIHdoaWNoIG90aGVyIHJlc29sdmFibGVzIGFyZSBcInZpc2libGVcIiB0byB0aGUgYHJlc29sdmFibGVgIGFyZ3VtZW50XG4gICAgICAgIC8vIHN1YnBhdGggc3RvcHBpbmcgYXQgcmVzb2x2YWJsZSdzIG5vZGUsIG9yIHRoZSB3aG9sZSBwYXRoIChpZiB0aGUgcmVzb2x2YWJsZSBpc24ndCBpbiB0aGUgcGF0aClcbiAgICAgICAgdmFyIHN1YlBhdGggPSBwYXRoRmFjdG9yeV8xLlBhdGhVdGlscy5zdWJQYXRoKHRoaXMuX3BhdGgsIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ID09PSBub2RlOyB9KSB8fCB0aGlzLl9wYXRoO1xuICAgICAgICB2YXIgYXZhaWxhYmxlUmVzb2x2YWJsZXMgPSBzdWJQYXRoXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhY2MsIF9ub2RlKSB7IHJldHVybiBhY2MuY29uY2F0KF9ub2RlLnJlc29sdmFibGVzKTsgfSwgW10pIC8vYWxsIG9mIHN1YnBhdGgncyByZXNvbHZhYmxlc1xuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXMgIT09IHJlc29sdmFibGU7IH0pOyAvLyBmaWx0ZXIgb3V0IHRoZSBgcmVzb2x2YWJsZWAgYXJndW1lbnRcbiAgICAgICAgdmFyIGdldERlcGVuZGVuY3kgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGluZyA9IGF2YWlsYWJsZVJlc29sdmFibGVzLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gci50b2tlbiA9PT0gdG9rZW47IH0pO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbW9uXzEudGFpbChtYXRjaGluZyk7XG4gICAgICAgICAgICB2YXIgZnJvbUluamVjdG9yID0gX3RoaXMuaW5qZWN0b3IoKS5nZXROYXRpdmUodG9rZW4pO1xuICAgICAgICAgICAgaWYgKGNvbW1vbl8yLmlzVW5kZWZpbmVkKGZyb21JbmplY3RvcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBEZXBlbmRlbmN5IEluamVjdGlvbiB0b2tlbjogXCIgKyBzdHJpbmdzXzEuc3RyaW5naWZ5KHRva2VuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKHRva2VuLCBmdW5jdGlvbiAoKSB7IHJldHVybiBmcm9tSW5qZWN0b3I7IH0sIFtdLCBmcm9tSW5qZWN0b3IpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVzb2x2YWJsZS5kZXBzLm1hcChnZXREZXBlbmRlbmN5KTtcbiAgICB9O1xuICAgIHJldHVybiBSZXNvbHZlQ29udGV4dDtcbn0oKSk7XG5leHBvcnRzLlJlc29sdmVDb250ZXh0ID0gUmVzb2x2ZUNvbnRleHQ7XG52YXIgVUlJbmplY3RvckltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVUlJbmplY3RvckltcGwoY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLm5hdGl2ZSA9IHRoaXMuZ2V0KGV4cG9ydHMuTkFUSVZFX0lOSkVDVE9SX1RPS0VOKSB8fCBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kaW5qZWN0b3I7XG4gICAgfVxuICAgIFVJSW5qZWN0b3JJbXBsLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdmFyIHJlc29sdmFibGUgPSB0aGlzLmNvbnRleHQuZ2V0UmVzb2x2YWJsZSh0b2tlbik7XG4gICAgICAgIGlmIChyZXNvbHZhYmxlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LmdldFBvbGljeShyZXNvbHZhYmxlKS5hc3luYyA9PT0gJ05PV0FJVCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2YWJsZS5nZXQodGhpcy5jb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzb2x2YWJsZS5yZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlc29sdmFibGUgYXN5bmMgLmdldCgpIG5vdCBjb21wbGV0ZTpcIiArIHN0cmluZ3NfMS5zdHJpbmdpZnkocmVzb2x2YWJsZS50b2tlbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmFibGUuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXROYXRpdmUodG9rZW4pO1xuICAgIH07XG4gICAgVUlJbmplY3RvckltcGwucHJvdG90eXBlLmdldEFzeW5jID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHZhciByZXNvbHZhYmxlID0gdGhpcy5jb250ZXh0LmdldFJlc29sdmFibGUodG9rZW4pO1xuICAgICAgICBpZiAocmVzb2x2YWJsZSlcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZhYmxlLmdldCh0aGlzLmNvbnRleHQpO1xuICAgICAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEud2hlbih0aGlzLm5hdGl2ZS5nZXQodG9rZW4pKTtcbiAgICB9O1xuICAgIFVJSW5qZWN0b3JJbXBsLnByb3RvdHlwZS5nZXROYXRpdmUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF0aXZlICYmIHRoaXMubmF0aXZlLmdldCh0b2tlbik7XG4gICAgfTtcbiAgICByZXR1cm4gVUlJbmplY3RvckltcGw7XG59KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZUNvbnRleHQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9yZXNvbHZlL3Jlc29sdmVDb250ZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///17\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module transition\n */\n/** for typedoc */\nvar trace_1 = __webpack_require__(/*! ../common/trace */ 7);\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ 3);\nvar strings_1 = __webpack_require__(/*! ../common/strings */ 6);\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ 1);\nvar hof_1 = __webpack_require__(/*! ../common/hof */ 2);\nvar interface_1 = __webpack_require__(/*! ./interface */ 10); // has or is using\nvar transitionHook_1 = __webpack_require__(/*! ./transitionHook */ 13);\nvar hookRegistry_1 = __webpack_require__(/*! ./hookRegistry */ 25);\nvar hookBuilder_1 = __webpack_require__(/*! ./hookBuilder */ 39);\nvar pathFactory_1 = __webpack_require__(/*! ../path/pathFactory */ 16);\nvar param_1 = __webpack_require__(/*! ../params/param */ 8);\nvar resolvable_1 = __webpack_require__(/*! ../resolve/resolvable */ 11);\nvar resolveContext_1 = __webpack_require__(/*! ../resolve/resolveContext */ 17);\n/** @hidden */\nvar stateSelf = hof_1.prop(\"self\");\n/**\n * Represents a transition between two states.\n *\n * When navigating to a state, we are transitioning **from** the current state **to** the new state.\n *\n * This object contains all contextual information about the to/from states, parameters, resolves.\n * It has information about all states being entered and exited as a result of the transition.\n */\nvar Transition = /** @class */ (function () {\n    /**\n     * Creates a new Transition object.\n     *\n     * If the target state is not valid, an error is thrown.\n     *\n     * @internalapi\n     *\n     * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`\n     *        encapsulates the \"from state\".\n     * @param targetState The target state and parameters being transitioned to (also, the transition options)\n     * @param router The [[UIRouter]] instance\n     */\n    function Transition(fromPath, targetState, router) {\n        var _this = this;\n        /** @hidden */\n        this._deferred = coreservices_1.services.$q.defer();\n        /**\n         * This promise is resolved or rejected based on the outcome of the Transition.\n         *\n         * When the transition is successful, the promise is resolved\n         * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error\n         */\n        this.promise = this._deferred.promise;\n        /** @hidden Holds the hook registration functions such as those passed to Transition.onStart() */\n        this._registeredHooks = {};\n        /** @hidden */\n        this._hookBuilder = new hookBuilder_1.HookBuilder(this);\n        /** Checks if this transition is currently active/running. */\n        this.isActive = function () {\n            return _this.router.globals.transition === _this;\n        };\n        this.router = router;\n        this._targetState = targetState;\n        if (!targetState.valid()) {\n            throw new Error(targetState.error());\n        }\n        // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.\n        this._options = common_1.extend({ current: hof_1.val(this) }, targetState.options());\n        this.$id = router.transitionService._transitionCount++;\n        var toPath = pathFactory_1.PathUtils.buildToPath(fromPath, targetState);\n        this._treeChanges = pathFactory_1.PathUtils.treeChanges(fromPath, toPath, this._options.reloadState);\n        this.createTransitionHookRegFns();\n        var onCreateHooks = this._hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.CREATE);\n        transitionHook_1.TransitionHook.invokeHooks(onCreateHooks, function () { return null; });\n        this.applyViewConfigs(router);\n    }\n    /** @hidden */\n    Transition.prototype.onBefore = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onStart = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onExit = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onRetain = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onEnter = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onFinish = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onSuccess = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onError = function (criteria, callback, options) { return; };\n    /** @hidden\n     * Creates the transition-level hook registration functions\n     * (which can then be used to register hooks)\n     */\n    Transition.prototype.createTransitionHookRegFns = function () {\n        var _this = this;\n        this.router.transitionService._pluginapi._getEvents()\n            .filter(function (type) { return type.hookPhase !== interface_1.TransitionHookPhase.CREATE; })\n            .forEach(function (type) { return hookRegistry_1.makeEvent(_this, _this.router.transitionService, type); });\n    };\n    /** @internalapi */\n    Transition.prototype.getHooks = function (hookName) {\n        return this._registeredHooks[hookName];\n    };\n    Transition.prototype.applyViewConfigs = function (router) {\n        var enteringStates = this._treeChanges.entering.map(function (node) { return node.state; });\n        pathFactory_1.PathUtils.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);\n    };\n    /**\n     * @internalapi\n     *\n     * @returns the internal from [State] object\n     */\n    Transition.prototype.$from = function () {\n        return common_1.tail(this._treeChanges.from).state;\n    };\n    /**\n     * @internalapi\n     *\n     * @returns the internal to [State] object\n     */\n    Transition.prototype.$to = function () {\n        return common_1.tail(this._treeChanges.to).state;\n    };\n    /**\n     * Returns the \"from state\"\n     *\n     * Returns the state that the transition is coming *from*.\n     *\n     * @returns The state declaration object for the Transition's (\"from state\").\n     */\n    Transition.prototype.from = function () {\n        return this.$from().self;\n    };\n    /**\n     * Returns the \"to state\"\n     *\n     * Returns the state that the transition is going *to*.\n     *\n     * @returns The state declaration object for the Transition's target state (\"to state\").\n     */\n    Transition.prototype.to = function () {\n        return this.$to().self;\n    };\n    /**\n     * Gets the Target State\n     *\n     * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.\n     *\n     * @returns the [[TargetState]] of this Transition\n     */\n    Transition.prototype.targetState = function () {\n        return this._targetState;\n    };\n    /**\n     * Determines whether two transitions are equivalent.\n     * @deprecated\n     */\n    Transition.prototype.is = function (compare) {\n        if (compare instanceof Transition) {\n            // TODO: Also compare parameters\n            return this.is({ to: compare.$to().name, from: compare.$from().name });\n        }\n        return !((compare.to && !hookRegistry_1.matchState(this.$to(), compare.to)) ||\n            (compare.from && !hookRegistry_1.matchState(this.$from(), compare.from)));\n    };\n    Transition.prototype.params = function (pathname) {\n        if (pathname === void 0) { pathname = \"to\"; }\n        return Object.freeze(this._treeChanges[pathname].map(hof_1.prop(\"paramValues\")).reduce(common_1.mergeR, {}));\n    };\n    /**\n     * Creates a [[UIInjector]] Dependency Injector\n     *\n     * Returns a Dependency Injector for the Transition's target state (to state).\n     * The injector provides resolve values which the target state has access to.\n     *\n     * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).\n     *\n     * #### Example:\n     * ```js\n     * .onEnter({ entering: 'myState' }, trans => {\n     *   var myResolveValue = trans.injector().get('myResolve');\n     *   // Inject a global service from the global/native injector (if it exists)\n     *   var MyService = trans.injector().get('MyService');\n     * })\n     * ```\n     *\n     * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.\n     * You can use [[UIInjector.getAsync]] to get a promise for the data.\n     * #### Example:\n     * ```js\n     * .onBefore({}, trans => {\n     *   return trans.injector().getAsync('myResolve').then(myResolveValue =>\n     *     return myResolveValue !== 'ABORT';\n     *   });\n     * });\n     * ```\n     *\n     * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.\n     * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.\n     * #### Example:\n     * ```js\n     * .onEnter({ to: 'foo.bar' }, trans => {\n     *   // returns result of `foo` state's `data` resolve\n     *   // even though `foo.bar` also has a `data` resolve\n     *   var fooData = trans.injector('foo').get('data');\n     * });\n     * ```\n     *\n     * If you need resolve data from the exiting states, pass `'from'` as `pathName`.\n     * The resolve data from the `from` path will be returned.\n     * #### Example:\n     * ```js\n     * .onExit({ exiting: 'foo.bar' }, trans => {\n     *   // Gets the resolve value of `data` from the exiting state.\n     *   var fooData = trans.injector(null, 'foo.bar').get('data');\n     * });\n     * ```\n     *\n     *\n     * @param state Limits the resolves provided to only the resolves the provided state has access to.\n     * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.\n     *\n     * @returns a [[UIInjector]]\n     */\n    Transition.prototype.injector = function (state, pathName) {\n        if (pathName === void 0) { pathName = \"to\"; }\n        var path = this._treeChanges[pathName];\n        if (state)\n            path = pathFactory_1.PathUtils.subPath(path, function (node) { return node.state === state || node.state.name === state; });\n        return new resolveContext_1.ResolveContext(path).injector();\n    };\n    /**\n     * Gets all available resolve tokens (keys)\n     *\n     * This method can be used in conjunction with [[injector]] to inspect the resolve values\n     * available to the Transition.\n     *\n     * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states\n     * in the Transition's [[TreeChanges.to]] path.\n     *\n     * #### Example:\n     * This example logs all resolve values\n     * ```js\n     * let tokens = trans.getResolveTokens();\n     * tokens.forEach(token => console.log(token + \" = \" + trans.injector().get(token)));\n     * ```\n     *\n     * #### Example:\n     * This example creates promises for each resolve value.\n     * This triggers fetches of resolves (if any have not yet been fetched).\n     * When all promises have all settled, it logs the resolve values.\n     * ```js\n     * let tokens = trans.getResolveTokens();\n     * let promise = tokens.map(token => trans.injector().getAsync(token));\n     * Promise.all(promises).then(values => console.log(\"Resolved values: \" + values));\n     * ```\n     *\n     * Note: Angular 1 users whould use `$q.all()`\n     *\n     * @param pathname resolve context's path name (e.g., `to` or `from`)\n     *\n     * @returns an array of resolve tokens (keys)\n     */\n    Transition.prototype.getResolveTokens = function (pathname) {\n        if (pathname === void 0) { pathname = \"to\"; }\n        return new resolveContext_1.ResolveContext(this._treeChanges[pathname]).getTokens();\n    };\n    /**\n     * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.\n     *\n     * #### Example:\n     * ```js\n     * transitionService.onBefore({}, transition => {\n     *   transition.addResolvable({\n     *     token: 'myResolve',\n     *     deps: ['MyService'],\n     *     resolveFn: myService => myService.getData()\n     *   });\n     * });\n     * ```\n     *\n     * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])\n     * @param state the state in the \"to path\" which should receive the new resolve (otherwise, the root state)\n     */\n    Transition.prototype.addResolvable = function (resolvable, state) {\n        if (state === void 0) { state = \"\"; }\n        resolvable = hof_1.is(resolvable_1.Resolvable)(resolvable) ? resolvable : new resolvable_1.Resolvable(resolvable);\n        var stateName = (typeof state === \"string\") ? state : state.name;\n        var topath = this._treeChanges.to;\n        var targetNode = common_1.find(topath, function (node) { return node.state.name === stateName; });\n        var resolveContext = new resolveContext_1.ResolveContext(topath);\n        resolveContext.addResolvables([resolvable], targetNode.state);\n    };\n    /**\n     * Gets the transition from which this transition was redirected.\n     *\n     * If the current transition is a redirect, this method returns the transition that was redirected.\n     *\n     * #### Example:\n     * ```js\n     * let transitionA = $state.go('A').transition\n     * transitionA.onStart({}, () => $state.target('B'));\n     * $transitions.onSuccess({ to: 'B' }, (trans) => {\n     *   trans.to().name === 'B'; // true\n     *   trans.redirectedFrom() === transitionA; // true\n     * });\n     * ```\n     *\n     * @returns The previous Transition, or null if this Transition is not the result of a redirection\n     */\n    Transition.prototype.redirectedFrom = function () {\n        return this._options.redirectedFrom || null;\n    };\n    /**\n     * Gets the original transition in a redirect chain\n     *\n     * A transition might belong to a long chain of multiple redirects.\n     * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.\n     *\n     * #### Example:\n     * ```js\n     * // states\n     * registry.register({ name: 'A', redirectTo: 'B' });\n     * registry.register({ name: 'B', redirectTo: 'C' });\n     * registry.register({ name: 'C', redirectTo: 'D' });\n     * registry.register({ name: 'D' });\n     *\n     * let transitionA = $state.go('A').transition\n     *\n     * $transitions.onSuccess({ to: 'D' }, (trans) => {\n     *   trans.to().name === 'D'; // true\n     *   trans.redirectedFrom().to().name === 'C'; // true\n     *   trans.originalTransition() === transitionA; // true\n     *   trans.originalTransition().to().name === 'A'; // true\n     * });\n     * ```\n     *\n     * @returns The original Transition that started a redirect chain\n     */\n    Transition.prototype.originalTransition = function () {\n        var rf = this.redirectedFrom();\n        return (rf && rf.originalTransition()) || this;\n    };\n    /**\n     * Get the transition options\n     *\n     * @returns the options for this Transition.\n     */\n    Transition.prototype.options = function () {\n        return this._options;\n    };\n    /**\n     * Gets the states being entered.\n     *\n     * @returns an array of states that will be entered during this transition.\n     */\n    Transition.prototype.entering = function () {\n        return common_1.map(this._treeChanges.entering, hof_1.prop('state')).map(stateSelf);\n    };\n    /**\n     * Gets the states being exited.\n     *\n     * @returns an array of states that will be exited during this transition.\n     */\n    Transition.prototype.exiting = function () {\n        return common_1.map(this._treeChanges.exiting, hof_1.prop('state')).map(stateSelf).reverse();\n    };\n    /**\n     * Gets the states being retained.\n     *\n     * @returns an array of states that are already entered from a previous Transition, that will not be\n     *    exited during this Transition\n     */\n    Transition.prototype.retained = function () {\n        return common_1.map(this._treeChanges.retained, hof_1.prop('state')).map(stateSelf);\n    };\n    /**\n     * Get the [[ViewConfig]]s associated with this Transition\n     *\n     * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.\n     * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., \"to\" or \"entering\").\n     *\n     * @param pathname the name of the path to fetch views for:\n     *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n     * @param state If provided, only returns the `ViewConfig`s for a single state in the path\n     *\n     * @returns a list of ViewConfig objects for the given path.\n     */\n    Transition.prototype.views = function (pathname, state) {\n        if (pathname === void 0) { pathname = \"entering\"; }\n        var path = this._treeChanges[pathname];\n        path = !state ? path : path.filter(hof_1.propEq('state', state));\n        return path.map(hof_1.prop(\"views\")).filter(common_1.identity).reduce(common_1.unnestR, []);\n    };\n    Transition.prototype.treeChanges = function (pathname) {\n        return pathname ? this._treeChanges[pathname] : this._treeChanges;\n    };\n    /**\n     * Creates a new transition that is a redirection of the current one.\n     *\n     * This transition can be returned from a [[TransitionService]] hook to\n     * redirect a transition to a new state and/or set of parameters.\n     *\n     * @internalapi\n     *\n     * @returns Returns a new [[Transition]] instance.\n     */\n    Transition.prototype.redirect = function (targetState) {\n        var redirects = 1, trans = this;\n        while ((trans = trans.redirectedFrom()) != null) {\n            if (++redirects > 20)\n                throw new Error(\"Too many consecutive Transition redirects (20+)\");\n        }\n        var redirectOpts = { redirectedFrom: this, source: \"redirect\" };\n        // If the original transition was caused by URL sync, then use { location: 'replace' }\n        // on the new transition (unless the target state explicitly specifies location: false).\n        // This causes the original url to be replaced with the url for the redirect target\n        // so the original url disappears from the browser history.\n        if (this.options().source === 'url' && targetState.options().location !== false) {\n            redirectOpts.location = 'replace';\n        }\n        var newOptions = common_1.extend({}, this.options(), targetState.options(), redirectOpts);\n        targetState = targetState.withOptions(newOptions, true);\n        var newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);\n        var originalEnteringNodes = this._treeChanges.entering;\n        var redirectEnteringNodes = newTransition._treeChanges.entering;\n        // --- Re-use resolve data from original transition ---\n        // When redirecting from a parent state to a child state where the parent parameter values haven't changed\n        // (because of the redirect), the resolves fetched by the original transition are still valid in the\n        // redirected transition.\n        //\n        // This allows you to define a redirect on a parent state which depends on an async resolve value.\n        // You can wait for the resolve, then redirect to a child state based on the result.\n        // The redirected transition does not have to re-fetch the resolve.\n        // ---------------------------------------------------------\n        var nodeIsReloading = function (reloadState) { return function (node) {\n            return reloadState && node.state.includes[reloadState.name];\n        }; };\n        // Find any \"entering\" nodes in the redirect path that match the original path and aren't being reloaded\n        var matchingEnteringNodes = pathFactory_1.PathUtils.matching(redirectEnteringNodes, originalEnteringNodes, pathFactory_1.PathUtils.nonDynamicParams)\n            .filter(hof_1.not(nodeIsReloading(targetState.options().reloadState)));\n        // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.\n        matchingEnteringNodes.forEach(function (node, idx) {\n            node.resolvables = originalEnteringNodes[idx].resolvables;\n        });\n        return newTransition;\n    };\n    /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */\n    Transition.prototype._changedParams = function () {\n        var tc = this._treeChanges;\n        /** Return undefined if it's not a \"dynamic\" transition, for the following reasons */\n        // If user explicitly wants a reload\n        if (this._options.reload)\n            return undefined;\n        // If any states are exiting or entering\n        if (tc.exiting.length || tc.entering.length)\n            return undefined;\n        // If to/from path lengths differ\n        if (tc.to.length !== tc.from.length)\n            return undefined;\n        // If the to/from paths are different\n        var pathsDiffer = common_1.arrayTuples(tc.to, tc.from)\n            .map(function (tuple) { return tuple[0].state !== tuple[1].state; })\n            .reduce(common_1.anyTrueR, false);\n        if (pathsDiffer)\n            return undefined;\n        // Find any parameter values that differ\n        var nodeSchemas = tc.to.map(function (node) { return node.paramSchema; });\n        var _a = [tc.to, tc.from].map(function (path) { return path.map(function (x) { return x.paramValues; }); }), toValues = _a[0], fromValues = _a[1];\n        var tuples = common_1.arrayTuples(nodeSchemas, toValues, fromValues);\n        return tuples.map(function (_a) {\n            var schema = _a[0], toVals = _a[1], fromVals = _a[2];\n            return param_1.Param.changed(schema, toVals, fromVals);\n        }).reduce(common_1.unnestR, []);\n    };\n    /**\n     * Returns true if the transition is dynamic.\n     *\n     * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.\n     *\n     * @returns true if the Transition is dynamic\n     */\n    Transition.prototype.dynamic = function () {\n        var changes = this._changedParams();\n        return !changes ? false : changes.map(function (x) { return x.dynamic; }).reduce(common_1.anyTrueR, false);\n    };\n    /**\n     * Returns true if the transition is ignored.\n     *\n     * A transition is ignored if no states are entered nor exited, and no parameter values have changed.\n     *\n     * @returns true if the Transition is ignored.\n     */\n    Transition.prototype.ignored = function () {\n        return !!this._ignoredReason();\n    };\n    /** @hidden */\n    Transition.prototype._ignoredReason = function () {\n        var pending = this.router.globals.transition;\n        var reloadState = this._options.reloadState;\n        var same = function (pathA, pathB) {\n            if (pathA.length !== pathB.length)\n                return false;\n            var matching = pathFactory_1.PathUtils.matching(pathA, pathB);\n            return pathA.length === matching.filter(function (node) { return !reloadState || !node.state.includes[reloadState.name]; }).length;\n        };\n        var newTC = this.treeChanges();\n        var pendTC = pending && pending.treeChanges();\n        if (pendTC && same(pendTC.to, newTC.to) && same(pendTC.exiting, newTC.exiting))\n            return \"SameAsPending\";\n        if (newTC.exiting.length === 0 && newTC.entering.length === 0 && same(newTC.from, newTC.to))\n            return \"SameAsCurrent\";\n    };\n    /**\n     * Runs the transition\n     *\n     * This method is generally called from the [[StateService.transitionTo]]\n     *\n     * @internalapi\n     *\n     * @returns a promise for a successful transition.\n     */\n    Transition.prototype.run = function () {\n        var _this = this;\n        var runAllHooks = transitionHook_1.TransitionHook.runAllHooks;\n        // Gets transition hooks array for the given phase\n        var getHooksFor = function (phase) {\n            return _this._hookBuilder.buildHooksForPhase(phase);\n        };\n        // When the chain is complete, then resolve or reject the deferred\n        var transitionSuccess = function () {\n            trace_1.trace.traceSuccess(_this.$to(), _this);\n            _this.success = true;\n            _this._deferred.resolve(_this.to());\n            runAllHooks(getHooksFor(interface_1.TransitionHookPhase.SUCCESS));\n        };\n        var transitionError = function (reason) {\n            trace_1.trace.traceError(reason, _this);\n            _this.success = false;\n            _this._deferred.reject(reason);\n            _this._error = reason;\n            runAllHooks(getHooksFor(interface_1.TransitionHookPhase.ERROR));\n        };\n        var runTransition = function () {\n            // Wait to build the RUN hook chain until the BEFORE hooks are done\n            // This allows a BEFORE hook to dynamically add additional RUN hooks via the Transition object.\n            var allRunHooks = getHooksFor(interface_1.TransitionHookPhase.RUN);\n            var done = function () { return coreservices_1.services.$q.when(undefined); };\n            return transitionHook_1.TransitionHook.invokeHooks(allRunHooks, done);\n        };\n        var startTransition = function () {\n            var globals = _this.router.globals;\n            globals.lastStartedTransitionId = _this.$id;\n            globals.transition = _this;\n            globals.transitionHistory.enqueue(_this);\n            trace_1.trace.traceTransitionStart(_this);\n            return coreservices_1.services.$q.when(undefined);\n        };\n        var allBeforeHooks = getHooksFor(interface_1.TransitionHookPhase.BEFORE);\n        transitionHook_1.TransitionHook.invokeHooks(allBeforeHooks, startTransition)\n            .then(runTransition)\n            .then(transitionSuccess, transitionError);\n        return this.promise;\n    };\n    /**\n     * Checks if the Transition is valid\n     *\n     * @returns true if the Transition is valid\n     */\n    Transition.prototype.valid = function () {\n        return !this.error() || this.success !== undefined;\n    };\n    /**\n     * Aborts this transition\n     *\n     * Imperative API to abort a Transition.\n     * This only applies to Transitions that are not yet complete.\n     */\n    Transition.prototype.abort = function () {\n        // Do not set flag if the transition is already complete\n        if (predicates_1.isUndefined(this.success)) {\n            this._aborted = true;\n        }\n    };\n    /**\n     * The Transition error reason.\n     *\n     * If the transition is invalid (and could not be run), returns the reason the transition is invalid.\n     * If the transition was valid and ran, but was not successful, returns the reason the transition failed.\n     *\n     * @returns an error message explaining why the transition is invalid, or the reason the transition failed.\n     */\n    Transition.prototype.error = function () {\n        var state = this.$to();\n        if (state.self.abstract)\n            return \"Cannot transition to abstract state '\" + state.name + \"'\";\n        var paramDefs = state.parameters(), values = this.params();\n        var invalidParams = paramDefs.filter(function (param) { return !param.validates(values[param.id]); });\n        if (invalidParams.length) {\n            return \"Param values not valid for state '\" + state.name + \"'. Invalid params: [ \" + invalidParams.map(function (param) { return param.id; }).join(', ') + \" ]\";\n        }\n        if (this.success === false)\n            return this._error;\n    };\n    /**\n     * A string representation of the Transition\n     *\n     * @returns A string representation of the Transition\n     */\n    Transition.prototype.toString = function () {\n        var fromStateOrName = this.from();\n        var toStateOrName = this.to();\n        var avoidEmptyHash = function (params) {\n            return (params[\"#\"] !== null && params[\"#\"] !== undefined) ? params : common_1.omit(params, [\"#\"]);\n        };\n        // (X) means the to state is invalid.\n        var id = this.$id, from = predicates_1.isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = strings_1.stringify(avoidEmptyHash(this._treeChanges.from.map(hof_1.prop('paramValues')).reduce(common_1.mergeR, {}))), toValid = this.valid() ? \"\" : \"(X) \", to = predicates_1.isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = strings_1.stringify(avoidEmptyHash(this.params()));\n        return \"Transition#\" + id + \"( '\" + from + \"'\" + fromParams + \" -> \" + toValid + \"'\" + to + \"'\" + toParams + \" )\";\n    };\n    /** @hidden */\n    Transition.diToken = Transition;\n    return Transition;\n}());\nexports.Transition = Transition;\n//# sourceMappingURL=transition.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL3RyYW5zaXRpb24uanM/OTU1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgdHJhbnNpdGlvblxuICovXG4vKiogZm9yIHR5cGVkb2MgKi9cbnZhciB0cmFjZV8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi90cmFjZVwiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vc3RyaW5nc1wiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIGludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vaW50ZXJmYWNlXCIpOyAvLyBoYXMgb3IgaXMgdXNpbmdcbnZhciB0cmFuc2l0aW9uSG9va18xID0gcmVxdWlyZShcIi4vdHJhbnNpdGlvbkhvb2tcIik7XG52YXIgaG9va1JlZ2lzdHJ5XzEgPSByZXF1aXJlKFwiLi9ob29rUmVnaXN0cnlcIik7XG52YXIgaG9va0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL2hvb2tCdWlsZGVyXCIpO1xudmFyIHBhdGhGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi4vcGF0aC9wYXRoRmFjdG9yeVwiKTtcbnZhciBwYXJhbV8xID0gcmVxdWlyZShcIi4uL3BhcmFtcy9wYXJhbVwiKTtcbnZhciByZXNvbHZhYmxlXzEgPSByZXF1aXJlKFwiLi4vcmVzb2x2ZS9yZXNvbHZhYmxlXCIpO1xudmFyIHJlc29sdmVDb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vcmVzb2x2ZS9yZXNvbHZlQ29udGV4dFwiKTtcbi8qKiBAaGlkZGVuICovXG52YXIgc3RhdGVTZWxmID0gaG9mXzEucHJvcChcInNlbGZcIik7XG4vKipcbiAqIFJlcHJlc2VudHMgYSB0cmFuc2l0aW9uIGJldHdlZW4gdHdvIHN0YXRlcy5cbiAqXG4gKiBXaGVuIG5hdmlnYXRpbmcgdG8gYSBzdGF0ZSwgd2UgYXJlIHRyYW5zaXRpb25pbmcgKipmcm9tKiogdGhlIGN1cnJlbnQgc3RhdGUgKip0byoqIHRoZSBuZXcgc3RhdGUuXG4gKlxuICogVGhpcyBvYmplY3QgY29udGFpbnMgYWxsIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRvL2Zyb20gc3RhdGVzLCBwYXJhbWV0ZXJzLCByZXNvbHZlcy5cbiAqIEl0IGhhcyBpbmZvcm1hdGlvbiBhYm91dCBhbGwgc3RhdGVzIGJlaW5nIGVudGVyZWQgYW5kIGV4aXRlZCBhcyBhIHJlc3VsdCBvZiB0aGUgdHJhbnNpdGlvbi5cbiAqL1xudmFyIFRyYW5zaXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUcmFuc2l0aW9uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIElmIHRoZSB0YXJnZXQgc3RhdGUgaXMgbm90IHZhbGlkLCBhbiBlcnJvciBpcyB0aHJvd24uXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxhcGlcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmcm9tUGF0aCBUaGUgcGF0aCBvZiBbW1BhdGhOb2RlXV1zIGZyb20gd2hpY2ggdGhlIHRyYW5zaXRpb24gaXMgbGVhdmluZy4gIFRoZSBsYXN0IG5vZGUgaW4gdGhlIGBmcm9tUGF0aGBcbiAgICAgKiAgICAgICAgZW5jYXBzdWxhdGVzIHRoZSBcImZyb20gc3RhdGVcIi5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0U3RhdGUgVGhlIHRhcmdldCBzdGF0ZSBhbmQgcGFyYW1ldGVycyBiZWluZyB0cmFuc2l0aW9uZWQgdG8gKGFsc28sIHRoZSB0cmFuc2l0aW9uIG9wdGlvbnMpXG4gICAgICogQHBhcmFtIHJvdXRlciBUaGUgW1tVSVJvdXRlcl1dIGluc3RhbmNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gVHJhbnNpdGlvbihmcm9tUGF0aCwgdGFyZ2V0U3RhdGUsIHJvdXRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLl9kZWZlcnJlZCA9IGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLmRlZmVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHByb21pc2UgaXMgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgYmFzZWQgb24gdGhlIG91dGNvbWUgb2YgdGhlIFRyYW5zaXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gdGhlIHRyYW5zaXRpb24gaXMgc3VjY2Vzc2Z1bCwgdGhlIHByb21pc2UgaXMgcmVzb2x2ZWRcbiAgICAgICAgICogV2hlbiB0aGUgdHJhbnNpdGlvbiBpcyB1bnN1Y2Nlc3NmdWwsIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIHdpdGggdGhlIFtbUmVqZWN0aW9uXV0gb3IgamF2YXNjcmlwdCBlcnJvclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9taXNlID0gdGhpcy5fZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgLyoqIEBoaWRkZW4gSG9sZHMgdGhlIGhvb2sgcmVnaXN0cmF0aW9uIGZ1bmN0aW9ucyBzdWNoIGFzIHRob3NlIHBhc3NlZCB0byBUcmFuc2l0aW9uLm9uU3RhcnQoKSAqL1xuICAgICAgICB0aGlzLl9yZWdpc3RlcmVkSG9va3MgPSB7fTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgdGhpcy5faG9va0J1aWxkZXIgPSBuZXcgaG9va0J1aWxkZXJfMS5Ib29rQnVpbGRlcih0aGlzKTtcbiAgICAgICAgLyoqIENoZWNrcyBpZiB0aGlzIHRyYW5zaXRpb24gaXMgY3VycmVudGx5IGFjdGl2ZS9ydW5uaW5nLiAqL1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJvdXRlci5nbG9iYWxzLnRyYW5zaXRpb24gPT09IF90aGlzO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgdGhpcy5fdGFyZ2V0U3RhdGUgPSB0YXJnZXRTdGF0ZTtcbiAgICAgICAgaWYgKCF0YXJnZXRTdGF0ZS52YWxpZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGFyZ2V0U3RhdGUuZXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3VycmVudCgpIGlzIGFzc3VtZWQgdG8gY29tZSBmcm9tIHRhcmdldFN0YXRlLm9wdGlvbnMsIGJ1dCBwcm92aWRlIGEgbmFpdmUgaW1wbGVtZW50YXRpb24gb3RoZXJ3aXNlLlxuICAgICAgICB0aGlzLl9vcHRpb25zID0gY29tbW9uXzEuZXh0ZW5kKHsgY3VycmVudDogaG9mXzEudmFsKHRoaXMpIH0sIHRhcmdldFN0YXRlLm9wdGlvbnMoKSk7XG4gICAgICAgIHRoaXMuJGlkID0gcm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLl90cmFuc2l0aW9uQ291bnQrKztcbiAgICAgICAgdmFyIHRvUGF0aCA9IHBhdGhGYWN0b3J5XzEuUGF0aFV0aWxzLmJ1aWxkVG9QYXRoKGZyb21QYXRoLCB0YXJnZXRTdGF0ZSk7XG4gICAgICAgIHRoaXMuX3RyZWVDaGFuZ2VzID0gcGF0aEZhY3RvcnlfMS5QYXRoVXRpbHMudHJlZUNoYW5nZXMoZnJvbVBhdGgsIHRvUGF0aCwgdGhpcy5fb3B0aW9ucy5yZWxvYWRTdGF0ZSk7XG4gICAgICAgIHRoaXMuY3JlYXRlVHJhbnNpdGlvbkhvb2tSZWdGbnMoKTtcbiAgICAgICAgdmFyIG9uQ3JlYXRlSG9va3MgPSB0aGlzLl9ob29rQnVpbGRlci5idWlsZEhvb2tzRm9yUGhhc2UoaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tQaGFzZS5DUkVBVEUpO1xuICAgICAgICB0cmFuc2l0aW9uSG9va18xLlRyYW5zaXRpb25Ib29rLmludm9rZUhvb2tzKG9uQ3JlYXRlSG9va3MsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0pO1xuICAgICAgICB0aGlzLmFwcGx5Vmlld0NvbmZpZ3Mocm91dGVyKTtcbiAgICB9XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vbkJlZm9yZSA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vbkV4aXQgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vblJldGFpbiA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLm9uRW50ZXIgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vbkZpbmlzaCA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLm9uU3VjY2VzcyA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGhpZGRlblxuICAgICAqIENyZWF0ZXMgdGhlIHRyYW5zaXRpb24tbGV2ZWwgaG9vayByZWdpc3RyYXRpb24gZnVuY3Rpb25zXG4gICAgICogKHdoaWNoIGNhbiB0aGVuIGJlIHVzZWQgdG8gcmVnaXN0ZXIgaG9va3MpXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuY3JlYXRlVHJhbnNpdGlvbkhvb2tSZWdGbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLl9wbHVnaW5hcGkuX2dldEV2ZW50cygpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlLmhvb2tQaGFzZSAhPT0gaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tQaGFzZS5DUkVBVEU7IH0pXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gaG9va1JlZ2lzdHJ5XzEubWFrZUV2ZW50KF90aGlzLCBfdGhpcy5yb3V0ZXIudHJhbnNpdGlvblNlcnZpY2UsIHR5cGUpOyB9KTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5nZXRIb29rcyA9IGZ1bmN0aW9uIChob29rTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVnaXN0ZXJlZEhvb2tzW2hvb2tOYW1lXTtcbiAgICB9O1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmFwcGx5Vmlld0NvbmZpZ3MgPSBmdW5jdGlvbiAocm91dGVyKSB7XG4gICAgICAgIHZhciBlbnRlcmluZ1N0YXRlcyA9IHRoaXMuX3RyZWVDaGFuZ2VzLmVudGVyaW5nLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5zdGF0ZTsgfSk7XG4gICAgICAgIHBhdGhGYWN0b3J5XzEuUGF0aFV0aWxzLmFwcGx5Vmlld0NvbmZpZ3Mocm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLiR2aWV3LCB0aGlzLl90cmVlQ2hhbmdlcy50bywgZW50ZXJpbmdTdGF0ZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGludGVybmFsYXBpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgaW50ZXJuYWwgZnJvbSBbU3RhdGVdIG9iamVjdFxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLiRmcm9tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEudGFpbCh0aGlzLl90cmVlQ2hhbmdlcy5mcm9tKS5zdGF0ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbGFwaVxuICAgICAqXG4gICAgICogQHJldHVybnMgdGhlIGludGVybmFsIHRvIFtTdGF0ZV0gb2JqZWN0XG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuJHRvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEudGFpbCh0aGlzLl90cmVlQ2hhbmdlcy50bykuc3RhdGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBcImZyb20gc3RhdGVcIlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgc3RhdGUgdGhhdCB0aGUgdHJhbnNpdGlvbiBpcyBjb21pbmcgKmZyb20qLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHN0YXRlIGRlY2xhcmF0aW9uIG9iamVjdCBmb3IgdGhlIFRyYW5zaXRpb24ncyAoXCJmcm9tIHN0YXRlXCIpLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmZyb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRmcm9tKCkuc2VsZjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFwidG8gc3RhdGVcIlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgc3RhdGUgdGhhdCB0aGUgdHJhbnNpdGlvbiBpcyBnb2luZyAqdG8qLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHN0YXRlIGRlY2xhcmF0aW9uIG9iamVjdCBmb3IgdGhlIFRyYW5zaXRpb24ncyB0YXJnZXQgc3RhdGUgKFwidG8gc3RhdGVcIikuXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR0bygpLnNlbGY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBUYXJnZXQgU3RhdGVcbiAgICAgKlxuICAgICAqIEEgdHJhbnNpdGlvbidzIFtbVGFyZ2V0U3RhdGVdXSBlbmNhcHN1bGF0ZXMgdGhlIFtbdG9dXSBzdGF0ZSwgdGhlIFtbcGFyYW1zXV0sIGFuZCB0aGUgW1tvcHRpb25zXV0gYXMgYSBzaW5nbGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgdGhlIFtbVGFyZ2V0U3RhdGVdXSBvZiB0aGlzIFRyYW5zaXRpb25cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS50YXJnZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldFN0YXRlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHR3byB0cmFuc2l0aW9ucyBhcmUgZXF1aXZhbGVudC5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmlzID0gZnVuY3Rpb24gKGNvbXBhcmUpIHtcbiAgICAgICAgaWYgKGNvbXBhcmUgaW5zdGFuY2VvZiBUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBBbHNvIGNvbXBhcmUgcGFyYW1ldGVyc1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXMoeyB0bzogY29tcGFyZS4kdG8oKS5uYW1lLCBmcm9tOiBjb21wYXJlLiRmcm9tKCkubmFtZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISgoY29tcGFyZS50byAmJiAhaG9va1JlZ2lzdHJ5XzEubWF0Y2hTdGF0ZSh0aGlzLiR0bygpLCBjb21wYXJlLnRvKSkgfHxcbiAgICAgICAgICAgIChjb21wYXJlLmZyb20gJiYgIWhvb2tSZWdpc3RyeV8xLm1hdGNoU3RhdGUodGhpcy4kZnJvbSgpLCBjb21wYXJlLmZyb20pKSk7XG4gICAgfTtcbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbiAocGF0aG5hbWUpIHtcbiAgICAgICAgaWYgKHBhdGhuYW1lID09PSB2b2lkIDApIHsgcGF0aG5hbWUgPSBcInRvXCI7IH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUodGhpcy5fdHJlZUNoYW5nZXNbcGF0aG5hbWVdLm1hcChob2ZfMS5wcm9wKFwicGFyYW1WYWx1ZXNcIikpLnJlZHVjZShjb21tb25fMS5tZXJnZVIsIHt9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgW1tVSUluamVjdG9yXV0gRGVwZW5kZW5jeSBJbmplY3RvclxuICAgICAqXG4gICAgICogUmV0dXJucyBhIERlcGVuZGVuY3kgSW5qZWN0b3IgZm9yIHRoZSBUcmFuc2l0aW9uJ3MgdGFyZ2V0IHN0YXRlICh0byBzdGF0ZSkuXG4gICAgICogVGhlIGluamVjdG9yIHByb3ZpZGVzIHJlc29sdmUgdmFsdWVzIHdoaWNoIHRoZSB0YXJnZXQgc3RhdGUgaGFzIGFjY2VzcyB0by5cbiAgICAgKlxuICAgICAqIFRoZSBgVUlJbmplY3RvcmAgY2FuIGFsc28gcHJvdmlkZSB2YWx1ZXMgZnJvbSB0aGUgbmF0aXZlIHJvb3QvZ2xvYmFsIGluamVjdG9yIChuZzEvbmcyKS5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIC5vbkVudGVyKHsgZW50ZXJpbmc6ICdteVN0YXRlJyB9LCB0cmFucyA9PiB7XG4gICAgICogICB2YXIgbXlSZXNvbHZlVmFsdWUgPSB0cmFucy5pbmplY3RvcigpLmdldCgnbXlSZXNvbHZlJyk7XG4gICAgICogICAvLyBJbmplY3QgYSBnbG9iYWwgc2VydmljZSBmcm9tIHRoZSBnbG9iYWwvbmF0aXZlIGluamVjdG9yIChpZiBpdCBleGlzdHMpXG4gICAgICogICB2YXIgTXlTZXJ2aWNlID0gdHJhbnMuaW5qZWN0b3IoKS5nZXQoJ015U2VydmljZScpO1xuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBJbiBzb21lIGNhc2VzIChzdWNoIGFzIGBvbkJlZm9yZWApLCB5b3UgbWF5IG5lZWQgYWNjZXNzIHRvIHNvbWUgcmVzb2x2ZSBkYXRhIGJ1dCBpdCBoYXMgbm90IHlldCBiZWVuIGZldGNoZWQuXG4gICAgICogWW91IGNhbiB1c2UgW1tVSUluamVjdG9yLmdldEFzeW5jXV0gdG8gZ2V0IGEgcHJvbWlzZSBmb3IgdGhlIGRhdGEuXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogLm9uQmVmb3JlKHt9LCB0cmFucyA9PiB7XG4gICAgICogICByZXR1cm4gdHJhbnMuaW5qZWN0b3IoKS5nZXRBc3luYygnbXlSZXNvbHZlJykudGhlbihteVJlc29sdmVWYWx1ZSA9PlxuICAgICAqICAgICByZXR1cm4gbXlSZXNvbHZlVmFsdWUgIT09ICdBQk9SVCc7XG4gICAgICogICB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIElmIGEgYHN0YXRlYCBpcyBwcm92aWRlZCwgdGhlIGluamVjdG9yIHRoYXQgaXMgcmV0dXJuZWQgd2lsbCBiZSBsaW1pdGVkIHRvIHJlc29sdmUgdmFsdWVzIHRoYXQgdGhlIHByb3ZpZGVkIHN0YXRlIGhhcyBhY2Nlc3MgdG8uXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZnVsIGlmIGJvdGggYSBwYXJlbnQgc3RhdGUgYGZvb2AgYW5kIGEgY2hpbGQgc3RhdGUgYGZvby5iYXJgIGhhdmUgYm90aCBkZWZpbmVkIGEgcmVzb2x2ZSBzdWNoIGFzIGBkYXRhYC5cbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiAub25FbnRlcih7IHRvOiAnZm9vLmJhcicgfSwgdHJhbnMgPT4ge1xuICAgICAqICAgLy8gcmV0dXJucyByZXN1bHQgb2YgYGZvb2Agc3RhdGUncyBgZGF0YWAgcmVzb2x2ZVxuICAgICAqICAgLy8gZXZlbiB0aG91Z2ggYGZvby5iYXJgIGFsc28gaGFzIGEgYGRhdGFgIHJlc29sdmVcbiAgICAgKiAgIHZhciBmb29EYXRhID0gdHJhbnMuaW5qZWN0b3IoJ2ZvbycpLmdldCgnZGF0YScpO1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogSWYgeW91IG5lZWQgcmVzb2x2ZSBkYXRhIGZyb20gdGhlIGV4aXRpbmcgc3RhdGVzLCBwYXNzIGAnZnJvbSdgIGFzIGBwYXRoTmFtZWAuXG4gICAgICogVGhlIHJlc29sdmUgZGF0YSBmcm9tIHRoZSBgZnJvbWAgcGF0aCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIC5vbkV4aXQoeyBleGl0aW5nOiAnZm9vLmJhcicgfSwgdHJhbnMgPT4ge1xuICAgICAqICAgLy8gR2V0cyB0aGUgcmVzb2x2ZSB2YWx1ZSBvZiBgZGF0YWAgZnJvbSB0aGUgZXhpdGluZyBzdGF0ZS5cbiAgICAgKiAgIHZhciBmb29EYXRhID0gdHJhbnMuaW5qZWN0b3IobnVsbCwgJ2Zvby5iYXInKS5nZXQoJ2RhdGEnKTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlIExpbWl0cyB0aGUgcmVzb2x2ZXMgcHJvdmlkZWQgdG8gb25seSB0aGUgcmVzb2x2ZXMgdGhlIHByb3ZpZGVkIHN0YXRlIGhhcyBhY2Nlc3MgdG8uXG4gICAgICogQHBhcmFtIHBhdGhOYW1lIERlZmF1bHQ6IGAndG8nYDogQ2hvb3NlcyB0aGUgcGF0aCBmb3Igd2hpY2ggdG8gY3JlYXRlIHRoZSBpbmplY3Rvci4gVXNlIHRoaXMgdG8gYWNjZXNzIHJlc29sdmVzIGZvciBgZXhpdGluZ2Agc3RhdGVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBbW1VJSW5qZWN0b3JdXVxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmluamVjdG9yID0gZnVuY3Rpb24gKHN0YXRlLCBwYXRoTmFtZSkge1xuICAgICAgICBpZiAocGF0aE5hbWUgPT09IHZvaWQgMCkgeyBwYXRoTmFtZSA9IFwidG9cIjsgfVxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMuX3RyZWVDaGFuZ2VzW3BhdGhOYW1lXTtcbiAgICAgICAgaWYgKHN0YXRlKVxuICAgICAgICAgICAgcGF0aCA9IHBhdGhGYWN0b3J5XzEuUGF0aFV0aWxzLnN1YlBhdGgocGF0aCwgZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUuc3RhdGUgPT09IHN0YXRlIHx8IG5vZGUuc3RhdGUubmFtZSA9PT0gc3RhdGU7IH0pO1xuICAgICAgICByZXR1cm4gbmV3IHJlc29sdmVDb250ZXh0XzEuUmVzb2x2ZUNvbnRleHQocGF0aCkuaW5qZWN0b3IoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGF2YWlsYWJsZSByZXNvbHZlIHRva2VucyAoa2V5cylcbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggW1tpbmplY3Rvcl1dIHRvIGluc3BlY3QgdGhlIHJlc29sdmUgdmFsdWVzXG4gICAgICogYXZhaWxhYmxlIHRvIHRoZSBUcmFuc2l0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyByZXR1cm5zIGFsbCB0aGUgdG9rZW5zIGRlZmluZWQgb24gW1tTdGF0ZURlY2xhcmF0aW9uLnJlc29sdmVdXSBibG9ja3MsIGZvciB0aGUgc3RhdGVzXG4gICAgICogaW4gdGhlIFRyYW5zaXRpb24ncyBbW1RyZWVDaGFuZ2VzLnRvXV0gcGF0aC5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBUaGlzIGV4YW1wbGUgbG9ncyBhbGwgcmVzb2x2ZSB2YWx1ZXNcbiAgICAgKiBgYGBqc1xuICAgICAqIGxldCB0b2tlbnMgPSB0cmFucy5nZXRSZXNvbHZlVG9rZW5zKCk7XG4gICAgICogdG9rZW5zLmZvckVhY2godG9rZW4gPT4gY29uc29sZS5sb2codG9rZW4gKyBcIiA9IFwiICsgdHJhbnMuaW5qZWN0b3IoKS5nZXQodG9rZW4pKSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogVGhpcyBleGFtcGxlIGNyZWF0ZXMgcHJvbWlzZXMgZm9yIGVhY2ggcmVzb2x2ZSB2YWx1ZS5cbiAgICAgKiBUaGlzIHRyaWdnZXJzIGZldGNoZXMgb2YgcmVzb2x2ZXMgKGlmIGFueSBoYXZlIG5vdCB5ZXQgYmVlbiBmZXRjaGVkKS5cbiAgICAgKiBXaGVuIGFsbCBwcm9taXNlcyBoYXZlIGFsbCBzZXR0bGVkLCBpdCBsb2dzIHRoZSByZXNvbHZlIHZhbHVlcy5cbiAgICAgKiBgYGBqc1xuICAgICAqIGxldCB0b2tlbnMgPSB0cmFucy5nZXRSZXNvbHZlVG9rZW5zKCk7XG4gICAgICogbGV0IHByb21pc2UgPSB0b2tlbnMubWFwKHRva2VuID0+IHRyYW5zLmluamVjdG9yKCkuZ2V0QXN5bmModG9rZW4pKTtcbiAgICAgKiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbih2YWx1ZXMgPT4gY29uc29sZS5sb2coXCJSZXNvbHZlZCB2YWx1ZXM6IFwiICsgdmFsdWVzKSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBOb3RlOiBBbmd1bGFyIDEgdXNlcnMgd2hvdWxkIHVzZSBgJHEuYWxsKClgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aG5hbWUgcmVzb2x2ZSBjb250ZXh0J3MgcGF0aCBuYW1lIChlLmcuLCBgdG9gIG9yIGBmcm9tYClcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIHJlc29sdmUgdG9rZW5zIChrZXlzKVxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmdldFJlc29sdmVUb2tlbnMgPSBmdW5jdGlvbiAocGF0aG5hbWUpIHtcbiAgICAgICAgaWYgKHBhdGhuYW1lID09PSB2b2lkIDApIHsgcGF0aG5hbWUgPSBcInRvXCI7IH1cbiAgICAgICAgcmV0dXJuIG5ldyByZXNvbHZlQ29udGV4dF8xLlJlc29sdmVDb250ZXh0KHRoaXMuX3RyZWVDaGFuZ2VzW3BhdGhuYW1lXSkuZ2V0VG9rZW5zKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEeW5hbWljYWxseSBhZGRzIGEgbmV3IFtbUmVzb2x2YWJsZV1dIChpLmUuLCBbW1N0YXRlRGVjbGFyYXRpb24ucmVzb2x2ZV1dKSB0byB0aGlzIHRyYW5zaXRpb24uXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiB0cmFuc2l0aW9uU2VydmljZS5vbkJlZm9yZSh7fSwgdHJhbnNpdGlvbiA9PiB7XG4gICAgICogICB0cmFuc2l0aW9uLmFkZFJlc29sdmFibGUoe1xuICAgICAqICAgICB0b2tlbjogJ215UmVzb2x2ZScsXG4gICAgICogICAgIGRlcHM6IFsnTXlTZXJ2aWNlJ10sXG4gICAgICogICAgIHJlc29sdmVGbjogbXlTZXJ2aWNlID0+IG15U2VydmljZS5nZXREYXRhKClcbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHJlc29sdmFibGUgYSBbW1Jlc29sdmFibGVMaXRlcmFsXV0gb2JqZWN0IChvciBhIFtbUmVzb2x2YWJsZV1dKVxuICAgICAqIEBwYXJhbSBzdGF0ZSB0aGUgc3RhdGUgaW4gdGhlIFwidG8gcGF0aFwiIHdoaWNoIHNob3VsZCByZWNlaXZlIHRoZSBuZXcgcmVzb2x2ZSAob3RoZXJ3aXNlLCB0aGUgcm9vdCBzdGF0ZSlcbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5hZGRSZXNvbHZhYmxlID0gZnVuY3Rpb24gKHJlc29sdmFibGUsIHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7IHN0YXRlID0gXCJcIjsgfVxuICAgICAgICByZXNvbHZhYmxlID0gaG9mXzEuaXMocmVzb2x2YWJsZV8xLlJlc29sdmFibGUpKHJlc29sdmFibGUpID8gcmVzb2x2YWJsZSA6IG5ldyByZXNvbHZhYmxlXzEuUmVzb2x2YWJsZShyZXNvbHZhYmxlKTtcbiAgICAgICAgdmFyIHN0YXRlTmFtZSA9ICh0eXBlb2Ygc3RhdGUgPT09IFwic3RyaW5nXCIpID8gc3RhdGUgOiBzdGF0ZS5uYW1lO1xuICAgICAgICB2YXIgdG9wYXRoID0gdGhpcy5fdHJlZUNoYW5nZXMudG87XG4gICAgICAgIHZhciB0YXJnZXROb2RlID0gY29tbW9uXzEuZmluZCh0b3BhdGgsIGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnN0YXRlLm5hbWUgPT09IHN0YXRlTmFtZTsgfSk7XG4gICAgICAgIHZhciByZXNvbHZlQ29udGV4dCA9IG5ldyByZXNvbHZlQ29udGV4dF8xLlJlc29sdmVDb250ZXh0KHRvcGF0aCk7XG4gICAgICAgIHJlc29sdmVDb250ZXh0LmFkZFJlc29sdmFibGVzKFtyZXNvbHZhYmxlXSwgdGFyZ2V0Tm9kZS5zdGF0ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0cmFuc2l0aW9uIGZyb20gd2hpY2ggdGhpcyB0cmFuc2l0aW9uIHdhcyByZWRpcmVjdGVkLlxuICAgICAqXG4gICAgICogSWYgdGhlIGN1cnJlbnQgdHJhbnNpdGlvbiBpcyBhIHJlZGlyZWN0LCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSB0cmFuc2l0aW9uIHRoYXQgd2FzIHJlZGlyZWN0ZWQuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBsZXQgdHJhbnNpdGlvbkEgPSAkc3RhdGUuZ28oJ0EnKS50cmFuc2l0aW9uXG4gICAgICogdHJhbnNpdGlvbkEub25TdGFydCh7fSwgKCkgPT4gJHN0YXRlLnRhcmdldCgnQicpKTtcbiAgICAgKiAkdHJhbnNpdGlvbnMub25TdWNjZXNzKHsgdG86ICdCJyB9LCAodHJhbnMpID0+IHtcbiAgICAgKiAgIHRyYW5zLnRvKCkubmFtZSA9PT0gJ0InOyAvLyB0cnVlXG4gICAgICogICB0cmFucy5yZWRpcmVjdGVkRnJvbSgpID09PSB0cmFuc2l0aW9uQTsgLy8gdHJ1ZVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHByZXZpb3VzIFRyYW5zaXRpb24sIG9yIG51bGwgaWYgdGhpcyBUcmFuc2l0aW9uIGlzIG5vdCB0aGUgcmVzdWx0IG9mIGEgcmVkaXJlY3Rpb25cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5yZWRpcmVjdGVkRnJvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnMucmVkaXJlY3RlZEZyb20gfHwgbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG9yaWdpbmFsIHRyYW5zaXRpb24gaW4gYSByZWRpcmVjdCBjaGFpblxuICAgICAqXG4gICAgICogQSB0cmFuc2l0aW9uIG1pZ2h0IGJlbG9uZyB0byBhIGxvbmcgY2hhaW4gb2YgbXVsdGlwbGUgcmVkaXJlY3RzLlxuICAgICAqIFRoaXMgbWV0aG9kIHdhbGtzIHRoZSBbW3JlZGlyZWN0ZWRGcm9tXV0gY2hhaW4gYmFjayB0byB0aGUgb3JpZ2luYWwgKGZpcnN0KSB0cmFuc2l0aW9uIGluIHRoZSBjaGFpbi5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIC8vIHN0YXRlc1xuICAgICAqIHJlZ2lzdHJ5LnJlZ2lzdGVyKHsgbmFtZTogJ0EnLCByZWRpcmVjdFRvOiAnQicgfSk7XG4gICAgICogcmVnaXN0cnkucmVnaXN0ZXIoeyBuYW1lOiAnQicsIHJlZGlyZWN0VG86ICdDJyB9KTtcbiAgICAgKiByZWdpc3RyeS5yZWdpc3Rlcih7IG5hbWU6ICdDJywgcmVkaXJlY3RUbzogJ0QnIH0pO1xuICAgICAqIHJlZ2lzdHJ5LnJlZ2lzdGVyKHsgbmFtZTogJ0QnIH0pO1xuICAgICAqXG4gICAgICogbGV0IHRyYW5zaXRpb25BID0gJHN0YXRlLmdvKCdBJykudHJhbnNpdGlvblxuICAgICAqXG4gICAgICogJHRyYW5zaXRpb25zLm9uU3VjY2Vzcyh7IHRvOiAnRCcgfSwgKHRyYW5zKSA9PiB7XG4gICAgICogICB0cmFucy50bygpLm5hbWUgPT09ICdEJzsgLy8gdHJ1ZVxuICAgICAqICAgdHJhbnMucmVkaXJlY3RlZEZyb20oKS50bygpLm5hbWUgPT09ICdDJzsgLy8gdHJ1ZVxuICAgICAqICAgdHJhbnMub3JpZ2luYWxUcmFuc2l0aW9uKCkgPT09IHRyYW5zaXRpb25BOyAvLyB0cnVlXG4gICAgICogICB0cmFucy5vcmlnaW5hbFRyYW5zaXRpb24oKS50bygpLm5hbWUgPT09ICdBJzsgLy8gdHJ1ZVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG9yaWdpbmFsIFRyYW5zaXRpb24gdGhhdCBzdGFydGVkIGEgcmVkaXJlY3QgY2hhaW5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vcmlnaW5hbFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZiA9IHRoaXMucmVkaXJlY3RlZEZyb20oKTtcbiAgICAgICAgcmV0dXJuIChyZiAmJiByZi5vcmlnaW5hbFRyYW5zaXRpb24oKSkgfHwgdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdHJhbnNpdGlvbiBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgb3B0aW9ucyBmb3IgdGhpcyBUcmFuc2l0aW9uLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLm9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhdGVzIGJlaW5nIGVudGVyZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBzdGF0ZXMgdGhhdCB3aWxsIGJlIGVudGVyZWQgZHVyaW5nIHRoaXMgdHJhbnNpdGlvbi5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5lbnRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLm1hcCh0aGlzLl90cmVlQ2hhbmdlcy5lbnRlcmluZywgaG9mXzEucHJvcCgnc3RhdGUnKSkubWFwKHN0YXRlU2VsZik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGF0ZXMgYmVpbmcgZXhpdGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYW4gYXJyYXkgb2Ygc3RhdGVzIHRoYXQgd2lsbCBiZSBleGl0ZWQgZHVyaW5nIHRoaXMgdHJhbnNpdGlvbi5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5leGl0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEubWFwKHRoaXMuX3RyZWVDaGFuZ2VzLmV4aXRpbmcsIGhvZl8xLnByb3AoJ3N0YXRlJykpLm1hcChzdGF0ZVNlbGYpLnJldmVyc2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN0YXRlcyBiZWluZyByZXRhaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIHN0YXRlcyB0aGF0IGFyZSBhbHJlYWR5IGVudGVyZWQgZnJvbSBhIHByZXZpb3VzIFRyYW5zaXRpb24sIHRoYXQgd2lsbCBub3QgYmVcbiAgICAgKiAgICBleGl0ZWQgZHVyaW5nIHRoaXMgVHJhbnNpdGlvblxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLnJldGFpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEubWFwKHRoaXMuX3RyZWVDaGFuZ2VzLnJldGFpbmVkLCBob2ZfMS5wcm9wKCdzdGF0ZScpKS5tYXAoc3RhdGVTZWxmKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgW1tWaWV3Q29uZmlnXV1zIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFRyYW5zaXRpb25cbiAgICAgKlxuICAgICAqIEVhY2ggc3RhdGUgY2FuIGRlZmluZSBvbmUgb3IgbW9yZSB2aWV3cyAodGVtcGxhdGUvY29udHJvbGxlciksIHdoaWNoIGFyZSBlbmNhcHN1bGF0ZWQgYXMgYFZpZXdDb25maWdgIG9iamVjdHMuXG4gICAgICogVGhpcyBtZXRob2QgZmV0Y2hlcyB0aGUgYFZpZXdDb25maWdzYCBmb3IgYSBnaXZlbiBwYXRoIGluIHRoZSBUcmFuc2l0aW9uIChlLmcuLCBcInRvXCIgb3IgXCJlbnRlcmluZ1wiKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRobmFtZSB0aGUgbmFtZSBvZiB0aGUgcGF0aCB0byBmZXRjaCB2aWV3cyBmb3I6XG4gICAgICogICAoYCd0bydgLCBgJ2Zyb20nYCwgYCdlbnRlcmluZydgLCBgJ2V4aXRpbmcnYCwgYCdyZXRhaW5lZCdgKVxuICAgICAqIEBwYXJhbSBzdGF0ZSBJZiBwcm92aWRlZCwgb25seSByZXR1cm5zIHRoZSBgVmlld0NvbmZpZ2BzIGZvciBhIHNpbmdsZSBzdGF0ZSBpbiB0aGUgcGF0aFxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBsaXN0IG9mIFZpZXdDb25maWcgb2JqZWN0cyBmb3IgdGhlIGdpdmVuIHBhdGguXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUudmlld3MgPSBmdW5jdGlvbiAocGF0aG5hbWUsIHN0YXRlKSB7XG4gICAgICAgIGlmIChwYXRobmFtZSA9PT0gdm9pZCAwKSB7IHBhdGhuYW1lID0gXCJlbnRlcmluZ1wiOyB9XG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5fdHJlZUNoYW5nZXNbcGF0aG5hbWVdO1xuICAgICAgICBwYXRoID0gIXN0YXRlID8gcGF0aCA6IHBhdGguZmlsdGVyKGhvZl8xLnByb3BFcSgnc3RhdGUnLCBzdGF0ZSkpO1xuICAgICAgICByZXR1cm4gcGF0aC5tYXAoaG9mXzEucHJvcChcInZpZXdzXCIpKS5maWx0ZXIoY29tbW9uXzEuaWRlbnRpdHkpLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSk7XG4gICAgfTtcbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS50cmVlQ2hhbmdlcyA9IGZ1bmN0aW9uIChwYXRobmFtZSkge1xuICAgICAgICByZXR1cm4gcGF0aG5hbWUgPyB0aGlzLl90cmVlQ2hhbmdlc1twYXRobmFtZV0gOiB0aGlzLl90cmVlQ2hhbmdlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdHJhbnNpdGlvbiB0aGF0IGlzIGEgcmVkaXJlY3Rpb24gb2YgdGhlIGN1cnJlbnQgb25lLlxuICAgICAqXG4gICAgICogVGhpcyB0cmFuc2l0aW9uIGNhbiBiZSByZXR1cm5lZCBmcm9tIGEgW1tUcmFuc2l0aW9uU2VydmljZV1dIGhvb2sgdG9cbiAgICAgKiByZWRpcmVjdCBhIHRyYW5zaXRpb24gdG8gYSBuZXcgc3RhdGUgYW5kL29yIHNldCBvZiBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogQGludGVybmFsYXBpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGEgbmV3IFtbVHJhbnNpdGlvbl1dIGluc3RhbmNlLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLnJlZGlyZWN0ID0gZnVuY3Rpb24gKHRhcmdldFN0YXRlKSB7XG4gICAgICAgIHZhciByZWRpcmVjdHMgPSAxLCB0cmFucyA9IHRoaXM7XG4gICAgICAgIHdoaWxlICgodHJhbnMgPSB0cmFucy5yZWRpcmVjdGVkRnJvbSgpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoKytyZWRpcmVjdHMgPiAyMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb28gbWFueSBjb25zZWN1dGl2ZSBUcmFuc2l0aW9uIHJlZGlyZWN0cyAoMjArKVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVkaXJlY3RPcHRzID0geyByZWRpcmVjdGVkRnJvbTogdGhpcywgc291cmNlOiBcInJlZGlyZWN0XCIgfTtcbiAgICAgICAgLy8gSWYgdGhlIG9yaWdpbmFsIHRyYW5zaXRpb24gd2FzIGNhdXNlZCBieSBVUkwgc3luYywgdGhlbiB1c2UgeyBsb2NhdGlvbjogJ3JlcGxhY2UnIH1cbiAgICAgICAgLy8gb24gdGhlIG5ldyB0cmFuc2l0aW9uICh1bmxlc3MgdGhlIHRhcmdldCBzdGF0ZSBleHBsaWNpdGx5IHNwZWNpZmllcyBsb2NhdGlvbjogZmFsc2UpLlxuICAgICAgICAvLyBUaGlzIGNhdXNlcyB0aGUgb3JpZ2luYWwgdXJsIHRvIGJlIHJlcGxhY2VkIHdpdGggdGhlIHVybCBmb3IgdGhlIHJlZGlyZWN0IHRhcmdldFxuICAgICAgICAvLyBzbyB0aGUgb3JpZ2luYWwgdXJsIGRpc2FwcGVhcnMgZnJvbSB0aGUgYnJvd3NlciBoaXN0b3J5LlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zKCkuc291cmNlID09PSAndXJsJyAmJiB0YXJnZXRTdGF0ZS5vcHRpb25zKCkubG9jYXRpb24gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZWRpcmVjdE9wdHMubG9jYXRpb24gPSAncmVwbGFjZSc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld09wdGlvbnMgPSBjb21tb25fMS5leHRlbmQoe30sIHRoaXMub3B0aW9ucygpLCB0YXJnZXRTdGF0ZS5vcHRpb25zKCksIHJlZGlyZWN0T3B0cyk7XG4gICAgICAgIHRhcmdldFN0YXRlID0gdGFyZ2V0U3RhdGUud2l0aE9wdGlvbnMobmV3T3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIHZhciBuZXdUcmFuc2l0aW9uID0gdGhpcy5yb3V0ZXIudHJhbnNpdGlvblNlcnZpY2UuY3JlYXRlKHRoaXMuX3RyZWVDaGFuZ2VzLmZyb20sIHRhcmdldFN0YXRlKTtcbiAgICAgICAgdmFyIG9yaWdpbmFsRW50ZXJpbmdOb2RlcyA9IHRoaXMuX3RyZWVDaGFuZ2VzLmVudGVyaW5nO1xuICAgICAgICB2YXIgcmVkaXJlY3RFbnRlcmluZ05vZGVzID0gbmV3VHJhbnNpdGlvbi5fdHJlZUNoYW5nZXMuZW50ZXJpbmc7XG4gICAgICAgIC8vIC0tLSBSZS11c2UgcmVzb2x2ZSBkYXRhIGZyb20gb3JpZ2luYWwgdHJhbnNpdGlvbiAtLS1cbiAgICAgICAgLy8gV2hlbiByZWRpcmVjdGluZyBmcm9tIGEgcGFyZW50IHN0YXRlIHRvIGEgY2hpbGQgc3RhdGUgd2hlcmUgdGhlIHBhcmVudCBwYXJhbWV0ZXIgdmFsdWVzIGhhdmVuJ3QgY2hhbmdlZFxuICAgICAgICAvLyAoYmVjYXVzZSBvZiB0aGUgcmVkaXJlY3QpLCB0aGUgcmVzb2x2ZXMgZmV0Y2hlZCBieSB0aGUgb3JpZ2luYWwgdHJhbnNpdGlvbiBhcmUgc3RpbGwgdmFsaWQgaW4gdGhlXG4gICAgICAgIC8vIHJlZGlyZWN0ZWQgdHJhbnNpdGlvbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhpcyBhbGxvd3MgeW91IHRvIGRlZmluZSBhIHJlZGlyZWN0IG9uIGEgcGFyZW50IHN0YXRlIHdoaWNoIGRlcGVuZHMgb24gYW4gYXN5bmMgcmVzb2x2ZSB2YWx1ZS5cbiAgICAgICAgLy8gWW91IGNhbiB3YWl0IGZvciB0aGUgcmVzb2x2ZSwgdGhlbiByZWRpcmVjdCB0byBhIGNoaWxkIHN0YXRlIGJhc2VkIG9uIHRoZSByZXN1bHQuXG4gICAgICAgIC8vIFRoZSByZWRpcmVjdGVkIHRyYW5zaXRpb24gZG9lcyBub3QgaGF2ZSB0byByZS1mZXRjaCB0aGUgcmVzb2x2ZS5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHZhciBub2RlSXNSZWxvYWRpbmcgPSBmdW5jdGlvbiAocmVsb2FkU3RhdGUpIHsgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVsb2FkU3RhdGUgJiYgbm9kZS5zdGF0ZS5pbmNsdWRlc1tyZWxvYWRTdGF0ZS5uYW1lXTtcbiAgICAgICAgfTsgfTtcbiAgICAgICAgLy8gRmluZCBhbnkgXCJlbnRlcmluZ1wiIG5vZGVzIGluIHRoZSByZWRpcmVjdCBwYXRoIHRoYXQgbWF0Y2ggdGhlIG9yaWdpbmFsIHBhdGggYW5kIGFyZW4ndCBiZWluZyByZWxvYWRlZFxuICAgICAgICB2YXIgbWF0Y2hpbmdFbnRlcmluZ05vZGVzID0gcGF0aEZhY3RvcnlfMS5QYXRoVXRpbHMubWF0Y2hpbmcocmVkaXJlY3RFbnRlcmluZ05vZGVzLCBvcmlnaW5hbEVudGVyaW5nTm9kZXMsIHBhdGhGYWN0b3J5XzEuUGF0aFV0aWxzLm5vbkR5bmFtaWNQYXJhbXMpXG4gICAgICAgICAgICAuZmlsdGVyKGhvZl8xLm5vdChub2RlSXNSZWxvYWRpbmcodGFyZ2V0U3RhdGUub3B0aW9ucygpLnJlbG9hZFN0YXRlKSkpO1xuICAgICAgICAvLyBVc2UgdGhlIGV4aXN0aW5nIChwb3NzaWJseSBwcmUtcmVzb2x2ZWQpIHJlc29sdmFibGVzIGZvciB0aGUgbWF0Y2hpbmcgZW50ZXJpbmcgbm9kZXMuXG4gICAgICAgIG1hdGNoaW5nRW50ZXJpbmdOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlLCBpZHgpIHtcbiAgICAgICAgICAgIG5vZGUucmVzb2x2YWJsZXMgPSBvcmlnaW5hbEVudGVyaW5nTm9kZXNbaWR4XS5yZXNvbHZhYmxlcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXdUcmFuc2l0aW9uO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gSWYgYSB0cmFuc2l0aW9uIGRvZXNuJ3QgZXhpdC9lbnRlciBhbnkgc3RhdGVzLCByZXR1cm5zIGFueSBbW1BhcmFtXV0gd2hvc2UgdmFsdWUgY2hhbmdlZCAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLl9jaGFuZ2VkUGFyYW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGMgPSB0aGlzLl90cmVlQ2hhbmdlcztcbiAgICAgICAgLyoqIFJldHVybiB1bmRlZmluZWQgaWYgaXQncyBub3QgYSBcImR5bmFtaWNcIiB0cmFuc2l0aW9uLCBmb3IgdGhlIGZvbGxvd2luZyByZWFzb25zICovXG4gICAgICAgIC8vIElmIHVzZXIgZXhwbGljaXRseSB3YW50cyBhIHJlbG9hZFxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5yZWxvYWQpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAvLyBJZiBhbnkgc3RhdGVzIGFyZSBleGl0aW5nIG9yIGVudGVyaW5nXG4gICAgICAgIGlmICh0Yy5leGl0aW5nLmxlbmd0aCB8fCB0Yy5lbnRlcmluZy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAvLyBJZiB0by9mcm9tIHBhdGggbGVuZ3RocyBkaWZmZXJcbiAgICAgICAgaWYgKHRjLnRvLmxlbmd0aCAhPT0gdGMuZnJvbS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAvLyBJZiB0aGUgdG8vZnJvbSBwYXRocyBhcmUgZGlmZmVyZW50XG4gICAgICAgIHZhciBwYXRoc0RpZmZlciA9IGNvbW1vbl8xLmFycmF5VHVwbGVzKHRjLnRvLCB0Yy5mcm9tKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodHVwbGUpIHsgcmV0dXJuIHR1cGxlWzBdLnN0YXRlICE9PSB0dXBsZVsxXS5zdGF0ZTsgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoY29tbW9uXzEuYW55VHJ1ZVIsIGZhbHNlKTtcbiAgICAgICAgaWYgKHBhdGhzRGlmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgLy8gRmluZCBhbnkgcGFyYW1ldGVyIHZhbHVlcyB0aGF0IGRpZmZlclxuICAgICAgICB2YXIgbm9kZVNjaGVtYXMgPSB0Yy50by5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUucGFyYW1TY2hlbWE7IH0pO1xuICAgICAgICB2YXIgX2EgPSBbdGMudG8sIHRjLmZyb21dLm1hcChmdW5jdGlvbiAocGF0aCkgeyByZXR1cm4gcGF0aC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgucGFyYW1WYWx1ZXM7IH0pOyB9KSwgdG9WYWx1ZXMgPSBfYVswXSwgZnJvbVZhbHVlcyA9IF9hWzFdO1xuICAgICAgICB2YXIgdHVwbGVzID0gY29tbW9uXzEuYXJyYXlUdXBsZXMobm9kZVNjaGVtYXMsIHRvVmFsdWVzLCBmcm9tVmFsdWVzKTtcbiAgICAgICAgcmV0dXJuIHR1cGxlcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgc2NoZW1hID0gX2FbMF0sIHRvVmFscyA9IF9hWzFdLCBmcm9tVmFscyA9IF9hWzJdO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtXzEuUGFyYW0uY2hhbmdlZChzY2hlbWEsIHRvVmFscywgZnJvbVZhbHMpO1xuICAgICAgICB9KS5yZWR1Y2UoY29tbW9uXzEudW5uZXN0UiwgW10pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2l0aW9uIGlzIGR5bmFtaWMuXG4gICAgICpcbiAgICAgKiBBIHRyYW5zaXRpb24gaXMgZHluYW1pYyBpZiBubyBzdGF0ZXMgYXJlIGVudGVyZWQgbm9yIGV4aXRlZCwgYnV0IGF0IGxlYXN0IG9uZSBkeW5hbWljIHBhcmFtZXRlciBoYXMgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIFRyYW5zaXRpb24gaXMgZHluYW1pY1xuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmR5bmFtaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGFuZ2VzID0gdGhpcy5fY2hhbmdlZFBhcmFtcygpO1xuICAgICAgICByZXR1cm4gIWNoYW5nZXMgPyBmYWxzZSA6IGNoYW5nZXMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmR5bmFtaWM7IH0pLnJlZHVjZShjb21tb25fMS5hbnlUcnVlUiwgZmFsc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2l0aW9uIGlzIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBBIHRyYW5zaXRpb24gaXMgaWdub3JlZCBpZiBubyBzdGF0ZXMgYXJlIGVudGVyZWQgbm9yIGV4aXRlZCwgYW5kIG5vIHBhcmFtZXRlciB2YWx1ZXMgaGF2ZSBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgVHJhbnNpdGlvbiBpcyBpZ25vcmVkLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmlnbm9yZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2lnbm9yZWRSZWFzb24oKTtcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuX2lnbm9yZWRSZWFzb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwZW5kaW5nID0gdGhpcy5yb3V0ZXIuZ2xvYmFscy50cmFuc2l0aW9uO1xuICAgICAgICB2YXIgcmVsb2FkU3RhdGUgPSB0aGlzLl9vcHRpb25zLnJlbG9hZFN0YXRlO1xuICAgICAgICB2YXIgc2FtZSA9IGZ1bmN0aW9uIChwYXRoQSwgcGF0aEIpIHtcbiAgICAgICAgICAgIGlmIChwYXRoQS5sZW5ndGggIT09IHBhdGhCLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbWF0Y2hpbmcgPSBwYXRoRmFjdG9yeV8xLlBhdGhVdGlscy5tYXRjaGluZyhwYXRoQSwgcGF0aEIpO1xuICAgICAgICAgICAgcmV0dXJuIHBhdGhBLmxlbmd0aCA9PT0gbWF0Y2hpbmcuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiAhcmVsb2FkU3RhdGUgfHwgIW5vZGUuc3RhdGUuaW5jbHVkZXNbcmVsb2FkU3RhdGUubmFtZV07IH0pLmxlbmd0aDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG5ld1RDID0gdGhpcy50cmVlQ2hhbmdlcygpO1xuICAgICAgICB2YXIgcGVuZFRDID0gcGVuZGluZyAmJiBwZW5kaW5nLnRyZWVDaGFuZ2VzKCk7XG4gICAgICAgIGlmIChwZW5kVEMgJiYgc2FtZShwZW5kVEMudG8sIG5ld1RDLnRvKSAmJiBzYW1lKHBlbmRUQy5leGl0aW5nLCBuZXdUQy5leGl0aW5nKSlcbiAgICAgICAgICAgIHJldHVybiBcIlNhbWVBc1BlbmRpbmdcIjtcbiAgICAgICAgaWYgKG5ld1RDLmV4aXRpbmcubGVuZ3RoID09PSAwICYmIG5ld1RDLmVudGVyaW5nLmxlbmd0aCA9PT0gMCAmJiBzYW1lKG5ld1RDLmZyb20sIG5ld1RDLnRvKSlcbiAgICAgICAgICAgIHJldHVybiBcIlNhbWVBc0N1cnJlbnRcIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIHRyYW5zaXRpb25cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGdlbmVyYWxseSBjYWxsZWQgZnJvbSB0aGUgW1tTdGF0ZVNlcnZpY2UudHJhbnNpdGlvblRvXV1cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbGFwaVxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBwcm9taXNlIGZvciBhIHN1Y2Nlc3NmdWwgdHJhbnNpdGlvbi5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBydW5BbGxIb29rcyA9IHRyYW5zaXRpb25Ib29rXzEuVHJhbnNpdGlvbkhvb2sucnVuQWxsSG9va3M7XG4gICAgICAgIC8vIEdldHMgdHJhbnNpdGlvbiBob29rcyBhcnJheSBmb3IgdGhlIGdpdmVuIHBoYXNlXG4gICAgICAgIHZhciBnZXRIb29rc0ZvciA9IGZ1bmN0aW9uIChwaGFzZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9ob29rQnVpbGRlci5idWlsZEhvb2tzRm9yUGhhc2UocGhhc2UpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBXaGVuIHRoZSBjaGFpbiBpcyBjb21wbGV0ZSwgdGhlbiByZXNvbHZlIG9yIHJlamVjdCB0aGUgZGVmZXJyZWRcbiAgICAgICAgdmFyIHRyYW5zaXRpb25TdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJhY2VfMS50cmFjZS50cmFjZVN1Y2Nlc3MoX3RoaXMuJHRvKCksIF90aGlzKTtcbiAgICAgICAgICAgIF90aGlzLnN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuX2RlZmVycmVkLnJlc29sdmUoX3RoaXMudG8oKSk7XG4gICAgICAgICAgICBydW5BbGxIb29rcyhnZXRIb29rc0ZvcihpbnRlcmZhY2VfMS5UcmFuc2l0aW9uSG9va1BoYXNlLlNVQ0NFU1MpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRyYW5zaXRpb25FcnJvciA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VFcnJvcihyZWFzb24sIF90aGlzKTtcbiAgICAgICAgICAgIF90aGlzLnN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLl9kZWZlcnJlZC5yZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgIF90aGlzLl9lcnJvciA9IHJlYXNvbjtcbiAgICAgICAgICAgIHJ1bkFsbEhvb2tzKGdldEhvb2tzRm9yKGludGVyZmFjZV8xLlRyYW5zaXRpb25Ib29rUGhhc2UuRVJST1IpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJ1blRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBXYWl0IHRvIGJ1aWxkIHRoZSBSVU4gaG9vayBjaGFpbiB1bnRpbCB0aGUgQkVGT1JFIGhvb2tzIGFyZSBkb25lXG4gICAgICAgICAgICAvLyBUaGlzIGFsbG93cyBhIEJFRk9SRSBob29rIHRvIGR5bmFtaWNhbGx5IGFkZCBhZGRpdGlvbmFsIFJVTiBob29rcyB2aWEgdGhlIFRyYW5zaXRpb24gb2JqZWN0LlxuICAgICAgICAgICAgdmFyIGFsbFJ1bkhvb2tzID0gZ2V0SG9va3NGb3IoaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tQaGFzZS5SVU4pO1xuICAgICAgICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS53aGVuKHVuZGVmaW5lZCk7IH07XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNpdGlvbkhvb2tfMS5UcmFuc2l0aW9uSG9vay5pbnZva2VIb29rcyhhbGxSdW5Ib29rcywgZG9uZSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdGFydFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZ2xvYmFscyA9IF90aGlzLnJvdXRlci5nbG9iYWxzO1xuICAgICAgICAgICAgZ2xvYmFscy5sYXN0U3RhcnRlZFRyYW5zaXRpb25JZCA9IF90aGlzLiRpZDtcbiAgICAgICAgICAgIGdsb2JhbHMudHJhbnNpdGlvbiA9IF90aGlzO1xuICAgICAgICAgICAgZ2xvYmFscy50cmFuc2l0aW9uSGlzdG9yeS5lbnF1ZXVlKF90aGlzKTtcbiAgICAgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VUcmFuc2l0aW9uU3RhcnQoX3RoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLndoZW4odW5kZWZpbmVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGFsbEJlZm9yZUhvb2tzID0gZ2V0SG9va3NGb3IoaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tQaGFzZS5CRUZPUkUpO1xuICAgICAgICB0cmFuc2l0aW9uSG9va18xLlRyYW5zaXRpb25Ib29rLmludm9rZUhvb2tzKGFsbEJlZm9yZUhvb2tzLCBzdGFydFRyYW5zaXRpb24pXG4gICAgICAgICAgICAudGhlbihydW5UcmFuc2l0aW9uKVxuICAgICAgICAgICAgLnRoZW4odHJhbnNpdGlvblN1Y2Nlc3MsIHRyYW5zaXRpb25FcnJvcik7XG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIFRyYW5zaXRpb24gaXMgdmFsaWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIFRyYW5zaXRpb24gaXMgdmFsaWRcbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS52YWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmVycm9yKCkgfHwgdGhpcy5zdWNjZXNzICE9PSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBYm9ydHMgdGhpcyB0cmFuc2l0aW9uXG4gICAgICpcbiAgICAgKiBJbXBlcmF0aXZlIEFQSSB0byBhYm9ydCBhIFRyYW5zaXRpb24uXG4gICAgICogVGhpcyBvbmx5IGFwcGxpZXMgdG8gVHJhbnNpdGlvbnMgdGhhdCBhcmUgbm90IHlldCBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRG8gbm90IHNldCBmbGFnIGlmIHRoZSB0cmFuc2l0aW9uIGlzIGFscmVhZHkgY29tcGxldGVcbiAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc1VuZGVmaW5lZCh0aGlzLnN1Y2Nlc3MpKSB7XG4gICAgICAgICAgICB0aGlzLl9hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIFRyYW5zaXRpb24gZXJyb3IgcmVhc29uLlxuICAgICAqXG4gICAgICogSWYgdGhlIHRyYW5zaXRpb24gaXMgaW52YWxpZCAoYW5kIGNvdWxkIG5vdCBiZSBydW4pLCByZXR1cm5zIHRoZSByZWFzb24gdGhlIHRyYW5zaXRpb24gaXMgaW52YWxpZC5cbiAgICAgKiBJZiB0aGUgdHJhbnNpdGlvbiB3YXMgdmFsaWQgYW5kIHJhbiwgYnV0IHdhcyBub3Qgc3VjY2Vzc2Z1bCwgcmV0dXJucyB0aGUgcmVhc29uIHRoZSB0cmFuc2l0aW9uIGZhaWxlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGFuIGVycm9yIG1lc3NhZ2UgZXhwbGFpbmluZyB3aHkgdGhlIHRyYW5zaXRpb24gaXMgaW52YWxpZCwgb3IgdGhlIHJlYXNvbiB0aGUgdHJhbnNpdGlvbiBmYWlsZWQuXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuJHRvKCk7XG4gICAgICAgIGlmIChzdGF0ZS5zZWxmLmFic3RyYWN0KVxuICAgICAgICAgICAgcmV0dXJuIFwiQ2Fubm90IHRyYW5zaXRpb24gdG8gYWJzdHJhY3Qgc3RhdGUgJ1wiICsgc3RhdGUubmFtZSArIFwiJ1wiO1xuICAgICAgICB2YXIgcGFyYW1EZWZzID0gc3RhdGUucGFyYW1ldGVycygpLCB2YWx1ZXMgPSB0aGlzLnBhcmFtcygpO1xuICAgICAgICB2YXIgaW52YWxpZFBhcmFtcyA9IHBhcmFtRGVmcy5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiAhcGFyYW0udmFsaWRhdGVzKHZhbHVlc1twYXJhbS5pZF0pOyB9KTtcbiAgICAgICAgaWYgKGludmFsaWRQYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJQYXJhbSB2YWx1ZXMgbm90IHZhbGlkIGZvciBzdGF0ZSAnXCIgKyBzdGF0ZS5uYW1lICsgXCInLiBJbnZhbGlkIHBhcmFtczogWyBcIiArIGludmFsaWRQYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW0uaWQ7IH0pLmpvaW4oJywgJykgKyBcIiBdXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3VjY2VzcyA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVHJhbnNpdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFRyYW5zaXRpb25cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZyb21TdGF0ZU9yTmFtZSA9IHRoaXMuZnJvbSgpO1xuICAgICAgICB2YXIgdG9TdGF0ZU9yTmFtZSA9IHRoaXMudG8oKTtcbiAgICAgICAgdmFyIGF2b2lkRW1wdHlIYXNoID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuIChwYXJhbXNbXCIjXCJdICE9PSBudWxsICYmIHBhcmFtc1tcIiNcIl0gIT09IHVuZGVmaW5lZCkgPyBwYXJhbXMgOiBjb21tb25fMS5vbWl0KHBhcmFtcywgW1wiI1wiXSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIChYKSBtZWFucyB0aGUgdG8gc3RhdGUgaXMgaW52YWxpZC5cbiAgICAgICAgdmFyIGlkID0gdGhpcy4kaWQsIGZyb20gPSBwcmVkaWNhdGVzXzEuaXNPYmplY3QoZnJvbVN0YXRlT3JOYW1lKSA/IGZyb21TdGF0ZU9yTmFtZS5uYW1lIDogZnJvbVN0YXRlT3JOYW1lLCBmcm9tUGFyYW1zID0gc3RyaW5nc18xLnN0cmluZ2lmeShhdm9pZEVtcHR5SGFzaCh0aGlzLl90cmVlQ2hhbmdlcy5mcm9tLm1hcChob2ZfMS5wcm9wKCdwYXJhbVZhbHVlcycpKS5yZWR1Y2UoY29tbW9uXzEubWVyZ2VSLCB7fSkpKSwgdG9WYWxpZCA9IHRoaXMudmFsaWQoKSA/IFwiXCIgOiBcIihYKSBcIiwgdG8gPSBwcmVkaWNhdGVzXzEuaXNPYmplY3QodG9TdGF0ZU9yTmFtZSkgPyB0b1N0YXRlT3JOYW1lLm5hbWUgOiB0b1N0YXRlT3JOYW1lLCB0b1BhcmFtcyA9IHN0cmluZ3NfMS5zdHJpbmdpZnkoYXZvaWRFbXB0eUhhc2godGhpcy5wYXJhbXMoKSkpO1xuICAgICAgICByZXR1cm4gXCJUcmFuc2l0aW9uI1wiICsgaWQgKyBcIiggJ1wiICsgZnJvbSArIFwiJ1wiICsgZnJvbVBhcmFtcyArIFwiIC0+IFwiICsgdG9WYWxpZCArIFwiJ1wiICsgdG8gKyBcIidcIiArIHRvUGFyYW1zICsgXCIgKVwiO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBUcmFuc2l0aW9uLmRpVG9rZW4gPSBUcmFuc2l0aW9uO1xuICAgIHJldHVybiBUcmFuc2l0aW9uO1xufSgpKTtcbmV4cG9ydHMuVHJhbnNpdGlvbiA9IFRyYW5zaXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2l0aW9uLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi90cmFuc2l0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///18\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module url\n */\n/** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar hof_1 = __webpack_require__(/*! ../common/hof */ 2);\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ 1);\nvar param_1 = __webpack_require__(/*! ../params/param */ 8);\nvar strings_1 = __webpack_require__(/*! ../common/strings */ 6);\n/** @hidden */\nfunction quoteRegExp(string, param) {\n    var surroundPattern = ['', ''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!param)\n        return result;\n    switch (param.squash) {\n        case false:\n            surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];\n            break;\n        case true:\n            result = result.replace(/\\/$/, '');\n            surroundPattern = ['(?:\\/(', ')|\\/)?'];\n            break;\n        default:\n            surroundPattern = [\"(\" + param.squash + \"|\", ')?'];\n            break;\n    }\n    return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];\n}\n/** @hidden */\nvar memoizeTo = function (obj, prop, fn) {\n    return obj[prop] = obj[prop] || fn();\n};\n/** @hidden */\nvar splitOnSlash = strings_1.splitOnDelim('/');\n/**\n * Matches URLs against patterns.\n *\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL.\n *\n * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)\n * parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by [[UrlMatcher.exec]].\n *\n * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)\n * or colon placeholders (`/somePath/:param`).\n *\n * - *A parameter RegExp* may be defined for a param after a colon\n * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.\n * The regexp must match for the url to be matched.\n * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].\n *\n * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.\n *   See [[UrlMatcherFactory.type]] for more information.\n *\n * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).\n *   A catch-all * parameter value will contain the remainder of the URL.\n *\n * ---\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters).\n * A path parameter matches any number of characters other than '/'. For catch-all\n * placeholders the path parameter matches any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n */\nvar UrlMatcher = /** @class */ (function () {\n    /**\n     * @param pattern The pattern to compile into a matcher.\n     * @param paramTypes The [[ParamTypes]] registry\n     * @param config  A configuration object\n     * - `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n     * - `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n     */\n    function UrlMatcher(pattern, paramTypes, paramFactory, config) {\n        var _this = this;\n        this.config = config;\n        /** @hidden */\n        this._cache = { path: [this] };\n        /** @hidden */\n        this._children = [];\n        /** @hidden */\n        this._params = [];\n        /** @hidden */\n        this._segments = [];\n        /** @hidden */\n        this._compiled = [];\n        this.pattern = pattern;\n        this.config = common_1.defaults(this.config, {\n            params: {},\n            strict: true,\n            caseInsensitive: false,\n            paramMap: common_1.identity\n        });\n        // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n        //   '*' name\n        //   ':' name\n        //   '{' name '}'\n        //   '{' name ':' regexp '}'\n        // The regular expression is somewhat complicated due to the need to allow curly braces\n        // inside the regular expression. The placeholder regexp breaks down as follows:\n        //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n        //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n        //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n        //    [^{}\\\\]+                       - anything other than curly braces or backslash\n        //    \\\\.                            - a backslash escape\n        //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n        var placeholder = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g, last = 0, m, patterns = [];\n        var checkParamErrors = function (id) {\n            if (!UrlMatcher.nameValidator.test(id))\n                throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n            if (common_1.find(_this._params, hof_1.propEq('id', id)))\n                throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n        };\n        // Split into static segments separated by path parameter placeholders.\n        // The number of segments is always 1 more than the number of parameters.\n        var matchDetails = function (m, isSearch) {\n            // IE[78] returns '' for unmatched groups instead of null\n            var id = m[2] || m[3];\n            var regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '[\\\\s\\\\S]*' : null);\n            var makeRegexpType = function (regexp) { return common_1.inherit(paramTypes.type(isSearch ? \"query\" : \"path\"), {\n                pattern: new RegExp(regexp, _this.config.caseInsensitive ? 'i' : undefined)\n            }); };\n            return {\n                id: id,\n                regexp: regexp,\n                cfg: _this.config.params[id],\n                segment: pattern.substring(last, m.index),\n                type: !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp)\n            };\n        };\n        var p, segment;\n        while ((m = placeholder.exec(pattern))) {\n            p = matchDetails(m, false);\n            if (p.segment.indexOf('?') >= 0)\n                break; // we're into the search part\n            checkParamErrors(p.id);\n            this._params.push(paramFactory.fromPath(p.id, p.type, this.config.paramMap(p.cfg, false)));\n            this._segments.push(p.segment);\n            patterns.push([p.segment, common_1.tail(this._params)]);\n            last = placeholder.lastIndex;\n        }\n        segment = pattern.substring(last);\n        // Find any search parameter names and remove them from the last segment\n        var i = segment.indexOf('?');\n        if (i >= 0) {\n            var search = segment.substring(i);\n            segment = segment.substring(0, i);\n            if (search.length > 0) {\n                last = 0;\n                while ((m = searchPlaceholder.exec(search))) {\n                    p = matchDetails(m, true);\n                    checkParamErrors(p.id);\n                    this._params.push(paramFactory.fromSearch(p.id, p.type, this.config.paramMap(p.cfg, true)));\n                    last = placeholder.lastIndex;\n                    // check if ?&\n                }\n            }\n        }\n        this._segments.push(segment);\n        this._compiled = patterns.map(function (pattern) { return quoteRegExp.apply(null, pattern); }).concat(quoteRegExp(segment));\n    }\n    /**\n     * Creates a new concatenated UrlMatcher\n     *\n     * Builds a new UrlMatcher by appending another UrlMatcher to this one.\n     *\n     * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.\n     */\n    UrlMatcher.prototype.append = function (url) {\n        this._children.push(url);\n        url._cache = {\n            path: this._cache.path.concat(url),\n            parent: this,\n            pattern: null,\n        };\n        return url;\n    };\n    /** @hidden */\n    UrlMatcher.prototype.isRoot = function () {\n        return this._cache.path[0] === this;\n    };\n    /** Returns the input pattern string */\n    UrlMatcher.prototype.toString = function () {\n        return this.pattern;\n    };\n    /**\n     * Tests the specified url/path against this matcher.\n     *\n     * Tests if the given url matches this matcher's pattern, and returns an object containing the captured\n     * parameter values.  Returns null if the path does not match.\n     *\n     * The returned object contains the values\n     * of any search parameters that are mentioned in the pattern, but their value may be null if\n     * they are not present in `search`. This means that search parameters are always treated\n     * as optional.\n     *\n     * #### Example:\n     * ```js\n     * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n     *   x: '1', q: 'hello'\n     * });\n     * // returns { id: 'bob', q: 'hello', r: null }\n     * ```\n     *\n     * @param path    The URL path to match, e.g. `$location.path()`.\n     * @param search  URL search parameters, e.g. `$location.search()`.\n     * @param hash    URL hash e.g. `$location.hash()`.\n     * @param options\n     *\n     * @returns The captured parameter values.\n     */\n    UrlMatcher.prototype.exec = function (path, search, hash, options) {\n        var _this = this;\n        if (search === void 0) { search = {}; }\n        if (options === void 0) { options = {}; }\n        var match = memoizeTo(this._cache, 'pattern', function () {\n            return new RegExp([\n                '^',\n                common_1.unnest(_this._cache.path.map(hof_1.prop('_compiled'))).join(''),\n                _this.config.strict === false ? '\\/?' : '',\n                '$'\n            ].join(''), _this.config.caseInsensitive ? 'i' : undefined);\n        }).exec(path);\n        if (!match)\n            return null;\n        //options = defaults(options, { isolate: false });\n        var allParams = this.parameters(), pathParams = allParams.filter(function (param) { return !param.isSearch(); }), searchParams = allParams.filter(function (param) { return param.isSearch(); }), nPathSegments = this._cache.path.map(function (urlm) { return urlm._segments.length - 1; }).reduce(function (a, x) { return a + x; }), values = {};\n        if (nPathSegments !== match.length - 1)\n            throw new Error(\"Unbalanced capture group in route '\" + this.pattern + \"'\");\n        function decodePathArray(string) {\n            var reverseString = function (str) { return str.split(\"\").reverse().join(\"\"); };\n            var unquoteDashes = function (str) { return str.replace(/\\\\-/g, \"-\"); };\n            var split = reverseString(string).split(/-(?!\\\\)/);\n            var allReversed = common_1.map(split, reverseString);\n            return common_1.map(allReversed, unquoteDashes).reverse();\n        }\n        for (var i = 0; i < nPathSegments; i++) {\n            var param = pathParams[i];\n            var value = match[i + 1];\n            // if the param value matches a pre-replace pair, replace the value before decoding.\n            for (var j = 0; j < param.replace.length; j++) {\n                if (param.replace[j].from === value)\n                    value = param.replace[j].to;\n            }\n            if (value && param.array === true)\n                value = decodePathArray(value);\n            if (predicates_1.isDefined(value))\n                value = param.type.decode(value);\n            values[param.id] = param.value(value);\n        }\n        searchParams.forEach(function (param) {\n            var value = search[param.id];\n            for (var j = 0; j < param.replace.length; j++) {\n                if (param.replace[j].from === value)\n                    value = param.replace[j].to;\n            }\n            if (predicates_1.isDefined(value))\n                value = param.type.decode(value);\n            values[param.id] = param.value(value);\n        });\n        if (hash)\n            values[\"#\"] = hash;\n        return values;\n    };\n    /**\n     * @hidden\n     * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.\n     *\n     * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the\n     *    pattern has no parameters, an empty array is returned.\n     */\n    UrlMatcher.prototype.parameters = function (opts) {\n        if (opts === void 0) { opts = {}; }\n        if (opts.inherit === false)\n            return this._params;\n        return common_1.unnest(this._cache.path.map(function (matcher) { return matcher._params; }));\n    };\n    /**\n     * @hidden\n     * Returns a single parameter from this UrlMatcher by id\n     *\n     * @param id\n     * @param opts\n     * @returns {T|Param|any|boolean|UrlMatcher|null}\n     */\n    UrlMatcher.prototype.parameter = function (id, opts) {\n        var _this = this;\n        if (opts === void 0) { opts = {}; }\n        var findParam = function () {\n            for (var _i = 0, _a = _this._params; _i < _a.length; _i++) {\n                var param = _a[_i];\n                if (param.id === id)\n                    return param;\n            }\n        };\n        var parent = this._cache.parent;\n        return findParam() || (opts.inherit !== false && parent && parent.parameter(id, opts)) || null;\n    };\n    /**\n     * Validates the input parameter values against this UrlMatcher\n     *\n     * Checks an object hash of parameters to validate their correctness according to the parameter\n     * types of this `UrlMatcher`.\n     *\n     * @param params The object hash of parameters to validate.\n     * @returns Returns `true` if `params` validates, otherwise `false`.\n     */\n    UrlMatcher.prototype.validates = function (params) {\n        var validParamVal = function (param, val) {\n            return !param || param.validates(val);\n        };\n        params = params || {};\n        // I'm not sure why this checks only the param keys passed in, and not all the params known to the matcher\n        var paramSchema = this.parameters().filter(function (paramDef) { return params.hasOwnProperty(paramDef.id); });\n        return paramSchema.map(function (paramDef) { return validParamVal(paramDef, params[paramDef.id]); }).reduce(common_1.allTrueR, true);\n    };\n    /**\n     * Given a set of parameter values, creates a URL from this UrlMatcher.\n     *\n     * Creates a URL that matches this pattern by substituting the specified values\n     * for the path and search parameters.\n     *\n     * #### Example:\n     * ```js\n     * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n     * // returns '/user/bob?q=yes'\n     * ```\n     *\n     * @param values  the values to substitute for the parameters in this pattern.\n     * @returns the formatted URL (path and optionally search part).\n     */\n    UrlMatcher.prototype.format = function (values) {\n        if (values === void 0) { values = {}; }\n        // Build the full path of UrlMatchers (including all parent UrlMatchers)\n        var urlMatchers = this._cache.path;\n        // Extract all the static segments and Params (processed as ParamDetails)\n        // into an ordered array\n        var pathSegmentsAndParams = urlMatchers.map(UrlMatcher.pathSegmentsAndParams)\n            .reduce(common_1.unnestR, [])\n            .map(function (x) { return predicates_1.isString(x) ? x : getDetails(x); });\n        // Extract the query params into a separate array\n        var queryParams = urlMatchers.map(UrlMatcher.queryParams)\n            .reduce(common_1.unnestR, [])\n            .map(getDetails);\n        var isInvalid = function (param) { return param.isValid === false; };\n        if (pathSegmentsAndParams.concat(queryParams).filter(isInvalid).length) {\n            return null;\n        }\n        /**\n         * Given a Param, applies the parameter value, then returns detailed information about it\n         */\n        function getDetails(param) {\n            // Normalize to typed value\n            var value = param.value(values[param.id]);\n            var isValid = param.validates(value);\n            var isDefaultValue = param.isDefaultValue(value);\n            // Check if we're in squash mode for the parameter\n            var squash = isDefaultValue ? param.squash : false;\n            // Allow the Parameter's Type to encode the value\n            var encoded = param.type.encode(value);\n            return { param: param, value: value, isValid: isValid, isDefaultValue: isDefaultValue, squash: squash, encoded: encoded };\n        }\n        // Build up the path-portion from the list of static segments and parameters\n        var pathString = pathSegmentsAndParams.reduce(function (acc, x) {\n            // The element is a static segment (a raw string); just append it\n            if (predicates_1.isString(x))\n                return acc + x;\n            // Otherwise, it's a ParamDetails.\n            var squash = x.squash, encoded = x.encoded, param = x.param;\n            // If squash is === true, try to remove a slash from the path\n            if (squash === true)\n                return (acc.match(/\\/$/)) ? acc.slice(0, -1) : acc;\n            // If squash is a string, use the string for the param value\n            if (predicates_1.isString(squash))\n                return acc + squash;\n            if (squash !== false)\n                return acc; // ?\n            if (encoded == null)\n                return acc;\n            // If this parameter value is an array, encode the value using encodeDashes\n            if (predicates_1.isArray(encoded))\n                return acc + common_1.map(encoded, UrlMatcher.encodeDashes).join(\"-\");\n            // If the parameter type is \"raw\", then do not encodeURIComponent\n            if (param.raw)\n                return acc + encoded;\n            // Encode the value\n            return acc + encodeURIComponent(encoded);\n        }, \"\");\n        // Build the query string by applying parameter values (array or regular)\n        // then mapping to key=value, then flattening and joining using \"&\"\n        var queryString = queryParams.map(function (paramDetails) {\n            var param = paramDetails.param, squash = paramDetails.squash, encoded = paramDetails.encoded, isDefaultValue = paramDetails.isDefaultValue;\n            if (encoded == null || (isDefaultValue && squash !== false))\n                return;\n            if (!predicates_1.isArray(encoded))\n                encoded = [encoded];\n            if (encoded.length === 0)\n                return;\n            if (!param.raw)\n                encoded = common_1.map(encoded, encodeURIComponent);\n            return encoded.map(function (val) { return param.id + \"=\" + val; });\n        }).filter(common_1.identity).reduce(common_1.unnestR, []).join(\"&\");\n        // Concat the pathstring with the queryString (if exists) and the hashString (if exists)\n        return pathString + (queryString ? \"?\" + queryString : \"\") + (values[\"#\"] ? \"#\" + values[\"#\"] : \"\");\n    };\n    /** @hidden */\n    UrlMatcher.encodeDashes = function (str) {\n        return encodeURIComponent(str).replace(/-/g, function (c) { return \"%5C%\" + c.charCodeAt(0).toString(16).toUpperCase(); });\n    };\n    /** @hidden Given a matcher, return an array with the matcher's path segments and path params, in order */\n    UrlMatcher.pathSegmentsAndParams = function (matcher) {\n        var staticSegments = matcher._segments;\n        var pathParams = matcher._params.filter(function (p) { return p.location === param_1.DefType.PATH; });\n        return common_1.arrayTuples(staticSegments, pathParams.concat(undefined))\n            .reduce(common_1.unnestR, [])\n            .filter(function (x) { return x !== \"\" && predicates_1.isDefined(x); });\n    };\n    /** @hidden Given a matcher, return an array with the matcher's query params */\n    UrlMatcher.queryParams = function (matcher) {\n        return matcher._params.filter(function (p) { return p.location === param_1.DefType.SEARCH; });\n    };\n    /**\n     * Compare two UrlMatchers\n     *\n     * This comparison function converts a UrlMatcher into static and dynamic path segments.\n     * Each static path segment is a static string between a path separator (slash character).\n     * Each dynamic segment is a path parameter.\n     *\n     * The comparison function sorts static segments before dynamic ones.\n     */\n    UrlMatcher.compare = function (a, b) {\n        /**\n         * Turn a UrlMatcher and all its parent matchers into an array\n         * of slash literals '/', string literals, and Param objects\n         *\n         * This example matcher matches strings like \"/foo/:param/tail\":\n         * var matcher = $umf.compile(\"/foo\").append($umf.compile(\"/:param\")).append($umf.compile(\"/\")).append($umf.compile(\"tail\"));\n         * var result = segments(matcher); // [ '/', 'foo', '/', Param, '/', 'tail' ]\n         *\n         * Caches the result as `matcher._cache.segments`\n         */\n        var segments = function (matcher) {\n            return matcher._cache.segments = matcher._cache.segments ||\n                matcher._cache.path.map(UrlMatcher.pathSegmentsAndParams)\n                    .reduce(common_1.unnestR, [])\n                    .reduce(strings_1.joinNeighborsR, [])\n                    .map(function (x) { return predicates_1.isString(x) ? splitOnSlash(x) : x; })\n                    .reduce(common_1.unnestR, []);\n        };\n        /**\n         * Gets the sort weight for each segment of a UrlMatcher\n         *\n         * Caches the result as `matcher._cache.weights`\n         */\n        var weights = function (matcher) {\n            return matcher._cache.weights = matcher._cache.weights ||\n                segments(matcher).map(function (segment) {\n                    // Sort slashes first, then static strings, the Params\n                    if (segment === '/')\n                        return 1;\n                    if (predicates_1.isString(segment))\n                        return 2;\n                    if (segment instanceof param_1.Param)\n                        return 3;\n                });\n        };\n        /**\n         * Pads shorter array in-place (mutates)\n         */\n        var padArrays = function (l, r, padVal) {\n            var len = Math.max(l.length, r.length);\n            while (l.length < len)\n                l.push(padVal);\n            while (r.length < len)\n                r.push(padVal);\n        };\n        var weightsA = weights(a), weightsB = weights(b);\n        padArrays(weightsA, weightsB, 0);\n        var cmp, i, pairs = common_1.arrayTuples(weightsA, weightsB);\n        for (i = 0; i < pairs.length; i++) {\n            cmp = pairs[i][0] - pairs[i][1];\n            if (cmp !== 0)\n                return cmp;\n        }\n        return 0;\n    };\n    /** @hidden */\n    UrlMatcher.nameValidator = /^\\w+([-.]+\\w+)*(?:\\[\\])?$/;\n    return UrlMatcher;\n}());\nexports.UrlMatcher = UrlMatcher;\n//# sourceMappingURL=urlMatcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi91cmwvdXJsTWF0Y2hlci5qcz82YWYyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSB1cmxcbiAqL1xuLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBwYXJhbV8xID0gcmVxdWlyZShcIi4uL3BhcmFtcy9wYXJhbVwiKTtcbnZhciBzdHJpbmdzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3N0cmluZ3NcIik7XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gcXVvdGVSZWdFeHAoc3RyaW5nLCBwYXJhbSkge1xuICAgIHZhciBzdXJyb3VuZFBhdHRlcm4gPSBbJycsICcnXSwgcmVzdWx0ID0gc3RyaW5nLnJlcGxhY2UoL1tcXFxcXFxbXFxdXFxeJCorPy4oKXx7fV0vZywgXCJcXFxcJCZcIik7XG4gICAgaWYgKCFwYXJhbSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBzd2l0Y2ggKHBhcmFtLnNxdWFzaCkge1xuICAgICAgICBjYXNlIGZhbHNlOlxuICAgICAgICAgICAgc3Vycm91bmRQYXR0ZXJuID0gWycoJywgJyknICsgKHBhcmFtLmlzT3B0aW9uYWwgPyAnPycgOiAnJyldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgICAgICAgICAgc3Vycm91bmRQYXR0ZXJuID0gWycoPzpcXC8oJywgJyl8XFwvKT8nXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc3Vycm91bmRQYXR0ZXJuID0gW1wiKFwiICsgcGFyYW0uc3F1YXNoICsgXCJ8XCIsICcpPyddO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgKyBzdXJyb3VuZFBhdHRlcm5bMF0gKyBwYXJhbS50eXBlLnBhdHRlcm4uc291cmNlICsgc3Vycm91bmRQYXR0ZXJuWzFdO1xufVxuLyoqIEBoaWRkZW4gKi9cbnZhciBtZW1vaXplVG8gPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBmbikge1xuICAgIHJldHVybiBvYmpbcHJvcF0gPSBvYmpbcHJvcF0gfHwgZm4oKTtcbn07XG4vKiogQGhpZGRlbiAqL1xudmFyIHNwbGl0T25TbGFzaCA9IHN0cmluZ3NfMS5zcGxpdE9uRGVsaW0oJy8nKTtcbi8qKlxuICogTWF0Y2hlcyBVUkxzIGFnYWluc3QgcGF0dGVybnMuXG4gKlxuICogTWF0Y2hlcyBVUkxzIGFnYWluc3QgcGF0dGVybnMgYW5kIGV4dHJhY3RzIG5hbWVkIHBhcmFtZXRlcnMgZnJvbSB0aGUgcGF0aCBvciB0aGUgc2VhcmNoXG4gKiBwYXJ0IG9mIHRoZSBVUkwuXG4gKlxuICogQSBVUkwgcGF0dGVybiBjb25zaXN0cyBvZiBhIHBhdGggcGF0dGVybiwgb3B0aW9uYWxseSBmb2xsb3dlZCBieSAnPycgYW5kIGEgbGlzdCBvZiBzZWFyY2ggKHF1ZXJ5KVxuICogcGFyYW1ldGVycy4gTXVsdGlwbGUgc2VhcmNoIHBhcmFtZXRlciBuYW1lcyBhcmUgc2VwYXJhdGVkIGJ5ICcmJy4gU2VhcmNoIHBhcmFtZXRlcnNcbiAqIGRvIG5vdCBpbmZsdWVuY2Ugd2hldGhlciBvciBub3QgYSBVUkwgaXMgbWF0Y2hlZCwgYnV0IHRoZWlyIHZhbHVlcyBhcmUgcGFzc2VkIHRocm91Z2ggaW50b1xuICogdGhlIG1hdGNoZWQgcGFyYW1ldGVycyByZXR1cm5lZCBieSBbW1VybE1hdGNoZXIuZXhlY11dLlxuICpcbiAqIC0gKlBhdGggcGFyYW1ldGVycyogYXJlIGRlZmluZWQgdXNpbmcgY3VybHkgYnJhY2UgcGxhY2Vob2xkZXJzIChgL3NvbWVwYXRoL3twYXJhbX1gKVxuICogb3IgY29sb24gcGxhY2Vob2xkZXJzIChgL3NvbWVQYXRoLzpwYXJhbWApLlxuICpcbiAqIC0gKkEgcGFyYW1ldGVyIFJlZ0V4cCogbWF5IGJlIGRlZmluZWQgZm9yIGEgcGFyYW0gYWZ0ZXIgYSBjb2xvblxuICogKGAvc29tZVBhdGgve3BhcmFtOlthLXpBLVowLTldK31gKSBpbiBhIGN1cmx5IGJyYWNlIHBsYWNlaG9sZGVyLlxuICogVGhlIHJlZ2V4cCBtdXN0IG1hdGNoIGZvciB0aGUgdXJsIHRvIGJlIG1hdGNoZWQuXG4gKiBTaG91bGQgdGhlIHJlZ2V4cCBpdHNlbGYgY29udGFpbiBjdXJseSBicmFjZXMsIHRoZXkgbXVzdCBiZSBpbiBtYXRjaGVkIHBhaXJzIG9yIGVzY2FwZWQgd2l0aCBhIGJhY2tzbGFzaC5cbiAqXG4gKiBOb3RlOiBhIFJlZ0V4cCBwYXJhbWV0ZXIgd2lsbCBlbmNvZGUgaXRzIHZhbHVlIHVzaW5nIGVpdGhlciBbW1BhcmFtVHlwZXMucGF0aF1dIG9yIFtbUGFyYW1UeXBlcy5xdWVyeV1dLlxuICpcbiAqIC0gKkN1c3RvbSBwYXJhbWV0ZXIgdHlwZXMqIG1heSBhbHNvIGJlIHNwZWNpZmllZCBhZnRlciBhIGNvbG9uIChgL3NvbWVQYXRoL3twYXJhbTppbnR9YCkgaW4gY3VybHkgYnJhY2UgcGFyYW1ldGVycy5cbiAqICAgU2VlIFtbVXJsTWF0Y2hlckZhY3RvcnkudHlwZV1dIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIC0gKkNhdGNoLWFsbCBwYXJhbWV0ZXJzKiBhcmUgZGVmaW5lZCB1c2luZyBhbiBhc3RlcmlzayBwbGFjZWhvbGRlciAoYC9zb21lcGF0aC8qY2F0Y2hhbGxwYXJhbWApLlxuICogICBBIGNhdGNoLWFsbCAqIHBhcmFtZXRlciB2YWx1ZSB3aWxsIGNvbnRhaW4gdGhlIHJlbWFpbmRlciBvZiB0aGUgVVJMLlxuICpcbiAqIC0tLVxuICpcbiAqIFBhcmFtZXRlciBuYW1lcyBtYXkgY29udGFpbiBvbmx5IHdvcmQgY2hhcmFjdGVycyAobGF0aW4gbGV0dGVycywgZGlnaXRzLCBhbmQgdW5kZXJzY29yZSkgYW5kXG4gKiBtdXN0IGJlIHVuaXF1ZSB3aXRoaW4gdGhlIHBhdHRlcm4gKGFjcm9zcyBib3RoIHBhdGggYW5kIHNlYXJjaCBwYXJhbWV0ZXJzKS5cbiAqIEEgcGF0aCBwYXJhbWV0ZXIgbWF0Y2hlcyBhbnkgbnVtYmVyIG9mIGNoYXJhY3RlcnMgb3RoZXIgdGhhbiAnLycuIEZvciBjYXRjaC1hbGxcbiAqIHBsYWNlaG9sZGVycyB0aGUgcGF0aCBwYXJhbWV0ZXIgbWF0Y2hlcyBhbnkgbnVtYmVyIG9mIGNoYXJhY3RlcnMuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogKiBgJy9oZWxsby8nYCAtIE1hdGNoZXMgb25seSBpZiB0aGUgcGF0aCBpcyBleGFjdGx5ICcvaGVsbG8vJy4gVGhlcmUgaXMgbm8gc3BlY2lhbCB0cmVhdG1lbnQgZm9yXG4gKiAgIHRyYWlsaW5nIHNsYXNoZXMsIGFuZCBwYXR0ZXJucyBoYXZlIHRvIG1hdGNoIHRoZSBlbnRpcmUgcGF0aCwgbm90IGp1c3QgYSBwcmVmaXguXG4gKiAqIGAnL3VzZXIvOmlkJ2AgLSBNYXRjaGVzICcvdXNlci9ib2InIG9yICcvdXNlci8xMjM0ISEhJyBvciBldmVuICcvdXNlci8nIGJ1dCBub3QgJy91c2VyJyBvclxuICogICAnL3VzZXIvYm9iL2RldGFpbHMnLiBUaGUgc2Vjb25kIHBhdGggc2VnbWVudCB3aWxsIGJlIGNhcHR1cmVkIGFzIHRoZSBwYXJhbWV0ZXIgJ2lkJy5cbiAqICogYCcvdXNlci97aWR9J2AgLSBTYW1lIGFzIHRoZSBwcmV2aW91cyBleGFtcGxlLCBidXQgdXNpbmcgY3VybHkgYnJhY2Ugc3ludGF4LlxuICogKiBgJy91c2VyL3tpZDpbXi9dKn0nYCAtIFNhbWUgYXMgdGhlIHByZXZpb3VzIGV4YW1wbGUuXG4gKiAqIGAnL3VzZXIve2lkOlswLTlhLWZBLUZdezEsOH19J2AgLSBTaW1pbGFyIHRvIHRoZSBwcmV2aW91cyBleGFtcGxlLCBidXQgb25seSBtYXRjaGVzIGlmIHRoZSBpZFxuICogICBwYXJhbWV0ZXIgY29uc2lzdHMgb2YgMSB0byA4IGhleCBkaWdpdHMuXG4gKiAqIGAnL2ZpbGVzL3twYXRoOi4qfSdgIC0gTWF0Y2hlcyBhbnkgVVJMIHN0YXJ0aW5nIHdpdGggJy9maWxlcy8nIGFuZCBjYXB0dXJlcyB0aGUgcmVzdCBvZiB0aGVcbiAqICAgcGF0aCBpbnRvIHRoZSBwYXJhbWV0ZXIgJ3BhdGgnLlxuICogKiBgJy9maWxlcy8qcGF0aCdgIC0gZGl0dG8uXG4gKiAqIGAnL2NhbGVuZGFyL3tzdGFydDpkYXRlfSdgIC0gTWF0Y2hlcyBcIi9jYWxlbmRhci8yMDE0LTExLTEyXCIgKGJlY2F1c2UgdGhlIHBhdHRlcm4gZGVmaW5lZFxuICogICBpbiB0aGUgYnVpbHQtaW4gIGBkYXRlYCBQYXJhbVR5cGUgbWF0Y2hlcyBgMjAxNC0xMS0xMmApIGFuZCBwcm92aWRlcyBhIERhdGUgb2JqZWN0IGluICRzdGF0ZVBhcmFtcy5zdGFydFxuICpcbiAqL1xudmFyIFVybE1hdGNoZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gY29tcGlsZSBpbnRvIGEgbWF0Y2hlci5cbiAgICAgKiBAcGFyYW0gcGFyYW1UeXBlcyBUaGUgW1tQYXJhbVR5cGVzXV0gcmVnaXN0cnlcbiAgICAgKiBAcGFyYW0gY29uZmlnICBBIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICogLSBgY2FzZUluc2Vuc2l0aXZlYCAtIGB0cnVlYCBpZiBVUkwgbWF0Y2hpbmcgc2hvdWxkIGJlIGNhc2UgaW5zZW5zaXRpdmUsIG90aGVyd2lzZSBgZmFsc2VgLCB0aGUgZGVmYXVsdCB2YWx1ZSAoZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpIGlzIGBmYWxzZWAuXG4gICAgICogLSBgc3RyaWN0YCAtIGBmYWxzZWAgaWYgbWF0Y2hpbmcgYWdhaW5zdCBhIFVSTCB3aXRoIGEgdHJhaWxpbmcgc2xhc2ggc2hvdWxkIGJlIHRyZWF0ZWQgYXMgZXF1aXZhbGVudCB0byBhIFVSTCB3aXRob3V0IGEgdHJhaWxpbmcgc2xhc2gsIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGB0cnVlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBVcmxNYXRjaGVyKHBhdHRlcm4sIHBhcmFtVHlwZXMsIHBhcmFtRmFjdG9yeSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLl9jYWNoZSA9IHsgcGF0aDogW3RoaXNdIH07XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuX3BhcmFtcyA9IFtdO1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLl9zZWdtZW50cyA9IFtdO1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLl9jb21waWxlZCA9IFtdO1xuICAgICAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbW1vbl8xLmRlZmF1bHRzKHRoaXMuY29uZmlnLCB7XG4gICAgICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgICAgICAgY2FzZUluc2Vuc2l0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIHBhcmFtTWFwOiBjb21tb25fMS5pZGVudGl0eVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gRmluZCBhbGwgcGxhY2Vob2xkZXJzIGFuZCBjcmVhdGUgYSBjb21waWxlZCBwYXR0ZXJuLCB1c2luZyBlaXRoZXIgY2xhc3NpYyBvciBjdXJseSBzeW50YXg6XG4gICAgICAgIC8vICAgJyonIG5hbWVcbiAgICAgICAgLy8gICAnOicgbmFtZVxuICAgICAgICAvLyAgICd7JyBuYW1lICd9J1xuICAgICAgICAvLyAgICd7JyBuYW1lICc6JyByZWdleHAgJ30nXG4gICAgICAgIC8vIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gaXMgc29tZXdoYXQgY29tcGxpY2F0ZWQgZHVlIHRvIHRoZSBuZWVkIHRvIGFsbG93IGN1cmx5IGJyYWNlc1xuICAgICAgICAvLyBpbnNpZGUgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbi4gVGhlIHBsYWNlaG9sZGVyIHJlZ2V4cCBicmVha3MgZG93biBhcyBmb2xsb3dzOlxuICAgICAgICAvLyAgICAoWzoqXSkoW1xcd1xcW1xcXV0rKSAgICAgICAgICAgICAgLSBjbGFzc2ljIHBsYWNlaG9sZGVyICgkMSAvICQyKSAoc2VhcmNoIHZlcnNpb24gaGFzIC0gZm9yIHNuYWtlLWNhc2UpXG4gICAgICAgIC8vICAgIFxceyhbXFx3XFxbXFxdXSspKD86XFw6XFxzKiggLi4uICkpP1xcfSAgLSBjdXJseSBicmFjZSBwbGFjZWhvbGRlciAoJDMpIHdpdGggb3B0aW9uYWwgcmVnZXhwL3R5cGUgLi4uICgkNCkgKHNlYXJjaCB2ZXJzaW9uIGhhcyAtIGZvciBzbmFrZS1jYXNlXG4gICAgICAgIC8vICAgICg/OiAuLi4gfCAuLi4gfCAuLi4gKSsgICAgICAgICAtIHRoZSByZWdleHAgY29uc2lzdHMgb2YgYW55IG51bWJlciBvZiBhdG9tcywgYW4gYXRvbSBiZWluZyBlaXRoZXJcbiAgICAgICAgLy8gICAgW157fVxcXFxdKyAgICAgICAgICAgICAgICAgICAgICAgLSBhbnl0aGluZyBvdGhlciB0aGFuIGN1cmx5IGJyYWNlcyBvciBiYWNrc2xhc2hcbiAgICAgICAgLy8gICAgXFxcXC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBhIGJhY2tzbGFzaCBlc2NhcGVcbiAgICAgICAgLy8gICAgXFx7KD86W157fVxcXFxdK3xcXFxcLikqXFx9ICAgICAgICAgIC0gYSBtYXRjaGVkIHNldCBvZiBjdXJseSBicmFjZXMgY29udGFpbmluZyBvdGhlciBhdG9tc1xuICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSAvKFs6Kl0pKFtcXHdcXFtcXF1dKyl8XFx7KFtcXHdcXFtcXF1dKykoPzpcXDpcXHMqKCg/Oltee31cXFxcXSt8XFxcXC58XFx7KD86W157fVxcXFxdK3xcXFxcLikqXFx9KSspKT9cXH0vZywgc2VhcmNoUGxhY2Vob2xkZXIgPSAvKFs6XT8pKFtcXHdcXFtcXF0uLV0rKXxcXHsoW1xcd1xcW1xcXS4tXSspKD86XFw6XFxzKigoPzpbXnt9XFxcXF0rfFxcXFwufFxceyg/Oltee31cXFxcXSt8XFxcXC4pKlxcfSkrKSk/XFx9L2csIGxhc3QgPSAwLCBtLCBwYXR0ZXJucyA9IFtdO1xuICAgICAgICB2YXIgY2hlY2tQYXJhbUVycm9ycyA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgaWYgKCFVcmxNYXRjaGVyLm5hbWVWYWxpZGF0b3IudGVzdChpZCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXJhbWV0ZXIgbmFtZSAnXCIgKyBpZCArIFwiJyBpbiBwYXR0ZXJuICdcIiArIHBhdHRlcm4gKyBcIidcIik7XG4gICAgICAgICAgICBpZiAoY29tbW9uXzEuZmluZChfdGhpcy5fcGFyYW1zLCBob2ZfMS5wcm9wRXEoJ2lkJywgaWQpKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgcGFyYW1ldGVyIG5hbWUgJ1wiICsgaWQgKyBcIicgaW4gcGF0dGVybiAnXCIgKyBwYXR0ZXJuICsgXCInXCIpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBTcGxpdCBpbnRvIHN0YXRpYyBzZWdtZW50cyBzZXBhcmF0ZWQgYnkgcGF0aCBwYXJhbWV0ZXIgcGxhY2Vob2xkZXJzLlxuICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzIGlzIGFsd2F5cyAxIG1vcmUgdGhhbiB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMuXG4gICAgICAgIHZhciBtYXRjaERldGFpbHMgPSBmdW5jdGlvbiAobSwgaXNTZWFyY2gpIHtcbiAgICAgICAgICAgIC8vIElFWzc4XSByZXR1cm5zICcnIGZvciB1bm1hdGNoZWQgZ3JvdXBzIGluc3RlYWQgb2YgbnVsbFxuICAgICAgICAgICAgdmFyIGlkID0gbVsyXSB8fCBtWzNdO1xuICAgICAgICAgICAgdmFyIHJlZ2V4cCA9IGlzU2VhcmNoID8gbVs0XSA6IG1bNF0gfHwgKG1bMV0gPT09ICcqJyA/ICdbXFxcXHNcXFxcU10qJyA6IG51bGwpO1xuICAgICAgICAgICAgdmFyIG1ha2VSZWdleHBUeXBlID0gZnVuY3Rpb24gKHJlZ2V4cCkgeyByZXR1cm4gY29tbW9uXzEuaW5oZXJpdChwYXJhbVR5cGVzLnR5cGUoaXNTZWFyY2ggPyBcInF1ZXJ5XCIgOiBcInBhdGhcIiksIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBuZXcgUmVnRXhwKHJlZ2V4cCwgX3RoaXMuY29uZmlnLmNhc2VJbnNlbnNpdGl2ZSA/ICdpJyA6IHVuZGVmaW5lZClcbiAgICAgICAgICAgIH0pOyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgcmVnZXhwOiByZWdleHAsXG4gICAgICAgICAgICAgICAgY2ZnOiBfdGhpcy5jb25maWcucGFyYW1zW2lkXSxcbiAgICAgICAgICAgICAgICBzZWdtZW50OiBwYXR0ZXJuLnN1YnN0cmluZyhsYXN0LCBtLmluZGV4KSxcbiAgICAgICAgICAgICAgICB0eXBlOiAhcmVnZXhwID8gbnVsbCA6IHBhcmFtVHlwZXMudHlwZShyZWdleHApIHx8IG1ha2VSZWdleHBUeXBlKHJlZ2V4cClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHZhciBwLCBzZWdtZW50O1xuICAgICAgICB3aGlsZSAoKG0gPSBwbGFjZWhvbGRlci5leGVjKHBhdHRlcm4pKSkge1xuICAgICAgICAgICAgcCA9IG1hdGNoRGV0YWlscyhtLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAocC5zZWdtZW50LmluZGV4T2YoJz8nKSA+PSAwKVxuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyB3ZSdyZSBpbnRvIHRoZSBzZWFyY2ggcGFydFxuICAgICAgICAgICAgY2hlY2tQYXJhbUVycm9ycyhwLmlkKTtcbiAgICAgICAgICAgIHRoaXMuX3BhcmFtcy5wdXNoKHBhcmFtRmFjdG9yeS5mcm9tUGF0aChwLmlkLCBwLnR5cGUsIHRoaXMuY29uZmlnLnBhcmFtTWFwKHAuY2ZnLCBmYWxzZSkpKTtcbiAgICAgICAgICAgIHRoaXMuX3NlZ21lbnRzLnB1c2gocC5zZWdtZW50KTtcbiAgICAgICAgICAgIHBhdHRlcm5zLnB1c2goW3Auc2VnbWVudCwgY29tbW9uXzEudGFpbCh0aGlzLl9wYXJhbXMpXSk7XG4gICAgICAgICAgICBsYXN0ID0gcGxhY2Vob2xkZXIubGFzdEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHNlZ21lbnQgPSBwYXR0ZXJuLnN1YnN0cmluZyhsYXN0KTtcbiAgICAgICAgLy8gRmluZCBhbnkgc2VhcmNoIHBhcmFtZXRlciBuYW1lcyBhbmQgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbGFzdCBzZWdtZW50XG4gICAgICAgIHZhciBpID0gc2VnbWVudC5pbmRleE9mKCc/Jyk7XG4gICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICAgIHZhciBzZWFyY2ggPSBzZWdtZW50LnN1YnN0cmluZyhpKTtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBzZWdtZW50LnN1YnN0cmluZygwLCBpKTtcbiAgICAgICAgICAgIGlmIChzZWFyY2gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxhc3QgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlICgobSA9IHNlYXJjaFBsYWNlaG9sZGVyLmV4ZWMoc2VhcmNoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IG1hdGNoRGV0YWlscyhtLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tQYXJhbUVycm9ycyhwLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1zLnB1c2gocGFyYW1GYWN0b3J5LmZyb21TZWFyY2gocC5pZCwgcC50eXBlLCB0aGlzLmNvbmZpZy5wYXJhbU1hcChwLmNmZywgdHJ1ZSkpKTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IHBsYWNlaG9sZGVyLmxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgPyZcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICAgICAgdGhpcy5fY29tcGlsZWQgPSBwYXR0ZXJucy5tYXAoZnVuY3Rpb24gKHBhdHRlcm4pIHsgcmV0dXJuIHF1b3RlUmVnRXhwLmFwcGx5KG51bGwsIHBhdHRlcm4pOyB9KS5jb25jYXQocXVvdGVSZWdFeHAoc2VnbWVudCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbmNhdGVuYXRlZCBVcmxNYXRjaGVyXG4gICAgICpcbiAgICAgKiBCdWlsZHMgYSBuZXcgVXJsTWF0Y2hlciBieSBhcHBlbmRpbmcgYW5vdGhlciBVcmxNYXRjaGVyIHRvIHRoaXMgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVybCBBIGBVcmxNYXRjaGVyYCBpbnN0YW5jZSB0byBhcHBlbmQgYXMgYSBjaGlsZCBvZiB0aGUgY3VycmVudCBgVXJsTWF0Y2hlcmAuXG4gICAgICovXG4gICAgVXJsTWF0Y2hlci5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKHVybCk7XG4gICAgICAgIHVybC5fY2FjaGUgPSB7XG4gICAgICAgICAgICBwYXRoOiB0aGlzLl9jYWNoZS5wYXRoLmNvbmNhdCh1cmwpLFxuICAgICAgICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgICAgICAgcGF0dGVybjogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVXJsTWF0Y2hlci5wcm90b3R5cGUuaXNSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGUucGF0aFswXSA9PT0gdGhpcztcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIHRoZSBpbnB1dCBwYXR0ZXJuIHN0cmluZyAqL1xuICAgIFVybE1hdGNoZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXR0ZXJuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGVzdHMgdGhlIHNwZWNpZmllZCB1cmwvcGF0aCBhZ2FpbnN0IHRoaXMgbWF0Y2hlci5cbiAgICAgKlxuICAgICAqIFRlc3RzIGlmIHRoZSBnaXZlbiB1cmwgbWF0Y2hlcyB0aGlzIG1hdGNoZXIncyBwYXR0ZXJuLCBhbmQgcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgY2FwdHVyZWRcbiAgICAgKiBwYXJhbWV0ZXIgdmFsdWVzLiAgUmV0dXJucyBudWxsIGlmIHRoZSBwYXRoIGRvZXMgbm90IG1hdGNoLlxuICAgICAqXG4gICAgICogVGhlIHJldHVybmVkIG9iamVjdCBjb250YWlucyB0aGUgdmFsdWVzXG4gICAgICogb2YgYW55IHNlYXJjaCBwYXJhbWV0ZXJzIHRoYXQgYXJlIG1lbnRpb25lZCBpbiB0aGUgcGF0dGVybiwgYnV0IHRoZWlyIHZhbHVlIG1heSBiZSBudWxsIGlmXG4gICAgICogdGhleSBhcmUgbm90IHByZXNlbnQgaW4gYHNlYXJjaGAuIFRoaXMgbWVhbnMgdGhhdCBzZWFyY2ggcGFyYW1ldGVycyBhcmUgYWx3YXlzIHRyZWF0ZWRcbiAgICAgKiBhcyBvcHRpb25hbC5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIG5ldyBVcmxNYXRjaGVyKCcvdXNlci97aWR9P3EmcicpLmV4ZWMoJy91c2VyL2JvYicsIHtcbiAgICAgKiAgIHg6ICcxJywgcTogJ2hlbGxvJ1xuICAgICAqIH0pO1xuICAgICAqIC8vIHJldHVybnMgeyBpZDogJ2JvYicsIHE6ICdoZWxsbycsIHI6IG51bGwgfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggICAgVGhlIFVSTCBwYXRoIHRvIG1hdGNoLCBlLmcuIGAkbG9jYXRpb24ucGF0aCgpYC5cbiAgICAgKiBAcGFyYW0gc2VhcmNoICBVUkwgc2VhcmNoIHBhcmFtZXRlcnMsIGUuZy4gYCRsb2NhdGlvbi5zZWFyY2goKWAuXG4gICAgICogQHBhcmFtIGhhc2ggICAgVVJMIGhhc2ggZS5nLiBgJGxvY2F0aW9uLmhhc2goKWAuXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBjYXB0dXJlZCBwYXJhbWV0ZXIgdmFsdWVzLlxuICAgICAqL1xuICAgIFVybE1hdGNoZXIucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbiAocGF0aCwgc2VhcmNoLCBoYXNoLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChzZWFyY2ggPT09IHZvaWQgMCkgeyBzZWFyY2ggPSB7fTsgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgbWF0Y2ggPSBtZW1vaXplVG8odGhpcy5fY2FjaGUsICdwYXR0ZXJuJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoW1xuICAgICAgICAgICAgICAgICdeJyxcbiAgICAgICAgICAgICAgICBjb21tb25fMS51bm5lc3QoX3RoaXMuX2NhY2hlLnBhdGgubWFwKGhvZl8xLnByb3AoJ19jb21waWxlZCcpKSkuam9pbignJyksXG4gICAgICAgICAgICAgICAgX3RoaXMuY29uZmlnLnN0cmljdCA9PT0gZmFsc2UgPyAnXFwvPycgOiAnJyxcbiAgICAgICAgICAgICAgICAnJCdcbiAgICAgICAgICAgIF0uam9pbignJyksIF90aGlzLmNvbmZpZy5jYXNlSW5zZW5zaXRpdmUgPyAnaScgOiB1bmRlZmluZWQpO1xuICAgICAgICB9KS5leGVjKHBhdGgpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMsIHsgaXNvbGF0ZTogZmFsc2UgfSk7XG4gICAgICAgIHZhciBhbGxQYXJhbXMgPSB0aGlzLnBhcmFtZXRlcnMoKSwgcGF0aFBhcmFtcyA9IGFsbFBhcmFtcy5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiAhcGFyYW0uaXNTZWFyY2goKTsgfSksIHNlYXJjaFBhcmFtcyA9IGFsbFBhcmFtcy5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5pc1NlYXJjaCgpOyB9KSwgblBhdGhTZWdtZW50cyA9IHRoaXMuX2NhY2hlLnBhdGgubWFwKGZ1bmN0aW9uICh1cmxtKSB7IHJldHVybiB1cmxtLl9zZWdtZW50cy5sZW5ndGggLSAxOyB9KS5yZWR1Y2UoZnVuY3Rpb24gKGEsIHgpIHsgcmV0dXJuIGEgKyB4OyB9KSwgdmFsdWVzID0ge307XG4gICAgICAgIGlmIChuUGF0aFNlZ21lbnRzICE9PSBtYXRjaC5sZW5ndGggLSAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5iYWxhbmNlZCBjYXB0dXJlIGdyb3VwIGluIHJvdXRlICdcIiArIHRoaXMucGF0dGVybiArIFwiJ1wiKTtcbiAgICAgICAgZnVuY3Rpb24gZGVjb2RlUGF0aEFycmF5KHN0cmluZykge1xuICAgICAgICAgICAgdmFyIHJldmVyc2VTdHJpbmcgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHIuc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIik7IH07XG4gICAgICAgICAgICB2YXIgdW5xdW90ZURhc2hlcyA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXFxcLS9nLCBcIi1cIik7IH07XG4gICAgICAgICAgICB2YXIgc3BsaXQgPSByZXZlcnNlU3RyaW5nKHN0cmluZykuc3BsaXQoLy0oPyFcXFxcKS8pO1xuICAgICAgICAgICAgdmFyIGFsbFJldmVyc2VkID0gY29tbW9uXzEubWFwKHNwbGl0LCByZXZlcnNlU3RyaW5nKTtcbiAgICAgICAgICAgIHJldHVybiBjb21tb25fMS5tYXAoYWxsUmV2ZXJzZWQsIHVucXVvdGVEYXNoZXMpLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5QYXRoU2VnbWVudHM7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcmFtID0gcGF0aFBhcmFtc1tpXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG1hdGNoW2kgKyAxXTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwYXJhbSB2YWx1ZSBtYXRjaGVzIGEgcHJlLXJlcGxhY2UgcGFpciwgcmVwbGFjZSB0aGUgdmFsdWUgYmVmb3JlIGRlY29kaW5nLlxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJhbS5yZXBsYWNlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLnJlcGxhY2Vbal0uZnJvbSA9PT0gdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyYW0ucmVwbGFjZVtqXS50bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiBwYXJhbS5hcnJheSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlY29kZVBhdGhBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzRGVmaW5lZCh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJhbS50eXBlLmRlY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZXNbcGFyYW0uaWRdID0gcGFyYW0udmFsdWUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHNlYXJjaFBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gc2VhcmNoW3BhcmFtLmlkXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFyYW0ucmVwbGFjZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbS5yZXBsYWNlW2pdLmZyb20gPT09IHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcmFtLnJlcGxhY2Vbal0udG87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzRGVmaW5lZCh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJhbS50eXBlLmRlY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZXNbcGFyYW0uaWRdID0gcGFyYW0udmFsdWUodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGhhc2gpXG4gICAgICAgICAgICB2YWx1ZXNbXCIjXCJdID0gaGFzaDtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBSZXR1cm5zIGFsbCB0aGUgW1tQYXJhbV1dIG9iamVjdHMgb2YgYWxsIHBhdGggYW5kIHNlYXJjaCBwYXJhbWV0ZXJzIG9mIHRoaXMgcGF0dGVybiBpbiBvcmRlciBvZiBhcHBlYXJhbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5LjxQYXJhbT59ICBBbiBhcnJheSBvZiBbW1BhcmFtXV0gb2JqZWN0cy4gTXVzdCBiZSB0cmVhdGVkIGFzIHJlYWQtb25seS4gSWYgdGhlXG4gICAgICogICAgcGF0dGVybiBoYXMgbm8gcGFyYW1ldGVycywgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgVXJsTWF0Y2hlci5wcm90b3R5cGUucGFyYW1ldGVycyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIHsgb3B0cyA9IHt9OyB9XG4gICAgICAgIGlmIChvcHRzLmluaGVyaXQgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtcztcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLnVubmVzdCh0aGlzLl9jYWNoZS5wYXRoLm1hcChmdW5jdGlvbiAobWF0Y2hlcikgeyByZXR1cm4gbWF0Y2hlci5fcGFyYW1zOyB9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogUmV0dXJucyBhIHNpbmdsZSBwYXJhbWV0ZXIgZnJvbSB0aGlzIFVybE1hdGNoZXIgYnkgaWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZFxuICAgICAqIEBwYXJhbSBvcHRzXG4gICAgICogQHJldHVybnMge1R8UGFyYW18YW55fGJvb2xlYW58VXJsTWF0Y2hlcnxudWxsfVxuICAgICAqL1xuICAgIFVybE1hdGNoZXIucHJvdG90eXBlLnBhcmFtZXRlciA9IGZ1bmN0aW9uIChpZCwgb3B0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7IG9wdHMgPSB7fTsgfVxuICAgICAgICB2YXIgZmluZFBhcmFtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IF90aGlzLl9wYXJhbXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbS5pZCA9PT0gaWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX2NhY2hlLnBhcmVudDtcbiAgICAgICAgcmV0dXJuIGZpbmRQYXJhbSgpIHx8IChvcHRzLmluaGVyaXQgIT09IGZhbHNlICYmIHBhcmVudCAmJiBwYXJlbnQucGFyYW1ldGVyKGlkLCBvcHRzKSkgfHwgbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUgaW5wdXQgcGFyYW1ldGVyIHZhbHVlcyBhZ2FpbnN0IHRoaXMgVXJsTWF0Y2hlclxuICAgICAqXG4gICAgICogQ2hlY2tzIGFuIG9iamVjdCBoYXNoIG9mIHBhcmFtZXRlcnMgdG8gdmFsaWRhdGUgdGhlaXIgY29ycmVjdG5lc3MgYWNjb3JkaW5nIHRvIHRoZSBwYXJhbWV0ZXJcbiAgICAgKiB0eXBlcyBvZiB0aGlzIGBVcmxNYXRjaGVyYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgVGhlIG9iamVjdCBoYXNoIG9mIHBhcmFtZXRlcnMgdG8gdmFsaWRhdGUuXG4gICAgICogQHJldHVybnMgUmV0dXJucyBgdHJ1ZWAgaWYgYHBhcmFtc2AgdmFsaWRhdGVzLCBvdGhlcndpc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBVcmxNYXRjaGVyLnByb3RvdHlwZS52YWxpZGF0ZXMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciB2YWxpZFBhcmFtVmFsID0gZnVuY3Rpb24gKHBhcmFtLCB2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiAhcGFyYW0gfHwgcGFyYW0udmFsaWRhdGVzKHZhbCk7XG4gICAgICAgIH07XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgLy8gSSdtIG5vdCBzdXJlIHdoeSB0aGlzIGNoZWNrcyBvbmx5IHRoZSBwYXJhbSBrZXlzIHBhc3NlZCBpbiwgYW5kIG5vdCBhbGwgdGhlIHBhcmFtcyBrbm93biB0byB0aGUgbWF0Y2hlclxuICAgICAgICB2YXIgcGFyYW1TY2hlbWEgPSB0aGlzLnBhcmFtZXRlcnMoKS5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtRGVmKSB7IHJldHVybiBwYXJhbXMuaGFzT3duUHJvcGVydHkocGFyYW1EZWYuaWQpOyB9KTtcbiAgICAgICAgcmV0dXJuIHBhcmFtU2NoZW1hLm1hcChmdW5jdGlvbiAocGFyYW1EZWYpIHsgcmV0dXJuIHZhbGlkUGFyYW1WYWwocGFyYW1EZWYsIHBhcmFtc1twYXJhbURlZi5pZF0pOyB9KS5yZWR1Y2UoY29tbW9uXzEuYWxsVHJ1ZVIsIHRydWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBzZXQgb2YgcGFyYW1ldGVyIHZhbHVlcywgY3JlYXRlcyBhIFVSTCBmcm9tIHRoaXMgVXJsTWF0Y2hlci5cbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYSBVUkwgdGhhdCBtYXRjaGVzIHRoaXMgcGF0dGVybiBieSBzdWJzdGl0dXRpbmcgdGhlIHNwZWNpZmllZCB2YWx1ZXNcbiAgICAgKiBmb3IgdGhlIHBhdGggYW5kIHNlYXJjaCBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogbmV3IFVybE1hdGNoZXIoJy91c2VyL3tpZH0/cScpLmZvcm1hdCh7IGlkOidib2InLCBxOid5ZXMnIH0pO1xuICAgICAqIC8vIHJldHVybnMgJy91c2VyL2JvYj9xPXllcydcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgIHRoZSB2YWx1ZXMgdG8gc3Vic3RpdHV0ZSBmb3IgdGhlIHBhcmFtZXRlcnMgaW4gdGhpcyBwYXR0ZXJuLlxuICAgICAqIEByZXR1cm5zIHRoZSBmb3JtYXR0ZWQgVVJMIChwYXRoIGFuZCBvcHRpb25hbGx5IHNlYXJjaCBwYXJ0KS5cbiAgICAgKi9cbiAgICBVcmxNYXRjaGVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWx1ZXMgPT09IHZvaWQgMCkgeyB2YWx1ZXMgPSB7fTsgfVxuICAgICAgICAvLyBCdWlsZCB0aGUgZnVsbCBwYXRoIG9mIFVybE1hdGNoZXJzIChpbmNsdWRpbmcgYWxsIHBhcmVudCBVcmxNYXRjaGVycylcbiAgICAgICAgdmFyIHVybE1hdGNoZXJzID0gdGhpcy5fY2FjaGUucGF0aDtcbiAgICAgICAgLy8gRXh0cmFjdCBhbGwgdGhlIHN0YXRpYyBzZWdtZW50cyBhbmQgUGFyYW1zIChwcm9jZXNzZWQgYXMgUGFyYW1EZXRhaWxzKVxuICAgICAgICAvLyBpbnRvIGFuIG9yZGVyZWQgYXJyYXlcbiAgICAgICAgdmFyIHBhdGhTZWdtZW50c0FuZFBhcmFtcyA9IHVybE1hdGNoZXJzLm1hcChVcmxNYXRjaGVyLnBhdGhTZWdtZW50c0FuZFBhcmFtcylcbiAgICAgICAgICAgIC5yZWR1Y2UoY29tbW9uXzEudW5uZXN0UiwgW10pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoeCkgPyB4IDogZ2V0RGV0YWlscyh4KTsgfSk7XG4gICAgICAgIC8vIEV4dHJhY3QgdGhlIHF1ZXJ5IHBhcmFtcyBpbnRvIGEgc2VwYXJhdGUgYXJyYXlcbiAgICAgICAgdmFyIHF1ZXJ5UGFyYW1zID0gdXJsTWF0Y2hlcnMubWFwKFVybE1hdGNoZXIucXVlcnlQYXJhbXMpXG4gICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKVxuICAgICAgICAgICAgLm1hcChnZXREZXRhaWxzKTtcbiAgICAgICAgdmFyIGlzSW52YWxpZCA9IGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW0uaXNWYWxpZCA9PT0gZmFsc2U7IH07XG4gICAgICAgIGlmIChwYXRoU2VnbWVudHNBbmRQYXJhbXMuY29uY2F0KHF1ZXJ5UGFyYW1zKS5maWx0ZXIoaXNJbnZhbGlkKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhIFBhcmFtLCBhcHBsaWVzIHRoZSBwYXJhbWV0ZXIgdmFsdWUsIHRoZW4gcmV0dXJucyBkZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCBpdFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZ2V0RGV0YWlscyhwYXJhbSkge1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRvIHR5cGVkIHZhbHVlXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbS52YWx1ZSh2YWx1ZXNbcGFyYW0uaWRdKTtcbiAgICAgICAgICAgIHZhciBpc1ZhbGlkID0gcGFyYW0udmFsaWRhdGVzKHZhbHVlKTtcbiAgICAgICAgICAgIHZhciBpc0RlZmF1bHRWYWx1ZSA9IHBhcmFtLmlzRGVmYXVsdFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGluIHNxdWFzaCBtb2RlIGZvciB0aGUgcGFyYW1ldGVyXG4gICAgICAgICAgICB2YXIgc3F1YXNoID0gaXNEZWZhdWx0VmFsdWUgPyBwYXJhbS5zcXVhc2ggOiBmYWxzZTtcbiAgICAgICAgICAgIC8vIEFsbG93IHRoZSBQYXJhbWV0ZXIncyBUeXBlIHRvIGVuY29kZSB0aGUgdmFsdWVcbiAgICAgICAgICAgIHZhciBlbmNvZGVkID0gcGFyYW0udHlwZS5lbmNvZGUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHsgcGFyYW06IHBhcmFtLCB2YWx1ZTogdmFsdWUsIGlzVmFsaWQ6IGlzVmFsaWQsIGlzRGVmYXVsdFZhbHVlOiBpc0RlZmF1bHRWYWx1ZSwgc3F1YXNoOiBzcXVhc2gsIGVuY29kZWQ6IGVuY29kZWQgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWlsZCB1cCB0aGUgcGF0aC1wb3J0aW9uIGZyb20gdGhlIGxpc3Qgb2Ygc3RhdGljIHNlZ21lbnRzIGFuZCBwYXJhbWV0ZXJzXG4gICAgICAgIHZhciBwYXRoU3RyaW5nID0gcGF0aFNlZ21lbnRzQW5kUGFyYW1zLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB4KSB7XG4gICAgICAgICAgICAvLyBUaGUgZWxlbWVudCBpcyBhIHN0YXRpYyBzZWdtZW50IChhIHJhdyBzdHJpbmcpOyBqdXN0IGFwcGVuZCBpdFxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc1N0cmluZyh4KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjICsgeDtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaXQncyBhIFBhcmFtRGV0YWlscy5cbiAgICAgICAgICAgIHZhciBzcXVhc2ggPSB4LnNxdWFzaCwgZW5jb2RlZCA9IHguZW5jb2RlZCwgcGFyYW0gPSB4LnBhcmFtO1xuICAgICAgICAgICAgLy8gSWYgc3F1YXNoIGlzID09PSB0cnVlLCB0cnkgdG8gcmVtb3ZlIGEgc2xhc2ggZnJvbSB0aGUgcGF0aFxuICAgICAgICAgICAgaWYgKHNxdWFzaCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gKGFjYy5tYXRjaCgvXFwvJC8pKSA/IGFjYy5zbGljZSgwLCAtMSkgOiBhY2M7XG4gICAgICAgICAgICAvLyBJZiBzcXVhc2ggaXMgYSBzdHJpbmcsIHVzZSB0aGUgc3RyaW5nIGZvciB0aGUgcGFyYW0gdmFsdWVcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcoc3F1YXNoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjICsgc3F1YXNoO1xuICAgICAgICAgICAgaWYgKHNxdWFzaCAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYzsgLy8gP1xuICAgICAgICAgICAgaWYgKGVuY29kZWQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBwYXJhbWV0ZXIgdmFsdWUgaXMgYW4gYXJyYXksIGVuY29kZSB0aGUgdmFsdWUgdXNpbmcgZW5jb2RlRGFzaGVzXG4gICAgICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzQXJyYXkoZW5jb2RlZCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYyArIGNvbW1vbl8xLm1hcChlbmNvZGVkLCBVcmxNYXRjaGVyLmVuY29kZURhc2hlcykuam9pbihcIi1cIik7XG4gICAgICAgICAgICAvLyBJZiB0aGUgcGFyYW1ldGVyIHR5cGUgaXMgXCJyYXdcIiwgdGhlbiBkbyBub3QgZW5jb2RlVVJJQ29tcG9uZW50XG4gICAgICAgICAgICBpZiAocGFyYW0ucmF3KVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2MgKyBlbmNvZGVkO1xuICAgICAgICAgICAgLy8gRW5jb2RlIHRoZSB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuIGFjYyArIGVuY29kZVVSSUNvbXBvbmVudChlbmNvZGVkKTtcbiAgICAgICAgfSwgXCJcIik7XG4gICAgICAgIC8vIEJ1aWxkIHRoZSBxdWVyeSBzdHJpbmcgYnkgYXBwbHlpbmcgcGFyYW1ldGVyIHZhbHVlcyAoYXJyYXkgb3IgcmVndWxhcilcbiAgICAgICAgLy8gdGhlbiBtYXBwaW5nIHRvIGtleT12YWx1ZSwgdGhlbiBmbGF0dGVuaW5nIGFuZCBqb2luaW5nIHVzaW5nIFwiJlwiXG4gICAgICAgIHZhciBxdWVyeVN0cmluZyA9IHF1ZXJ5UGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW1EZXRhaWxzKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW0gPSBwYXJhbURldGFpbHMucGFyYW0sIHNxdWFzaCA9IHBhcmFtRGV0YWlscy5zcXVhc2gsIGVuY29kZWQgPSBwYXJhbURldGFpbHMuZW5jb2RlZCwgaXNEZWZhdWx0VmFsdWUgPSBwYXJhbURldGFpbHMuaXNEZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICBpZiAoZW5jb2RlZCA9PSBudWxsIHx8IChpc0RlZmF1bHRWYWx1ZSAmJiBzcXVhc2ggIT09IGZhbHNlKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc0FycmF5KGVuY29kZWQpKVxuICAgICAgICAgICAgICAgIGVuY29kZWQgPSBbZW5jb2RlZF07XG4gICAgICAgICAgICBpZiAoZW5jb2RlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCFwYXJhbS5yYXcpXG4gICAgICAgICAgICAgICAgZW5jb2RlZCA9IGNvbW1vbl8xLm1hcChlbmNvZGVkLCBlbmNvZGVVUklDb21wb25lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZWQubWFwKGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHBhcmFtLmlkICsgXCI9XCIgKyB2YWw7IH0pO1xuICAgICAgICB9KS5maWx0ZXIoY29tbW9uXzEuaWRlbnRpdHkpLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSkuam9pbihcIiZcIik7XG4gICAgICAgIC8vIENvbmNhdCB0aGUgcGF0aHN0cmluZyB3aXRoIHRoZSBxdWVyeVN0cmluZyAoaWYgZXhpc3RzKSBhbmQgdGhlIGhhc2hTdHJpbmcgKGlmIGV4aXN0cylcbiAgICAgICAgcmV0dXJuIHBhdGhTdHJpbmcgKyAocXVlcnlTdHJpbmcgPyBcIj9cIiArIHF1ZXJ5U3RyaW5nIDogXCJcIikgKyAodmFsdWVzW1wiI1wiXSA/IFwiI1wiICsgdmFsdWVzW1wiI1wiXSA6IFwiXCIpO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBVcmxNYXRjaGVyLmVuY29kZURhc2hlcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoLy0vZywgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFwiJTVDJVwiICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyB9KTtcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuIEdpdmVuIGEgbWF0Y2hlciwgcmV0dXJuIGFuIGFycmF5IHdpdGggdGhlIG1hdGNoZXIncyBwYXRoIHNlZ21lbnRzIGFuZCBwYXRoIHBhcmFtcywgaW4gb3JkZXIgKi9cbiAgICBVcmxNYXRjaGVyLnBhdGhTZWdtZW50c0FuZFBhcmFtcyA9IGZ1bmN0aW9uIChtYXRjaGVyKSB7XG4gICAgICAgIHZhciBzdGF0aWNTZWdtZW50cyA9IG1hdGNoZXIuX3NlZ21lbnRzO1xuICAgICAgICB2YXIgcGF0aFBhcmFtcyA9IG1hdGNoZXIuX3BhcmFtcy5maWx0ZXIoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAubG9jYXRpb24gPT09IHBhcmFtXzEuRGVmVHlwZS5QQVRIOyB9KTtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmFycmF5VHVwbGVzKHN0YXRpY1NlZ21lbnRzLCBwYXRoUGFyYW1zLmNvbmNhdCh1bmRlZmluZWQpKVxuICAgICAgICAgICAgLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggIT09IFwiXCIgJiYgcHJlZGljYXRlc18xLmlzRGVmaW5lZCh4KTsgfSk7XG4gICAgfTtcbiAgICAvKiogQGhpZGRlbiBHaXZlbiBhIG1hdGNoZXIsIHJldHVybiBhbiBhcnJheSB3aXRoIHRoZSBtYXRjaGVyJ3MgcXVlcnkgcGFyYW1zICovXG4gICAgVXJsTWF0Y2hlci5xdWVyeVBhcmFtcyA9IGZ1bmN0aW9uIChtYXRjaGVyKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVyLl9wYXJhbXMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLmxvY2F0aW9uID09PSBwYXJhbV8xLkRlZlR5cGUuU0VBUkNIOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXBhcmUgdHdvIFVybE1hdGNoZXJzXG4gICAgICpcbiAgICAgKiBUaGlzIGNvbXBhcmlzb24gZnVuY3Rpb24gY29udmVydHMgYSBVcmxNYXRjaGVyIGludG8gc3RhdGljIGFuZCBkeW5hbWljIHBhdGggc2VnbWVudHMuXG4gICAgICogRWFjaCBzdGF0aWMgcGF0aCBzZWdtZW50IGlzIGEgc3RhdGljIHN0cmluZyBiZXR3ZWVuIGEgcGF0aCBzZXBhcmF0b3IgKHNsYXNoIGNoYXJhY3RlcikuXG4gICAgICogRWFjaCBkeW5hbWljIHNlZ21lbnQgaXMgYSBwYXRoIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIFRoZSBjb21wYXJpc29uIGZ1bmN0aW9uIHNvcnRzIHN0YXRpYyBzZWdtZW50cyBiZWZvcmUgZHluYW1pYyBvbmVzLlxuICAgICAqL1xuICAgIFVybE1hdGNoZXIuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUdXJuIGEgVXJsTWF0Y2hlciBhbmQgYWxsIGl0cyBwYXJlbnQgbWF0Y2hlcnMgaW50byBhbiBhcnJheVxuICAgICAgICAgKiBvZiBzbGFzaCBsaXRlcmFscyAnLycsIHN0cmluZyBsaXRlcmFscywgYW5kIFBhcmFtIG9iamVjdHNcbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBleGFtcGxlIG1hdGNoZXIgbWF0Y2hlcyBzdHJpbmdzIGxpa2UgXCIvZm9vLzpwYXJhbS90YWlsXCI6XG4gICAgICAgICAqIHZhciBtYXRjaGVyID0gJHVtZi5jb21waWxlKFwiL2Zvb1wiKS5hcHBlbmQoJHVtZi5jb21waWxlKFwiLzpwYXJhbVwiKSkuYXBwZW5kKCR1bWYuY29tcGlsZShcIi9cIikpLmFwcGVuZCgkdW1mLmNvbXBpbGUoXCJ0YWlsXCIpKTtcbiAgICAgICAgICogdmFyIHJlc3VsdCA9IHNlZ21lbnRzKG1hdGNoZXIpOyAvLyBbICcvJywgJ2ZvbycsICcvJywgUGFyYW0sICcvJywgJ3RhaWwnIF1cbiAgICAgICAgICpcbiAgICAgICAgICogQ2FjaGVzIHRoZSByZXN1bHQgYXMgYG1hdGNoZXIuX2NhY2hlLnNlZ21lbnRzYFxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gZnVuY3Rpb24gKG1hdGNoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVyLl9jYWNoZS5zZWdtZW50cyA9IG1hdGNoZXIuX2NhY2hlLnNlZ21lbnRzIHx8XG4gICAgICAgICAgICAgICAgbWF0Y2hlci5fY2FjaGUucGF0aC5tYXAoVXJsTWF0Y2hlci5wYXRoU2VnbWVudHNBbmRQYXJhbXMpXG4gICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoY29tbW9uXzEudW5uZXN0UiwgW10pXG4gICAgICAgICAgICAgICAgICAgIC5yZWR1Y2Uoc3RyaW5nc18xLmpvaW5OZWlnaGJvcnNSLCBbXSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gcHJlZGljYXRlc18xLmlzU3RyaW5nKHgpID8gc3BsaXRPblNsYXNoKHgpIDogeDsgfSlcbiAgICAgICAgICAgICAgICAgICAgLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBzb3J0IHdlaWdodCBmb3IgZWFjaCBzZWdtZW50IG9mIGEgVXJsTWF0Y2hlclxuICAgICAgICAgKlxuICAgICAgICAgKiBDYWNoZXMgdGhlIHJlc3VsdCBhcyBgbWF0Y2hlci5fY2FjaGUud2VpZ2h0c2BcbiAgICAgICAgICovXG4gICAgICAgIHZhciB3ZWlnaHRzID0gZnVuY3Rpb24gKG1hdGNoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVyLl9jYWNoZS53ZWlnaHRzID0gbWF0Y2hlci5fY2FjaGUud2VpZ2h0cyB8fFxuICAgICAgICAgICAgICAgIHNlZ21lbnRzKG1hdGNoZXIpLm1hcChmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTb3J0IHNsYXNoZXMgZmlyc3QsIHRoZW4gc3RhdGljIHN0cmluZ3MsIHRoZSBQYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ21lbnQgPT09ICcvJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzU3RyaW5nKHNlZ21lbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWdtZW50IGluc3RhbmNlb2YgcGFyYW1fMS5QYXJhbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUGFkcyBzaG9ydGVyIGFycmF5IGluLXBsYWNlIChtdXRhdGVzKVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHBhZEFycmF5cyA9IGZ1bmN0aW9uIChsLCByLCBwYWRWYWwpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBNYXRoLm1heChsLmxlbmd0aCwgci5sZW5ndGgpO1xuICAgICAgICAgICAgd2hpbGUgKGwubGVuZ3RoIDwgbGVuKVxuICAgICAgICAgICAgICAgIGwucHVzaChwYWRWYWwpO1xuICAgICAgICAgICAgd2hpbGUgKHIubGVuZ3RoIDwgbGVuKVxuICAgICAgICAgICAgICAgIHIucHVzaChwYWRWYWwpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgd2VpZ2h0c0EgPSB3ZWlnaHRzKGEpLCB3ZWlnaHRzQiA9IHdlaWdodHMoYik7XG4gICAgICAgIHBhZEFycmF5cyh3ZWlnaHRzQSwgd2VpZ2h0c0IsIDApO1xuICAgICAgICB2YXIgY21wLCBpLCBwYWlycyA9IGNvbW1vbl8xLmFycmF5VHVwbGVzKHdlaWdodHNBLCB3ZWlnaHRzQik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY21wID0gcGFpcnNbaV1bMF0gLSBwYWlyc1tpXVsxXTtcbiAgICAgICAgICAgIGlmIChjbXAgIT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVXJsTWF0Y2hlci5uYW1lVmFsaWRhdG9yID0gL15cXHcrKFstLl0rXFx3KykqKD86XFxbXFxdKT8kLztcbiAgICByZXR1cm4gVXJsTWF0Y2hlcjtcbn0oKSk7XG5leHBvcnRzLlVybE1hdGNoZXIgPSBVcmxNYXRjaGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsTWF0Y2hlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL3VybC91cmxNYXRjaGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///19\n")},function(module,exports,__webpack_require__){"use strict";eval('\n/**\n * @internalapi\n * @module vanilla\n */ /** */\nObject.defineProperty(exports, "__esModule", { value: true });\nvar common_1 = __webpack_require__(/*! ../common */ 5);\nvar utils_1 = __webpack_require__(/*! ./utils */ 27);\n/** A base `LocationServices` */\nvar BaseLocationServices = /** @class */ (function () {\n    function BaseLocationServices(router, fireAfterUpdate) {\n        var _this = this;\n        this.fireAfterUpdate = fireAfterUpdate;\n        this._listener = function (evt) { return _this._listeners.forEach(function (cb) { return cb(evt); }); };\n        this._listeners = [];\n        this.hash = function () { return utils_1.parseUrl(_this._get()).hash; };\n        this.path = function () { return utils_1.parseUrl(_this._get()).path; };\n        this.search = function () { return utils_1.getParams(utils_1.parseUrl(_this._get()).search); };\n        this._location = common_1.root.location;\n        this._history = common_1.root.history;\n    }\n    BaseLocationServices.prototype.url = function (url, replace) {\n        if (replace === void 0) { replace = true; }\n        if (common_1.isDefined(url) && url !== this._get()) {\n            this._set(null, null, url, replace);\n            if (this.fireAfterUpdate) {\n                this._listeners.forEach(function (cb) { return cb({ url: url }); });\n            }\n        }\n        return utils_1.buildUrl(this);\n    };\n    BaseLocationServices.prototype.onChange = function (cb) {\n        var _this = this;\n        this._listeners.push(cb);\n        return function () { return common_1.removeFrom(_this._listeners, cb); };\n    };\n    BaseLocationServices.prototype.dispose = function (router) {\n        common_1.deregAll(this._listeners);\n    };\n    return BaseLocationServices;\n}());\nexports.BaseLocationServices = BaseLocationServices;\n//# sourceMappingURL=baseLocationService.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL2Jhc2VMb2NhdGlvblNlcnZpY2UuanM/YTM5MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGludGVybmFsYXBpXG4gKiBAbW9kdWxlIHZhbmlsbGFcbiAqLyAvKiogKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqIEEgYmFzZSBgTG9jYXRpb25TZXJ2aWNlc2AgKi9cbnZhciBCYXNlTG9jYXRpb25TZXJ2aWNlcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXNlTG9jYXRpb25TZXJ2aWNlcyhyb3V0ZXIsIGZpcmVBZnRlclVwZGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmZpcmVBZnRlclVwZGF0ZSA9IGZpcmVBZnRlclVwZGF0ZTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZ0KSB7IHJldHVybiBfdGhpcy5fbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IHJldHVybiBjYihldnQpOyB9KTsgfTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuaGFzaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEucGFyc2VVcmwoX3RoaXMuX2dldCgpKS5oYXNoOyB9O1xuICAgICAgICB0aGlzLnBhdGggPSBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLnBhcnNlVXJsKF90aGlzLl9nZXQoKSkucGF0aDsgfTtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLmdldFBhcmFtcyh1dGlsc18xLnBhcnNlVXJsKF90aGlzLl9nZXQoKSkuc2VhcmNoKTsgfTtcbiAgICAgICAgdGhpcy5fbG9jYXRpb24gPSBjb21tb25fMS5yb290LmxvY2F0aW9uO1xuICAgICAgICB0aGlzLl9oaXN0b3J5ID0gY29tbW9uXzEucm9vdC5oaXN0b3J5O1xuICAgIH1cbiAgICBCYXNlTG9jYXRpb25TZXJ2aWNlcy5wcm90b3R5cGUudXJsID0gZnVuY3Rpb24gKHVybCwgcmVwbGFjZSkge1xuICAgICAgICBpZiAocmVwbGFjZSA9PT0gdm9pZCAwKSB7IHJlcGxhY2UgPSB0cnVlOyB9XG4gICAgICAgIGlmIChjb21tb25fMS5pc0RlZmluZWQodXJsKSAmJiB1cmwgIT09IHRoaXMuX2dldCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXQobnVsbCwgbnVsbCwgdXJsLCByZXBsYWNlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpcmVBZnRlclVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyByZXR1cm4gY2IoeyB1cmw6IHVybCB9KTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0aWxzXzEuYnVpbGRVcmwodGhpcyk7XG4gICAgfTtcbiAgICBCYXNlTG9jYXRpb25TZXJ2aWNlcy5wcm90b3R5cGUub25DaGFuZ2UgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzLnB1c2goY2IpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tbW9uXzEucmVtb3ZlRnJvbShfdGhpcy5fbGlzdGVuZXJzLCBjYik7IH07XG4gICAgfTtcbiAgICBCYXNlTG9jYXRpb25TZXJ2aWNlcy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChyb3V0ZXIpIHtcbiAgICAgICAgY29tbW9uXzEuZGVyZWdBbGwodGhpcy5fbGlzdGVuZXJzKTtcbiAgICB9O1xuICAgIHJldHVybiBCYXNlTG9jYXRpb25TZXJ2aWNlcztcbn0oKSk7XG5leHBvcnRzLkJhc2VMb2NhdGlvblNlcnZpY2VzID0gQmFzZUxvY2F0aW9uU2VydmljZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlTG9jYXRpb25TZXJ2aWNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9iYXNlTG9jYXRpb25TZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///20\n')},function(module,exports,__webpack_require__){"use strict";eval('\n/**\n * @module common\n */ /** for typedoc */\nObject.defineProperty(exports, "__esModule", { value: true });\nvar Queue = /** @class */ (function () {\n    function Queue(_items, _limit) {\n        if (_items === void 0) { _items = []; }\n        if (_limit === void 0) { _limit = null; }\n        this._items = _items;\n        this._limit = _limit;\n    }\n    Queue.prototype.enqueue = function (item) {\n        var items = this._items;\n        items.push(item);\n        if (this._limit && items.length > this._limit)\n            items.shift();\n        return item;\n    };\n    Queue.prototype.dequeue = function () {\n        if (this.size())\n            return this._items.splice(0, 1)[0];\n    };\n    Queue.prototype.clear = function () {\n        var current = this._items;\n        this._items = [];\n        return current;\n    };\n    Queue.prototype.size = function () {\n        return this._items.length;\n    };\n    Queue.prototype.remove = function (item) {\n        var idx = this._items.indexOf(item);\n        return idx > -1 && this._items.splice(idx, 1)[0];\n    };\n    Queue.prototype.peekTail = function () {\n        return this._items[this._items.length - 1];\n    };\n    Queue.prototype.peekHead = function () {\n        if (this.size())\n            return this._items[0];\n    };\n    return Queue;\n}());\nexports.Queue = Queue;\n//# sourceMappingURL=queue.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9jb21tb24vcXVldWUuanM/YTNkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQG1vZHVsZSBjb21tb25cbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBRdWV1ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRdWV1ZShfaXRlbXMsIF9saW1pdCkge1xuICAgICAgICBpZiAoX2l0ZW1zID09PSB2b2lkIDApIHsgX2l0ZW1zID0gW107IH1cbiAgICAgICAgaWYgKF9saW1pdCA9PT0gdm9pZCAwKSB7IF9saW1pdCA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5faXRlbXMgPSBfaXRlbXM7XG4gICAgICAgIHRoaXMuX2xpbWl0ID0gX2xpbWl0O1xuICAgIH1cbiAgICBRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMuX2l0ZW1zO1xuICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICBpZiAodGhpcy5fbGltaXQgJiYgaXRlbXMubGVuZ3RoID4gdGhpcy5fbGltaXQpXG4gICAgICAgICAgICBpdGVtcy5zaGlmdCgpO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9O1xuICAgIFF1ZXVlLnByb3RvdHlwZS5kZXF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zaXplKCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMuc3BsaWNlKDAsIDEpWzBdO1xuICAgIH07XG4gICAgUXVldWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2l0ZW1zO1xuICAgICAgICB0aGlzLl9pdGVtcyA9IFtdO1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9O1xuICAgIFF1ZXVlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMubGVuZ3RoO1xuICAgIH07XG4gICAgUXVldWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGl0ZW0pO1xuICAgICAgICByZXR1cm4gaWR4ID4gLTEgJiYgdGhpcy5faXRlbXMuc3BsaWNlKGlkeCwgMSlbMF07XG4gICAgfTtcbiAgICBRdWV1ZS5wcm90b3R5cGUucGVla1RhaWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtc1t0aGlzLl9pdGVtcy5sZW5ndGggLSAxXTtcbiAgICB9O1xuICAgIFF1ZXVlLnByb3RvdHlwZS5wZWVrSGVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSgpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zWzBdO1xuICAgIH07XG4gICAgcmV0dXJuIFF1ZXVlO1xufSgpKTtcbmV4cG9ydHMuUXVldWUgPSBRdWV1ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXVlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL3F1ZXVlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///21\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @coreapi\n * @module params\n */\n/** */\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ 1);\n/**\n * An internal class which implements [[ParamTypeDefinition]].\n *\n * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.\n * When a param type definition is registered, an instance of this class is created internally.\n *\n * This class has naive implementations for all the [[ParamTypeDefinition]] methods.\n *\n * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.\n *\n * #### Example:\n * ```js\n * var paramTypeDef = {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n *\n * var paramType = new ParamType(paramTypeDef);\n * ```\n * @internalapi\n */\nvar ParamType = /** @class */ (function () {\n    /**\n     * @param def  A configuration object which contains the custom type definition.  The object\'s\n     *        properties will override the default methods and/or pattern in `ParamType`\'s public interface.\n     * @returns a new ParamType object\n     */\n    function ParamType(def) {\n        /** @inheritdoc */\n        this.pattern = /.*/;\n        /** @inheritdoc */\n        this.inherit = true;\n        common_1.extend(this, def);\n    }\n    // consider these four methods to be "abstract methods" that should be overridden\n    /** @inheritdoc */\n    ParamType.prototype.is = function (val, key) { return true; };\n    /** @inheritdoc */\n    ParamType.prototype.encode = function (val, key) { return val; };\n    /** @inheritdoc */\n    ParamType.prototype.decode = function (val, key) { return val; };\n    /** @inheritdoc */\n    ParamType.prototype.equals = function (a, b) { return a == b; };\n    ParamType.prototype.$subPattern = function () {\n        var sub = this.pattern.toString();\n        return sub.substr(1, sub.length - 2);\n    };\n    ParamType.prototype.toString = function () {\n        return "{ParamType:" + this.name + "}";\n    };\n    /** Given an encoded string, or a decoded object, returns a decoded object */\n    ParamType.prototype.$normalize = function (val) {\n        return this.is(val) ? val : this.decode(val);\n    };\n    /**\n     * Wraps an existing custom ParamType as an array of ParamType, depending on \'mode\'.\n     * e.g.:\n     * - urlmatcher pattern "/path?{queryParam[]:int}"\n     * - url: "/path?queryParam=1&queryParam=2\n     * - $stateParams.queryParam will be [1, 2]\n     * if `mode` is "auto", then\n     * - url: "/path?queryParam=1 will create $stateParams.queryParam: 1\n     * - url: "/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n     */\n    ParamType.prototype.$asArray = function (mode, isSearch) {\n        if (!mode)\n            return this;\n        if (mode === "auto" && !isSearch)\n            throw new Error("\'auto\' array mode is for query parameters only");\n        return new ArrayType(this, mode);\n    };\n    return ParamType;\n}());\nexports.ParamType = ParamType;\n/**\n * Wraps up a `ParamType` object to handle array values.\n * @internalapi\n */\nfunction ArrayType(type, mode) {\n    var _this = this;\n    // Wrap non-array value as array\n    function arrayWrap(val) {\n        return predicates_1.isArray(val) ? val : (predicates_1.isDefined(val) ? [val] : []);\n    }\n    // Unwrap array value for "auto" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n        switch (val.length) {\n            case 0: return undefined;\n            case 1: return mode === "auto" ? val[0] : val;\n            default: return val;\n        }\n    }\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n        return function handleArray(val) {\n            if (predicates_1.isArray(val) && val.length === 0)\n                return val;\n            var arr = arrayWrap(val);\n            var result = common_1.map(arr, callback);\n            return (allTruthyMode === true) ? common_1.filter(result, function (x) { return !x; }).length === 0 : arrayUnwrap(result);\n        };\n    }\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n        return function handleArray(val1, val2) {\n            var left = arrayWrap(val1), right = arrayWrap(val2);\n            if (left.length !== right.length)\n                return false;\n            for (var i = 0; i < left.length; i++) {\n                if (!callback(left[i], right[i]))\n                    return false;\n            }\n            return true;\n        };\n    }\n    [\'encode\', \'decode\', \'equals\', \'$normalize\'].forEach(function (name) {\n        var paramTypeFn = type[name].bind(type);\n        var wrapperFn = name === \'equals\' ? arrayEqualsHandler : arrayHandler;\n        _this[name] = wrapperFn(paramTypeFn);\n    });\n    common_1.extend(this, {\n        dynamic: type.dynamic,\n        name: type.name,\n        pattern: type.pattern,\n        inherit: type.inherit,\n        is: arrayHandler(type.is.bind(type), true),\n        $arrayMode: mode\n    });\n}\n//# sourceMappingURL=paramType.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9wYXJhbXMvcGFyYW1UeXBlLmpzPzhhNWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHBhcmFtc1xuICovXG4vKiogKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbi8qKlxuICogQW4gaW50ZXJuYWwgY2xhc3Mgd2hpY2ggaW1wbGVtZW50cyBbW1BhcmFtVHlwZURlZmluaXRpb25dXS5cbiAqXG4gKiBBIFtbUGFyYW1UeXBlRGVmaW5pdGlvbl1dIGlzIGEgcGxhaW4gamF2YXNjcmlwdCBvYmplY3QgdXNlZCB0byByZWdpc3RlciBjdXN0b20gcGFyYW1ldGVyIHR5cGVzLlxuICogV2hlbiBhIHBhcmFtIHR5cGUgZGVmaW5pdGlvbiBpcyByZWdpc3RlcmVkLCBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGlzIGNyZWF0ZWQgaW50ZXJuYWxseS5cbiAqXG4gKiBUaGlzIGNsYXNzIGhhcyBuYWl2ZSBpbXBsZW1lbnRhdGlvbnMgZm9yIGFsbCB0aGUgW1tQYXJhbVR5cGVEZWZpbml0aW9uXV0gbWV0aG9kcy5cbiAqXG4gKiBVc2VkIGJ5IFtbVXJsTWF0Y2hlcl1dIHdoZW4gbWF0Y2hpbmcgb3IgZm9ybWF0dGluZyBVUkxzLCBvciBjb21wYXJpbmcgYW5kIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHZhbHVlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBqc1xuICogdmFyIHBhcmFtVHlwZURlZiA9IHtcbiAqICAgZGVjb2RlOiBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApOyB9LFxuICogICBlbmNvZGU6IGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gdmFsICYmIHZhbC50b1N0cmluZygpOyB9LFxuICogICBlcXVhbHM6IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIHRoaXMuaXMoYSkgJiYgYSA9PT0gYjsgfSxcbiAqICAgaXM6IGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gYW5ndWxhci5pc051bWJlcih2YWwpICYmIGlzRmluaXRlKHZhbCkgJiYgdmFsICUgMSA9PT0gMDsgfSxcbiAqICAgcGF0dGVybjogL1xcZCsvXG4gKiB9XG4gKlxuICogdmFyIHBhcmFtVHlwZSA9IG5ldyBQYXJhbVR5cGUocGFyYW1UeXBlRGVmKTtcbiAqIGBgYFxuICogQGludGVybmFsYXBpXG4gKi9cbnZhciBQYXJhbVR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGRlZiAgQSBjb25maWd1cmF0aW9uIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgY3VzdG9tIHR5cGUgZGVmaW5pdGlvbi4gIFRoZSBvYmplY3Qnc1xuICAgICAqICAgICAgICBwcm9wZXJ0aWVzIHdpbGwgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgbWV0aG9kcyBhbmQvb3IgcGF0dGVybiBpbiBgUGFyYW1UeXBlYCdzIHB1YmxpYyBpbnRlcmZhY2UuXG4gICAgICogQHJldHVybnMgYSBuZXcgUGFyYW1UeXBlIG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBhcmFtVHlwZShkZWYpIHtcbiAgICAgICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgICAgIHRoaXMucGF0dGVybiA9IC8uKi87XG4gICAgICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgICAgICB0aGlzLmluaGVyaXQgPSB0cnVlO1xuICAgICAgICBjb21tb25fMS5leHRlbmQodGhpcywgZGVmKTtcbiAgICB9XG4gICAgLy8gY29uc2lkZXIgdGhlc2UgZm91ciBtZXRob2RzIHRvIGJlIFwiYWJzdHJhY3QgbWV0aG9kc1wiIHRoYXQgc2hvdWxkIGJlIG92ZXJyaWRkZW5cbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBQYXJhbVR5cGUucHJvdG90eXBlLmlzID0gZnVuY3Rpb24gKHZhbCwga2V5KSB7IHJldHVybiB0cnVlOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFBhcmFtVHlwZS5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHZhbCwga2V5KSB7IHJldHVybiB2YWw7IH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgUGFyYW1UeXBlLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAodmFsLCBrZXkpIHsgcmV0dXJuIHZhbDsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBQYXJhbVR5cGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhID09IGI7IH07XG4gICAgUGFyYW1UeXBlLnByb3RvdHlwZS4kc3ViUGF0dGVybiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN1YiA9IHRoaXMucGF0dGVybi50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gc3ViLnN1YnN0cigxLCBzdWIubGVuZ3RoIC0gMik7XG4gICAgfTtcbiAgICBQYXJhbVR5cGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJ7UGFyYW1UeXBlOlwiICsgdGhpcy5uYW1lICsgXCJ9XCI7XG4gICAgfTtcbiAgICAvKiogR2l2ZW4gYW4gZW5jb2RlZCBzdHJpbmcsIG9yIGEgZGVjb2RlZCBvYmplY3QsIHJldHVybnMgYSBkZWNvZGVkIG9iamVjdCAqL1xuICAgIFBhcmFtVHlwZS5wcm90b3R5cGUuJG5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXModmFsKSA/IHZhbCA6IHRoaXMuZGVjb2RlKHZhbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXcmFwcyBhbiBleGlzdGluZyBjdXN0b20gUGFyYW1UeXBlIGFzIGFuIGFycmF5IG9mIFBhcmFtVHlwZSwgZGVwZW5kaW5nIG9uICdtb2RlJy5cbiAgICAgKiBlLmcuOlxuICAgICAqIC0gdXJsbWF0Y2hlciBwYXR0ZXJuIFwiL3BhdGg/e3F1ZXJ5UGFyYW1bXTppbnR9XCJcbiAgICAgKiAtIHVybDogXCIvcGF0aD9xdWVyeVBhcmFtPTEmcXVlcnlQYXJhbT0yXG4gICAgICogLSAkc3RhdGVQYXJhbXMucXVlcnlQYXJhbSB3aWxsIGJlIFsxLCAyXVxuICAgICAqIGlmIGBtb2RlYCBpcyBcImF1dG9cIiwgdGhlblxuICAgICAqIC0gdXJsOiBcIi9wYXRoP3F1ZXJ5UGFyYW09MSB3aWxsIGNyZWF0ZSAkc3RhdGVQYXJhbXMucXVlcnlQYXJhbTogMVxuICAgICAqIC0gdXJsOiBcIi9wYXRoP3F1ZXJ5UGFyYW09MSZxdWVyeVBhcmFtPTIgd2lsbCBjcmVhdGUgJHN0YXRlUGFyYW1zLnF1ZXJ5UGFyYW06IFsxLCAyXVxuICAgICAqL1xuICAgIFBhcmFtVHlwZS5wcm90b3R5cGUuJGFzQXJyYXkgPSBmdW5jdGlvbiAobW9kZSwgaXNTZWFyY2gpIHtcbiAgICAgICAgaWYgKCFtb2RlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChtb2RlID09PSBcImF1dG9cIiAmJiAhaXNTZWFyY2gpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInYXV0bycgYXJyYXkgbW9kZSBpcyBmb3IgcXVlcnkgcGFyYW1ldGVycyBvbmx5XCIpO1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5VHlwZSh0aGlzLCBtb2RlKTtcbiAgICB9O1xuICAgIHJldHVybiBQYXJhbVR5cGU7XG59KCkpO1xuZXhwb3J0cy5QYXJhbVR5cGUgPSBQYXJhbVR5cGU7XG4vKipcbiAqIFdyYXBzIHVwIGEgYFBhcmFtVHlwZWAgb2JqZWN0IHRvIGhhbmRsZSBhcnJheSB2YWx1ZXMuXG4gKiBAaW50ZXJuYWxhcGlcbiAqL1xuZnVuY3Rpb24gQXJyYXlUeXBlKHR5cGUsIG1vZGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIC8vIFdyYXAgbm9uLWFycmF5IHZhbHVlIGFzIGFycmF5XG4gICAgZnVuY3Rpb24gYXJyYXlXcmFwKHZhbCkge1xuICAgICAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzQXJyYXkodmFsKSA/IHZhbCA6IChwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHZhbCkgPyBbdmFsXSA6IFtdKTtcbiAgICB9XG4gICAgLy8gVW53cmFwIGFycmF5IHZhbHVlIGZvciBcImF1dG9cIiBtb2RlLiBSZXR1cm4gdW5kZWZpbmVkIGZvciBlbXB0eSBhcnJheS5cbiAgICBmdW5jdGlvbiBhcnJheVVud3JhcCh2YWwpIHtcbiAgICAgICAgc3dpdGNoICh2YWwubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBtb2RlID09PSBcImF1dG9cIiA/IHZhbFswXSA6IHZhbDtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gV3JhcHMgdHlwZSAoLmlzLy5lbmNvZGUvLmRlY29kZSkgZnVuY3Rpb25zIHRvIG9wZXJhdGUgb24gZWFjaCB2YWx1ZSBvZiBhbiBhcnJheVxuICAgIGZ1bmN0aW9uIGFycmF5SGFuZGxlcihjYWxsYmFjaywgYWxsVHJ1dGh5TW9kZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlQXJyYXkodmFsKSB7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzQXJyYXkodmFsKSAmJiB2YWwubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB2YXIgYXJyID0gYXJyYXlXcmFwKHZhbCk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY29tbW9uXzEubWFwKGFyciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuIChhbGxUcnV0aHlNb2RlID09PSB0cnVlKSA/IGNvbW1vbl8xLmZpbHRlcihyZXN1bHQsIGZ1bmN0aW9uICh4KSB7IHJldHVybiAheDsgfSkubGVuZ3RoID09PSAwIDogYXJyYXlVbndyYXAocmVzdWx0KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gV3JhcHMgdHlwZSAoLmVxdWFscykgZnVuY3Rpb25zIHRvIG9wZXJhdGUgb24gZWFjaCB2YWx1ZSBvZiBhbiBhcnJheVxuICAgIGZ1bmN0aW9uIGFycmF5RXF1YWxzSGFuZGxlcihjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlQXJyYXkodmFsMSwgdmFsMikge1xuICAgICAgICAgICAgdmFyIGxlZnQgPSBhcnJheVdyYXAodmFsMSksIHJpZ2h0ID0gYXJyYXlXcmFwKHZhbDIpO1xuICAgICAgICAgICAgaWYgKGxlZnQubGVuZ3RoICE9PSByaWdodC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWZ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWxsYmFjayhsZWZ0W2ldLCByaWdodFtpXSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBbJ2VuY29kZScsICdkZWNvZGUnLCAnZXF1YWxzJywgJyRub3JtYWxpemUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBwYXJhbVR5cGVGbiA9IHR5cGVbbmFtZV0uYmluZCh0eXBlKTtcbiAgICAgICAgdmFyIHdyYXBwZXJGbiA9IG5hbWUgPT09ICdlcXVhbHMnID8gYXJyYXlFcXVhbHNIYW5kbGVyIDogYXJyYXlIYW5kbGVyO1xuICAgICAgICBfdGhpc1tuYW1lXSA9IHdyYXBwZXJGbihwYXJhbVR5cGVGbik7XG4gICAgfSk7XG4gICAgY29tbW9uXzEuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgZHluYW1pYzogdHlwZS5keW5hbWljLFxuICAgICAgICBuYW1lOiB0eXBlLm5hbWUsXG4gICAgICAgIHBhdHRlcm46IHR5cGUucGF0dGVybixcbiAgICAgICAgaW5oZXJpdDogdHlwZS5pbmhlcml0LFxuICAgICAgICBpczogYXJyYXlIYW5kbGVyKHR5cGUuaXMuYmluZCh0eXBlKSwgdHJ1ZSksXG4gICAgICAgICRhcnJheU1vZGU6IG1vZGVcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcmFtVHlwZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9wYXJhbVR5cGUuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///22\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/** @module path */ /** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar hof_1 = __webpack_require__(/*! ../common/hof */ 2);\nvar param_1 = __webpack_require__(/*! ../params/param */ 8);\n/**\n * @internalapi\n *\n * A node in a [[TreeChanges]] path\n *\n * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.\n * Each PathNode corresponds to a state being entered, exited, or retained.\n * The stateful information includes parameter values and resolve data.\n */\nvar PathNode = /** @class */ (function () {\n    function PathNode(stateOrNode) {\n        if (stateOrNode instanceof PathNode) {\n            var node = stateOrNode;\n            this.state = node.state;\n            this.paramSchema = node.paramSchema.slice();\n            this.paramValues = common_1.extend({}, node.paramValues);\n            this.resolvables = node.resolvables.slice();\n            this.views = node.views && node.views.slice();\n        }\n        else {\n            var state = stateOrNode;\n            this.state = state;\n            this.paramSchema = state.parameters({ inherit: false });\n            this.paramValues = {};\n            this.resolvables = state.resolvables.map(function (res) { return res.clone(); });\n        }\n    }\n    /** Sets [[paramValues]] for the node, from the values of an object hash */\n    PathNode.prototype.applyRawParams = function (params) {\n        var getParamVal = function (paramDef) { return [paramDef.id, paramDef.value(params[paramDef.id])]; };\n        this.paramValues = this.paramSchema.reduce(function (memo, pDef) { return common_1.applyPairs(memo, getParamVal(pDef)); }, {});\n        return this;\n    };\n    /** Gets a specific [[Param]] metadata that belongs to the node */\n    PathNode.prototype.parameter = function (name) {\n        return common_1.find(this.paramSchema, hof_1.propEq("id", name));\n    };\n    /**\n     * @returns true if the state and parameter values for another PathNode are\n     * equal to the state and param values for this PathNode\n     */\n    PathNode.prototype.equals = function (node, paramsFn) {\n        var diff = this.diff(node, paramsFn);\n        return diff && diff.length === 0;\n    };\n    /**\n     * Finds Params with different parameter values on another PathNode.\n     *\n     * Given another node (of the same state), finds the parameter values which differ.\n     * Returns the [[Param]] (schema objects) whose parameter values differ.\n     *\n     * Given another node for a different state, returns `false`\n     *\n     * @param node The node to compare to\n     * @param paramsFn A function that returns which parameters should be compared.\n     * @returns The [[Param]]s which differ, or null if the two nodes are for different states\n     */\n    PathNode.prototype.diff = function (node, paramsFn) {\n        if (this.state !== node.state)\n            return false;\n        var params = paramsFn ? paramsFn(this) : this.paramSchema;\n        return param_1.Param.changed(params, this.paramValues, node.paramValues);\n    };\n    /** Returns a clone of the PathNode */\n    PathNode.clone = function (node) {\n        return new PathNode(node);\n    };\n    return PathNode;\n}());\nexports.PathNode = PathNode;\n//# sourceMappingURL=pathNode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9wYXRoL3BhdGhOb2RlLmpzPzQ4OTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogQG1vZHVsZSBwYXRoICovIC8qKiBmb3IgdHlwZWRvYyAqL1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciBwYXJhbV8xID0gcmVxdWlyZShcIi4uL3BhcmFtcy9wYXJhbVwiKTtcbi8qKlxuICogQGludGVybmFsYXBpXG4gKlxuICogQSBub2RlIGluIGEgW1tUcmVlQ2hhbmdlc11dIHBhdGhcbiAqXG4gKiBGb3IgYSBbW1RyZWVDaGFuZ2VzXV0gcGF0aCwgdGhpcyBjbGFzcyBob2xkcyB0aGUgc3RhdGVmdWwgaW5mb3JtYXRpb24gZm9yIGEgc2luZ2xlIG5vZGUgaW4gdGhlIHBhdGguXG4gKiBFYWNoIFBhdGhOb2RlIGNvcnJlc3BvbmRzIHRvIGEgc3RhdGUgYmVpbmcgZW50ZXJlZCwgZXhpdGVkLCBvciByZXRhaW5lZC5cbiAqIFRoZSBzdGF0ZWZ1bCBpbmZvcm1hdGlvbiBpbmNsdWRlcyBwYXJhbWV0ZXIgdmFsdWVzIGFuZCByZXNvbHZlIGRhdGEuXG4gKi9cbnZhciBQYXRoTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXRoTm9kZShzdGF0ZU9yTm9kZSkge1xuICAgICAgICBpZiAoc3RhdGVPck5vZGUgaW5zdGFuY2VvZiBQYXRoTm9kZSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGF0ZU9yTm9kZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBub2RlLnN0YXRlO1xuICAgICAgICAgICAgdGhpcy5wYXJhbVNjaGVtYSA9IG5vZGUucGFyYW1TY2hlbWEuc2xpY2UoKTtcbiAgICAgICAgICAgIHRoaXMucGFyYW1WYWx1ZXMgPSBjb21tb25fMS5leHRlbmQoe30sIG5vZGUucGFyYW1WYWx1ZXMpO1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZhYmxlcyA9IG5vZGUucmVzb2x2YWJsZXMuc2xpY2UoKTtcbiAgICAgICAgICAgIHRoaXMudmlld3MgPSBub2RlLnZpZXdzICYmIG5vZGUudmlld3Muc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHN0YXRlT3JOb2RlO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgdGhpcy5wYXJhbVNjaGVtYSA9IHN0YXRlLnBhcmFtZXRlcnMoeyBpbmhlcml0OiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHRoaXMucGFyYW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2YWJsZXMgPSBzdGF0ZS5yZXNvbHZhYmxlcy5tYXAoZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gcmVzLmNsb25lKCk7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBTZXRzIFtbcGFyYW1WYWx1ZXNdXSBmb3IgdGhlIG5vZGUsIGZyb20gdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QgaGFzaCAqL1xuICAgIFBhdGhOb2RlLnByb3RvdHlwZS5hcHBseVJhd1BhcmFtcyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIGdldFBhcmFtVmFsID0gZnVuY3Rpb24gKHBhcmFtRGVmKSB7IHJldHVybiBbcGFyYW1EZWYuaWQsIHBhcmFtRGVmLnZhbHVlKHBhcmFtc1twYXJhbURlZi5pZF0pXTsgfTtcbiAgICAgICAgdGhpcy5wYXJhbVZhbHVlcyA9IHRoaXMucGFyYW1TY2hlbWEucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBwRGVmKSB7IHJldHVybiBjb21tb25fMS5hcHBseVBhaXJzKG1lbW8sIGdldFBhcmFtVmFsKHBEZWYpKTsgfSwge30pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBHZXRzIGEgc3BlY2lmaWMgW1tQYXJhbV1dIG1ldGFkYXRhIHRoYXQgYmVsb25ncyB0byB0aGUgbm9kZSAqL1xuICAgIFBhdGhOb2RlLnByb3RvdHlwZS5wYXJhbWV0ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEuZmluZCh0aGlzLnBhcmFtU2NoZW1hLCBob2ZfMS5wcm9wRXEoXCJpZFwiLCBuYW1lKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBzdGF0ZSBhbmQgcGFyYW1ldGVyIHZhbHVlcyBmb3IgYW5vdGhlciBQYXRoTm9kZSBhcmVcbiAgICAgKiBlcXVhbCB0byB0aGUgc3RhdGUgYW5kIHBhcmFtIHZhbHVlcyBmb3IgdGhpcyBQYXRoTm9kZVxuICAgICAqL1xuICAgIFBhdGhOb2RlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAobm9kZSwgcGFyYW1zRm4pIHtcbiAgICAgICAgdmFyIGRpZmYgPSB0aGlzLmRpZmYobm9kZSwgcGFyYW1zRm4pO1xuICAgICAgICByZXR1cm4gZGlmZiAmJiBkaWZmLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpbmRzIFBhcmFtcyB3aXRoIGRpZmZlcmVudCBwYXJhbWV0ZXIgdmFsdWVzIG9uIGFub3RoZXIgUGF0aE5vZGUuXG4gICAgICpcbiAgICAgKiBHaXZlbiBhbm90aGVyIG5vZGUgKG9mIHRoZSBzYW1lIHN0YXRlKSwgZmluZHMgdGhlIHBhcmFtZXRlciB2YWx1ZXMgd2hpY2ggZGlmZmVyLlxuICAgICAqIFJldHVybnMgdGhlIFtbUGFyYW1dXSAoc2NoZW1hIG9iamVjdHMpIHdob3NlIHBhcmFtZXRlciB2YWx1ZXMgZGlmZmVyLlxuICAgICAqXG4gICAgICogR2l2ZW4gYW5vdGhlciBub2RlIGZvciBhIGRpZmZlcmVudCBzdGF0ZSwgcmV0dXJucyBgZmFsc2VgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byBjb21wYXJlIHRvXG4gICAgICogQHBhcmFtIHBhcmFtc0ZuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHdoaWNoIHBhcmFtZXRlcnMgc2hvdWxkIGJlIGNvbXBhcmVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBbW1BhcmFtXV1zIHdoaWNoIGRpZmZlciwgb3IgbnVsbCBpZiB0aGUgdHdvIG5vZGVzIGFyZSBmb3IgZGlmZmVyZW50IHN0YXRlc1xuICAgICAqL1xuICAgIFBhdGhOb2RlLnByb3RvdHlwZS5kaWZmID0gZnVuY3Rpb24gKG5vZGUsIHBhcmFtc0ZuKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBub2RlLnN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgcGFyYW1zID0gcGFyYW1zRm4gPyBwYXJhbXNGbih0aGlzKSA6IHRoaXMucGFyYW1TY2hlbWE7XG4gICAgICAgIHJldHVybiBwYXJhbV8xLlBhcmFtLmNoYW5nZWQocGFyYW1zLCB0aGlzLnBhcmFtVmFsdWVzLCBub2RlLnBhcmFtVmFsdWVzKTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIFBhdGhOb2RlICovXG4gICAgUGF0aE5vZGUuY2xvbmUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IFBhdGhOb2RlKG5vZGUpO1xuICAgIH07XG4gICAgcmV0dXJuIFBhdGhOb2RlO1xufSgpKTtcbmV4cG9ydHMuUGF0aE5vZGUgPSBQYXRoTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGhOb2RlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvcGF0aC9wYXRoTm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23\n')},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar hof_1 = __webpack_require__(/*! ../common/hof */ 2);\nvar glob_1 = __webpack_require__(/*! ../common/glob */ 15);\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ 1);\n/**\n * Internal representation of a UI-Router state.\n *\n * Instances of this class are created when a [[StateDeclaration]] is registered with the [[StateRegistry]].\n *\n * A registered [[StateDeclaration]] is augmented with a getter ([[StateDeclaration.$$state]]) which returns the corresponding [[StateObject]] object.\n *\n * This class prototypally inherits from the corresponding [[StateDeclaration]].\n * Each of its own properties (i.e., `hasOwnProperty`) are built using builders from the [[StateBuilder]].\n */\nvar StateObject = /** @class */ (function () {\n    /** @deprecated use State.create() */\n    function StateObject(config) {\n        return StateObject.create(config || {});\n    }\n    /**\n     * Create a state object to put the private/internal implementation details onto.\n     * The object's prototype chain looks like:\n     * (Internal State Object) -> (Copy of State.prototype) -> (State Declaration object) -> (State Declaration's prototype...)\n     *\n     * @param stateDecl the user-supplied State Declaration\n     * @returns {StateObject} an internal State object\n     */\n    StateObject.create = function (stateDecl) {\n        stateDecl = StateObject.isStateClass(stateDecl) ? new stateDecl() : stateDecl;\n        var state = common_1.inherit(common_1.inherit(stateDecl, StateObject.prototype));\n        stateDecl.$$state = function () { return state; };\n        state.self = stateDecl;\n        state.__stateObjectCache = {\n            nameGlob: glob_1.Glob.fromString(state.name) // might return null\n        };\n        return state;\n    };\n    /**\n     * Returns true if the provided parameter is the same state.\n     *\n     * Compares the identity of the state against the passed value, which is either an object\n     * reference to the actual `State` instance, the original definition object passed to\n     * `$stateProvider.state()`, or the fully-qualified name.\n     *\n     * @param ref Can be one of (a) a `State` instance, (b) an object that was passed\n     *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.\n     * @returns Returns `true` if `ref` matches the current `State` instance.\n     */\n    StateObject.prototype.is = function (ref) {\n        return this === ref || this.self === ref || this.fqn() === ref;\n    };\n    /**\n     * @deprecated this does not properly handle dot notation\n     * @returns Returns a dot-separated name of the state.\n     */\n    StateObject.prototype.fqn = function () {\n        if (!this.parent || !(this.parent instanceof this.constructor))\n            return this.name;\n        var name = this.parent.fqn();\n        return name ? name + \".\" + this.name : this.name;\n    };\n    /**\n     * Returns the root node of this state's tree.\n     *\n     * @returns The root of this state's tree.\n     */\n    StateObject.prototype.root = function () {\n        return this.parent && this.parent.root() || this;\n    };\n    /**\n     * Gets the state's `Param` objects\n     *\n     * Gets the list of [[Param]] objects owned by the state.\n     * If `opts.inherit` is true, it also includes the ancestor states' [[Param]] objects.\n     * If `opts.matchingKeys` exists, returns only `Param`s whose `id` is a key on the `matchingKeys` object\n     *\n     * @param opts options\n     */\n    StateObject.prototype.parameters = function (opts) {\n        opts = common_1.defaults(opts, { inherit: true, matchingKeys: null });\n        var inherited = opts.inherit && this.parent && this.parent.parameters() || [];\n        return inherited.concat(common_1.values(this.params))\n            .filter(function (param) { return !opts.matchingKeys || opts.matchingKeys.hasOwnProperty(param.id); });\n    };\n    /**\n     * Returns a single [[Param]] that is owned by the state\n     *\n     * If `opts.inherit` is true, it also searches the ancestor states` [[Param]]s.\n     * @param id the name of the [[Param]] to return\n     * @param opts options\n     */\n    StateObject.prototype.parameter = function (id, opts) {\n        if (opts === void 0) { opts = {}; }\n        return (this.url && this.url.parameter(id, opts) ||\n            common_1.find(common_1.values(this.params), hof_1.propEq('id', id)) ||\n            opts.inherit && this.parent && this.parent.parameter(id));\n    };\n    StateObject.prototype.toString = function () {\n        return this.fqn();\n    };\n    /** Predicate which returns true if the object is an class with @State() decorator */\n    StateObject.isStateClass = function (stateDecl) {\n        return predicates_1.isFunction(stateDecl) && stateDecl['__uiRouterState'] === true;\n    };\n    /** Predicate which returns true if the object is an internal [[StateObject]] object */\n    StateObject.isState = function (obj) {\n        return predicates_1.isObject(obj['__stateObjectCache']);\n    };\n    return StateObject;\n}());\nexports.StateObject = StateObject;\n//# sourceMappingURL=stateObject.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9zdGF0ZU9iamVjdC5qcz8wZTA1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciBnbG9iXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2dsb2JcIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xuLyoqXG4gKiBJbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIFVJLVJvdXRlciBzdGF0ZS5cbiAqXG4gKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgY3JlYXRlZCB3aGVuIGEgW1tTdGF0ZURlY2xhcmF0aW9uXV0gaXMgcmVnaXN0ZXJlZCB3aXRoIHRoZSBbW1N0YXRlUmVnaXN0cnldXS5cbiAqXG4gKiBBIHJlZ2lzdGVyZWQgW1tTdGF0ZURlY2xhcmF0aW9uXV0gaXMgYXVnbWVudGVkIHdpdGggYSBnZXR0ZXIgKFtbU3RhdGVEZWNsYXJhdGlvbi4kJHN0YXRlXV0pIHdoaWNoIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgW1tTdGF0ZU9iamVjdF1dIG9iamVjdC5cbiAqXG4gKiBUaGlzIGNsYXNzIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIFtbU3RhdGVEZWNsYXJhdGlvbl1dLlxuICogRWFjaCBvZiBpdHMgb3duIHByb3BlcnRpZXMgKGkuZS4sIGBoYXNPd25Qcm9wZXJ0eWApIGFyZSBidWlsdCB1c2luZyBidWlsZGVycyBmcm9tIHRoZSBbW1N0YXRlQnVpbGRlcl1dLlxuICovXG52YXIgU3RhdGVPYmplY3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBTdGF0ZS5jcmVhdGUoKSAqL1xuICAgIGZ1bmN0aW9uIFN0YXRlT2JqZWN0KGNvbmZpZykge1xuICAgICAgICByZXR1cm4gU3RhdGVPYmplY3QuY3JlYXRlKGNvbmZpZyB8fCB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHN0YXRlIG9iamVjdCB0byBwdXQgdGhlIHByaXZhdGUvaW50ZXJuYWwgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbnRvLlxuICAgICAqIFRoZSBvYmplY3QncyBwcm90b3R5cGUgY2hhaW4gbG9va3MgbGlrZTpcbiAgICAgKiAoSW50ZXJuYWwgU3RhdGUgT2JqZWN0KSAtPiAoQ29weSBvZiBTdGF0ZS5wcm90b3R5cGUpIC0+IChTdGF0ZSBEZWNsYXJhdGlvbiBvYmplY3QpIC0+IChTdGF0ZSBEZWNsYXJhdGlvbidzIHByb3RvdHlwZS4uLilcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZURlY2wgdGhlIHVzZXItc3VwcGxpZWQgU3RhdGUgRGVjbGFyYXRpb25cbiAgICAgKiBAcmV0dXJucyB7U3RhdGVPYmplY3R9IGFuIGludGVybmFsIFN0YXRlIG9iamVjdFxuICAgICAqL1xuICAgIFN0YXRlT2JqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIChzdGF0ZURlY2wpIHtcbiAgICAgICAgc3RhdGVEZWNsID0gU3RhdGVPYmplY3QuaXNTdGF0ZUNsYXNzKHN0YXRlRGVjbCkgPyBuZXcgc3RhdGVEZWNsKCkgOiBzdGF0ZURlY2w7XG4gICAgICAgIHZhciBzdGF0ZSA9IGNvbW1vbl8xLmluaGVyaXQoY29tbW9uXzEuaW5oZXJpdChzdGF0ZURlY2wsIFN0YXRlT2JqZWN0LnByb3RvdHlwZSkpO1xuICAgICAgICBzdGF0ZURlY2wuJCRzdGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0YXRlOyB9O1xuICAgICAgICBzdGF0ZS5zZWxmID0gc3RhdGVEZWNsO1xuICAgICAgICBzdGF0ZS5fX3N0YXRlT2JqZWN0Q2FjaGUgPSB7XG4gICAgICAgICAgICBuYW1lR2xvYjogZ2xvYl8xLkdsb2IuZnJvbVN0cmluZyhzdGF0ZS5uYW1lKSAvLyBtaWdodCByZXR1cm4gbnVsbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBpcyB0aGUgc2FtZSBzdGF0ZS5cbiAgICAgKlxuICAgICAqIENvbXBhcmVzIHRoZSBpZGVudGl0eSBvZiB0aGUgc3RhdGUgYWdhaW5zdCB0aGUgcGFzc2VkIHZhbHVlLCB3aGljaCBpcyBlaXRoZXIgYW4gb2JqZWN0XG4gICAgICogcmVmZXJlbmNlIHRvIHRoZSBhY3R1YWwgYFN0YXRlYCBpbnN0YW5jZSwgdGhlIG9yaWdpbmFsIGRlZmluaXRpb24gb2JqZWN0IHBhc3NlZCB0b1xuICAgICAqIGAkc3RhdGVQcm92aWRlci5zdGF0ZSgpYCwgb3IgdGhlIGZ1bGx5LXF1YWxpZmllZCBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlZiBDYW4gYmUgb25lIG9mIChhKSBhIGBTdGF0ZWAgaW5zdGFuY2UsIChiKSBhbiBvYmplY3QgdGhhdCB3YXMgcGFzc2VkXG4gICAgICogICAgICAgIGludG8gYCRzdGF0ZVByb3ZpZGVyLnN0YXRlKClgLCAoYykgdGhlIGZ1bGx5LXF1YWxpZmllZCBuYW1lIG9mIGEgc3RhdGUgYXMgYSBzdHJpbmcuXG4gICAgICogQHJldHVybnMgUmV0dXJucyBgdHJ1ZWAgaWYgYHJlZmAgbWF0Y2hlcyB0aGUgY3VycmVudCBgU3RhdGVgIGluc3RhbmNlLlxuICAgICAqL1xuICAgIFN0YXRlT2JqZWN0LnByb3RvdHlwZS5pcyA9IGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT09IHJlZiB8fCB0aGlzLnNlbGYgPT09IHJlZiB8fCB0aGlzLmZxbigpID09PSByZWY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCB0aGlzIGRvZXMgbm90IHByb3Blcmx5IGhhbmRsZSBkb3Qgbm90YXRpb25cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGEgZG90LXNlcGFyYXRlZCBuYW1lIG9mIHRoZSBzdGF0ZS5cbiAgICAgKi9cbiAgICBTdGF0ZU9iamVjdC5wcm90b3R5cGUuZnFuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50IHx8ICEodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5wYXJlbnQuZnFuKCk7XG4gICAgICAgIHJldHVybiBuYW1lID8gbmFtZSArIFwiLlwiICsgdGhpcy5uYW1lIDogdGhpcy5uYW1lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcm9vdCBub2RlIG9mIHRoaXMgc3RhdGUncyB0cmVlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHJvb3Qgb2YgdGhpcyBzdGF0ZSdzIHRyZWUuXG4gICAgICovXG4gICAgU3RhdGVPYmplY3QucHJvdG90eXBlLnJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5yb290KCkgfHwgdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN0YXRlJ3MgYFBhcmFtYCBvYmplY3RzXG4gICAgICpcbiAgICAgKiBHZXRzIHRoZSBsaXN0IG9mIFtbUGFyYW1dXSBvYmplY3RzIG93bmVkIGJ5IHRoZSBzdGF0ZS5cbiAgICAgKiBJZiBgb3B0cy5pbmhlcml0YCBpcyB0cnVlLCBpdCBhbHNvIGluY2x1ZGVzIHRoZSBhbmNlc3RvciBzdGF0ZXMnIFtbUGFyYW1dXSBvYmplY3RzLlxuICAgICAqIElmIGBvcHRzLm1hdGNoaW5nS2V5c2AgZXhpc3RzLCByZXR1cm5zIG9ubHkgYFBhcmFtYHMgd2hvc2UgYGlkYCBpcyBhIGtleSBvbiB0aGUgYG1hdGNoaW5nS2V5c2Agb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyBvcHRpb25zXG4gICAgICovXG4gICAgU3RhdGVPYmplY3QucHJvdG90eXBlLnBhcmFtZXRlcnMgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICBvcHRzID0gY29tbW9uXzEuZGVmYXVsdHMob3B0cywgeyBpbmhlcml0OiB0cnVlLCBtYXRjaGluZ0tleXM6IG51bGwgfSk7XG4gICAgICAgIHZhciBpbmhlcml0ZWQgPSBvcHRzLmluaGVyaXQgJiYgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQucGFyYW1ldGVycygpIHx8IFtdO1xuICAgICAgICByZXR1cm4gaW5oZXJpdGVkLmNvbmNhdChjb21tb25fMS52YWx1ZXModGhpcy5wYXJhbXMpKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuICFvcHRzLm1hdGNoaW5nS2V5cyB8fCBvcHRzLm1hdGNoaW5nS2V5cy5oYXNPd25Qcm9wZXJ0eShwYXJhbS5pZCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHNpbmdsZSBbW1BhcmFtXV0gdGhhdCBpcyBvd25lZCBieSB0aGUgc3RhdGVcbiAgICAgKlxuICAgICAqIElmIGBvcHRzLmluaGVyaXRgIGlzIHRydWUsIGl0IGFsc28gc2VhcmNoZXMgdGhlIGFuY2VzdG9yIHN0YXRlc2AgW1tQYXJhbV1dcy5cbiAgICAgKiBAcGFyYW0gaWQgdGhlIG5hbWUgb2YgdGhlIFtbUGFyYW1dXSB0byByZXR1cm5cbiAgICAgKiBAcGFyYW0gb3B0cyBvcHRpb25zXG4gICAgICovXG4gICAgU3RhdGVPYmplY3QucHJvdG90eXBlLnBhcmFtZXRlciA9IGZ1bmN0aW9uIChpZCwgb3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7IG9wdHMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gKHRoaXMudXJsICYmIHRoaXMudXJsLnBhcmFtZXRlcihpZCwgb3B0cykgfHxcbiAgICAgICAgICAgIGNvbW1vbl8xLmZpbmQoY29tbW9uXzEudmFsdWVzKHRoaXMucGFyYW1zKSwgaG9mXzEucHJvcEVxKCdpZCcsIGlkKSkgfHxcbiAgICAgICAgICAgIG9wdHMuaW5oZXJpdCAmJiB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5wYXJhbWV0ZXIoaWQpKTtcbiAgICB9O1xuICAgIFN0YXRlT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnFuKCk7XG4gICAgfTtcbiAgICAvKiogUHJlZGljYXRlIHdoaWNoIHJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGFuIGNsYXNzIHdpdGggQFN0YXRlKCkgZGVjb3JhdG9yICovXG4gICAgU3RhdGVPYmplY3QuaXNTdGF0ZUNsYXNzID0gZnVuY3Rpb24gKHN0YXRlRGVjbCkge1xuICAgICAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzRnVuY3Rpb24oc3RhdGVEZWNsKSAmJiBzdGF0ZURlY2xbJ19fdWlSb3V0ZXJTdGF0ZSddID09PSB0cnVlO1xuICAgIH07XG4gICAgLyoqIFByZWRpY2F0ZSB3aGljaCByZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBhbiBpbnRlcm5hbCBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0ICovXG4gICAgU3RhdGVPYmplY3QuaXNTdGF0ZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc09iamVjdChvYmpbJ19fc3RhdGVPYmplY3RDYWNoZSddKTtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0ZU9iamVjdDtcbn0oKSk7XG5leHBvcnRzLlN0YXRlT2JqZWN0ID0gU3RhdGVPYmplY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0ZU9iamVjdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlT2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///24\n")},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ 1);\nvar interface_1 = __webpack_require__(/*! ./interface */ 10); // has or is using\nvar glob_1 = __webpack_require__(/*! ../common/glob */ 15);\n/**\n * Determines if the given state matches the matchCriteria\n *\n * @hidden\n *\n * @param state a State Object to test against\n * @param criterion\n * - If a string, matchState uses the string as a glob-matcher against the state name\n * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name\n *   and returns a positive match if any of the globs match.\n * - If a function, matchState calls the function with the state and returns true if the function\'s result is truthy.\n * @returns {boolean}\n */\nfunction matchState(state, criterion) {\n    var toMatch = predicates_1.isString(criterion) ? [criterion] : criterion;\n    function matchGlobs(_state) {\n        var globStrings = toMatch;\n        for (var i = 0; i < globStrings.length; i++) {\n            var glob = new glob_1.Glob(globStrings[i]);\n            if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    var matchFn = (predicates_1.isFunction(toMatch) ? toMatch : matchGlobs);\n    return !!matchFn(state);\n}\nexports.matchState = matchState;\n/**\n * @internalapi\n * The registration data for a registered transition hook\n */\nvar RegisteredHook = /** @class */ (function () {\n    function RegisteredHook(tranSvc, eventType, callback, matchCriteria, removeHookFromRegistry, options) {\n        if (options === void 0) { options = {}; }\n        this.tranSvc = tranSvc;\n        this.eventType = eventType;\n        this.callback = callback;\n        this.matchCriteria = matchCriteria;\n        this.removeHookFromRegistry = removeHookFromRegistry;\n        this.invokeCount = 0;\n        this._deregistered = false;\n        this.priority = options.priority || 0;\n        this.bind = options.bind || null;\n        this.invokeLimit = options.invokeLimit;\n    }\n    /**\n     * Gets the matching [[PathNode]]s\n     *\n     * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing\n     * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.\n     *\n     * Returning `null` is significant to distinguish between the default\n     * "match-all criterion value" of `true` compared to a `() => true` function,\n     * when the nodes is an empty array.\n     *\n     * This is useful to allow a transition match criteria of `entering: true`\n     * to still match a transition, even when `entering === []`.  Contrast that\n     * with `entering: (state) => true` which only matches when a state is actually\n     * being entered.\n     */\n    RegisteredHook.prototype._matchingNodes = function (nodes, criterion) {\n        if (criterion === true)\n            return nodes;\n        var matching = nodes.filter(function (node) { return matchState(node.state, criterion); });\n        return matching.length ? matching : null;\n    };\n    /**\n     * Gets the default match criteria (all `true`)\n     *\n     * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:\n     *\n     * ```js\n     * {\n     *   to: true,\n     *   from: true,\n     *   entering: true,\n     *   exiting: true,\n     *   retained: true,\n     * }\n     */\n    RegisteredHook.prototype._getDefaultMatchCriteria = function () {\n        return common_1.map(this.tranSvc._pluginapi._getPathTypes(), function () { return true; });\n    };\n    /**\n     * Gets matching nodes as [[IMatchingNodes]]\n     *\n     * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:\n     *\n     * ```js\n     * let matches: IMatchingNodes = {\n     *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),\n     *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),\n     *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),\n     *   retained: _matchingNodes(treeChanges.retained,     mc.retained),\n     *   entering: _matchingNodes(treeChanges.entering,     mc.entering),\n     * };\n     * ```\n     */\n    RegisteredHook.prototype._getMatchingNodes = function (treeChanges) {\n        var _this = this;\n        var criteria = common_1.extend(this._getDefaultMatchCriteria(), this.matchCriteria);\n        var paths = common_1.values(this.tranSvc._pluginapi._getPathTypes());\n        return paths.reduce(function (mn, pathtype) {\n            // STATE scope criteria matches against every node in the path.\n            // TRANSITION scope criteria matches against only the last node in the path\n            var isStateHook = pathtype.scope === interface_1.TransitionHookScope.STATE;\n            var path = treeChanges[pathtype.name] || [];\n            var nodes = isStateHook ? path : [common_1.tail(path)];\n            mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name]);\n            return mn;\n        }, {});\n    };\n    /**\n     * Determines if this hook\'s [[matchCriteria]] match the given [[TreeChanges]]\n     *\n     * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values\n     * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)\n     */\n    RegisteredHook.prototype.matches = function (treeChanges) {\n        var matches = this._getMatchingNodes(treeChanges);\n        // Check if all the criteria matched the TreeChanges object\n        var allMatched = common_1.values(matches).every(common_1.identity);\n        return allMatched ? matches : null;\n    };\n    RegisteredHook.prototype.deregister = function () {\n        this.removeHookFromRegistry(this);\n        this._deregistered = true;\n    };\n    return RegisteredHook;\n}());\nexports.RegisteredHook = RegisteredHook;\n/** @hidden Return a registration function of the requested type. */\nfunction makeEvent(registry, transitionService, eventType) {\n    // Create the object which holds the registered transition hooks.\n    var _registeredHooks = registry._registeredHooks = (registry._registeredHooks || {});\n    var hooks = _registeredHooks[eventType.name] = [];\n    var removeHookFn = common_1.removeFrom(hooks);\n    // Create hook registration function on the IHookRegistry for the event\n    registry[eventType.name] = hookRegistrationFn;\n    function hookRegistrationFn(matchObject, callback, options) {\n        if (options === void 0) { options = {}; }\n        var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, removeHookFn, options);\n        hooks.push(registeredHook);\n        return registeredHook.deregister.bind(registeredHook);\n    }\n    return hookRegistrationFn;\n}\nexports.makeEvent = makeEvent;\n//# sourceMappingURL=hookRegistry.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL2hvb2tSZWdpc3RyeS5qcz8yN2RlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSB0cmFuc2l0aW9uXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9pbnRlcmZhY2VcIik7IC8vIGhhcyBvciBpcyB1c2luZ1xudmFyIGdsb2JfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vZ2xvYlwiKTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gc3RhdGUgbWF0Y2hlcyB0aGUgbWF0Y2hDcml0ZXJpYVxuICpcbiAqIEBoaWRkZW5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgYSBTdGF0ZSBPYmplY3QgdG8gdGVzdCBhZ2FpbnN0XG4gKiBAcGFyYW0gY3JpdGVyaW9uXG4gKiAtIElmIGEgc3RyaW5nLCBtYXRjaFN0YXRlIHVzZXMgdGhlIHN0cmluZyBhcyBhIGdsb2ItbWF0Y2hlciBhZ2FpbnN0IHRoZSBzdGF0ZSBuYW1lXG4gKiAtIElmIGFuIGFycmF5IChvZiBzdHJpbmdzKSwgbWF0Y2hTdGF0ZSB1c2VzIGVhY2ggc3RyaW5nIGluIHRoZSBhcnJheSBhcyBhIGdsb2ItbWF0Y2hlcnMgYWdhaW5zdCB0aGUgc3RhdGUgbmFtZVxuICogICBhbmQgcmV0dXJucyBhIHBvc2l0aXZlIG1hdGNoIGlmIGFueSBvZiB0aGUgZ2xvYnMgbWF0Y2guXG4gKiAtIElmIGEgZnVuY3Rpb24sIG1hdGNoU3RhdGUgY2FsbHMgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIHN0YXRlIGFuZCByZXR1cm5zIHRydWUgaWYgdGhlIGZ1bmN0aW9uJ3MgcmVzdWx0IGlzIHRydXRoeS5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBtYXRjaFN0YXRlKHN0YXRlLCBjcml0ZXJpb24pIHtcbiAgICB2YXIgdG9NYXRjaCA9IHByZWRpY2F0ZXNfMS5pc1N0cmluZyhjcml0ZXJpb24pID8gW2NyaXRlcmlvbl0gOiBjcml0ZXJpb247XG4gICAgZnVuY3Rpb24gbWF0Y2hHbG9icyhfc3RhdGUpIHtcbiAgICAgICAgdmFyIGdsb2JTdHJpbmdzID0gdG9NYXRjaDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbG9iU3RyaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGdsb2IgPSBuZXcgZ2xvYl8xLkdsb2IoZ2xvYlN0cmluZ3NbaV0pO1xuICAgICAgICAgICAgaWYgKChnbG9iICYmIGdsb2IubWF0Y2hlcyhfc3RhdGUubmFtZSkpIHx8ICghZ2xvYiAmJiBnbG9iU3RyaW5nc1tpXSA9PT0gX3N0YXRlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgbWF0Y2hGbiA9IChwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbih0b01hdGNoKSA/IHRvTWF0Y2ggOiBtYXRjaEdsb2JzKTtcbiAgICByZXR1cm4gISFtYXRjaEZuKHN0YXRlKTtcbn1cbmV4cG9ydHMubWF0Y2hTdGF0ZSA9IG1hdGNoU3RhdGU7XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogVGhlIHJlZ2lzdHJhdGlvbiBkYXRhIGZvciBhIHJlZ2lzdGVyZWQgdHJhbnNpdGlvbiBob29rXG4gKi9cbnZhciBSZWdpc3RlcmVkSG9vayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWdpc3RlcmVkSG9vayh0cmFuU3ZjLCBldmVudFR5cGUsIGNhbGxiYWNrLCBtYXRjaENyaXRlcmlhLCByZW1vdmVIb29rRnJvbVJlZ2lzdHJ5LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHRoaXMudHJhblN2YyA9IHRyYW5TdmM7XG4gICAgICAgIHRoaXMuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMubWF0Y2hDcml0ZXJpYSA9IG1hdGNoQ3JpdGVyaWE7XG4gICAgICAgIHRoaXMucmVtb3ZlSG9va0Zyb21SZWdpc3RyeSA9IHJlbW92ZUhvb2tGcm9tUmVnaXN0cnk7XG4gICAgICAgIHRoaXMuaW52b2tlQ291bnQgPSAwO1xuICAgICAgICB0aGlzLl9kZXJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IG9wdGlvbnMucHJpb3JpdHkgfHwgMDtcbiAgICAgICAgdGhpcy5iaW5kID0gb3B0aW9ucy5iaW5kIHx8IG51bGw7XG4gICAgICAgIHRoaXMuaW52b2tlTGltaXQgPSBvcHRpb25zLmludm9rZUxpbWl0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtYXRjaGluZyBbW1BhdGhOb2RlXV1zXG4gICAgICpcbiAgICAgKiBHaXZlbiBhbiBhcnJheSBvZiBbW1BhdGhOb2RlXV1zLCBhbmQgYSBbW0hvb2tNYXRjaENyaXRlcmlvbl1dLCByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmdcbiAgICAgKiB0aGUgW1tQYXRoTm9kZV1dcyB0aGF0IHRoZSBjcml0ZXJpYSBtYXRjaGVzLCBvciBgbnVsbGAgaWYgdGhlcmUgd2VyZSBubyBtYXRjaGluZyBub2Rlcy5cbiAgICAgKlxuICAgICAqIFJldHVybmluZyBgbnVsbGAgaXMgc2lnbmlmaWNhbnQgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGUgZGVmYXVsdFxuICAgICAqIFwibWF0Y2gtYWxsIGNyaXRlcmlvbiB2YWx1ZVwiIG9mIGB0cnVlYCBjb21wYXJlZCB0byBhIGAoKSA9PiB0cnVlYCBmdW5jdGlvbixcbiAgICAgKiB3aGVuIHRoZSBub2RlcyBpcyBhbiBlbXB0eSBhcnJheS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdXNlZnVsIHRvIGFsbG93IGEgdHJhbnNpdGlvbiBtYXRjaCBjcml0ZXJpYSBvZiBgZW50ZXJpbmc6IHRydWVgXG4gICAgICogdG8gc3RpbGwgbWF0Y2ggYSB0cmFuc2l0aW9uLCBldmVuIHdoZW4gYGVudGVyaW5nID09PSBbXWAuICBDb250cmFzdCB0aGF0XG4gICAgICogd2l0aCBgZW50ZXJpbmc6IChzdGF0ZSkgPT4gdHJ1ZWAgd2hpY2ggb25seSBtYXRjaGVzIHdoZW4gYSBzdGF0ZSBpcyBhY3R1YWxseVxuICAgICAqIGJlaW5nIGVudGVyZWQuXG4gICAgICovXG4gICAgUmVnaXN0ZXJlZEhvb2sucHJvdG90eXBlLl9tYXRjaGluZ05vZGVzID0gZnVuY3Rpb24gKG5vZGVzLCBjcml0ZXJpb24pIHtcbiAgICAgICAgaWYgKGNyaXRlcmlvbiA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgdmFyIG1hdGNoaW5nID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBtYXRjaFN0YXRlKG5vZGUuc3RhdGUsIGNyaXRlcmlvbik7IH0pO1xuICAgICAgICByZXR1cm4gbWF0Y2hpbmcubGVuZ3RoID8gbWF0Y2hpbmcgOiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVmYXVsdCBtYXRjaCBjcml0ZXJpYSAoYWxsIGB0cnVlYClcbiAgICAgKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHdoaWNoIGhhcyBhbGwgdGhlIGNyaXRlcmlhIG1hdGNoIHBhdGhzIGFzIGtleXMgYW5kIGB0cnVlYCBhcyB2YWx1ZXMsIGkuZS46XG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIHtcbiAgICAgKiAgIHRvOiB0cnVlLFxuICAgICAqICAgZnJvbTogdHJ1ZSxcbiAgICAgKiAgIGVudGVyaW5nOiB0cnVlLFxuICAgICAqICAgZXhpdGluZzogdHJ1ZSxcbiAgICAgKiAgIHJldGFpbmVkOiB0cnVlLFxuICAgICAqIH1cbiAgICAgKi9cbiAgICBSZWdpc3RlcmVkSG9vay5wcm90b3R5cGUuX2dldERlZmF1bHRNYXRjaENyaXRlcmlhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEubWFwKHRoaXMudHJhblN2Yy5fcGx1Z2luYXBpLl9nZXRQYXRoVHlwZXMoKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIG1hdGNoaW5nIG5vZGVzIGFzIFtbSU1hdGNoaW5nTm9kZXNdXVxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgSU1hdGNoaW5nTm9kZXMgb2JqZWN0IGZyb20gdGhlIFRyYW5zaXRpb25Ib29rVHlwZXMgdGhhdCBpcyByb3VnaGx5IGVxdWl2YWxlbnQgdG86XG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIGxldCBtYXRjaGVzOiBJTWF0Y2hpbmdOb2RlcyA9IHtcbiAgICAgKiAgIHRvOiAgICAgICBfbWF0Y2hpbmdOb2RlcyhbdGFpbCh0cmVlQ2hhbmdlcy50byldLCAgIG1jLnRvKSxcbiAgICAgKiAgIGZyb206ICAgICBfbWF0Y2hpbmdOb2RlcyhbdGFpbCh0cmVlQ2hhbmdlcy5mcm9tKV0sIG1jLmZyb20pLFxuICAgICAqICAgZXhpdGluZzogIF9tYXRjaGluZ05vZGVzKHRyZWVDaGFuZ2VzLmV4aXRpbmcsICAgICAgbWMuZXhpdGluZyksXG4gICAgICogICByZXRhaW5lZDogX21hdGNoaW5nTm9kZXModHJlZUNoYW5nZXMucmV0YWluZWQsICAgICBtYy5yZXRhaW5lZCksXG4gICAgICogICBlbnRlcmluZzogX21hdGNoaW5nTm9kZXModHJlZUNoYW5nZXMuZW50ZXJpbmcsICAgICBtYy5lbnRlcmluZyksXG4gICAgICogfTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBSZWdpc3RlcmVkSG9vay5wcm90b3R5cGUuX2dldE1hdGNoaW5nTm9kZXMgPSBmdW5jdGlvbiAodHJlZUNoYW5nZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNyaXRlcmlhID0gY29tbW9uXzEuZXh0ZW5kKHRoaXMuX2dldERlZmF1bHRNYXRjaENyaXRlcmlhKCksIHRoaXMubWF0Y2hDcml0ZXJpYSk7XG4gICAgICAgIHZhciBwYXRocyA9IGNvbW1vbl8xLnZhbHVlcyh0aGlzLnRyYW5TdmMuX3BsdWdpbmFwaS5fZ2V0UGF0aFR5cGVzKCkpO1xuICAgICAgICByZXR1cm4gcGF0aHMucmVkdWNlKGZ1bmN0aW9uIChtbiwgcGF0aHR5cGUpIHtcbiAgICAgICAgICAgIC8vIFNUQVRFIHNjb3BlIGNyaXRlcmlhIG1hdGNoZXMgYWdhaW5zdCBldmVyeSBub2RlIGluIHRoZSBwYXRoLlxuICAgICAgICAgICAgLy8gVFJBTlNJVElPTiBzY29wZSBjcml0ZXJpYSBtYXRjaGVzIGFnYWluc3Qgb25seSB0aGUgbGFzdCBub2RlIGluIHRoZSBwYXRoXG4gICAgICAgICAgICB2YXIgaXNTdGF0ZUhvb2sgPSBwYXRodHlwZS5zY29wZSA9PT0gaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tTY29wZS5TVEFURTtcbiAgICAgICAgICAgIHZhciBwYXRoID0gdHJlZUNoYW5nZXNbcGF0aHR5cGUubmFtZV0gfHwgW107XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSBpc1N0YXRlSG9vayA/IHBhdGggOiBbY29tbW9uXzEudGFpbChwYXRoKV07XG4gICAgICAgICAgICBtbltwYXRodHlwZS5uYW1lXSA9IF90aGlzLl9tYXRjaGluZ05vZGVzKG5vZGVzLCBjcml0ZXJpYVtwYXRodHlwZS5uYW1lXSk7XG4gICAgICAgICAgICByZXR1cm4gbW47XG4gICAgICAgIH0sIHt9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhpcyBob29rJ3MgW1ttYXRjaENyaXRlcmlhXV0gbWF0Y2ggdGhlIGdpdmVuIFtbVHJlZUNoYW5nZXNdXVxuICAgICAqXG4gICAgICogQHJldHVybnMgYW4gSU1hdGNoaW5nTm9kZXMgb2JqZWN0LCBvciBudWxsLiBJZiBhbiBJTWF0Y2hpbmdOb2RlcyBvYmplY3QgaXMgcmV0dXJuZWQsIGl0cyB2YWx1ZXNcbiAgICAgKiBhcmUgdGhlIG1hdGNoaW5nIFtbUGF0aE5vZGVdXXMgZm9yIGVhY2ggW1tIb29rTWF0Y2hDcml0ZXJpb25dXSAodG8sIGZyb20sIGV4aXRpbmcsIHJldGFpbmVkLCBlbnRlcmluZylcbiAgICAgKi9cbiAgICBSZWdpc3RlcmVkSG9vay5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uICh0cmVlQ2hhbmdlcykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IHRoaXMuX2dldE1hdGNoaW5nTm9kZXModHJlZUNoYW5nZXMpO1xuICAgICAgICAvLyBDaGVjayBpZiBhbGwgdGhlIGNyaXRlcmlhIG1hdGNoZWQgdGhlIFRyZWVDaGFuZ2VzIG9iamVjdFxuICAgICAgICB2YXIgYWxsTWF0Y2hlZCA9IGNvbW1vbl8xLnZhbHVlcyhtYXRjaGVzKS5ldmVyeShjb21tb25fMS5pZGVudGl0eSk7XG4gICAgICAgIHJldHVybiBhbGxNYXRjaGVkID8gbWF0Y2hlcyA6IG51bGw7XG4gICAgfTtcbiAgICBSZWdpc3RlcmVkSG9vay5wcm90b3R5cGUuZGVyZWdpc3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVIb29rRnJvbVJlZ2lzdHJ5KHRoaXMpO1xuICAgICAgICB0aGlzLl9kZXJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZ2lzdGVyZWRIb29rO1xufSgpKTtcbmV4cG9ydHMuUmVnaXN0ZXJlZEhvb2sgPSBSZWdpc3RlcmVkSG9vaztcbi8qKiBAaGlkZGVuIFJldHVybiBhIHJlZ2lzdHJhdGlvbiBmdW5jdGlvbiBvZiB0aGUgcmVxdWVzdGVkIHR5cGUuICovXG5mdW5jdGlvbiBtYWtlRXZlbnQocmVnaXN0cnksIHRyYW5zaXRpb25TZXJ2aWNlLCBldmVudFR5cGUpIHtcbiAgICAvLyBDcmVhdGUgdGhlIG9iamVjdCB3aGljaCBob2xkcyB0aGUgcmVnaXN0ZXJlZCB0cmFuc2l0aW9uIGhvb2tzLlxuICAgIHZhciBfcmVnaXN0ZXJlZEhvb2tzID0gcmVnaXN0cnkuX3JlZ2lzdGVyZWRIb29rcyA9IChyZWdpc3RyeS5fcmVnaXN0ZXJlZEhvb2tzIHx8IHt9KTtcbiAgICB2YXIgaG9va3MgPSBfcmVnaXN0ZXJlZEhvb2tzW2V2ZW50VHlwZS5uYW1lXSA9IFtdO1xuICAgIHZhciByZW1vdmVIb29rRm4gPSBjb21tb25fMS5yZW1vdmVGcm9tKGhvb2tzKTtcbiAgICAvLyBDcmVhdGUgaG9vayByZWdpc3RyYXRpb24gZnVuY3Rpb24gb24gdGhlIElIb29rUmVnaXN0cnkgZm9yIHRoZSBldmVudFxuICAgIHJlZ2lzdHJ5W2V2ZW50VHlwZS5uYW1lXSA9IGhvb2tSZWdpc3RyYXRpb25GbjtcbiAgICBmdW5jdGlvbiBob29rUmVnaXN0cmF0aW9uRm4obWF0Y2hPYmplY3QsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciByZWdpc3RlcmVkSG9vayA9IG5ldyBSZWdpc3RlcmVkSG9vayh0cmFuc2l0aW9uU2VydmljZSwgZXZlbnRUeXBlLCBjYWxsYmFjaywgbWF0Y2hPYmplY3QsIHJlbW92ZUhvb2tGbiwgb3B0aW9ucyk7XG4gICAgICAgIGhvb2tzLnB1c2gocmVnaXN0ZXJlZEhvb2spO1xuICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZEhvb2suZGVyZWdpc3Rlci5iaW5kKHJlZ2lzdGVyZWRIb29rKTtcbiAgICB9XG4gICAgcmV0dXJuIGhvb2tSZWdpc3RyYXRpb25Gbjtcbn1cbmV4cG9ydHMubWFrZUV2ZW50ID0gbWFrZUV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9va1JlZ2lzdHJ5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi9ob29rUmVnaXN0cnkuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///25\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @coreapi\n * @module transition\n */\n/** for typedoc */\nvar interface_1 = __webpack_require__(/*! ./interface */ 10);\nvar transition_1 = __webpack_require__(/*! ./transition */ 18);\nvar hookRegistry_1 = __webpack_require__(/*! ./hookRegistry */ 25);\nvar coreResolvables_1 = __webpack_require__(/*! ../hooks/coreResolvables */ 59);\nvar redirectTo_1 = __webpack_require__(/*! ../hooks/redirectTo */ 63);\nvar onEnterExitRetain_1 = __webpack_require__(/*! ../hooks/onEnterExitRetain */ 62);\nvar resolve_1 = __webpack_require__(/*! ../hooks/resolve */ 64);\nvar views_1 = __webpack_require__(/*! ../hooks/views */ 67);\nvar updateGlobals_1 = __webpack_require__(/*! ../hooks/updateGlobals */ 65);\nvar url_1 = __webpack_require__(/*! ../hooks/url */ 66);\nvar lazyLoad_1 = __webpack_require__(/*! ../hooks/lazyLoad */ 29);\nvar transitionEventType_1 = __webpack_require__(/*! ./transitionEventType */ 40);\nvar transitionHook_1 = __webpack_require__(/*! ./transitionHook */ 13);\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ 1);\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar hof_1 = __webpack_require__(/*! ../common/hof */ 2);\nvar ignoredTransition_1 = __webpack_require__(/*! ../hooks/ignoredTransition */ 60);\nvar invalidTransition_1 = __webpack_require__(/*! ../hooks/invalidTransition */ 61);\n/**\n * The default [[Transition]] options.\n *\n * Include this object when applying custom defaults:\n * let reloadOpts = { reload: true, notify: true }\n * let options = defaults(theirOpts, customDefaults, defaultOptions);\n */\nexports.defaultTransOpts = {\n    location: true,\n    relative: null,\n    inherit: false,\n    notify: true,\n    reload: false,\n    custom: {},\n    current: function () { return null; },\n    source: "unknown"\n};\n/**\n * This class provides services related to Transitions.\n *\n * - Most importantly, it allows global Transition Hooks to be registered.\n * - It allows the default transition error handler to be set.\n * - It also has a factory function for creating new [[Transition]] objects, (used internally by the [[StateService]]).\n *\n * At bootstrap, [[UIRouter]] creates a single instance (singleton) of this class.\n */\nvar TransitionService = /** @class */ (function () {\n    /** @hidden */\n    function TransitionService(_router) {\n        /** @hidden */\n        this._transitionCount = 0;\n        /** @hidden The transition hook types, such as `onEnter`, `onStart`, etc */\n        this._eventTypes = [];\n        /** @hidden The registered transition hooks */\n        this._registeredHooks = {};\n        /** @hidden The  paths on a criteria object */\n        this._criteriaPaths = {};\n        this._router = _router;\n        this.$view = _router.viewService;\n        this._deregisterHookFns = {};\n        this._pluginapi = common_1.createProxyFunctions(hof_1.val(this), {}, hof_1.val(this), [\n            \'_definePathType\',\n            \'_defineEvent\',\n            \'_getPathTypes\',\n            \'_getEvents\',\n            \'getHooks\',\n        ]);\n        this._defineCorePaths();\n        this._defineCoreEvents();\n        this._registerCoreTransitionHooks();\n    }\n    /**\n     * Registers a [[TransitionHookFn]], called *while a transition is being constructed*.\n     *\n     * Registers a transition lifecycle hook, which is invoked during transition construction.\n     *\n     * This low level hook should only be used by plugins.\n     * This can be a useful time for plugins to add resolves or mutate the transition as needed.\n     * The Sticky States plugin uses this hook to modify the treechanges.\n     *\n     * ### Lifecycle\n     *\n     * `onCreate` hooks are invoked *while a transition is being constructed*.\n     *\n     * ### Return value\n     *\n     * The hook\'s return value is ignored\n     *\n     * @internalapi\n     * @param criteria defines which Transitions the Hook should be invoked for.\n     * @param callback the hook function which will be invoked.\n     * @param options the registration options\n     * @returns a function which deregisters the hook.\n     */\n    TransitionService.prototype.onCreate = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onBefore = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onStart = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onExit = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onRetain = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onEnter = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onFinish = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onSuccess = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onError = function (criteria, callback, options) { return; };\n    /**\n     * dispose\n     * @internalapi\n     */\n    TransitionService.prototype.dispose = function (router) {\n        common_1.values(this._registeredHooks).forEach(function (hooksArray) { return hooksArray.forEach(function (hook) {\n            hook._deregistered = true;\n            common_1.removeFrom(hooksArray, hook);\n        }); });\n    };\n    /**\n     * Creates a new [[Transition]] object\n     *\n     * This is a factory function for creating new Transition objects.\n     * It is used internally by the [[StateService]] and should generally not be called by application code.\n     *\n     * @param fromPath the path to the current state (the from state)\n     * @param targetState the target state (destination)\n     * @returns a Transition\n     */\n    TransitionService.prototype.create = function (fromPath, targetState) {\n        return new transition_1.Transition(fromPath, targetState, this._router);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineCoreEvents = function () {\n        var Phase = interface_1.TransitionHookPhase;\n        var TH = transitionHook_1.TransitionHook;\n        var paths = this._criteriaPaths;\n        var NORMAL_SORT = false, REVERSE_SORT = true;\n        var ASYNCHRONOUS = false, SYNCHRONOUS = true;\n        this._defineEvent("onCreate", Phase.CREATE, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.THROW_ERROR, SYNCHRONOUS);\n        this._defineEvent("onBefore", Phase.BEFORE, 0, paths.to);\n        this._defineEvent("onStart", Phase.RUN, 0, paths.to);\n        this._defineEvent("onExit", Phase.RUN, 100, paths.exiting, REVERSE_SORT);\n        this._defineEvent("onRetain", Phase.RUN, 200, paths.retained);\n        this._defineEvent("onEnter", Phase.RUN, 300, paths.entering);\n        this._defineEvent("onFinish", Phase.RUN, 400, paths.to);\n        this._defineEvent("onSuccess", Phase.SUCCESS, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);\n        this._defineEvent("onError", Phase.ERROR, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineCorePaths = function () {\n        var STATE = interface_1.TransitionHookScope.STATE, TRANSITION = interface_1.TransitionHookScope.TRANSITION;\n        this._definePathType("to", TRANSITION);\n        this._definePathType("from", TRANSITION);\n        this._definePathType("exiting", STATE);\n        this._definePathType("retained", STATE);\n        this._definePathType("entering", STATE);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineEvent = function (name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {\n        if (reverseSort === void 0) { reverseSort = false; }\n        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n        if (synchronous === void 0) { synchronous = false; }\n        var eventType = new transitionEventType_1.TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous);\n        this._eventTypes.push(eventType);\n        hookRegistry_1.makeEvent(this, this, eventType);\n    };\n    ;\n    /** @hidden */\n    TransitionService.prototype._getEvents = function (phase) {\n        var transitionHookTypes = predicates_1.isDefined(phase) ?\n            this._eventTypes.filter(function (type) { return type.hookPhase === phase; }) :\n            this._eventTypes.slice();\n        return transitionHookTypes.sort(function (l, r) {\n            var cmpByPhase = l.hookPhase - r.hookPhase;\n            return cmpByPhase === 0 ? l.hookOrder - r.hookOrder : cmpByPhase;\n        });\n    };\n    /**\n     * Adds a Path to be used as a criterion against a TreeChanges path\n     *\n     * For example: the `exiting` path in [[HookMatchCriteria]] is a STATE scoped path.\n     * It was defined by calling `defineTreeChangesCriterion(\'exiting\', TransitionHookScope.STATE)`\n     * Each state in the exiting path is checked against the criteria and returned as part of the match.\n     *\n     * Another example: the `to` path in [[HookMatchCriteria]] is a TRANSITION scoped path.\n     * It was defined by calling `defineTreeChangesCriterion(\'to\', TransitionHookScope.TRANSITION)`\n     * Only the tail of the `to` path is checked against the criteria and returned as part of the match.\n     *\n     * @hidden\n     */\n    TransitionService.prototype._definePathType = function (name, hookScope) {\n        this._criteriaPaths[name] = { name: name, scope: hookScope };\n    };\n    /** * @hidden */\n    TransitionService.prototype._getPathTypes = function () {\n        return this._criteriaPaths;\n    };\n    /** @hidden */\n    TransitionService.prototype.getHooks = function (hookName) {\n        return this._registeredHooks[hookName];\n    };\n    /** @hidden */\n    TransitionService.prototype._registerCoreTransitionHooks = function () {\n        var fns = this._deregisterHookFns;\n        fns.addCoreResolves = coreResolvables_1.registerAddCoreResolvables(this);\n        fns.ignored = ignoredTransition_1.registerIgnoredTransitionHook(this);\n        fns.invalid = invalidTransition_1.registerInvalidTransitionHook(this);\n        // Wire up redirectTo hook\n        fns.redirectTo = redirectTo_1.registerRedirectToHook(this);\n        // Wire up onExit/Retain/Enter state hooks\n        fns.onExit = onEnterExitRetain_1.registerOnExitHook(this);\n        fns.onRetain = onEnterExitRetain_1.registerOnRetainHook(this);\n        fns.onEnter = onEnterExitRetain_1.registerOnEnterHook(this);\n        // Wire up Resolve hooks\n        fns.eagerResolve = resolve_1.registerEagerResolvePath(this);\n        fns.lazyResolve = resolve_1.registerLazyResolveState(this);\n        // Wire up the View management hooks\n        fns.loadViews = views_1.registerLoadEnteringViews(this);\n        fns.activateViews = views_1.registerActivateViews(this);\n        // Updates global state after a transition\n        fns.updateGlobals = updateGlobals_1.registerUpdateGlobalState(this);\n        // After globals.current is updated at priority: 10000\n        fns.updateUrl = url_1.registerUpdateUrl(this);\n        // Lazy load state trees\n        fns.lazyLoad = lazyLoad_1.registerLazyLoadHook(this);\n    };\n    return TransitionService;\n}());\nexports.TransitionService = TransitionService;\n//# sourceMappingURL=transitionService.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL3RyYW5zaXRpb25TZXJ2aWNlLmpzP2I0NDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHRyYW5zaXRpb25cbiAqL1xuLyoqIGZvciB0eXBlZG9jICovXG52YXIgaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9pbnRlcmZhY2VcIik7XG52YXIgdHJhbnNpdGlvbl8xID0gcmVxdWlyZShcIi4vdHJhbnNpdGlvblwiKTtcbnZhciBob29rUmVnaXN0cnlfMSA9IHJlcXVpcmUoXCIuL2hvb2tSZWdpc3RyeVwiKTtcbnZhciBjb3JlUmVzb2x2YWJsZXNfMSA9IHJlcXVpcmUoXCIuLi9ob29rcy9jb3JlUmVzb2x2YWJsZXNcIik7XG52YXIgcmVkaXJlY3RUb18xID0gcmVxdWlyZShcIi4uL2hvb2tzL3JlZGlyZWN0VG9cIik7XG52YXIgb25FbnRlckV4aXRSZXRhaW5fMSA9IHJlcXVpcmUoXCIuLi9ob29rcy9vbkVudGVyRXhpdFJldGFpblwiKTtcbnZhciByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi4vaG9va3MvcmVzb2x2ZVwiKTtcbnZhciB2aWV3c18xID0gcmVxdWlyZShcIi4uL2hvb2tzL3ZpZXdzXCIpO1xudmFyIHVwZGF0ZUdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuLi9ob29rcy91cGRhdGVHbG9iYWxzXCIpO1xudmFyIHVybF8xID0gcmVxdWlyZShcIi4uL2hvb2tzL3VybFwiKTtcbnZhciBsYXp5TG9hZF8xID0gcmVxdWlyZShcIi4uL2hvb2tzL2xhenlMb2FkXCIpO1xudmFyIHRyYW5zaXRpb25FdmVudFR5cGVfMSA9IHJlcXVpcmUoXCIuL3RyYW5zaXRpb25FdmVudFR5cGVcIik7XG52YXIgdHJhbnNpdGlvbkhvb2tfMSA9IHJlcXVpcmUoXCIuL3RyYW5zaXRpb25Ib29rXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG52YXIgaWdub3JlZFRyYW5zaXRpb25fMSA9IHJlcXVpcmUoXCIuLi9ob29rcy9pZ25vcmVkVHJhbnNpdGlvblwiKTtcbnZhciBpbnZhbGlkVHJhbnNpdGlvbl8xID0gcmVxdWlyZShcIi4uL2hvb2tzL2ludmFsaWRUcmFuc2l0aW9uXCIpO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBbW1RyYW5zaXRpb25dXSBvcHRpb25zLlxuICpcbiAqIEluY2x1ZGUgdGhpcyBvYmplY3Qgd2hlbiBhcHBseWluZyBjdXN0b20gZGVmYXVsdHM6XG4gKiBsZXQgcmVsb2FkT3B0cyA9IHsgcmVsb2FkOiB0cnVlLCBub3RpZnk6IHRydWUgfVxuICogbGV0IG9wdGlvbnMgPSBkZWZhdWx0cyh0aGVpck9wdHMsIGN1c3RvbURlZmF1bHRzLCBkZWZhdWx0T3B0aW9ucyk7XG4gKi9cbmV4cG9ydHMuZGVmYXVsdFRyYW5zT3B0cyA9IHtcbiAgICBsb2NhdGlvbjogdHJ1ZSxcbiAgICByZWxhdGl2ZTogbnVsbCxcbiAgICBpbmhlcml0OiBmYWxzZSxcbiAgICBub3RpZnk6IHRydWUsXG4gICAgcmVsb2FkOiBmYWxzZSxcbiAgICBjdXN0b206IHt9LFxuICAgIGN1cnJlbnQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgc291cmNlOiBcInVua25vd25cIlxufTtcbi8qKlxuICogVGhpcyBjbGFzcyBwcm92aWRlcyBzZXJ2aWNlcyByZWxhdGVkIHRvIFRyYW5zaXRpb25zLlxuICpcbiAqIC0gTW9zdCBpbXBvcnRhbnRseSwgaXQgYWxsb3dzIGdsb2JhbCBUcmFuc2l0aW9uIEhvb2tzIHRvIGJlIHJlZ2lzdGVyZWQuXG4gKiAtIEl0IGFsbG93cyB0aGUgZGVmYXVsdCB0cmFuc2l0aW9uIGVycm9yIGhhbmRsZXIgdG8gYmUgc2V0LlxuICogLSBJdCBhbHNvIGhhcyBhIGZhY3RvcnkgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIG5ldyBbW1RyYW5zaXRpb25dXSBvYmplY3RzLCAodXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBbW1N0YXRlU2VydmljZV1dKS5cbiAqXG4gKiBBdCBib290c3RyYXAsIFtbVUlSb3V0ZXJdXSBjcmVhdGVzIGEgc2luZ2xlIGluc3RhbmNlIChzaW5nbGV0b24pIG9mIHRoaXMgY2xhc3MuXG4gKi9cbnZhciBUcmFuc2l0aW9uU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25TZXJ2aWNlKF9yb3V0ZXIpIHtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkNvdW50ID0gMDtcbiAgICAgICAgLyoqIEBoaWRkZW4gVGhlIHRyYW5zaXRpb24gaG9vayB0eXBlcywgc3VjaCBhcyBgb25FbnRlcmAsIGBvblN0YXJ0YCwgZXRjICovXG4gICAgICAgIHRoaXMuX2V2ZW50VHlwZXMgPSBbXTtcbiAgICAgICAgLyoqIEBoaWRkZW4gVGhlIHJlZ2lzdGVyZWQgdHJhbnNpdGlvbiBob29rcyAqL1xuICAgICAgICB0aGlzLl9yZWdpc3RlcmVkSG9va3MgPSB7fTtcbiAgICAgICAgLyoqIEBoaWRkZW4gVGhlICBwYXRocyBvbiBhIGNyaXRlcmlhIG9iamVjdCAqL1xuICAgICAgICB0aGlzLl9jcml0ZXJpYVBhdGhzID0ge307XG4gICAgICAgIHRoaXMuX3JvdXRlciA9IF9yb3V0ZXI7XG4gICAgICAgIHRoaXMuJHZpZXcgPSBfcm91dGVyLnZpZXdTZXJ2aWNlO1xuICAgICAgICB0aGlzLl9kZXJlZ2lzdGVySG9va0ZucyA9IHt9O1xuICAgICAgICB0aGlzLl9wbHVnaW5hcGkgPSBjb21tb25fMS5jcmVhdGVQcm94eUZ1bmN0aW9ucyhob2ZfMS52YWwodGhpcyksIHt9LCBob2ZfMS52YWwodGhpcyksIFtcbiAgICAgICAgICAgICdfZGVmaW5lUGF0aFR5cGUnLFxuICAgICAgICAgICAgJ19kZWZpbmVFdmVudCcsXG4gICAgICAgICAgICAnX2dldFBhdGhUeXBlcycsXG4gICAgICAgICAgICAnX2dldEV2ZW50cycsXG4gICAgICAgICAgICAnZ2V0SG9va3MnLFxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lQ29yZVBhdGhzKCk7XG4gICAgICAgIHRoaXMuX2RlZmluZUNvcmVFdmVudHMoKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJDb3JlVHJhbnNpdGlvbkhvb2tzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIFtbVHJhbnNpdGlvbkhvb2tGbl1dLCBjYWxsZWQgKndoaWxlIGEgdHJhbnNpdGlvbiBpcyBiZWluZyBjb25zdHJ1Y3RlZCouXG4gICAgICpcbiAgICAgKiBSZWdpc3RlcnMgYSB0cmFuc2l0aW9uIGxpZmVjeWNsZSBob29rLCB3aGljaCBpcyBpbnZva2VkIGR1cmluZyB0cmFuc2l0aW9uIGNvbnN0cnVjdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgbG93IGxldmVsIGhvb2sgc2hvdWxkIG9ubHkgYmUgdXNlZCBieSBwbHVnaW5zLlxuICAgICAqIFRoaXMgY2FuIGJlIGEgdXNlZnVsIHRpbWUgZm9yIHBsdWdpbnMgdG8gYWRkIHJlc29sdmVzIG9yIG11dGF0ZSB0aGUgdHJhbnNpdGlvbiBhcyBuZWVkZWQuXG4gICAgICogVGhlIFN0aWNreSBTdGF0ZXMgcGx1Z2luIHVzZXMgdGhpcyBob29rIHRvIG1vZGlmeSB0aGUgdHJlZWNoYW5nZXMuXG4gICAgICpcbiAgICAgKiAjIyMgTGlmZWN5Y2xlXG4gICAgICpcbiAgICAgKiBgb25DcmVhdGVgIGhvb2tzIGFyZSBpbnZva2VkICp3aGlsZSBhIHRyYW5zaXRpb24gaXMgYmVpbmcgY29uc3RydWN0ZWQqLlxuICAgICAqXG4gICAgICogIyMjIFJldHVybiB2YWx1ZVxuICAgICAqXG4gICAgICogVGhlIGhvb2sncyByZXR1cm4gdmFsdWUgaXMgaWdub3JlZFxuICAgICAqXG4gICAgICogQGludGVybmFsYXBpXG4gICAgICogQHBhcmFtIGNyaXRlcmlhIGRlZmluZXMgd2hpY2ggVHJhbnNpdGlvbnMgdGhlIEhvb2sgc2hvdWxkIGJlIGludm9rZWQgZm9yLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayB0aGUgaG9vayBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGludm9rZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgdGhlIHJlZ2lzdHJhdGlvbiBvcHRpb25zXG4gICAgICogQHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBkZXJlZ2lzdGVycyB0aGUgaG9vay5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUub25DcmVhdGUgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUub25CZWZvcmUgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5vbkV4aXQgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUub25SZXRhaW4gPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUub25FbnRlciA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5vbkZpbmlzaCA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5vblN1Y2Nlc3MgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKlxuICAgICAqIGRpc3Bvc2VcbiAgICAgKiBAaW50ZXJuYWxhcGlcbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChyb3V0ZXIpIHtcbiAgICAgICAgY29tbW9uXzEudmFsdWVzKHRoaXMuX3JlZ2lzdGVyZWRIb29rcykuZm9yRWFjaChmdW5jdGlvbiAoaG9va3NBcnJheSkgeyByZXR1cm4gaG9va3NBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gICAgICAgICAgICBob29rLl9kZXJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgY29tbW9uXzEucmVtb3ZlRnJvbShob29rc0FycmF5LCBob29rKTtcbiAgICAgICAgfSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBbW1RyYW5zaXRpb25dXSBvYmplY3RcbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBmYWN0b3J5IGZ1bmN0aW9uIGZvciBjcmVhdGluZyBuZXcgVHJhbnNpdGlvbiBvYmplY3RzLlxuICAgICAqIEl0IGlzIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgW1tTdGF0ZVNlcnZpY2VdXSBhbmQgc2hvdWxkIGdlbmVyYWxseSBub3QgYmUgY2FsbGVkIGJ5IGFwcGxpY2F0aW9uIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbVBhdGggdGhlIHBhdGggdG8gdGhlIGN1cnJlbnQgc3RhdGUgKHRoZSBmcm9tIHN0YXRlKVxuICAgICAqIEBwYXJhbSB0YXJnZXRTdGF0ZSB0aGUgdGFyZ2V0IHN0YXRlIChkZXN0aW5hdGlvbilcbiAgICAgKiBAcmV0dXJucyBhIFRyYW5zaXRpb25cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGZyb21QYXRoLCB0YXJnZXRTdGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IHRyYW5zaXRpb25fMS5UcmFuc2l0aW9uKGZyb21QYXRoLCB0YXJnZXRTdGF0ZSwgdGhpcy5fcm91dGVyKTtcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLl9kZWZpbmVDb3JlRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgUGhhc2UgPSBpbnRlcmZhY2VfMS5UcmFuc2l0aW9uSG9va1BoYXNlO1xuICAgICAgICB2YXIgVEggPSB0cmFuc2l0aW9uSG9va18xLlRyYW5zaXRpb25Ib29rO1xuICAgICAgICB2YXIgcGF0aHMgPSB0aGlzLl9jcml0ZXJpYVBhdGhzO1xuICAgICAgICB2YXIgTk9STUFMX1NPUlQgPSBmYWxzZSwgUkVWRVJTRV9TT1JUID0gdHJ1ZTtcbiAgICAgICAgdmFyIEFTWU5DSFJPTk9VUyA9IGZhbHNlLCBTWU5DSFJPTk9VUyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2RlZmluZUV2ZW50KFwib25DcmVhdGVcIiwgUGhhc2UuQ1JFQVRFLCAwLCBwYXRocy50bywgTk9STUFMX1NPUlQsIFRILkxPR19SRUpFQ1RFRF9SRVNVTFQsIFRILlRIUk9XX0VSUk9SLCBTWU5DSFJPTk9VUyk7XG4gICAgICAgIHRoaXMuX2RlZmluZUV2ZW50KFwib25CZWZvcmVcIiwgUGhhc2UuQkVGT1JFLCAwLCBwYXRocy50byk7XG4gICAgICAgIHRoaXMuX2RlZmluZUV2ZW50KFwib25TdGFydFwiLCBQaGFzZS5SVU4sIDAsIHBhdGhzLnRvKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lRXZlbnQoXCJvbkV4aXRcIiwgUGhhc2UuUlVOLCAxMDAsIHBhdGhzLmV4aXRpbmcsIFJFVkVSU0VfU09SVCk7XG4gICAgICAgIHRoaXMuX2RlZmluZUV2ZW50KFwib25SZXRhaW5cIiwgUGhhc2UuUlVOLCAyMDAsIHBhdGhzLnJldGFpbmVkKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lRXZlbnQoXCJvbkVudGVyXCIsIFBoYXNlLlJVTiwgMzAwLCBwYXRocy5lbnRlcmluZyk7XG4gICAgICAgIHRoaXMuX2RlZmluZUV2ZW50KFwib25GaW5pc2hcIiwgUGhhc2UuUlVOLCA0MDAsIHBhdGhzLnRvKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lRXZlbnQoXCJvblN1Y2Nlc3NcIiwgUGhhc2UuU1VDQ0VTUywgMCwgcGF0aHMudG8sIE5PUk1BTF9TT1JULCBUSC5MT0dfUkVKRUNURURfUkVTVUxULCBUSC5MT0dfRVJST1IsIFNZTkNIUk9OT1VTKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lRXZlbnQoXCJvbkVycm9yXCIsIFBoYXNlLkVSUk9SLCAwLCBwYXRocy50bywgTk9STUFMX1NPUlQsIFRILkxPR19SRUpFQ1RFRF9SRVNVTFQsIFRILkxPR19FUlJPUiwgU1lOQ0hST05PVVMpO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUuX2RlZmluZUNvcmVQYXRocyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIFNUQVRFID0gaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tTY29wZS5TVEFURSwgVFJBTlNJVElPTiA9IGludGVyZmFjZV8xLlRyYW5zaXRpb25Ib29rU2NvcGUuVFJBTlNJVElPTjtcbiAgICAgICAgdGhpcy5fZGVmaW5lUGF0aFR5cGUoXCJ0b1wiLCBUUkFOU0lUSU9OKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lUGF0aFR5cGUoXCJmcm9tXCIsIFRSQU5TSVRJT04pO1xuICAgICAgICB0aGlzLl9kZWZpbmVQYXRoVHlwZShcImV4aXRpbmdcIiwgU1RBVEUpO1xuICAgICAgICB0aGlzLl9kZWZpbmVQYXRoVHlwZShcInJldGFpbmVkXCIsIFNUQVRFKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lUGF0aFR5cGUoXCJlbnRlcmluZ1wiLCBTVEFURSk7XG4gICAgfTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fZGVmaW5lRXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgaG9va1BoYXNlLCBob29rT3JkZXIsIGNyaXRlcmlhTWF0Y2hQYXRoLCByZXZlcnNlU29ydCwgZ2V0UmVzdWx0SGFuZGxlciwgZ2V0RXJyb3JIYW5kbGVyLCBzeW5jaHJvbm91cykge1xuICAgICAgICBpZiAocmV2ZXJzZVNvcnQgPT09IHZvaWQgMCkgeyByZXZlcnNlU29ydCA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChnZXRSZXN1bHRIYW5kbGVyID09PSB2b2lkIDApIHsgZ2V0UmVzdWx0SGFuZGxlciA9IHRyYW5zaXRpb25Ib29rXzEuVHJhbnNpdGlvbkhvb2suSEFORExFX1JFU1VMVDsgfVxuICAgICAgICBpZiAoZ2V0RXJyb3JIYW5kbGVyID09PSB2b2lkIDApIHsgZ2V0RXJyb3JIYW5kbGVyID0gdHJhbnNpdGlvbkhvb2tfMS5UcmFuc2l0aW9uSG9vay5SRUpFQ1RfRVJST1I7IH1cbiAgICAgICAgaWYgKHN5bmNocm9ub3VzID09PSB2b2lkIDApIHsgc3luY2hyb25vdXMgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgZXZlbnRUeXBlID0gbmV3IHRyYW5zaXRpb25FdmVudFR5cGVfMS5UcmFuc2l0aW9uRXZlbnRUeXBlKG5hbWUsIGhvb2tQaGFzZSwgaG9va09yZGVyLCBjcml0ZXJpYU1hdGNoUGF0aCwgcmV2ZXJzZVNvcnQsIGdldFJlc3VsdEhhbmRsZXIsIGdldEVycm9ySGFuZGxlciwgc3luY2hyb25vdXMpO1xuICAgICAgICB0aGlzLl9ldmVudFR5cGVzLnB1c2goZXZlbnRUeXBlKTtcbiAgICAgICAgaG9va1JlZ2lzdHJ5XzEubWFrZUV2ZW50KHRoaXMsIHRoaXMsIGV2ZW50VHlwZSk7XG4gICAgfTtcbiAgICA7XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUuX2dldEV2ZW50cyA9IGZ1bmN0aW9uIChwaGFzZSkge1xuICAgICAgICB2YXIgdHJhbnNpdGlvbkhvb2tUeXBlcyA9IHByZWRpY2F0ZXNfMS5pc0RlZmluZWQocGhhc2UpID9cbiAgICAgICAgICAgIHRoaXMuX2V2ZW50VHlwZXMuZmlsdGVyKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlLmhvb2tQaGFzZSA9PT0gcGhhc2U7IH0pIDpcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50VHlwZXMuc2xpY2UoKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zaXRpb25Ib29rVHlwZXMuc29ydChmdW5jdGlvbiAobCwgcikge1xuICAgICAgICAgICAgdmFyIGNtcEJ5UGhhc2UgPSBsLmhvb2tQaGFzZSAtIHIuaG9va1BoYXNlO1xuICAgICAgICAgICAgcmV0dXJuIGNtcEJ5UGhhc2UgPT09IDAgPyBsLmhvb2tPcmRlciAtIHIuaG9va09yZGVyIDogY21wQnlQaGFzZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgUGF0aCB0byBiZSB1c2VkIGFzIGEgY3JpdGVyaW9uIGFnYWluc3QgYSBUcmVlQ2hhbmdlcyBwYXRoXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZTogdGhlIGBleGl0aW5nYCBwYXRoIGluIFtbSG9va01hdGNoQ3JpdGVyaWFdXSBpcyBhIFNUQVRFIHNjb3BlZCBwYXRoLlxuICAgICAqIEl0IHdhcyBkZWZpbmVkIGJ5IGNhbGxpbmcgYGRlZmluZVRyZWVDaGFuZ2VzQ3JpdGVyaW9uKCdleGl0aW5nJywgVHJhbnNpdGlvbkhvb2tTY29wZS5TVEFURSlgXG4gICAgICogRWFjaCBzdGF0ZSBpbiB0aGUgZXhpdGluZyBwYXRoIGlzIGNoZWNrZWQgYWdhaW5zdCB0aGUgY3JpdGVyaWEgYW5kIHJldHVybmVkIGFzIHBhcnQgb2YgdGhlIG1hdGNoLlxuICAgICAqXG4gICAgICogQW5vdGhlciBleGFtcGxlOiB0aGUgYHRvYCBwYXRoIGluIFtbSG9va01hdGNoQ3JpdGVyaWFdXSBpcyBhIFRSQU5TSVRJT04gc2NvcGVkIHBhdGguXG4gICAgICogSXQgd2FzIGRlZmluZWQgYnkgY2FsbGluZyBgZGVmaW5lVHJlZUNoYW5nZXNDcml0ZXJpb24oJ3RvJywgVHJhbnNpdGlvbkhvb2tTY29wZS5UUkFOU0lUSU9OKWBcbiAgICAgKiBPbmx5IHRoZSB0YWlsIG9mIHRoZSBgdG9gIHBhdGggaXMgY2hlY2tlZCBhZ2FpbnN0IHRoZSBjcml0ZXJpYSBhbmQgcmV0dXJuZWQgYXMgcGFydCBvZiB0aGUgbWF0Y2guXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLl9kZWZpbmVQYXRoVHlwZSA9IGZ1bmN0aW9uIChuYW1lLCBob29rU2NvcGUpIHtcbiAgICAgICAgdGhpcy5fY3JpdGVyaWFQYXRoc1tuYW1lXSA9IHsgbmFtZTogbmFtZSwgc2NvcGU6IGhvb2tTY29wZSB9O1xuICAgIH07XG4gICAgLyoqICogQGhpZGRlbiAqL1xuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fZ2V0UGF0aFR5cGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3JpdGVyaWFQYXRocztcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLmdldEhvb2tzID0gZnVuY3Rpb24gKGhvb2tOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWdpc3RlcmVkSG9va3NbaG9va05hbWVdO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUuX3JlZ2lzdGVyQ29yZVRyYW5zaXRpb25Ib29rcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZucyA9IHRoaXMuX2RlcmVnaXN0ZXJIb29rRm5zO1xuICAgICAgICBmbnMuYWRkQ29yZVJlc29sdmVzID0gY29yZVJlc29sdmFibGVzXzEucmVnaXN0ZXJBZGRDb3JlUmVzb2x2YWJsZXModGhpcyk7XG4gICAgICAgIGZucy5pZ25vcmVkID0gaWdub3JlZFRyYW5zaXRpb25fMS5yZWdpc3Rlcklnbm9yZWRUcmFuc2l0aW9uSG9vayh0aGlzKTtcbiAgICAgICAgZm5zLmludmFsaWQgPSBpbnZhbGlkVHJhbnNpdGlvbl8xLnJlZ2lzdGVySW52YWxpZFRyYW5zaXRpb25Ib29rKHRoaXMpO1xuICAgICAgICAvLyBXaXJlIHVwIHJlZGlyZWN0VG8gaG9va1xuICAgICAgICBmbnMucmVkaXJlY3RUbyA9IHJlZGlyZWN0VG9fMS5yZWdpc3RlclJlZGlyZWN0VG9Ib29rKHRoaXMpO1xuICAgICAgICAvLyBXaXJlIHVwIG9uRXhpdC9SZXRhaW4vRW50ZXIgc3RhdGUgaG9va3NcbiAgICAgICAgZm5zLm9uRXhpdCA9IG9uRW50ZXJFeGl0UmV0YWluXzEucmVnaXN0ZXJPbkV4aXRIb29rKHRoaXMpO1xuICAgICAgICBmbnMub25SZXRhaW4gPSBvbkVudGVyRXhpdFJldGFpbl8xLnJlZ2lzdGVyT25SZXRhaW5Ib29rKHRoaXMpO1xuICAgICAgICBmbnMub25FbnRlciA9IG9uRW50ZXJFeGl0UmV0YWluXzEucmVnaXN0ZXJPbkVudGVySG9vayh0aGlzKTtcbiAgICAgICAgLy8gV2lyZSB1cCBSZXNvbHZlIGhvb2tzXG4gICAgICAgIGZucy5lYWdlclJlc29sdmUgPSByZXNvbHZlXzEucmVnaXN0ZXJFYWdlclJlc29sdmVQYXRoKHRoaXMpO1xuICAgICAgICBmbnMubGF6eVJlc29sdmUgPSByZXNvbHZlXzEucmVnaXN0ZXJMYXp5UmVzb2x2ZVN0YXRlKHRoaXMpO1xuICAgICAgICAvLyBXaXJlIHVwIHRoZSBWaWV3IG1hbmFnZW1lbnQgaG9va3NcbiAgICAgICAgZm5zLmxvYWRWaWV3cyA9IHZpZXdzXzEucmVnaXN0ZXJMb2FkRW50ZXJpbmdWaWV3cyh0aGlzKTtcbiAgICAgICAgZm5zLmFjdGl2YXRlVmlld3MgPSB2aWV3c18xLnJlZ2lzdGVyQWN0aXZhdGVWaWV3cyh0aGlzKTtcbiAgICAgICAgLy8gVXBkYXRlcyBnbG9iYWwgc3RhdGUgYWZ0ZXIgYSB0cmFuc2l0aW9uXG4gICAgICAgIGZucy51cGRhdGVHbG9iYWxzID0gdXBkYXRlR2xvYmFsc18xLnJlZ2lzdGVyVXBkYXRlR2xvYmFsU3RhdGUodGhpcyk7XG4gICAgICAgIC8vIEFmdGVyIGdsb2JhbHMuY3VycmVudCBpcyB1cGRhdGVkIGF0IHByaW9yaXR5OiAxMDAwMFxuICAgICAgICBmbnMudXBkYXRlVXJsID0gdXJsXzEucmVnaXN0ZXJVcGRhdGVVcmwodGhpcyk7XG4gICAgICAgIC8vIExhenkgbG9hZCBzdGF0ZSB0cmVlc1xuICAgICAgICBmbnMubGF6eUxvYWQgPSBsYXp5TG9hZF8xLnJlZ2lzdGVyTGF6eUxvYWRIb29rKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFRyYW5zaXRpb25TZXJ2aWNlO1xufSgpKTtcbmV4cG9ydHMuVHJhbnNpdGlvblNlcnZpY2UgPSBUcmFuc2l0aW9uU2VydmljZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zaXRpb25TZXJ2aWNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi90cmFuc2l0aW9uU2VydmljZS5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///26\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar common_1 = __webpack_require__(/*! ../common */ 5);\nexports.keyValsToObjectR = function (accum, _a) {\n    var key = _a[0], val = _a[1];\n    if (!accum.hasOwnProperty(key)) {\n        accum[key] = val;\n    }\n    else if (common_1.isArray(accum[key])) {\n        accum[key].push(val);\n    }\n    else {\n        accum[key] = [accum[key], val];\n    }\n    return accum;\n};\nexports.getParams = function (queryString) {\n    return queryString.split("&").filter(common_1.identity).map(common_1.splitEqual).reduce(exports.keyValsToObjectR, {});\n};\nfunction parseUrl(url) {\n    var orEmptyString = function (x) { return x || ""; };\n    var _a = common_1.splitHash(url).map(orEmptyString), beforehash = _a[0], hash = _a[1];\n    var _b = common_1.splitQuery(beforehash).map(orEmptyString), path = _b[0], search = _b[1];\n    return { path: path, search: search, hash: hash, url: url };\n}\nexports.parseUrl = parseUrl;\nexports.buildUrl = function (loc) {\n    var path = loc.path();\n    var searchObject = loc.search();\n    var hash = loc.hash();\n    var search = Object.keys(searchObject).map(function (key) {\n        var param = searchObject[key];\n        var vals = common_1.isArray(param) ? param : [param];\n        return vals.map(function (val) { return key + "=" + val; });\n    }).reduce(common_1.unnestR, []).join("&");\n    return path + (search ? "?" + search : "") + (hash ? "#" + hash : "");\n};\nfunction locationPluginFactory(name, isHtml5, serviceClass, configurationClass) {\n    return function (router) {\n        var service = router.locationService = new serviceClass(router);\n        var configuration = router.locationConfig = new configurationClass(router, isHtml5);\n        function dispose(router) {\n            router.dispose(service);\n            router.dispose(configuration);\n        }\n        return { name: name, service: service, configuration: configuration, dispose: dispose };\n    };\n}\nexports.locationPluginFactory = locationPluginFactory;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL3V0aWxzLmpzPzE3MDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogQG1vZHVsZSB2YW5pbGxhXG4gKi9cbi8qKiAqL1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbmV4cG9ydHMua2V5VmFsc1RvT2JqZWN0UiA9IGZ1bmN0aW9uIChhY2N1bSwgX2EpIHtcbiAgICB2YXIga2V5ID0gX2FbMF0sIHZhbCA9IF9hWzFdO1xuICAgIGlmICghYWNjdW0uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBhY2N1bVtrZXldID0gdmFsO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb21tb25fMS5pc0FycmF5KGFjY3VtW2tleV0pKSB7XG4gICAgICAgIGFjY3VtW2tleV0ucHVzaCh2YWwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYWNjdW1ba2V5XSA9IFthY2N1bVtrZXldLCB2YWxdO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW07XG59O1xuZXhwb3J0cy5nZXRQYXJhbXMgPSBmdW5jdGlvbiAocXVlcnlTdHJpbmcpIHtcbiAgICByZXR1cm4gcXVlcnlTdHJpbmcuc3BsaXQoXCImXCIpLmZpbHRlcihjb21tb25fMS5pZGVudGl0eSkubWFwKGNvbW1vbl8xLnNwbGl0RXF1YWwpLnJlZHVjZShleHBvcnRzLmtleVZhbHNUb09iamVjdFIsIHt9KTtcbn07XG5mdW5jdGlvbiBwYXJzZVVybCh1cmwpIHtcbiAgICB2YXIgb3JFbXB0eVN0cmluZyA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IHx8IFwiXCI7IH07XG4gICAgdmFyIF9hID0gY29tbW9uXzEuc3BsaXRIYXNoKHVybCkubWFwKG9yRW1wdHlTdHJpbmcpLCBiZWZvcmVoYXNoID0gX2FbMF0sIGhhc2ggPSBfYVsxXTtcbiAgICB2YXIgX2IgPSBjb21tb25fMS5zcGxpdFF1ZXJ5KGJlZm9yZWhhc2gpLm1hcChvckVtcHR5U3RyaW5nKSwgcGF0aCA9IF9iWzBdLCBzZWFyY2ggPSBfYlsxXTtcbiAgICByZXR1cm4geyBwYXRoOiBwYXRoLCBzZWFyY2g6IHNlYXJjaCwgaGFzaDogaGFzaCwgdXJsOiB1cmwgfTtcbn1cbmV4cG9ydHMucGFyc2VVcmwgPSBwYXJzZVVybDtcbmV4cG9ydHMuYnVpbGRVcmwgPSBmdW5jdGlvbiAobG9jKSB7XG4gICAgdmFyIHBhdGggPSBsb2MucGF0aCgpO1xuICAgIHZhciBzZWFyY2hPYmplY3QgPSBsb2Muc2VhcmNoKCk7XG4gICAgdmFyIGhhc2ggPSBsb2MuaGFzaCgpO1xuICAgIHZhciBzZWFyY2ggPSBPYmplY3Qua2V5cyhzZWFyY2hPYmplY3QpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBwYXJhbSA9IHNlYXJjaE9iamVjdFtrZXldO1xuICAgICAgICB2YXIgdmFscyA9IGNvbW1vbl8xLmlzQXJyYXkocGFyYW0pID8gcGFyYW0gOiBbcGFyYW1dO1xuICAgICAgICByZXR1cm4gdmFscy5tYXAoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4ga2V5ICsgXCI9XCIgKyB2YWw7IH0pO1xuICAgIH0pLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSkuam9pbihcIiZcIik7XG4gICAgcmV0dXJuIHBhdGggKyAoc2VhcmNoID8gXCI/XCIgKyBzZWFyY2ggOiBcIlwiKSArIChoYXNoID8gXCIjXCIgKyBoYXNoIDogXCJcIik7XG59O1xuZnVuY3Rpb24gbG9jYXRpb25QbHVnaW5GYWN0b3J5KG5hbWUsIGlzSHRtbDUsIHNlcnZpY2VDbGFzcywgY29uZmlndXJhdGlvbkNsYXNzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyb3V0ZXIpIHtcbiAgICAgICAgdmFyIHNlcnZpY2UgPSByb3V0ZXIubG9jYXRpb25TZXJ2aWNlID0gbmV3IHNlcnZpY2VDbGFzcyhyb3V0ZXIpO1xuICAgICAgICB2YXIgY29uZmlndXJhdGlvbiA9IHJvdXRlci5sb2NhdGlvbkNvbmZpZyA9IG5ldyBjb25maWd1cmF0aW9uQ2xhc3Mocm91dGVyLCBpc0h0bWw1KTtcbiAgICAgICAgZnVuY3Rpb24gZGlzcG9zZShyb3V0ZXIpIHtcbiAgICAgICAgICAgIHJvdXRlci5kaXNwb3NlKHNlcnZpY2UpO1xuICAgICAgICAgICAgcm91dGVyLmRpc3Bvc2UoY29uZmlndXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbmFtZTogbmFtZSwgc2VydmljZTogc2VydmljZSwgY29uZmlndXJhdGlvbjogY29uZmlndXJhdGlvbiwgZGlzcG9zZTogZGlzcG9zZSB9O1xuICAgIH07XG59XG5leHBvcnRzLmxvY2F0aW9uUGx1Z2luRmFjdG9yeSA9IGxvY2F0aW9uUGx1Z2luRmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS91dGlscy5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///27\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @coreapi\n * @module core\n */ /** */\nvar stateParams_1 = __webpack_require__(/*! ./params/stateParams */ 31);\nvar queue_1 = __webpack_require__(/*! ./common/queue */ 21);\n/**\n * Global router state\n *\n * This is where we hold the global mutable state such as current state, current\n * params, current transition, etc.\n */\nvar UIRouterGlobals = /** @class */ (function () {\n    function UIRouterGlobals() {\n        /**\n         * Current parameter values\n         *\n         * The parameter values from the latest successful transition\n         */\n        this.params = new stateParams_1.StateParams();\n        /** @internalapi */\n        this.lastStartedTransitionId = -1;\n        /** @internalapi */\n        this.transitionHistory = new queue_1.Queue([], 1);\n        /** @internalapi */\n        this.successfulTransitions = new queue_1.Queue([], 1);\n    }\n    UIRouterGlobals.prototype.dispose = function () {\n        this.transitionHistory.clear();\n        this.successfulTransitions.clear();\n        this.transition = null;\n    };\n    return UIRouterGlobals;\n}());\nexports.UIRouterGlobals = UIRouterGlobals;\n//# sourceMappingURL=globals.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9nbG9iYWxzLmpzPzYxYzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIGNvcmVcbiAqLyAvKiogKi9cbnZhciBzdGF0ZVBhcmFtc18xID0gcmVxdWlyZShcIi4vcGFyYW1zL3N0YXRlUGFyYW1zXCIpO1xudmFyIHF1ZXVlXzEgPSByZXF1aXJlKFwiLi9jb21tb24vcXVldWVcIik7XG4vKipcbiAqIEdsb2JhbCByb3V0ZXIgc3RhdGVcbiAqXG4gKiBUaGlzIGlzIHdoZXJlIHdlIGhvbGQgdGhlIGdsb2JhbCBtdXRhYmxlIHN0YXRlIHN1Y2ggYXMgY3VycmVudCBzdGF0ZSwgY3VycmVudFxuICogcGFyYW1zLCBjdXJyZW50IHRyYW5zaXRpb24sIGV0Yy5cbiAqL1xudmFyIFVJUm91dGVyR2xvYmFscyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVSVJvdXRlckdsb2JhbHMoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXJyZW50IHBhcmFtZXRlciB2YWx1ZXNcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHBhcmFtZXRlciB2YWx1ZXMgZnJvbSB0aGUgbGF0ZXN0IHN1Y2Nlc3NmdWwgdHJhbnNpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXJhbXMgPSBuZXcgc3RhdGVQYXJhbXNfMS5TdGF0ZVBhcmFtcygpO1xuICAgICAgICAvKiogQGludGVybmFsYXBpICovXG4gICAgICAgIHRoaXMubGFzdFN0YXJ0ZWRUcmFuc2l0aW9uSWQgPSAtMTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25IaXN0b3J5ID0gbmV3IHF1ZXVlXzEuUXVldWUoW10sIDEpO1xuICAgICAgICAvKiogQGludGVybmFsYXBpICovXG4gICAgICAgIHRoaXMuc3VjY2Vzc2Z1bFRyYW5zaXRpb25zID0gbmV3IHF1ZXVlXzEuUXVldWUoW10sIDEpO1xuICAgIH1cbiAgICBVSVJvdXRlckdsb2JhbHMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbkhpc3RvcnkuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5zdWNjZXNzZnVsVHJhbnNpdGlvbnMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBVSVJvdXRlckdsb2JhbHM7XG59KCkpO1xuZXhwb3J0cy5VSVJvdXRlckdsb2JhbHMgPSBVSVJvdXRlckdsb2JhbHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbG9iYWxzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvZ2xvYmFscy5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///28\n')},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ 3);\n/**\n * A [[TransitionHookFn]] that performs lazy loading\n *\n * When entering a state \"abc\" which has a `lazyLoad` function defined:\n * - Invoke the `lazyLoad` function (unless it is already in process)\n *   - Flag the hook function as \"in process\"\n *   - The function should return a promise (that resolves when lazy loading is complete)\n * - Wait for the promise to settle\n *   - If the promise resolves to a [[LazyLoadResult]], then register those states\n *   - Flag the hook function as \"not in process\"\n * - If the hook was successful\n *   - Remove the `lazyLoad` function from the state declaration\n * - If all the hooks were successful\n *   - Retry the transition (by returning a TargetState)\n *\n * ```\n * .state('abc', {\n *   component: 'fooComponent',\n *   lazyLoad: () => System.import('./fooComponent')\n *   });\n * ```\n *\n * See [[StateDeclaration.lazyLoad]]\n */\nvar lazyLoadHook = function (transition) {\n    var router = transition.router;\n    function retryTransition() {\n        if (transition.originalTransition().options().source !== 'url') {\n            // The original transition was not triggered via url sync\n            // The lazy state should be loaded now, so re-try the original transition\n            var orig = transition.targetState();\n            return router.stateService.target(orig.identifier(), orig.params(), orig.options());\n        }\n        // The original transition was triggered via url sync\n        // Run the URL rules and find the best match\n        var $url = router.urlService;\n        var result = $url.match($url.parts());\n        var rule = result && result.rule;\n        // If the best match is a state, redirect the transition (instead\n        // of calling sync() which supersedes the current transition)\n        if (rule && rule.type === \"STATE\") {\n            var state = rule.state;\n            var params = result.match;\n            return router.stateService.target(state, params, transition.options());\n        }\n        // No matching state found, so let .sync() choose the best non-state match/otherwise\n        router.urlService.sync();\n    }\n    var promises = transition.entering()\n        .filter(function (state) { return !!state.$$state().lazyLoad; })\n        .map(function (state) { return lazyLoadState(transition, state); });\n    return coreservices_1.services.$q.all(promises).then(retryTransition);\n};\nexports.registerLazyLoadHook = function (transitionService) {\n    return transitionService.onBefore({ entering: function (state) { return !!state.lazyLoad; } }, lazyLoadHook);\n};\n/**\n * Invokes a state's lazy load function\n *\n * @param transition a Transition context\n * @param state the state to lazy load\n * @returns A promise for the lazy load result\n */\nfunction lazyLoadState(transition, state) {\n    var lazyLoadFn = state.$$state().lazyLoad;\n    // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked\n    var promise = lazyLoadFn['_promise'];\n    if (!promise) {\n        var success = function (result) {\n            delete state.lazyLoad;\n            delete state.$$state().lazyLoad;\n            delete lazyLoadFn['_promise'];\n            return result;\n        };\n        var error = function (err) {\n            delete lazyLoadFn['_promise'];\n            return coreservices_1.services.$q.reject(err);\n        };\n        promise = lazyLoadFn['_promise'] =\n            coreservices_1.services.$q.when(lazyLoadFn(transition, state))\n                .then(updateStateRegistry)\n                .then(success, error);\n    }\n    /** Register any lazy loaded state definitions */\n    function updateStateRegistry(result) {\n        if (result && Array.isArray(result.states)) {\n            result.states.forEach(function (state) { return transition.router.stateRegistry.register(state); });\n        }\n        return result;\n    }\n    return promise;\n}\nexports.lazyLoadState = lazyLoadState;\n//# sourceMappingURL=lazyLoad.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9sYXp5TG9hZC5qcz83Y2U5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVzZXJ2aWNlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb3Jlc2VydmljZXNcIik7XG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gdGhhdCBwZXJmb3JtcyBsYXp5IGxvYWRpbmdcbiAqXG4gKiBXaGVuIGVudGVyaW5nIGEgc3RhdGUgXCJhYmNcIiB3aGljaCBoYXMgYSBgbGF6eUxvYWRgIGZ1bmN0aW9uIGRlZmluZWQ6XG4gKiAtIEludm9rZSB0aGUgYGxhenlMb2FkYCBmdW5jdGlvbiAodW5sZXNzIGl0IGlzIGFscmVhZHkgaW4gcHJvY2VzcylcbiAqICAgLSBGbGFnIHRoZSBob29rIGZ1bmN0aW9uIGFzIFwiaW4gcHJvY2Vzc1wiXG4gKiAgIC0gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBwcm9taXNlICh0aGF0IHJlc29sdmVzIHdoZW4gbGF6eSBsb2FkaW5nIGlzIGNvbXBsZXRlKVxuICogLSBXYWl0IGZvciB0aGUgcHJvbWlzZSB0byBzZXR0bGVcbiAqICAgLSBJZiB0aGUgcHJvbWlzZSByZXNvbHZlcyB0byBhIFtbTGF6eUxvYWRSZXN1bHRdXSwgdGhlbiByZWdpc3RlciB0aG9zZSBzdGF0ZXNcbiAqICAgLSBGbGFnIHRoZSBob29rIGZ1bmN0aW9uIGFzIFwibm90IGluIHByb2Nlc3NcIlxuICogLSBJZiB0aGUgaG9vayB3YXMgc3VjY2Vzc2Z1bFxuICogICAtIFJlbW92ZSB0aGUgYGxhenlMb2FkYCBmdW5jdGlvbiBmcm9tIHRoZSBzdGF0ZSBkZWNsYXJhdGlvblxuICogLSBJZiBhbGwgdGhlIGhvb2tzIHdlcmUgc3VjY2Vzc2Z1bFxuICogICAtIFJldHJ5IHRoZSB0cmFuc2l0aW9uIChieSByZXR1cm5pbmcgYSBUYXJnZXRTdGF0ZSlcbiAqXG4gKiBgYGBcbiAqIC5zdGF0ZSgnYWJjJywge1xuICogICBjb21wb25lbnQ6ICdmb29Db21wb25lbnQnLFxuICogICBsYXp5TG9hZDogKCkgPT4gU3lzdGVtLmltcG9ydCgnLi9mb29Db21wb25lbnQnKVxuICogICB9KTtcbiAqIGBgYFxuICpcbiAqIFNlZSBbW1N0YXRlRGVjbGFyYXRpb24ubGF6eUxvYWRdXVxuICovXG52YXIgbGF6eUxvYWRIb29rID0gZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcbiAgICB2YXIgcm91dGVyID0gdHJhbnNpdGlvbi5yb3V0ZXI7XG4gICAgZnVuY3Rpb24gcmV0cnlUcmFuc2l0aW9uKCkge1xuICAgICAgICBpZiAodHJhbnNpdGlvbi5vcmlnaW5hbFRyYW5zaXRpb24oKS5vcHRpb25zKCkuc291cmNlICE9PSAndXJsJykge1xuICAgICAgICAgICAgLy8gVGhlIG9yaWdpbmFsIHRyYW5zaXRpb24gd2FzIG5vdCB0cmlnZ2VyZWQgdmlhIHVybCBzeW5jXG4gICAgICAgICAgICAvLyBUaGUgbGF6eSBzdGF0ZSBzaG91bGQgYmUgbG9hZGVkIG5vdywgc28gcmUtdHJ5IHRoZSBvcmlnaW5hbCB0cmFuc2l0aW9uXG4gICAgICAgICAgICB2YXIgb3JpZyA9IHRyYW5zaXRpb24udGFyZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiByb3V0ZXIuc3RhdGVTZXJ2aWNlLnRhcmdldChvcmlnLmlkZW50aWZpZXIoKSwgb3JpZy5wYXJhbXMoKSwgb3JpZy5vcHRpb25zKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBvcmlnaW5hbCB0cmFuc2l0aW9uIHdhcyB0cmlnZ2VyZWQgdmlhIHVybCBzeW5jXG4gICAgICAgIC8vIFJ1biB0aGUgVVJMIHJ1bGVzIGFuZCBmaW5kIHRoZSBiZXN0IG1hdGNoXG4gICAgICAgIHZhciAkdXJsID0gcm91dGVyLnVybFNlcnZpY2U7XG4gICAgICAgIHZhciByZXN1bHQgPSAkdXJsLm1hdGNoKCR1cmwucGFydHMoKSk7XG4gICAgICAgIHZhciBydWxlID0gcmVzdWx0ICYmIHJlc3VsdC5ydWxlO1xuICAgICAgICAvLyBJZiB0aGUgYmVzdCBtYXRjaCBpcyBhIHN0YXRlLCByZWRpcmVjdCB0aGUgdHJhbnNpdGlvbiAoaW5zdGVhZFxuICAgICAgICAvLyBvZiBjYWxsaW5nIHN5bmMoKSB3aGljaCBzdXBlcnNlZGVzIHRoZSBjdXJyZW50IHRyYW5zaXRpb24pXG4gICAgICAgIGlmIChydWxlICYmIHJ1bGUudHlwZSA9PT0gXCJTVEFURVwiKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBydWxlLnN0YXRlO1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHJlc3VsdC5tYXRjaDtcbiAgICAgICAgICAgIHJldHVybiByb3V0ZXIuc3RhdGVTZXJ2aWNlLnRhcmdldChzdGF0ZSwgcGFyYW1zLCB0cmFuc2l0aW9uLm9wdGlvbnMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gbWF0Y2hpbmcgc3RhdGUgZm91bmQsIHNvIGxldCAuc3luYygpIGNob29zZSB0aGUgYmVzdCBub24tc3RhdGUgbWF0Y2gvb3RoZXJ3aXNlXG4gICAgICAgIHJvdXRlci51cmxTZXJ2aWNlLnN5bmMoKTtcbiAgICB9XG4gICAgdmFyIHByb21pc2VzID0gdHJhbnNpdGlvbi5lbnRlcmluZygpXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiAhIXN0YXRlLiQkc3RhdGUoKS5sYXp5TG9hZDsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIGxhenlMb2FkU3RhdGUodHJhbnNpdGlvbiwgc3RhdGUpOyB9KTtcbiAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEuYWxsKHByb21pc2VzKS50aGVuKHJldHJ5VHJhbnNpdGlvbik7XG59O1xuZXhwb3J0cy5yZWdpc3RlckxhenlMb2FkSG9vayA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uU2VydmljZSkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uU2VydmljZS5vbkJlZm9yZSh7IGVudGVyaW5nOiBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuICEhc3RhdGUubGF6eUxvYWQ7IH0gfSwgbGF6eUxvYWRIb29rKTtcbn07XG4vKipcbiAqIEludm9rZXMgYSBzdGF0ZSdzIGxhenkgbG9hZCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB0cmFuc2l0aW9uIGEgVHJhbnNpdGlvbiBjb250ZXh0XG4gKiBAcGFyYW0gc3RhdGUgdGhlIHN0YXRlIHRvIGxhenkgbG9hZFxuICogQHJldHVybnMgQSBwcm9taXNlIGZvciB0aGUgbGF6eSBsb2FkIHJlc3VsdFxuICovXG5mdW5jdGlvbiBsYXp5TG9hZFN0YXRlKHRyYW5zaXRpb24sIHN0YXRlKSB7XG4gICAgdmFyIGxhenlMb2FkRm4gPSBzdGF0ZS4kJHN0YXRlKCkubGF6eUxvYWQ7XG4gICAgLy8gU3RvcmUvZ2V0IHRoZSBsYXp5IGxvYWQgcHJvbWlzZSBvbi9mcm9tIHRoZSBob29rZm4gc28gaXQgZG9lc24ndCBnZXQgcmUtaW52b2tlZFxuICAgIHZhciBwcm9taXNlID0gbGF6eUxvYWRGblsnX3Byb21pc2UnXTtcbiAgICBpZiAoIXByb21pc2UpIHtcbiAgICAgICAgdmFyIHN1Y2Nlc3MgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBkZWxldGUgc3RhdGUubGF6eUxvYWQ7XG4gICAgICAgICAgICBkZWxldGUgc3RhdGUuJCRzdGF0ZSgpLmxhenlMb2FkO1xuICAgICAgICAgICAgZGVsZXRlIGxhenlMb2FkRm5bJ19wcm9taXNlJ107XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBkZWxldGUgbGF6eUxvYWRGblsnX3Byb21pc2UnXTtcbiAgICAgICAgICAgIHJldHVybiBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS5yZWplY3QoZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvbWlzZSA9IGxhenlMb2FkRm5bJ19wcm9taXNlJ10gPVxuICAgICAgICAgICAgY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEud2hlbihsYXp5TG9hZEZuKHRyYW5zaXRpb24sIHN0YXRlKSlcbiAgICAgICAgICAgICAgICAudGhlbih1cGRhdGVTdGF0ZVJlZ2lzdHJ5KVxuICAgICAgICAgICAgICAgIC50aGVuKHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9XG4gICAgLyoqIFJlZ2lzdGVyIGFueSBsYXp5IGxvYWRlZCBzdGF0ZSBkZWZpbml0aW9ucyAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVN0YXRlUmVnaXN0cnkocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgQXJyYXkuaXNBcnJheShyZXN1bHQuc3RhdGVzKSkge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gdHJhbnNpdGlvbi5yb3V0ZXIuc3RhdGVSZWdpc3RyeS5yZWdpc3RlcihzdGF0ZSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlO1xufVxuZXhwb3J0cy5sYXp5TG9hZFN0YXRlID0gbGF6eUxvYWRTdGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhenlMb2FkLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvbGF6eUxvYWQuanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///29\n")},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @coreapi\n * @module params\n */\n/** */\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ 1);\nvar hof_1 = __webpack_require__(/*! ../common/hof */ 2);\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ 3);\nvar paramType_1 = __webpack_require__(/*! ./paramType */ 22);\n/**\n * A registry for parameter types.\n *\n * This registry manages the built-in (and custom) parameter types.\n *\n * The built-in parameter types are:\n *\n * - [[string]]\n * - [[path]]\n * - [[query]]\n * - [[hash]]\n * - [[int]]\n * - [[bool]]\n * - [[date]]\n * - [[json]]\n * - [[any]]\n */\nvar ParamTypes = /** @class */ (function () {\n    /** @internalapi */\n    function ParamTypes() {\n        /** @hidden */\n        this.enqueue = true;\n        /** @hidden */\n        this.typeQueue = [];\n        /** @internalapi */\n        this.defaultTypes = common_1.pick(ParamTypes.prototype, ["hash", "string", "query", "path", "int", "bool", "date", "json", "any"]);\n        // Register default types. Store them in the prototype of this.types.\n        var makeType = function (definition, name) {\n            return new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n        };\n        this.types = common_1.inherit(common_1.map(this.defaultTypes, makeType), {});\n    }\n    /** @internalapi */\n    ParamTypes.prototype.dispose = function () {\n        this.types = {};\n    };\n    /**\n     * Registers a parameter type\n     *\n     * End users should call [[UrlMatcherFactory.type]], which delegates to this method.\n     */\n    ParamTypes.prototype.type = function (name, definition, definitionFn) {\n        if (!predicates_1.isDefined(definition))\n            return this.types[name];\n        if (this.types.hasOwnProperty(name))\n            throw new Error("A type named \'" + name + "\' has already been defined.");\n        this.types[name] = new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n        if (definitionFn) {\n            this.typeQueue.push({ name: name, def: definitionFn });\n            if (!this.enqueue)\n                this._flushTypeQueue();\n        }\n        return this;\n    };\n    /** @internalapi */\n    ParamTypes.prototype._flushTypeQueue = function () {\n        while (this.typeQueue.length) {\n            var type = this.typeQueue.shift();\n            if (type.pattern)\n                throw new Error("You cannot override a type\'s .pattern at runtime.");\n            common_1.extend(this.types[type.name], coreservices_1.services.$injector.invoke(type.def));\n        }\n    };\n    return ParamTypes;\n}());\nexports.ParamTypes = ParamTypes;\n/** @hidden */\nfunction initDefaultTypes() {\n    var makeDefaultType = function (def) {\n        var valToString = function (val) {\n            return val != null ? val.toString() : val;\n        };\n        var defaultTypeBase = {\n            encode: valToString,\n            decode: valToString,\n            is: hof_1.is(String),\n            pattern: /.*/,\n            equals: function (a, b) { return a == b; },\n        };\n        return common_1.extend({}, defaultTypeBase, def);\n    };\n    // Default Parameter Type Definitions\n    common_1.extend(ParamTypes.prototype, {\n        string: makeDefaultType({}),\n        path: makeDefaultType({\n            pattern: /[^/]*/,\n        }),\n        query: makeDefaultType({}),\n        hash: makeDefaultType({\n            inherit: false,\n        }),\n        int: makeDefaultType({\n            decode: function (val) { return parseInt(val, 10); },\n            is: function (val) {\n                return !predicates_1.isNullOrUndefined(val) && this.decode(val.toString()) === val;\n            },\n            pattern: /-?\\d+/,\n        }),\n        bool: makeDefaultType({\n            encode: function (val) { return val && 1 || 0; },\n            decode: function (val) { return parseInt(val, 10) !== 0; },\n            is: hof_1.is(Boolean),\n            pattern: /0|1/,\n        }),\n        date: makeDefaultType({\n            encode: function (val) {\n                return !this.is(val) ? undefined : [\n                    val.getFullYear(),\n                    (\'0\' + (val.getMonth() + 1)).slice(-2),\n                    (\'0\' + val.getDate()).slice(-2),\n                ].join("-");\n            },\n            decode: function (val) {\n                if (this.is(val))\n                    return val;\n                var match = this.capture.exec(val);\n                return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n            },\n            is: function (val) { return val instanceof Date && !isNaN(val.valueOf()); },\n            equals: function (l, r) {\n                return [\'getFullYear\', \'getMonth\', \'getDate\']\n                    .reduce(function (acc, fn) { return acc && l[fn]() === r[fn](); }, true);\n            },\n            pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n            capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/,\n        }),\n        json: makeDefaultType({\n            encode: common_1.toJson,\n            decode: common_1.fromJson,\n            is: hof_1.is(Object),\n            equals: common_1.equals,\n            pattern: /[^/]*/,\n        }),\n        // does not encode/decode\n        any: makeDefaultType({\n            encode: common_1.identity,\n            decode: common_1.identity,\n            is: function () { return true; },\n            equals: common_1.equals,\n        }),\n    });\n}\ninitDefaultTypes();\n//# sourceMappingURL=paramTypes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9wYXJhbXMvcGFyYW1UeXBlcy5qcz9kOTI0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSBwYXJhbXNcbiAqL1xuLyoqICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xudmFyIHBhcmFtVHlwZV8xID0gcmVxdWlyZShcIi4vcGFyYW1UeXBlXCIpO1xuLyoqXG4gKiBBIHJlZ2lzdHJ5IGZvciBwYXJhbWV0ZXIgdHlwZXMuXG4gKlxuICogVGhpcyByZWdpc3RyeSBtYW5hZ2VzIHRoZSBidWlsdC1pbiAoYW5kIGN1c3RvbSkgcGFyYW1ldGVyIHR5cGVzLlxuICpcbiAqIFRoZSBidWlsdC1pbiBwYXJhbWV0ZXIgdHlwZXMgYXJlOlxuICpcbiAqIC0gW1tzdHJpbmddXVxuICogLSBbW3BhdGhdXVxuICogLSBbW3F1ZXJ5XV1cbiAqIC0gW1toYXNoXV1cbiAqIC0gW1tpbnRdXVxuICogLSBbW2Jvb2xdXVxuICogLSBbW2RhdGVdXVxuICogLSBbW2pzb25dXVxuICogLSBbW2FueV1dXG4gKi9cbnZhciBQYXJhbVR5cGVzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICBmdW5jdGlvbiBQYXJhbVR5cGVzKCkge1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLmVucXVldWUgPSB0cnVlO1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLnR5cGVRdWV1ZSA9IFtdO1xuICAgICAgICAvKiogQGludGVybmFsYXBpICovXG4gICAgICAgIHRoaXMuZGVmYXVsdFR5cGVzID0gY29tbW9uXzEucGljayhQYXJhbVR5cGVzLnByb3RvdHlwZSwgW1wiaGFzaFwiLCBcInN0cmluZ1wiLCBcInF1ZXJ5XCIsIFwicGF0aFwiLCBcImludFwiLCBcImJvb2xcIiwgXCJkYXRlXCIsIFwianNvblwiLCBcImFueVwiXSk7XG4gICAgICAgIC8vIFJlZ2lzdGVyIGRlZmF1bHQgdHlwZXMuIFN0b3JlIHRoZW0gaW4gdGhlIHByb3RvdHlwZSBvZiB0aGlzLnR5cGVzLlxuICAgICAgICB2YXIgbWFrZVR5cGUgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbiwgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBwYXJhbVR5cGVfMS5QYXJhbVR5cGUoY29tbW9uXzEuZXh0ZW5kKHsgbmFtZTogbmFtZSB9LCBkZWZpbml0aW9uKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHlwZXMgPSBjb21tb25fMS5pbmhlcml0KGNvbW1vbl8xLm1hcCh0aGlzLmRlZmF1bHRUeXBlcywgbWFrZVR5cGUpLCB7fSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICBQYXJhbVR5cGVzLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnR5cGVzID0ge307XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBwYXJhbWV0ZXIgdHlwZVxuICAgICAqXG4gICAgICogRW5kIHVzZXJzIHNob3VsZCBjYWxsIFtbVXJsTWF0Y2hlckZhY3RvcnkudHlwZV1dLCB3aGljaCBkZWxlZ2F0ZXMgdG8gdGhpcyBtZXRob2QuXG4gICAgICovXG4gICAgUGFyYW1UeXBlcy5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uIChuYW1lLCBkZWZpbml0aW9uLCBkZWZpbml0aW9uRm4pIHtcbiAgICAgICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKGRlZmluaXRpb24pKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZXNbbmFtZV07XG4gICAgICAgIGlmICh0aGlzLnR5cGVzLmhhc093blByb3BlcnR5KG5hbWUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSB0eXBlIG5hbWVkICdcIiArIG5hbWUgKyBcIicgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkLlwiKTtcbiAgICAgICAgdGhpcy50eXBlc1tuYW1lXSA9IG5ldyBwYXJhbVR5cGVfMS5QYXJhbVR5cGUoY29tbW9uXzEuZXh0ZW5kKHsgbmFtZTogbmFtZSB9LCBkZWZpbml0aW9uKSk7XG4gICAgICAgIGlmIChkZWZpbml0aW9uRm4pIHtcbiAgICAgICAgICAgIHRoaXMudHlwZVF1ZXVlLnB1c2goeyBuYW1lOiBuYW1lLCBkZWY6IGRlZmluaXRpb25GbiB9KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5lbnF1ZXVlKVxuICAgICAgICAgICAgICAgIHRoaXMuX2ZsdXNoVHlwZVF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpICovXG4gICAgUGFyYW1UeXBlcy5wcm90b3R5cGUuX2ZsdXNoVHlwZVF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodGhpcy50eXBlUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZVF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAodHlwZS5wYXR0ZXJuKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW5ub3Qgb3ZlcnJpZGUgYSB0eXBlJ3MgLnBhdHRlcm4gYXQgcnVudGltZS5cIik7XG4gICAgICAgICAgICBjb21tb25fMS5leHRlbmQodGhpcy50eXBlc1t0eXBlLm5hbWVdLCBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kaW5qZWN0b3IuaW52b2tlKHR5cGUuZGVmKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBQYXJhbVR5cGVzO1xufSgpKTtcbmV4cG9ydHMuUGFyYW1UeXBlcyA9IFBhcmFtVHlwZXM7XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gaW5pdERlZmF1bHRUeXBlcygpIHtcbiAgICB2YXIgbWFrZURlZmF1bHRUeXBlID0gZnVuY3Rpb24gKGRlZikge1xuICAgICAgICB2YXIgdmFsVG9TdHJpbmcgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsICE9IG51bGwgPyB2YWwudG9TdHJpbmcoKSA6IHZhbDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRlZmF1bHRUeXBlQmFzZSA9IHtcbiAgICAgICAgICAgIGVuY29kZTogdmFsVG9TdHJpbmcsXG4gICAgICAgICAgICBkZWNvZGU6IHZhbFRvU3RyaW5nLFxuICAgICAgICAgICAgaXM6IGhvZl8xLmlzKFN0cmluZyksXG4gICAgICAgICAgICBwYXR0ZXJuOiAvLiovLFxuICAgICAgICAgICAgZXF1YWxzOiBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSA9PSBiOyB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKHt9LCBkZWZhdWx0VHlwZUJhc2UsIGRlZik7XG4gICAgfTtcbiAgICAvLyBEZWZhdWx0IFBhcmFtZXRlciBUeXBlIERlZmluaXRpb25zXG4gICAgY29tbW9uXzEuZXh0ZW5kKFBhcmFtVHlwZXMucHJvdG90eXBlLCB7XG4gICAgICAgIHN0cmluZzogbWFrZURlZmF1bHRUeXBlKHt9KSxcbiAgICAgICAgcGF0aDogbWFrZURlZmF1bHRUeXBlKHtcbiAgICAgICAgICAgIHBhdHRlcm46IC9bXi9dKi8sXG4gICAgICAgIH0pLFxuICAgICAgICBxdWVyeTogbWFrZURlZmF1bHRUeXBlKHt9KSxcbiAgICAgICAgaGFzaDogbWFrZURlZmF1bHRUeXBlKHtcbiAgICAgICAgICAgIGluaGVyaXQ6IGZhbHNlLFxuICAgICAgICB9KSxcbiAgICAgICAgaW50OiBtYWtlRGVmYXVsdFR5cGUoe1xuICAgICAgICAgICAgZGVjb2RlOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBwYXJzZUludCh2YWwsIDEwKTsgfSxcbiAgICAgICAgICAgIGlzOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFwcmVkaWNhdGVzXzEuaXNOdWxsT3JVbmRlZmluZWQodmFsKSAmJiB0aGlzLmRlY29kZSh2YWwudG9TdHJpbmcoKSkgPT09IHZhbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXR0ZXJuOiAvLT9cXGQrLyxcbiAgICAgICAgfSksXG4gICAgICAgIGJvb2w6IG1ha2VEZWZhdWx0VHlwZSh7XG4gICAgICAgICAgICBlbmNvZGU6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbCAmJiAxIHx8IDA7IH0sXG4gICAgICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApICE9PSAwOyB9LFxuICAgICAgICAgICAgaXM6IGhvZl8xLmlzKEJvb2xlYW4pLFxuICAgICAgICAgICAgcGF0dGVybjogLzB8MS8sXG4gICAgICAgIH0pLFxuICAgICAgICBkYXRlOiBtYWtlRGVmYXVsdFR5cGUoe1xuICAgICAgICAgICAgZW5jb2RlOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLmlzKHZhbCkgPyB1bmRlZmluZWQgOiBbXG4gICAgICAgICAgICAgICAgICAgIHZhbC5nZXRGdWxsWWVhcigpLFxuICAgICAgICAgICAgICAgICAgICAoJzAnICsgKHZhbC5nZXRNb250aCgpICsgMSkpLnNsaWNlKC0yKSxcbiAgICAgICAgICAgICAgICAgICAgKCcwJyArIHZhbC5nZXREYXRlKCkpLnNsaWNlKC0yKSxcbiAgICAgICAgICAgICAgICBdLmpvaW4oXCItXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY29kZTogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzKHZhbCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gdGhpcy5jYXB0dXJlLmV4ZWModmFsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2ggPyBuZXcgRGF0ZShtYXRjaFsxXSwgbWF0Y2hbMl0gLSAxLCBtYXRjaFszXSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXM6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIERhdGUgJiYgIWlzTmFOKHZhbC52YWx1ZU9mKCkpOyB9LFxuICAgICAgICAgICAgZXF1YWxzOiBmdW5jdGlvbiAobCwgcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ2dldEZ1bGxZZWFyJywgJ2dldE1vbnRoJywgJ2dldERhdGUnXVxuICAgICAgICAgICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGZuKSB7IHJldHVybiBhY2MgJiYgbFtmbl0oKSA9PT0gcltmbl0oKTsgfSwgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0dGVybjogL1swLTldezR9LSg/OjBbMS05XXwxWzAtMl0pLSg/OjBbMS05XXxbMS0yXVswLTldfDNbMC0xXSkvLFxuICAgICAgICAgICAgY2FwdHVyZTogLyhbMC05XXs0fSktKDBbMS05XXwxWzAtMl0pLSgwWzEtOV18WzEtMl1bMC05XXwzWzAtMV0pLyxcbiAgICAgICAgfSksXG4gICAgICAgIGpzb246IG1ha2VEZWZhdWx0VHlwZSh7XG4gICAgICAgICAgICBlbmNvZGU6IGNvbW1vbl8xLnRvSnNvbixcbiAgICAgICAgICAgIGRlY29kZTogY29tbW9uXzEuZnJvbUpzb24sXG4gICAgICAgICAgICBpczogaG9mXzEuaXMoT2JqZWN0KSxcbiAgICAgICAgICAgIGVxdWFsczogY29tbW9uXzEuZXF1YWxzLFxuICAgICAgICAgICAgcGF0dGVybjogL1teL10qLyxcbiAgICAgICAgfSksXG4gICAgICAgIC8vIGRvZXMgbm90IGVuY29kZS9kZWNvZGVcbiAgICAgICAgYW55OiBtYWtlRGVmYXVsdFR5cGUoe1xuICAgICAgICAgICAgZW5jb2RlOiBjb21tb25fMS5pZGVudGl0eSxcbiAgICAgICAgICAgIGRlY29kZTogY29tbW9uXzEuaWRlbnRpdHksXG4gICAgICAgICAgICBpczogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgICAgIGVxdWFsczogY29tbW9uXzEuZXF1YWxzLFxuICAgICAgICB9KSxcbiAgICB9KTtcbn1cbmluaXREZWZhdWx0VHlwZXMoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcmFtVHlwZXMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9wYXJhbXMvcGFyYW1UeXBlcy5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///30\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @coreapi\n * @module params\n */\n/** */\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\n/** @internalapi */\nvar StateParams = /** @class */ (function () {\n    function StateParams(params) {\n        if (params === void 0) { params = {}; }\n        common_1.extend(this, params);\n    }\n    /**\n     * Merges a set of parameters with all parameters inherited between the common parents of the\n     * current state and a given destination state.\n     *\n     * @param {Object} newParams The set of parameters which will be composited with inherited params.\n     * @param {Object} $current Internal definition of object representing the current state.\n     * @param {Object} $to Internal definition of object representing state to transition to.\n     */\n    StateParams.prototype.$inherit = function (newParams, $current, $to) {\n        var parents = common_1.ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n        for (var i in parents) {\n            if (!parents[i] || !parents[i].params)\n                continue;\n            parentParams = Object.keys(parents[i].params);\n            if (!parentParams.length)\n                continue;\n            for (var j in parentParams) {\n                if (inheritList.indexOf(parentParams[j]) >= 0)\n                    continue;\n                inheritList.push(parentParams[j]);\n                inherited[parentParams[j]] = this[parentParams[j]];\n            }\n        }\n        return common_1.extend({}, inherited, newParams);\n    };\n    ;\n    return StateParams;\n}());\nexports.StateParams = StateParams;\n//# sourceMappingURL=stateParams.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9wYXJhbXMvc3RhdGVQYXJhbXMuanM/OWVmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgcGFyYW1zXG4gKi9cbi8qKiAqL1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG4vKiogQGludGVybmFsYXBpICovXG52YXIgU3RhdGVQYXJhbXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGVQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMgPT09IHZvaWQgMCkgeyBwYXJhbXMgPSB7fTsgfVxuICAgICAgICBjb21tb25fMS5leHRlbmQodGhpcywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVyZ2VzIGEgc2V0IG9mIHBhcmFtZXRlcnMgd2l0aCBhbGwgcGFyYW1ldGVycyBpbmhlcml0ZWQgYmV0d2VlbiB0aGUgY29tbW9uIHBhcmVudHMgb2YgdGhlXG4gICAgICogY3VycmVudCBzdGF0ZSBhbmQgYSBnaXZlbiBkZXN0aW5hdGlvbiBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdQYXJhbXMgVGhlIHNldCBvZiBwYXJhbWV0ZXJzIHdoaWNoIHdpbGwgYmUgY29tcG9zaXRlZCB3aXRoIGluaGVyaXRlZCBwYXJhbXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICRjdXJyZW50IEludGVybmFsIGRlZmluaXRpb24gb2Ygb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gJHRvIEludGVybmFsIGRlZmluaXRpb24gb2Ygb2JqZWN0IHJlcHJlc2VudGluZyBzdGF0ZSB0byB0cmFuc2l0aW9uIHRvLlxuICAgICAqL1xuICAgIFN0YXRlUGFyYW1zLnByb3RvdHlwZS4kaW5oZXJpdCA9IGZ1bmN0aW9uIChuZXdQYXJhbXMsICRjdXJyZW50LCAkdG8pIHtcbiAgICAgICAgdmFyIHBhcmVudHMgPSBjb21tb25fMS5hbmNlc3RvcnMoJGN1cnJlbnQsICR0byksIHBhcmVudFBhcmFtcywgaW5oZXJpdGVkID0ge30sIGluaGVyaXRMaXN0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgaW4gcGFyZW50cykge1xuICAgICAgICAgICAgaWYgKCFwYXJlbnRzW2ldIHx8ICFwYXJlbnRzW2ldLnBhcmFtcylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHBhcmVudFBhcmFtcyA9IE9iamVjdC5rZXlzKHBhcmVudHNbaV0ucGFyYW1zKTtcbiAgICAgICAgICAgIGlmICghcGFyZW50UGFyYW1zLmxlbmd0aClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGogaW4gcGFyZW50UGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluaGVyaXRMaXN0LmluZGV4T2YocGFyZW50UGFyYW1zW2pdKSA+PSAwKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpbmhlcml0TGlzdC5wdXNoKHBhcmVudFBhcmFtc1tqXSk7XG4gICAgICAgICAgICAgICAgaW5oZXJpdGVkW3BhcmVudFBhcmFtc1tqXV0gPSB0aGlzW3BhcmVudFBhcmFtc1tqXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZCh7fSwgaW5oZXJpdGVkLCBuZXdQYXJhbXMpO1xuICAgIH07XG4gICAgO1xuICAgIHJldHVybiBTdGF0ZVBhcmFtcztcbn0oKSk7XG5leHBvcnRzLlN0YXRlUGFyYW1zID0gU3RhdGVQYXJhbXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0ZVBhcmFtcy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9zdGF0ZVBhcmFtcy5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///31\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/** @internalapi */\nexports.resolvePolicies = {\n    when: {\n        LAZY: "LAZY",\n        EAGER: "EAGER"\n    },\n    async: {\n        WAIT: "WAIT",\n        NOWAIT: "NOWAIT",\n        RXWAIT: "RXWAIT"\n    }\n};\n//# sourceMappingURL=interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9yZXNvbHZlL2ludGVyZmFjZS5qcz8yNTg3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBpbnRlcm5hbGFwaSAqL1xuZXhwb3J0cy5yZXNvbHZlUG9saWNpZXMgPSB7XG4gICAgd2hlbjoge1xuICAgICAgICBMQVpZOiBcIkxBWllcIixcbiAgICAgICAgRUFHRVI6IFwiRUFHRVJcIlxuICAgIH0sXG4gICAgYXN5bmM6IHtcbiAgICAgICAgV0FJVDogXCJXQUlUXCIsXG4gICAgICAgIE5PV0FJVDogXCJOT1dBSVRcIixcbiAgICAgICAgUlhXQUlUOiBcIlJYV0FJVFwiXG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL3Jlc29sdmUvaW50ZXJmYWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///32\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @coreapi\n * @module core\n */ /** */\nvar urlMatcherFactory_1 = __webpack_require__(/*! ./url/urlMatcherFactory */ 41);\nvar urlRouter_1 = __webpack_require__(/*! ./url/urlRouter */ 42);\nvar transitionService_1 = __webpack_require__(/*! ./transition/transitionService */ 26);\nvar view_1 = __webpack_require__(/*! ./view/view */ 52);\nvar stateRegistry_1 = __webpack_require__(/*! ./state/stateRegistry */ 37);\nvar stateService_1 = __webpack_require__(/*! ./state/stateService */ 38);\nvar globals_1 = __webpack_require__(/*! ./globals */ 28);\nvar common_1 = __webpack_require__(/*! ./common/common */ 0);\nvar predicates_1 = __webpack_require__(/*! ./common/predicates */ 1);\nvar urlService_1 = __webpack_require__(/*! ./url/urlService */ 44);\nvar trace_1 = __webpack_require__(/*! ./common/trace */ 7);\n/** @hidden */\nvar _routerInstance = 0;\n/**\n * The master class used to instantiate an instance of UI-Router.\n *\n * UI-Router (for each specific framework) will create an instance of this class during bootstrap.\n * This class instantiates and wires the UI-Router services together.\n *\n * After a new instance of the UIRouter class is created, it should be configured for your app.\n * For instance, app states should be registered with the [[UIRouter.stateRegistry]].\n *\n * ---\n *\n * Normally the framework code will bootstrap UI-Router.\n * If you are bootstrapping UIRouter manually, tell it to monitor the URL by calling\n * [[UrlService.listen]] then [[UrlService.sync]].\n */\nvar UIRouter = /** @class */ (function () {\n    /**\n     * Creates a new `UIRouter` object\n     *\n     * @param locationService a [[LocationServices]] implementation\n     * @param locationConfig a [[LocationConfig]] implementation\n     * @internalapi\n     */\n    function UIRouter(locationService, locationConfig) {\n        if (locationService === void 0) { locationService = urlService_1.UrlService.locationServiceStub; }\n        if (locationConfig === void 0) { locationConfig = urlService_1.UrlService.locationConfigStub; }\n        this.locationService = locationService;\n        this.locationConfig = locationConfig;\n        /** @hidden */ this.$id = _routerInstance++;\n        /** @hidden */ this._disposed = false;\n        /** @hidden */ this._disposables = [];\n        /** Provides trace information to the console */\n        this.trace = trace_1.trace;\n        /** Provides services related to ui-view synchronization */\n        this.viewService = new view_1.ViewService();\n        /** Provides services related to Transitions */\n        this.transitionService = new transitionService_1.TransitionService(this);\n        /** Global router state */\n        this.globals = new globals_1.UIRouterGlobals();\n        /**\n         * Deprecated for public use. Use [[urlService]] instead.\n         * @deprecated Use [[urlService]] instead\n         */\n        this.urlMatcherFactory = new urlMatcherFactory_1.UrlMatcherFactory();\n        /**\n         * Deprecated for public use. Use [[urlService]] instead.\n         * @deprecated Use [[urlService]] instead\n         */\n        this.urlRouter = new urlRouter_1.UrlRouter(this);\n        /** Provides a registry for states, and related registration services */\n        this.stateRegistry = new stateRegistry_1.StateRegistry(this);\n        /** Provides services related to states */\n        this.stateService = new stateService_1.StateService(this);\n        /** Provides services related to the URL */\n        this.urlService = new urlService_1.UrlService(this);\n        /** @hidden */\n        this._plugins = {};\n        this.viewService._pluginapi._rootViewContext(this.stateRegistry.root());\n        this.globals.$current = this.stateRegistry.root();\n        this.globals.current = this.globals.$current.self;\n        this.disposable(this.globals);\n        this.disposable(this.stateService);\n        this.disposable(this.stateRegistry);\n        this.disposable(this.transitionService);\n        this.disposable(this.urlRouter);\n        this.disposable(locationService);\n        this.disposable(locationConfig);\n    }\n    /** Registers an object to be notified when the router is disposed */\n    UIRouter.prototype.disposable = function (disposable) {\n        this._disposables.push(disposable);\n    };\n    /**\n     * Disposes this router instance\n     *\n     * When called, clears resources retained by the router by calling `dispose(this)` on all\n     * registered [[disposable]] objects.\n     *\n     * Or, if a `disposable` object is provided, calls `dispose(this)` on that object only.\n     *\n     * @param disposable (optional) the disposable to dispose\n     */\n    UIRouter.prototype.dispose = function (disposable) {\n        var _this = this;\n        if (disposable && predicates_1.isFunction(disposable.dispose)) {\n            disposable.dispose(this);\n            return undefined;\n        }\n        this._disposed = true;\n        this._disposables.slice().forEach(function (d) {\n            try {\n                typeof d.dispose === \'function\' && d.dispose(_this);\n                common_1.removeFrom(_this._disposables, d);\n            }\n            catch (ignored) { }\n        });\n    };\n    /**\n     * Adds a plugin to UI-Router\n     *\n     * This method adds a UI-Router Plugin.\n     * A plugin can enhance or change UI-Router behavior using any public API.\n     *\n     * #### Example:\n     * ```js\n     * import { MyCoolPlugin } from "ui-router-cool-plugin";\n     *\n     * var plugin = router.addPlugin(MyCoolPlugin);\n     * ```\n     *\n     * ### Plugin authoring\n     *\n     * A plugin is simply a class (or constructor function) which accepts a [[UIRouter]] instance and (optionally) an options object.\n     *\n     * The plugin can implement its functionality using any of the public APIs of [[UIRouter]].\n     * For example, it may configure router options or add a Transition Hook.\n     *\n     * The plugin can then be published as a separate module.\n     *\n     * #### Example:\n     * ```js\n     * export class MyAuthPlugin implements UIRouterPlugin {\n     *   constructor(router: UIRouter, options: any) {\n     *     this.name = "MyAuthPlugin";\n     *     let $transitions = router.transitionService;\n     *     let $state = router.stateService;\n     *\n     *     let authCriteria = {\n     *       to: (state) => state.data && state.data.requiresAuth\n     *     };\n     *\n     *     function authHook(transition: Transition) {\n     *       let authService = transition.injector().get(\'AuthService\');\n     *       if (!authService.isAuthenticated()) {\n     *         return $state.target(\'login\');\n     *       }\n     *     }\n     *\n     *     $transitions.onStart(authCriteria, authHook);\n     *   }\n     * }\n     * ```\n     *\n     * @param plugin one of:\n     *        - a plugin class which implements [[UIRouterPlugin]]\n     *        - a constructor function for a [[UIRouterPlugin]] which accepts a [[UIRouter]] instance\n     *        - a factory function which accepts a [[UIRouter]] instance and returns a [[UIRouterPlugin]] instance\n     * @param options options to pass to the plugin class/factory\n     * @returns the registered plugin instance\n     */\n    UIRouter.prototype.plugin = function (plugin, options) {\n        if (options === void 0) { options = {}; }\n        var pluginInstance = new plugin(this, options);\n        if (!pluginInstance.name)\n            throw new Error("Required property `name` missing on plugin: " + pluginInstance);\n        this._disposables.push(pluginInstance);\n        return this._plugins[pluginInstance.name] = pluginInstance;\n    };\n    UIRouter.prototype.getPlugin = function (pluginName) {\n        return pluginName ? this._plugins[pluginName] : common_1.values(this._plugins);\n    };\n    return UIRouter;\n}());\nexports.UIRouter = UIRouter;\n//# sourceMappingURL=router.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9yb3V0ZXIuanM/YmJkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgY29yZVxuICovIC8qKiAqL1xudmFyIHVybE1hdGNoZXJGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi91cmwvdXJsTWF0Y2hlckZhY3RvcnlcIik7XG52YXIgdXJsUm91dGVyXzEgPSByZXF1aXJlKFwiLi91cmwvdXJsUm91dGVyXCIpO1xudmFyIHRyYW5zaXRpb25TZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi90cmFuc2l0aW9uL3RyYW5zaXRpb25TZXJ2aWNlXCIpO1xudmFyIHZpZXdfMSA9IHJlcXVpcmUoXCIuL3ZpZXcvdmlld1wiKTtcbnZhciBzdGF0ZVJlZ2lzdHJ5XzEgPSByZXF1aXJlKFwiLi9zdGF0ZS9zdGF0ZVJlZ2lzdHJ5XCIpO1xudmFyIHN0YXRlU2VydmljZV8xID0gcmVxdWlyZShcIi4vc3RhdGUvc3RhdGVTZXJ2aWNlXCIpO1xudmFyIGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuL2dsb2JhbHNcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIHVybFNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3VybC91cmxTZXJ2aWNlXCIpO1xudmFyIHRyYWNlXzEgPSByZXF1aXJlKFwiLi9jb21tb24vdHJhY2VcIik7XG4vKiogQGhpZGRlbiAqL1xudmFyIF9yb3V0ZXJJbnN0YW5jZSA9IDA7XG4vKipcbiAqIFRoZSBtYXN0ZXIgY2xhc3MgdXNlZCB0byBpbnN0YW50aWF0ZSBhbiBpbnN0YW5jZSBvZiBVSS1Sb3V0ZXIuXG4gKlxuICogVUktUm91dGVyIChmb3IgZWFjaCBzcGVjaWZpYyBmcmFtZXdvcmspIHdpbGwgY3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgZHVyaW5nIGJvb3RzdHJhcC5cbiAqIFRoaXMgY2xhc3MgaW5zdGFudGlhdGVzIGFuZCB3aXJlcyB0aGUgVUktUm91dGVyIHNlcnZpY2VzIHRvZ2V0aGVyLlxuICpcbiAqIEFmdGVyIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBVSVJvdXRlciBjbGFzcyBpcyBjcmVhdGVkLCBpdCBzaG91bGQgYmUgY29uZmlndXJlZCBmb3IgeW91ciBhcHAuXG4gKiBGb3IgaW5zdGFuY2UsIGFwcCBzdGF0ZXMgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgd2l0aCB0aGUgW1tVSVJvdXRlci5zdGF0ZVJlZ2lzdHJ5XV0uXG4gKlxuICogLS0tXG4gKlxuICogTm9ybWFsbHkgdGhlIGZyYW1ld29yayBjb2RlIHdpbGwgYm9vdHN0cmFwIFVJLVJvdXRlci5cbiAqIElmIHlvdSBhcmUgYm9vdHN0cmFwcGluZyBVSVJvdXRlciBtYW51YWxseSwgdGVsbCBpdCB0byBtb25pdG9yIHRoZSBVUkwgYnkgY2FsbGluZ1xuICogW1tVcmxTZXJ2aWNlLmxpc3Rlbl1dIHRoZW4gW1tVcmxTZXJ2aWNlLnN5bmNdXS5cbiAqL1xudmFyIFVJUm91dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYFVJUm91dGVyYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhdGlvblNlcnZpY2UgYSBbW0xvY2F0aW9uU2VydmljZXNdXSBpbXBsZW1lbnRhdGlvblxuICAgICAqIEBwYXJhbSBsb2NhdGlvbkNvbmZpZyBhIFtbTG9jYXRpb25Db25maWddXSBpbXBsZW1lbnRhdGlvblxuICAgICAqIEBpbnRlcm5hbGFwaVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFVJUm91dGVyKGxvY2F0aW9uU2VydmljZSwgbG9jYXRpb25Db25maWcpIHtcbiAgICAgICAgaWYgKGxvY2F0aW9uU2VydmljZSA9PT0gdm9pZCAwKSB7IGxvY2F0aW9uU2VydmljZSA9IHVybFNlcnZpY2VfMS5VcmxTZXJ2aWNlLmxvY2F0aW9uU2VydmljZVN0dWI7IH1cbiAgICAgICAgaWYgKGxvY2F0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgbG9jYXRpb25Db25maWcgPSB1cmxTZXJ2aWNlXzEuVXJsU2VydmljZS5sb2NhdGlvbkNvbmZpZ1N0dWI7IH1cbiAgICAgICAgdGhpcy5sb2NhdGlvblNlcnZpY2UgPSBsb2NhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubG9jYXRpb25Db25maWcgPSBsb2NhdGlvbkNvbmZpZztcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy4kaWQgPSBfcm91dGVySW5zdGFuY2UrKztcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5fZGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5fZGlzcG9zYWJsZXMgPSBbXTtcbiAgICAgICAgLyoqIFByb3ZpZGVzIHRyYWNlIGluZm9ybWF0aW9uIHRvIHRoZSBjb25zb2xlICovXG4gICAgICAgIHRoaXMudHJhY2UgPSB0cmFjZV8xLnRyYWNlO1xuICAgICAgICAvKiogUHJvdmlkZXMgc2VydmljZXMgcmVsYXRlZCB0byB1aS12aWV3IHN5bmNocm9uaXphdGlvbiAqL1xuICAgICAgICB0aGlzLnZpZXdTZXJ2aWNlID0gbmV3IHZpZXdfMS5WaWV3U2VydmljZSgpO1xuICAgICAgICAvKiogUHJvdmlkZXMgc2VydmljZXMgcmVsYXRlZCB0byBUcmFuc2l0aW9ucyAqL1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25TZXJ2aWNlID0gbmV3IHRyYW5zaXRpb25TZXJ2aWNlXzEuVHJhbnNpdGlvblNlcnZpY2UodGhpcyk7XG4gICAgICAgIC8qKiBHbG9iYWwgcm91dGVyIHN0YXRlICovXG4gICAgICAgIHRoaXMuZ2xvYmFscyA9IG5ldyBnbG9iYWxzXzEuVUlSb3V0ZXJHbG9iYWxzKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXByZWNhdGVkIGZvciBwdWJsaWMgdXNlLiBVc2UgW1t1cmxTZXJ2aWNlXV0gaW5zdGVhZC5cbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIFtbdXJsU2VydmljZV1dIGluc3RlYWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXJsTWF0Y2hlckZhY3RvcnkgPSBuZXcgdXJsTWF0Y2hlckZhY3RvcnlfMS5VcmxNYXRjaGVyRmFjdG9yeSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVwcmVjYXRlZCBmb3IgcHVibGljIHVzZS4gVXNlIFtbdXJsU2VydmljZV1dIGluc3RlYWQuXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBbW3VybFNlcnZpY2VdXSBpbnN0ZWFkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVybFJvdXRlciA9IG5ldyB1cmxSb3V0ZXJfMS5VcmxSb3V0ZXIodGhpcyk7XG4gICAgICAgIC8qKiBQcm92aWRlcyBhIHJlZ2lzdHJ5IGZvciBzdGF0ZXMsIGFuZCByZWxhdGVkIHJlZ2lzdHJhdGlvbiBzZXJ2aWNlcyAqL1xuICAgICAgICB0aGlzLnN0YXRlUmVnaXN0cnkgPSBuZXcgc3RhdGVSZWdpc3RyeV8xLlN0YXRlUmVnaXN0cnkodGhpcyk7XG4gICAgICAgIC8qKiBQcm92aWRlcyBzZXJ2aWNlcyByZWxhdGVkIHRvIHN0YXRlcyAqL1xuICAgICAgICB0aGlzLnN0YXRlU2VydmljZSA9IG5ldyBzdGF0ZVNlcnZpY2VfMS5TdGF0ZVNlcnZpY2UodGhpcyk7XG4gICAgICAgIC8qKiBQcm92aWRlcyBzZXJ2aWNlcyByZWxhdGVkIHRvIHRoZSBVUkwgKi9cbiAgICAgICAgdGhpcy51cmxTZXJ2aWNlID0gbmV3IHVybFNlcnZpY2VfMS5VcmxTZXJ2aWNlKHRoaXMpO1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLl9wbHVnaW5zID0ge307XG4gICAgICAgIHRoaXMudmlld1NlcnZpY2UuX3BsdWdpbmFwaS5fcm9vdFZpZXdDb250ZXh0KHRoaXMuc3RhdGVSZWdpc3RyeS5yb290KCkpO1xuICAgICAgICB0aGlzLmdsb2JhbHMuJGN1cnJlbnQgPSB0aGlzLnN0YXRlUmVnaXN0cnkucm9vdCgpO1xuICAgICAgICB0aGlzLmdsb2JhbHMuY3VycmVudCA9IHRoaXMuZ2xvYmFscy4kY3VycmVudC5zZWxmO1xuICAgICAgICB0aGlzLmRpc3Bvc2FibGUodGhpcy5nbG9iYWxzKTtcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlKHRoaXMuc3RhdGVTZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlKHRoaXMuc3RhdGVSZWdpc3RyeSk7XG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZSh0aGlzLnRyYW5zaXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlKHRoaXMudXJsUm91dGVyKTtcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlKGxvY2F0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZShsb2NhdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIC8qKiBSZWdpc3RlcnMgYW4gb2JqZWN0IHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHJvdXRlciBpcyBkaXNwb3NlZCAqL1xuICAgIFVJUm91dGVyLnByb3RvdHlwZS5kaXNwb3NhYmxlID0gZnVuY3Rpb24gKGRpc3Bvc2FibGUpIHtcbiAgICAgICAgdGhpcy5fZGlzcG9zYWJsZXMucHVzaChkaXNwb3NhYmxlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpc3Bvc2VzIHRoaXMgcm91dGVyIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBXaGVuIGNhbGxlZCwgY2xlYXJzIHJlc291cmNlcyByZXRhaW5lZCBieSB0aGUgcm91dGVyIGJ5IGNhbGxpbmcgYGRpc3Bvc2UodGhpcylgIG9uIGFsbFxuICAgICAqIHJlZ2lzdGVyZWQgW1tkaXNwb3NhYmxlXV0gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIE9yLCBpZiBhIGBkaXNwb3NhYmxlYCBvYmplY3QgaXMgcHJvdmlkZWQsIGNhbGxzIGBkaXNwb3NlKHRoaXMpYCBvbiB0aGF0IG9iamVjdCBvbmx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRpc3Bvc2FibGUgKG9wdGlvbmFsKSB0aGUgZGlzcG9zYWJsZSB0byBkaXNwb3NlXG4gICAgICovXG4gICAgVUlSb3V0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoZGlzcG9zYWJsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZGlzcG9zYWJsZSAmJiBwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihkaXNwb3NhYmxlLmRpc3Bvc2UpKSB7XG4gICAgICAgICAgICBkaXNwb3NhYmxlLmRpc3Bvc2UodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZGlzcG9zYWJsZXMuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHR5cGVvZiBkLmRpc3Bvc2UgPT09ICdmdW5jdGlvbicgJiYgZC5kaXNwb3NlKF90aGlzKTtcbiAgICAgICAgICAgICAgICBjb21tb25fMS5yZW1vdmVGcm9tKF90aGlzLl9kaXNwb3NhYmxlcywgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoaWdub3JlZCkgeyB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHBsdWdpbiB0byBVSS1Sb3V0ZXJcbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFkZHMgYSBVSS1Sb3V0ZXIgUGx1Z2luLlxuICAgICAqIEEgcGx1Z2luIGNhbiBlbmhhbmNlIG9yIGNoYW5nZSBVSS1Sb3V0ZXIgYmVoYXZpb3IgdXNpbmcgYW55IHB1YmxpYyBBUEkuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBpbXBvcnQgeyBNeUNvb2xQbHVnaW4gfSBmcm9tIFwidWktcm91dGVyLWNvb2wtcGx1Z2luXCI7XG4gICAgICpcbiAgICAgKiB2YXIgcGx1Z2luID0gcm91dGVyLmFkZFBsdWdpbihNeUNvb2xQbHVnaW4pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIFBsdWdpbiBhdXRob3JpbmdcbiAgICAgKlxuICAgICAqIEEgcGx1Z2luIGlzIHNpbXBseSBhIGNsYXNzIChvciBjb25zdHJ1Y3RvciBmdW5jdGlvbikgd2hpY2ggYWNjZXB0cyBhIFtbVUlSb3V0ZXJdXSBpbnN0YW5jZSBhbmQgKG9wdGlvbmFsbHkpIGFuIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqXG4gICAgICogVGhlIHBsdWdpbiBjYW4gaW1wbGVtZW50IGl0cyBmdW5jdGlvbmFsaXR5IHVzaW5nIGFueSBvZiB0aGUgcHVibGljIEFQSXMgb2YgW1tVSVJvdXRlcl1dLlxuICAgICAqIEZvciBleGFtcGxlLCBpdCBtYXkgY29uZmlndXJlIHJvdXRlciBvcHRpb25zIG9yIGFkZCBhIFRyYW5zaXRpb24gSG9vay5cbiAgICAgKlxuICAgICAqIFRoZSBwbHVnaW4gY2FuIHRoZW4gYmUgcHVibGlzaGVkIGFzIGEgc2VwYXJhdGUgbW9kdWxlLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogZXhwb3J0IGNsYXNzIE15QXV0aFBsdWdpbiBpbXBsZW1lbnRzIFVJUm91dGVyUGx1Z2luIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKHJvdXRlcjogVUlSb3V0ZXIsIG9wdGlvbnM6IGFueSkge1xuICAgICAqICAgICB0aGlzLm5hbWUgPSBcIk15QXV0aFBsdWdpblwiO1xuICAgICAqICAgICBsZXQgJHRyYW5zaXRpb25zID0gcm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlO1xuICAgICAqICAgICBsZXQgJHN0YXRlID0gcm91dGVyLnN0YXRlU2VydmljZTtcbiAgICAgKlxuICAgICAqICAgICBsZXQgYXV0aENyaXRlcmlhID0ge1xuICAgICAqICAgICAgIHRvOiAoc3RhdGUpID0+IHN0YXRlLmRhdGEgJiYgc3RhdGUuZGF0YS5yZXF1aXJlc0F1dGhcbiAgICAgKiAgICAgfTtcbiAgICAgKlxuICAgICAqICAgICBmdW5jdGlvbiBhdXRoSG9vayh0cmFuc2l0aW9uOiBUcmFuc2l0aW9uKSB7XG4gICAgICogICAgICAgbGV0IGF1dGhTZXJ2aWNlID0gdHJhbnNpdGlvbi5pbmplY3RvcigpLmdldCgnQXV0aFNlcnZpY2UnKTtcbiAgICAgKiAgICAgICBpZiAoIWF1dGhTZXJ2aWNlLmlzQXV0aGVudGljYXRlZCgpKSB7XG4gICAgICogICAgICAgICByZXR1cm4gJHN0YXRlLnRhcmdldCgnbG9naW4nKTtcbiAgICAgKiAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqICAgICAkdHJhbnNpdGlvbnMub25TdGFydChhdXRoQ3JpdGVyaWEsIGF1dGhIb29rKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGx1Z2luIG9uZSBvZjpcbiAgICAgKiAgICAgICAgLSBhIHBsdWdpbiBjbGFzcyB3aGljaCBpbXBsZW1lbnRzIFtbVUlSb3V0ZXJQbHVnaW5dXVxuICAgICAqICAgICAgICAtIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIGEgW1tVSVJvdXRlclBsdWdpbl1dIHdoaWNoIGFjY2VwdHMgYSBbW1VJUm91dGVyXV0gaW5zdGFuY2VcbiAgICAgKiAgICAgICAgLSBhIGZhY3RvcnkgZnVuY3Rpb24gd2hpY2ggYWNjZXB0cyBhIFtbVUlSb3V0ZXJdXSBpbnN0YW5jZSBhbmQgcmV0dXJucyBhIFtbVUlSb3V0ZXJQbHVnaW5dXSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgcGx1Z2luIGNsYXNzL2ZhY3RvcnlcbiAgICAgKiBAcmV0dXJucyB0aGUgcmVnaXN0ZXJlZCBwbHVnaW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBVSVJvdXRlci5wcm90b3R5cGUucGx1Z2luID0gZnVuY3Rpb24gKHBsdWdpbiwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgcGx1Z2luSW5zdGFuY2UgPSBuZXcgcGx1Z2luKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXBsdWdpbkluc3RhbmNlLm5hbWUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXF1aXJlZCBwcm9wZXJ0eSBgbmFtZWAgbWlzc2luZyBvbiBwbHVnaW46IFwiICsgcGx1Z2luSW5zdGFuY2UpO1xuICAgICAgICB0aGlzLl9kaXNwb3NhYmxlcy5wdXNoKHBsdWdpbkluc3RhbmNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BsdWdpbnNbcGx1Z2luSW5zdGFuY2UubmFtZV0gPSBwbHVnaW5JbnN0YW5jZTtcbiAgICB9O1xuICAgIFVJUm91dGVyLnByb3RvdHlwZS5nZXRQbHVnaW4gPSBmdW5jdGlvbiAocGx1Z2luTmFtZSkge1xuICAgICAgICByZXR1cm4gcGx1Z2luTmFtZSA/IHRoaXMuX3BsdWdpbnNbcGx1Z2luTmFtZV0gOiBjb21tb25fMS52YWx1ZXModGhpcy5fcGx1Z2lucyk7XG4gICAgfTtcbiAgICByZXR1cm4gVUlSb3V0ZXI7XG59KCkpO1xuZXhwb3J0cy5VSVJvdXRlciA9IFVJUm91dGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvcm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///33\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/** @module state */ /** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ 1);\nvar strings_1 = __webpack_require__(/*! ../common/strings */ 6);\nvar hof_1 = __webpack_require__(/*! ../common/hof */ 2);\nvar resolvable_1 = __webpack_require__(/*! ../resolve/resolvable */ 11);\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ 3);\nvar parseUrl = function (url) {\n    if (!predicates_1.isString(url))\n        return false;\n    var root = url.charAt(0) === \'^\';\n    return { val: root ? url.substring(1) : url, root: root };\n};\nfunction nameBuilder(state) {\n    return state.name;\n}\nfunction selfBuilder(state) {\n    state.self.$$state = function () { return state; };\n    return state.self;\n}\nfunction dataBuilder(state) {\n    if (state.parent && state.parent.data) {\n        state.data = state.self.data = common_1.inherit(state.parent.data, state.data);\n    }\n    return state.data;\n}\nvar getUrlBuilder = function ($urlMatcherFactoryProvider, root) {\n    return function urlBuilder(state) {\n        var stateDec = state;\n        // For future states, i.e., states whose name ends with `.**`,\n        // match anything that starts with the url prefix\n        if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\\.\\*\\*$/)) {\n            stateDec.url += "{remainder:any}"; // match any path (.*)\n        }\n        var parsed = parseUrl(stateDec.url), parent = state.parent;\n        var url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, {\n            params: state.params || {},\n            paramMap: function (paramConfig, isSearch) {\n                if (stateDec.reloadOnSearch === false && isSearch)\n                    paramConfig = common_1.extend(paramConfig || {}, { dynamic: true });\n                return paramConfig;\n            }\n        });\n        if (!url)\n            return null;\n        if (!$urlMatcherFactoryProvider.isMatcher(url))\n            throw new Error("Invalid url \'" + url + "\' in state \'" + state + "\'");\n        return (parsed && parsed.root) ? url : ((parent && parent.navigable) || root()).url.append(url);\n    };\n};\nvar getNavigableBuilder = function (isRoot) {\n    return function navigableBuilder(state) {\n        return !isRoot(state) && state.url ? state : (state.parent ? state.parent.navigable : null);\n    };\n};\nvar getParamsBuilder = function (paramFactory) {\n    return function paramsBuilder(state) {\n        var makeConfigParam = function (config, id) { return paramFactory.fromConfig(id, null, config); };\n        var urlParams = (state.url && state.url.parameters({ inherit: false })) || [];\n        var nonUrlParams = common_1.values(common_1.mapObj(common_1.omit(state.params || {}, urlParams.map(hof_1.prop(\'id\'))), makeConfigParam));\n        return urlParams.concat(nonUrlParams).map(function (p) { return [p.id, p]; }).reduce(common_1.applyPairs, {});\n    };\n};\nfunction pathBuilder(state) {\n    return state.parent ? state.parent.path.concat(state) : /*root*/ [state];\n}\nfunction includesBuilder(state) {\n    var includes = state.parent ? common_1.extend({}, state.parent.includes) : {};\n    includes[state.name] = true;\n    return includes;\n}\n/**\n * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * validates the `resolve` property and converts it to a [[Resolvable]] array.\n *\n * resolve: input value can be:\n *\n * {\n *   // analyzed but not injected\n *   myFooResolve: function() { return "myFooData"; },\n *\n *   // function.toString() parsed, "DependencyName" dep as string (not min-safe)\n *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },\n *\n *   // Array split; "DependencyName" dep as string\n *   myBazResolve: [ "DependencyName", function(dep) { return dep.fetchSomethingAsPromise() },\n *\n *   // Array split; DependencyType dep as token (compared using ===)\n *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },\n *\n *   // val.$inject used as deps\n *   // where:\n *   //     corgeResolve.$inject = ["DependencyName"];\n *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }\n *   // then "DependencyName" dep as string\n *   myCorgeResolve: corgeResolve,\n *\n *  // inject service by name\n *  // When a string is found, desugar creating a resolve that injects the named service\n *   myGraultResolve: "SomeService"\n * }\n *\n * or:\n *\n * [\n *   new Resolvable("myFooResolve", function() { return "myFooData" }),\n *   new Resolvable("myBarResolve", function(dep) { return dep.fetchSomethingAsPromise() }, [ "DependencyName" ]),\n *   { provide: "myBazResolve", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ "DependencyName" ] }\n * ]\n */\nfunction resolvablesBuilder(state) {\n    /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */\n    var objects2Tuples = function (resolveObj, resolvePolicies) {\n        return Object.keys(resolveObj || {}).map(function (token) { return ({ token: token, val: resolveObj[token], deps: undefined, policy: resolvePolicies[token] }); });\n    };\n    /** fetch DI annotations from a function or ng1-style array */\n    var annotate = function (fn) {\n        var $injector = coreservices_1.services.$injector;\n        // ng1 doesn\'t have an $injector until runtime.\n        // If the $injector doesn\'t exist, use "deferred" literal as a\n        // marker indicating they should be annotated when runtime starts\n        return fn[\'$inject\'] || ($injector && $injector.annotate(fn, $injector.strictDi)) || "deferred";\n    };\n    /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */\n    var isResolveLiteral = function (obj) { return !!(obj.token && obj.resolveFn); };\n    /** true if the object looks like a provide literal, or a ng2 Provider */\n    var isLikeNg2Provider = function (obj) { return !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass)); };\n    /** true if the object looks like a tuple from obj2Tuples */\n    var isTupleFromObj = function (obj) { return !!(obj && obj.val && (predicates_1.isString(obj.val) || predicates_1.isArray(obj.val) || predicates_1.isFunction(obj.val))); };\n    /** extracts the token from a Provider or provide literal */\n    var token = function (p) { return p.provide || p.token; };\n    /** Given a literal resolve or provider object, returns a Resolvable */\n    var literal2Resolvable = hof_1.pattern([\n        [hof_1.prop(\'resolveFn\'), function (p) { return new resolvable_1.Resolvable(token(p), p.resolveFn, p.deps, p.policy); }],\n        [hof_1.prop(\'useFactory\'), function (p) { return new resolvable_1.Resolvable(token(p), p.useFactory, (p.deps || p.dependencies), p.policy); }],\n        [hof_1.prop(\'useClass\'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return new p.useClass(); }, [], p.policy); }],\n        [hof_1.prop(\'useValue\'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return p.useValue; }, [], p.policy, p.useValue); }],\n        [hof_1.prop(\'useExisting\'), function (p) { return new resolvable_1.Resolvable(token(p), common_1.identity, [p.useExisting], p.policy); }],\n    ]);\n    var tuple2Resolvable = hof_1.pattern([\n        [hof_1.pipe(hof_1.prop("val"), predicates_1.isString), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.identity, [tuple.val], tuple.policy); }],\n        [hof_1.pipe(hof_1.prop("val"), predicates_1.isArray), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.tail(tuple.val), tuple.val.slice(0, -1), tuple.policy); }],\n        [hof_1.pipe(hof_1.prop("val"), predicates_1.isFunction), function (tuple) { return new resolvable_1.Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy); }],\n    ]);\n    var item2Resolvable = hof_1.pattern([\n        [hof_1.is(resolvable_1.Resolvable), function (r) { return r; }],\n        [isResolveLiteral, literal2Resolvable],\n        [isLikeNg2Provider, literal2Resolvable],\n        [isTupleFromObj, tuple2Resolvable],\n        [hof_1.val(true), function (obj) { throw new Error("Invalid resolve value: " + strings_1.stringify(obj)); }]\n    ]);\n    // If resolveBlock is already an array, use it as-is.\n    // Otherwise, assume it\'s an object and convert to an Array of tuples\n    var decl = state.resolve;\n    var items = predicates_1.isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});\n    return items.map(item2Resolvable);\n}\nexports.resolvablesBuilder = resolvablesBuilder;\n/**\n * @internalapi A internal global service\n *\n * StateBuilder is a factory for the internal [[StateObject]] objects.\n *\n * When you register a state with the [[StateRegistry]], you register a plain old javascript object which\n * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding\n * [[StateObject]] object, which has an API and is used internally.\n *\n * Custom properties or API may be added to the internal [[StateObject]] object by registering a decorator function\n * using the [[builder]] method.\n */\nvar StateBuilder = /** @class */ (function () {\n    function StateBuilder(matcher, urlMatcherFactory) {\n        this.matcher = matcher;\n        var self = this;\n        var root = function () { return matcher.find(""); };\n        var isRoot = function (state) { return state.name === ""; };\n        function parentBuilder(state) {\n            if (isRoot(state))\n                return null;\n            return matcher.find(self.parentName(state)) || root();\n        }\n        this.builders = {\n            name: [nameBuilder],\n            self: [selfBuilder],\n            parent: [parentBuilder],\n            data: [dataBuilder],\n            // Build a URLMatcher if necessary, either via a relative or absolute URL\n            url: [getUrlBuilder(urlMatcherFactory, root)],\n            // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n            navigable: [getNavigableBuilder(isRoot)],\n            params: [getParamsBuilder(urlMatcherFactory.paramFactory)],\n            // Each framework-specific ui-router implementation should define its own `views` builder\n            // e.g., src/ng1/statebuilders/views.ts\n            views: [],\n            // Keep a full path from the root down to this state as this is needed for state activation.\n            path: [pathBuilder],\n            // Speed up $state.includes() as it\'s used a lot\n            includes: [includesBuilder],\n            resolvables: [resolvablesBuilder]\n        };\n    }\n    /**\n     * Registers a [[BuilderFunction]] for a specific [[StateObject]] property (e.g., `parent`, `url`, or `path`).\n     * More than one BuilderFunction can be registered for a given property.\n     *\n     * The BuilderFunction(s) will be used to define the property on any subsequently built [[StateObject]] objects.\n     *\n     * @param name The name of the State property being registered for.\n     * @param fn The BuilderFunction which will be used to build the State property\n     * @returns a function which deregisters the BuilderFunction\n     */\n    StateBuilder.prototype.builder = function (name, fn) {\n        var builders = this.builders;\n        var array = builders[name] || [];\n        // Backwards compat: if only one builder exists, return it, else return whole arary.\n        if (predicates_1.isString(name) && !predicates_1.isDefined(fn))\n            return array.length > 1 ? array : array[0];\n        if (!predicates_1.isString(name) || !predicates_1.isFunction(fn))\n            return;\n        builders[name] = array;\n        builders[name].push(fn);\n        return function () { return builders[name].splice(builders[name].indexOf(fn, 1)) && null; };\n    };\n    /**\n     * Builds all of the properties on an essentially blank State object, returning a State object which has all its\n     * properties and API built.\n     *\n     * @param state an uninitialized State object\n     * @returns the built State object\n     */\n    StateBuilder.prototype.build = function (state) {\n        var _a = this, matcher = _a.matcher, builders = _a.builders;\n        var parent = this.parentName(state);\n        if (parent && !matcher.find(parent, undefined, false)) {\n            return null;\n        }\n        for (var key in builders) {\n            if (!builders.hasOwnProperty(key))\n                continue;\n            var chain = builders[key].reduce(function (parentFn, step) { return function (_state) { return step(_state, parentFn); }; }, common_1.noop);\n            state[key] = chain(state);\n        }\n        return state;\n    };\n    StateBuilder.prototype.parentName = function (state) {\n        // name = \'foo.bar.baz.**\'\n        var name = state.name || "";\n        // segments = [\'foo\', \'bar\', \'baz\', \'.**\']\n        var segments = name.split(\'.\');\n        // segments = [\'foo\', \'bar\', \'baz\']\n        var lastSegment = segments.pop();\n        // segments = [\'foo\', \'bar\'] (ignore .** segment for future states)\n        if (lastSegment === \'**\')\n            segments.pop();\n        if (segments.length) {\n            if (state.parent) {\n                throw new Error("States that specify the \'parent:\' property should not have a \'.\' in their name (" + name + ")");\n            }\n            // \'foo.bar\'\n            return segments.join(".");\n        }\n        if (!state.parent)\n            return "";\n        return predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n    };\n    StateBuilder.prototype.name = function (state) {\n        var name = state.name;\n        if (name.indexOf(\'.\') !== -1 || !state.parent)\n            return name;\n        var parentName = predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n        return parentName ? parentName + "." + name : name;\n    };\n    return StateBuilder;\n}());\nexports.StateBuilder = StateBuilder;\n//# sourceMappingURL=stateBuilder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9zdGF0ZUJ1aWxkZXIuanM/ZTllZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBAbW9kdWxlIHN0YXRlICovIC8qKiBmb3IgdHlwZWRvYyAqL1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vc3RyaW5nc1wiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIHJlc29sdmFibGVfMSA9IHJlcXVpcmUoXCIuLi9yZXNvbHZlL3Jlc29sdmFibGVcIik7XG52YXIgY29yZXNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvcmVzZXJ2aWNlc1wiKTtcbnZhciBwYXJzZVVybCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc1N0cmluZyh1cmwpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHJvb3QgPSB1cmwuY2hhckF0KDApID09PSAnXic7XG4gICAgcmV0dXJuIHsgdmFsOiByb290ID8gdXJsLnN1YnN0cmluZygxKSA6IHVybCwgcm9vdDogcm9vdCB9O1xufTtcbmZ1bmN0aW9uIG5hbWVCdWlsZGVyKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLm5hbWU7XG59XG5mdW5jdGlvbiBzZWxmQnVpbGRlcihzdGF0ZSkge1xuICAgIHN0YXRlLnNlbGYuJCRzdGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0YXRlOyB9O1xuICAgIHJldHVybiBzdGF0ZS5zZWxmO1xufVxuZnVuY3Rpb24gZGF0YUJ1aWxkZXIoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUucGFyZW50ICYmIHN0YXRlLnBhcmVudC5kYXRhKSB7XG4gICAgICAgIHN0YXRlLmRhdGEgPSBzdGF0ZS5zZWxmLmRhdGEgPSBjb21tb25fMS5pbmhlcml0KHN0YXRlLnBhcmVudC5kYXRhLCBzdGF0ZS5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmRhdGE7XG59XG52YXIgZ2V0VXJsQnVpbGRlciA9IGZ1bmN0aW9uICgkdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlciwgcm9vdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiB1cmxCdWlsZGVyKHN0YXRlKSB7XG4gICAgICAgIHZhciBzdGF0ZURlYyA9IHN0YXRlO1xuICAgICAgICAvLyBGb3IgZnV0dXJlIHN0YXRlcywgaS5lLiwgc3RhdGVzIHdob3NlIG5hbWUgZW5kcyB3aXRoIGAuKipgLFxuICAgICAgICAvLyBtYXRjaCBhbnl0aGluZyB0aGF0IHN0YXJ0cyB3aXRoIHRoZSB1cmwgcHJlZml4XG4gICAgICAgIGlmIChzdGF0ZURlYyAmJiBzdGF0ZURlYy51cmwgJiYgc3RhdGVEZWMubmFtZSAmJiBzdGF0ZURlYy5uYW1lLm1hdGNoKC9cXC5cXCpcXCokLykpIHtcbiAgICAgICAgICAgIHN0YXRlRGVjLnVybCArPSBcIntyZW1haW5kZXI6YW55fVwiOyAvLyBtYXRjaCBhbnkgcGF0aCAoLiopXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlVXJsKHN0YXRlRGVjLnVybCksIHBhcmVudCA9IHN0YXRlLnBhcmVudDtcbiAgICAgICAgdmFyIHVybCA9ICFwYXJzZWQgPyBzdGF0ZURlYy51cmwgOiAkdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlci5jb21waWxlKHBhcnNlZC52YWwsIHtcbiAgICAgICAgICAgIHBhcmFtczogc3RhdGUucGFyYW1zIHx8IHt9LFxuICAgICAgICAgICAgcGFyYW1NYXA6IGZ1bmN0aW9uIChwYXJhbUNvbmZpZywgaXNTZWFyY2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVEZWMucmVsb2FkT25TZWFyY2ggPT09IGZhbHNlICYmIGlzU2VhcmNoKVxuICAgICAgICAgICAgICAgICAgICBwYXJhbUNvbmZpZyA9IGNvbW1vbl8xLmV4dGVuZChwYXJhbUNvbmZpZyB8fCB7fSwgeyBkeW5hbWljOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbUNvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdXJsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghJHVybE1hdGNoZXJGYWN0b3J5UHJvdmlkZXIuaXNNYXRjaGVyKHVybCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHVybCAnXCIgKyB1cmwgKyBcIicgaW4gc3RhdGUgJ1wiICsgc3RhdGUgKyBcIidcIik7XG4gICAgICAgIHJldHVybiAocGFyc2VkICYmIHBhcnNlZC5yb290KSA/IHVybCA6ICgocGFyZW50ICYmIHBhcmVudC5uYXZpZ2FibGUpIHx8IHJvb3QoKSkudXJsLmFwcGVuZCh1cmwpO1xuICAgIH07XG59O1xudmFyIGdldE5hdmlnYWJsZUJ1aWxkZXIgPSBmdW5jdGlvbiAoaXNSb290KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5hdmlnYWJsZUJ1aWxkZXIoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuICFpc1Jvb3Qoc3RhdGUpICYmIHN0YXRlLnVybCA/IHN0YXRlIDogKHN0YXRlLnBhcmVudCA/IHN0YXRlLnBhcmVudC5uYXZpZ2FibGUgOiBudWxsKTtcbiAgICB9O1xufTtcbnZhciBnZXRQYXJhbXNCdWlsZGVyID0gZnVuY3Rpb24gKHBhcmFtRmFjdG9yeSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBwYXJhbXNCdWlsZGVyKHN0YXRlKSB7XG4gICAgICAgIHZhciBtYWtlQ29uZmlnUGFyYW0gPSBmdW5jdGlvbiAoY29uZmlnLCBpZCkgeyByZXR1cm4gcGFyYW1GYWN0b3J5LmZyb21Db25maWcoaWQsIG51bGwsIGNvbmZpZyk7IH07XG4gICAgICAgIHZhciB1cmxQYXJhbXMgPSAoc3RhdGUudXJsICYmIHN0YXRlLnVybC5wYXJhbWV0ZXJzKHsgaW5oZXJpdDogZmFsc2UgfSkpIHx8IFtdO1xuICAgICAgICB2YXIgbm9uVXJsUGFyYW1zID0gY29tbW9uXzEudmFsdWVzKGNvbW1vbl8xLm1hcE9iaihjb21tb25fMS5vbWl0KHN0YXRlLnBhcmFtcyB8fCB7fSwgdXJsUGFyYW1zLm1hcChob2ZfMS5wcm9wKCdpZCcpKSksIG1ha2VDb25maWdQYXJhbSkpO1xuICAgICAgICByZXR1cm4gdXJsUGFyYW1zLmNvbmNhdChub25VcmxQYXJhbXMpLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gW3AuaWQsIHBdOyB9KS5yZWR1Y2UoY29tbW9uXzEuYXBwbHlQYWlycywge30pO1xuICAgIH07XG59O1xuZnVuY3Rpb24gcGF0aEJ1aWxkZXIoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUucGFyZW50ID8gc3RhdGUucGFyZW50LnBhdGguY29uY2F0KHN0YXRlKSA6IC8qcm9vdCovIFtzdGF0ZV07XG59XG5mdW5jdGlvbiBpbmNsdWRlc0J1aWxkZXIoc3RhdGUpIHtcbiAgICB2YXIgaW5jbHVkZXMgPSBzdGF0ZS5wYXJlbnQgPyBjb21tb25fMS5leHRlbmQoe30sIHN0YXRlLnBhcmVudC5pbmNsdWRlcykgOiB7fTtcbiAgICBpbmNsdWRlc1tzdGF0ZS5uYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIGluY2x1ZGVzO1xufVxuLyoqXG4gKiBUaGlzIGlzIGEgW1tTdGF0ZUJ1aWxkZXIuYnVpbGRlcl1dIGZ1bmN0aW9uIGZvciB0aGUgYHJlc29sdmU6YCBibG9jayBvbiBhIFtbU3RhdGVEZWNsYXJhdGlvbl1dLlxuICpcbiAqIFdoZW4gdGhlIFtbU3RhdGVCdWlsZGVyXV0gYnVpbGRzIGEgW1tTdGF0ZU9iamVjdF1dIG9iamVjdCBmcm9tIGEgcmF3IFtbU3RhdGVEZWNsYXJhdGlvbl1dLCB0aGlzIGJ1aWxkZXJcbiAqIHZhbGlkYXRlcyB0aGUgYHJlc29sdmVgIHByb3BlcnR5IGFuZCBjb252ZXJ0cyBpdCB0byBhIFtbUmVzb2x2YWJsZV1dIGFycmF5LlxuICpcbiAqIHJlc29sdmU6IGlucHV0IHZhbHVlIGNhbiBiZTpcbiAqXG4gKiB7XG4gKiAgIC8vIGFuYWx5emVkIGJ1dCBub3QgaW5qZWN0ZWRcbiAqICAgbXlGb29SZXNvbHZlOiBmdW5jdGlvbigpIHsgcmV0dXJuIFwibXlGb29EYXRhXCI7IH0sXG4gKlxuICogICAvLyBmdW5jdGlvbi50b1N0cmluZygpIHBhcnNlZCwgXCJEZXBlbmRlbmN5TmFtZVwiIGRlcCBhcyBzdHJpbmcgKG5vdCBtaW4tc2FmZSlcbiAqICAgbXlCYXJSZXNvbHZlOiBmdW5jdGlvbihEZXBlbmRlbmN5TmFtZSkgeyByZXR1cm4gRGVwZW5kZW5jeU5hbWUuZmV0Y2hTb21ldGhpbmdBc1Byb21pc2UoKSB9LFxuICpcbiAqICAgLy8gQXJyYXkgc3BsaXQ7IFwiRGVwZW5kZW5jeU5hbWVcIiBkZXAgYXMgc3RyaW5nXG4gKiAgIG15QmF6UmVzb2x2ZTogWyBcIkRlcGVuZGVuY3lOYW1lXCIsIGZ1bmN0aW9uKGRlcCkgeyByZXR1cm4gZGVwLmZldGNoU29tZXRoaW5nQXNQcm9taXNlKCkgfSxcbiAqXG4gKiAgIC8vIEFycmF5IHNwbGl0OyBEZXBlbmRlbmN5VHlwZSBkZXAgYXMgdG9rZW4gKGNvbXBhcmVkIHVzaW5nID09PSlcbiAqICAgbXlRdXhSZXNvbHZlOiBbIERlcGVuZGVuY3lUeXBlLCBmdW5jdGlvbihkZXApIHsgcmV0dXJuIGRlcC5mZXRjaFNvbWV0aW5nQXNQcm9taXNlKCkgfSxcbiAqXG4gKiAgIC8vIHZhbC4kaW5qZWN0IHVzZWQgYXMgZGVwc1xuICogICAvLyB3aGVyZTpcbiAqICAgLy8gICAgIGNvcmdlUmVzb2x2ZS4kaW5qZWN0ID0gW1wiRGVwZW5kZW5jeU5hbWVcIl07XG4gKiAgIC8vICAgICBmdW5jdGlvbiBjb3JnZVJlc29sdmUoZGVwKSB7IGRlcC5mZXRjaFNvbWV0aW5nQXNQcm9taXNlKCkgfVxuICogICAvLyB0aGVuIFwiRGVwZW5kZW5jeU5hbWVcIiBkZXAgYXMgc3RyaW5nXG4gKiAgIG15Q29yZ2VSZXNvbHZlOiBjb3JnZVJlc29sdmUsXG4gKlxuICogIC8vIGluamVjdCBzZXJ2aWNlIGJ5IG5hbWVcbiAqICAvLyBXaGVuIGEgc3RyaW5nIGlzIGZvdW5kLCBkZXN1Z2FyIGNyZWF0aW5nIGEgcmVzb2x2ZSB0aGF0IGluamVjdHMgdGhlIG5hbWVkIHNlcnZpY2VcbiAqICAgbXlHcmF1bHRSZXNvbHZlOiBcIlNvbWVTZXJ2aWNlXCJcbiAqIH1cbiAqXG4gKiBvcjpcbiAqXG4gKiBbXG4gKiAgIG5ldyBSZXNvbHZhYmxlKFwibXlGb29SZXNvbHZlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJteUZvb0RhdGFcIiB9KSxcbiAqICAgbmV3IFJlc29sdmFibGUoXCJteUJhclJlc29sdmVcIiwgZnVuY3Rpb24oZGVwKSB7IHJldHVybiBkZXAuZmV0Y2hTb21ldGhpbmdBc1Byb21pc2UoKSB9LCBbIFwiRGVwZW5kZW5jeU5hbWVcIiBdKSxcbiAqICAgeyBwcm92aWRlOiBcIm15QmF6UmVzb2x2ZVwiLCB1c2VGYWN0b3J5OiBmdW5jdGlvbihkZXApIHsgZGVwLmZldGNoU29tZXRoaW5nQXNQcm9taXNlKCkgfSwgZGVwczogWyBcIkRlcGVuZGVuY3lOYW1lXCIgXSB9XG4gKiBdXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmFibGVzQnVpbGRlcihzdGF0ZSkge1xuICAgIC8qKiBjb252ZXJ0IHJlc29sdmU6IHt9IGFuZCByZXNvbHZlUG9saWN5OiB7fSBvYmplY3RzIHRvIGFuIGFycmF5IG9mIHR1cGxlcyAqL1xuICAgIHZhciBvYmplY3RzMlR1cGxlcyA9IGZ1bmN0aW9uIChyZXNvbHZlT2JqLCByZXNvbHZlUG9saWNpZXMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHJlc29sdmVPYmogfHwge30pLm1hcChmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuICh7IHRva2VuOiB0b2tlbiwgdmFsOiByZXNvbHZlT2JqW3Rva2VuXSwgZGVwczogdW5kZWZpbmVkLCBwb2xpY3k6IHJlc29sdmVQb2xpY2llc1t0b2tlbl0gfSk7IH0pO1xuICAgIH07XG4gICAgLyoqIGZldGNoIERJIGFubm90YXRpb25zIGZyb20gYSBmdW5jdGlvbiBvciBuZzEtc3R5bGUgYXJyYXkgKi9cbiAgICB2YXIgYW5ub3RhdGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdmFyICRpbmplY3RvciA9IGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRpbmplY3RvcjtcbiAgICAgICAgLy8gbmcxIGRvZXNuJ3QgaGF2ZSBhbiAkaW5qZWN0b3IgdW50aWwgcnVudGltZS5cbiAgICAgICAgLy8gSWYgdGhlICRpbmplY3RvciBkb2Vzbid0IGV4aXN0LCB1c2UgXCJkZWZlcnJlZFwiIGxpdGVyYWwgYXMgYVxuICAgICAgICAvLyBtYXJrZXIgaW5kaWNhdGluZyB0aGV5IHNob3VsZCBiZSBhbm5vdGF0ZWQgd2hlbiBydW50aW1lIHN0YXJ0c1xuICAgICAgICByZXR1cm4gZm5bJyRpbmplY3QnXSB8fCAoJGluamVjdG9yICYmICRpbmplY3Rvci5hbm5vdGF0ZShmbiwgJGluamVjdG9yLnN0cmljdERpKSkgfHwgXCJkZWZlcnJlZFwiO1xuICAgIH07XG4gICAgLyoqIHRydWUgaWYgdGhlIG9iamVjdCBoYXMgYm90aCBgdG9rZW5gIGFuZCBgcmVzb2x2ZUZuYCwgYW5kIGlzIHByb2JhYmx5IGEgW1tSZXNvbHZlTGl0ZXJhbF1dICovXG4gICAgdmFyIGlzUmVzb2x2ZUxpdGVyYWwgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiAhIShvYmoudG9rZW4gJiYgb2JqLnJlc29sdmVGbik7IH07XG4gICAgLyoqIHRydWUgaWYgdGhlIG9iamVjdCBsb29rcyBsaWtlIGEgcHJvdmlkZSBsaXRlcmFsLCBvciBhIG5nMiBQcm92aWRlciAqL1xuICAgIHZhciBpc0xpa2VOZzJQcm92aWRlciA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuICEhKChvYmoucHJvdmlkZSB8fCBvYmoudG9rZW4pICYmIChvYmoudXNlVmFsdWUgfHwgb2JqLnVzZUZhY3RvcnkgfHwgb2JqLnVzZUV4aXN0aW5nIHx8IG9iai51c2VDbGFzcykpOyB9O1xuICAgIC8qKiB0cnVlIGlmIHRoZSBvYmplY3QgbG9va3MgbGlrZSBhIHR1cGxlIGZyb20gb2JqMlR1cGxlcyAqL1xuICAgIHZhciBpc1R1cGxlRnJvbU9iaiA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuICEhKG9iaiAmJiBvYmoudmFsICYmIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcob2JqLnZhbCkgfHwgcHJlZGljYXRlc18xLmlzQXJyYXkob2JqLnZhbCkgfHwgcHJlZGljYXRlc18xLmlzRnVuY3Rpb24ob2JqLnZhbCkpKTsgfTtcbiAgICAvKiogZXh0cmFjdHMgdGhlIHRva2VuIGZyb20gYSBQcm92aWRlciBvciBwcm92aWRlIGxpdGVyYWwgKi9cbiAgICB2YXIgdG9rZW4gPSBmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5wcm92aWRlIHx8IHAudG9rZW47IH07XG4gICAgLyoqIEdpdmVuIGEgbGl0ZXJhbCByZXNvbHZlIG9yIHByb3ZpZGVyIG9iamVjdCwgcmV0dXJucyBhIFJlc29sdmFibGUgKi9cbiAgICB2YXIgbGl0ZXJhbDJSZXNvbHZhYmxlID0gaG9mXzEucGF0dGVybihbXG4gICAgICAgIFtob2ZfMS5wcm9wKCdyZXNvbHZlRm4nKSwgZnVuY3Rpb24gKHApIHsgcmV0dXJuIG5ldyByZXNvbHZhYmxlXzEuUmVzb2x2YWJsZSh0b2tlbihwKSwgcC5yZXNvbHZlRm4sIHAuZGVwcywgcC5wb2xpY3kpOyB9XSxcbiAgICAgICAgW2hvZl8xLnByb3AoJ3VzZUZhY3RvcnknKSwgZnVuY3Rpb24gKHApIHsgcmV0dXJuIG5ldyByZXNvbHZhYmxlXzEuUmVzb2x2YWJsZSh0b2tlbihwKSwgcC51c2VGYWN0b3J5LCAocC5kZXBzIHx8IHAuZGVwZW5kZW5jaWVzKSwgcC5wb2xpY3kpOyB9XSxcbiAgICAgICAgW2hvZl8xLnByb3AoJ3VzZUNsYXNzJyksIGZ1bmN0aW9uIChwKSB7IHJldHVybiBuZXcgcmVzb2x2YWJsZV8xLlJlc29sdmFibGUodG9rZW4ocCksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBwLnVzZUNsYXNzKCk7IH0sIFtdLCBwLnBvbGljeSk7IH1dLFxuICAgICAgICBbaG9mXzEucHJvcCgndXNlVmFsdWUnKSwgZnVuY3Rpb24gKHApIHsgcmV0dXJuIG5ldyByZXNvbHZhYmxlXzEuUmVzb2x2YWJsZSh0b2tlbihwKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gcC51c2VWYWx1ZTsgfSwgW10sIHAucG9saWN5LCBwLnVzZVZhbHVlKTsgfV0sXG4gICAgICAgIFtob2ZfMS5wcm9wKCd1c2VFeGlzdGluZycpLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gbmV3IHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKHRva2VuKHApLCBjb21tb25fMS5pZGVudGl0eSwgW3AudXNlRXhpc3RpbmddLCBwLnBvbGljeSk7IH1dLFxuICAgIF0pO1xuICAgIHZhciB0dXBsZTJSZXNvbHZhYmxlID0gaG9mXzEucGF0dGVybihbXG4gICAgICAgIFtob2ZfMS5waXBlKGhvZl8xLnByb3AoXCJ2YWxcIiksIHByZWRpY2F0ZXNfMS5pc1N0cmluZyksIGZ1bmN0aW9uICh0dXBsZSkgeyByZXR1cm4gbmV3IHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKHR1cGxlLnRva2VuLCBjb21tb25fMS5pZGVudGl0eSwgW3R1cGxlLnZhbF0sIHR1cGxlLnBvbGljeSk7IH1dLFxuICAgICAgICBbaG9mXzEucGlwZShob2ZfMS5wcm9wKFwidmFsXCIpLCBwcmVkaWNhdGVzXzEuaXNBcnJheSksIGZ1bmN0aW9uICh0dXBsZSkgeyByZXR1cm4gbmV3IHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKHR1cGxlLnRva2VuLCBjb21tb25fMS50YWlsKHR1cGxlLnZhbCksIHR1cGxlLnZhbC5zbGljZSgwLCAtMSksIHR1cGxlLnBvbGljeSk7IH1dLFxuICAgICAgICBbaG9mXzEucGlwZShob2ZfMS5wcm9wKFwidmFsXCIpLCBwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbiksIGZ1bmN0aW9uICh0dXBsZSkgeyByZXR1cm4gbmV3IHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKHR1cGxlLnRva2VuLCB0dXBsZS52YWwsIGFubm90YXRlKHR1cGxlLnZhbCksIHR1cGxlLnBvbGljeSk7IH1dLFxuICAgIF0pO1xuICAgIHZhciBpdGVtMlJlc29sdmFibGUgPSBob2ZfMS5wYXR0ZXJuKFtcbiAgICAgICAgW2hvZl8xLmlzKHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKSwgZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHI7IH1dLFxuICAgICAgICBbaXNSZXNvbHZlTGl0ZXJhbCwgbGl0ZXJhbDJSZXNvbHZhYmxlXSxcbiAgICAgICAgW2lzTGlrZU5nMlByb3ZpZGVyLCBsaXRlcmFsMlJlc29sdmFibGVdLFxuICAgICAgICBbaXNUdXBsZUZyb21PYmosIHR1cGxlMlJlc29sdmFibGVdLFxuICAgICAgICBbaG9mXzEudmFsKHRydWUpLCBmdW5jdGlvbiAob2JqKSB7IHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVzb2x2ZSB2YWx1ZTogXCIgKyBzdHJpbmdzXzEuc3RyaW5naWZ5KG9iaikpOyB9XVxuICAgIF0pO1xuICAgIC8vIElmIHJlc29sdmVCbG9jayBpcyBhbHJlYWR5IGFuIGFycmF5LCB1c2UgaXQgYXMtaXMuXG4gICAgLy8gT3RoZXJ3aXNlLCBhc3N1bWUgaXQncyBhbiBvYmplY3QgYW5kIGNvbnZlcnQgdG8gYW4gQXJyYXkgb2YgdHVwbGVzXG4gICAgdmFyIGRlY2wgPSBzdGF0ZS5yZXNvbHZlO1xuICAgIHZhciBpdGVtcyA9IHByZWRpY2F0ZXNfMS5pc0FycmF5KGRlY2wpID8gZGVjbCA6IG9iamVjdHMyVHVwbGVzKGRlY2wsIHN0YXRlLnJlc29sdmVQb2xpY3kgfHwge30pO1xuICAgIHJldHVybiBpdGVtcy5tYXAoaXRlbTJSZXNvbHZhYmxlKTtcbn1cbmV4cG9ydHMucmVzb2x2YWJsZXNCdWlsZGVyID0gcmVzb2x2YWJsZXNCdWlsZGVyO1xuLyoqXG4gKiBAaW50ZXJuYWxhcGkgQSBpbnRlcm5hbCBnbG9iYWwgc2VydmljZVxuICpcbiAqIFN0YXRlQnVpbGRlciBpcyBhIGZhY3RvcnkgZm9yIHRoZSBpbnRlcm5hbCBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0cy5cbiAqXG4gKiBXaGVuIHlvdSByZWdpc3RlciBhIHN0YXRlIHdpdGggdGhlIFtbU3RhdGVSZWdpc3RyeV1dLCB5b3UgcmVnaXN0ZXIgYSBwbGFpbiBvbGQgamF2YXNjcmlwdCBvYmplY3Qgd2hpY2hcbiAqIGNvbmZvcm1zIHRvIHRoZSBbW1N0YXRlRGVjbGFyYXRpb25dXSBpbnRlcmZhY2UuICBUaGlzIGZhY3RvcnkgdGFrZXMgdGhhdCBvYmplY3QgYW5kIGJ1aWxkcyB0aGUgY29ycmVzcG9uZGluZ1xuICogW1tTdGF0ZU9iamVjdF1dIG9iamVjdCwgd2hpY2ggaGFzIGFuIEFQSSBhbmQgaXMgdXNlZCBpbnRlcm5hbGx5LlxuICpcbiAqIEN1c3RvbSBwcm9wZXJ0aWVzIG9yIEFQSSBtYXkgYmUgYWRkZWQgdG8gdGhlIGludGVybmFsIFtbU3RhdGVPYmplY3RdXSBvYmplY3QgYnkgcmVnaXN0ZXJpbmcgYSBkZWNvcmF0b3IgZnVuY3Rpb25cbiAqIHVzaW5nIHRoZSBbW2J1aWxkZXJdXSBtZXRob2QuXG4gKi9cbnZhciBTdGF0ZUJ1aWxkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGVCdWlsZGVyKG1hdGNoZXIsIHVybE1hdGNoZXJGYWN0b3J5KSB7XG4gICAgICAgIHRoaXMubWF0Y2hlciA9IG1hdGNoZXI7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHJvb3QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRjaGVyLmZpbmQoXCJcIik7IH07XG4gICAgICAgIHZhciBpc1Jvb3QgPSBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIHN0YXRlLm5hbWUgPT09IFwiXCI7IH07XG4gICAgICAgIGZ1bmN0aW9uIHBhcmVudEJ1aWxkZXIoc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChpc1Jvb3Qoc3RhdGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXIuZmluZChzZWxmLnBhcmVudE5hbWUoc3RhdGUpKSB8fCByb290KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWlsZGVycyA9IHtcbiAgICAgICAgICAgIG5hbWU6IFtuYW1lQnVpbGRlcl0sXG4gICAgICAgICAgICBzZWxmOiBbc2VsZkJ1aWxkZXJdLFxuICAgICAgICAgICAgcGFyZW50OiBbcGFyZW50QnVpbGRlcl0sXG4gICAgICAgICAgICBkYXRhOiBbZGF0YUJ1aWxkZXJdLFxuICAgICAgICAgICAgLy8gQnVpbGQgYSBVUkxNYXRjaGVyIGlmIG5lY2Vzc2FyeSwgZWl0aGVyIHZpYSBhIHJlbGF0aXZlIG9yIGFic29sdXRlIFVSTFxuICAgICAgICAgICAgdXJsOiBbZ2V0VXJsQnVpbGRlcih1cmxNYXRjaGVyRmFjdG9yeSwgcm9vdCldLFxuICAgICAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgY2xvc2VzdCBhbmNlc3RvciBzdGF0ZSB0aGF0IGhhcyBhIFVSTCAoaS5lLiBpcyBuYXZpZ2FibGUpXG4gICAgICAgICAgICBuYXZpZ2FibGU6IFtnZXROYXZpZ2FibGVCdWlsZGVyKGlzUm9vdCldLFxuICAgICAgICAgICAgcGFyYW1zOiBbZ2V0UGFyYW1zQnVpbGRlcih1cmxNYXRjaGVyRmFjdG9yeS5wYXJhbUZhY3RvcnkpXSxcbiAgICAgICAgICAgIC8vIEVhY2ggZnJhbWV3b3JrLXNwZWNpZmljIHVpLXJvdXRlciBpbXBsZW1lbnRhdGlvbiBzaG91bGQgZGVmaW5lIGl0cyBvd24gYHZpZXdzYCBidWlsZGVyXG4gICAgICAgICAgICAvLyBlLmcuLCBzcmMvbmcxL3N0YXRlYnVpbGRlcnMvdmlld3MudHNcbiAgICAgICAgICAgIHZpZXdzOiBbXSxcbiAgICAgICAgICAgIC8vIEtlZXAgYSBmdWxsIHBhdGggZnJvbSB0aGUgcm9vdCBkb3duIHRvIHRoaXMgc3RhdGUgYXMgdGhpcyBpcyBuZWVkZWQgZm9yIHN0YXRlIGFjdGl2YXRpb24uXG4gICAgICAgICAgICBwYXRoOiBbcGF0aEJ1aWxkZXJdLFxuICAgICAgICAgICAgLy8gU3BlZWQgdXAgJHN0YXRlLmluY2x1ZGVzKCkgYXMgaXQncyB1c2VkIGEgbG90XG4gICAgICAgICAgICBpbmNsdWRlczogW2luY2x1ZGVzQnVpbGRlcl0sXG4gICAgICAgICAgICByZXNvbHZhYmxlczogW3Jlc29sdmFibGVzQnVpbGRlcl1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgW1tCdWlsZGVyRnVuY3Rpb25dXSBmb3IgYSBzcGVjaWZpYyBbW1N0YXRlT2JqZWN0XV0gcHJvcGVydHkgKGUuZy4sIGBwYXJlbnRgLCBgdXJsYCwgb3IgYHBhdGhgKS5cbiAgICAgKiBNb3JlIHRoYW4gb25lIEJ1aWxkZXJGdW5jdGlvbiBjYW4gYmUgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIFRoZSBCdWlsZGVyRnVuY3Rpb24ocykgd2lsbCBiZSB1c2VkIHRvIGRlZmluZSB0aGUgcHJvcGVydHkgb24gYW55IHN1YnNlcXVlbnRseSBidWlsdCBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBTdGF0ZSBwcm9wZXJ0eSBiZWluZyByZWdpc3RlcmVkIGZvci5cbiAgICAgKiBAcGFyYW0gZm4gVGhlIEJ1aWxkZXJGdW5jdGlvbiB3aGljaCB3aWxsIGJlIHVzZWQgdG8gYnVpbGQgdGhlIFN0YXRlIHByb3BlcnR5XG4gICAgICogQHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBkZXJlZ2lzdGVycyB0aGUgQnVpbGRlckZ1bmN0aW9uXG4gICAgICovXG4gICAgU3RhdGVCdWlsZGVyLnByb3RvdHlwZS5idWlsZGVyID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgICAgIHZhciBidWlsZGVycyA9IHRoaXMuYnVpbGRlcnM7XG4gICAgICAgIHZhciBhcnJheSA9IGJ1aWxkZXJzW25hbWVdIHx8IFtdO1xuICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0OiBpZiBvbmx5IG9uZSBidWlsZGVyIGV4aXN0cywgcmV0dXJuIGl0LCBlbHNlIHJldHVybiB3aG9sZSBhcmFyeS5cbiAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc1N0cmluZyhuYW1lKSAmJiAhcHJlZGljYXRlc18xLmlzRGVmaW5lZChmbikpXG4gICAgICAgICAgICByZXR1cm4gYXJyYXkubGVuZ3RoID4gMSA/IGFycmF5IDogYXJyYXlbMF07XG4gICAgICAgIGlmICghcHJlZGljYXRlc18xLmlzU3RyaW5nKG5hbWUpIHx8ICFwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihmbikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGJ1aWxkZXJzW25hbWVdID0gYXJyYXk7XG4gICAgICAgIGJ1aWxkZXJzW25hbWVdLnB1c2goZm4pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gYnVpbGRlcnNbbmFtZV0uc3BsaWNlKGJ1aWxkZXJzW25hbWVdLmluZGV4T2YoZm4sIDEpKSAmJiBudWxsOyB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQnVpbGRzIGFsbCBvZiB0aGUgcHJvcGVydGllcyBvbiBhbiBlc3NlbnRpYWxseSBibGFuayBTdGF0ZSBvYmplY3QsIHJldHVybmluZyBhIFN0YXRlIG9iamVjdCB3aGljaCBoYXMgYWxsIGl0c1xuICAgICAqIHByb3BlcnRpZXMgYW5kIEFQSSBidWlsdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZSBhbiB1bmluaXRpYWxpemVkIFN0YXRlIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHRoZSBidWlsdCBTdGF0ZSBvYmplY3RcbiAgICAgKi9cbiAgICBTdGF0ZUJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIG1hdGNoZXIgPSBfYS5tYXRjaGVyLCBidWlsZGVycyA9IF9hLmJ1aWxkZXJzO1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROYW1lKHN0YXRlKTtcbiAgICAgICAgaWYgKHBhcmVudCAmJiAhbWF0Y2hlci5maW5kKHBhcmVudCwgdW5kZWZpbmVkLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBidWlsZGVycykge1xuICAgICAgICAgICAgaWYgKCFidWlsZGVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIGNoYWluID0gYnVpbGRlcnNba2V5XS5yZWR1Y2UoZnVuY3Rpb24gKHBhcmVudEZuLCBzdGVwKSB7IHJldHVybiBmdW5jdGlvbiAoX3N0YXRlKSB7IHJldHVybiBzdGVwKF9zdGF0ZSwgcGFyZW50Rm4pOyB9OyB9LCBjb21tb25fMS5ub29wKTtcbiAgICAgICAgICAgIHN0YXRlW2tleV0gPSBjaGFpbihzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH07XG4gICAgU3RhdGVCdWlsZGVyLnByb3RvdHlwZS5wYXJlbnROYW1lID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIC8vIG5hbWUgPSAnZm9vLmJhci5iYXouKionXG4gICAgICAgIHZhciBuYW1lID0gc3RhdGUubmFtZSB8fCBcIlwiO1xuICAgICAgICAvLyBzZWdtZW50cyA9IFsnZm9vJywgJ2JhcicsICdiYXonLCAnLioqJ11cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgICAgICAvLyBzZWdtZW50cyA9IFsnZm9vJywgJ2JhcicsICdiYXonXVxuICAgICAgICB2YXIgbGFzdFNlZ21lbnQgPSBzZWdtZW50cy5wb3AoKTtcbiAgICAgICAgLy8gc2VnbWVudHMgPSBbJ2ZvbycsICdiYXInXSAoaWdub3JlIC4qKiBzZWdtZW50IGZvciBmdXR1cmUgc3RhdGVzKVxuICAgICAgICBpZiAobGFzdFNlZ21lbnQgPT09ICcqKicpXG4gICAgICAgICAgICBzZWdtZW50cy5wb3AoKTtcbiAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXRlcyB0aGF0IHNwZWNpZnkgdGhlICdwYXJlbnQ6JyBwcm9wZXJ0eSBzaG91bGQgbm90IGhhdmUgYSAnLicgaW4gdGhlaXIgbmFtZSAoXCIgKyBuYW1lICsgXCIpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gJ2Zvby5iYXInXG4gICAgICAgICAgICByZXR1cm4gc2VnbWVudHMuam9pbihcIi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdGF0ZS5wYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc1N0cmluZyhzdGF0ZS5wYXJlbnQpID8gc3RhdGUucGFyZW50IDogc3RhdGUucGFyZW50Lm5hbWU7XG4gICAgfTtcbiAgICBTdGF0ZUJ1aWxkZXIucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBzdGF0ZS5uYW1lO1xuICAgICAgICBpZiAobmFtZS5pbmRleE9mKCcuJykgIT09IC0xIHx8ICFzdGF0ZS5wYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgdmFyIHBhcmVudE5hbWUgPSBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoc3RhdGUucGFyZW50KSA/IHN0YXRlLnBhcmVudCA6IHN0YXRlLnBhcmVudC5uYW1lO1xuICAgICAgICByZXR1cm4gcGFyZW50TmFtZSA/IHBhcmVudE5hbWUgKyBcIi5cIiArIG5hbWUgOiBuYW1lO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRlQnVpbGRlcjtcbn0oKSk7XG5leHBvcnRzLlN0YXRlQnVpbGRlciA9IFN0YXRlQnVpbGRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlQnVpbGRlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlQnVpbGRlci5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///34\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/** @module state */ /** for typedoc */\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ 1);\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar StateMatcher = /** @class */ (function () {\n    function StateMatcher(_states) {\n        this._states = _states;\n    }\n    StateMatcher.prototype.isRelative = function (stateName) {\n        stateName = stateName || "";\n        return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;\n    };\n    StateMatcher.prototype.find = function (stateOrName, base, matchGlob) {\n        if (matchGlob === void 0) { matchGlob = true; }\n        if (!stateOrName && stateOrName !== "")\n            return undefined;\n        var isStr = predicates_1.isString(stateOrName);\n        var name = isStr ? stateOrName : stateOrName.name;\n        if (this.isRelative(name))\n            name = this.resolvePath(name, base);\n        var state = this._states[name];\n        if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n            return state;\n        }\n        else if (isStr && matchGlob) {\n            var _states = common_1.values(this._states);\n            var matches = _states.filter(function (state) {\n                return state.__stateObjectCache.nameGlob &&\n                    state.__stateObjectCache.nameGlob.matches(name);\n            });\n            if (matches.length > 1) {\n                console.log("stateMatcher.find: Found multiple matches for " + name + " using glob: ", matches.map(function (match) { return match.name; }));\n            }\n            return matches[0];\n        }\n        return undefined;\n    };\n    StateMatcher.prototype.resolvePath = function (name, base) {\n        if (!base)\n            throw new Error("No reference point given for path \'" + name + "\'");\n        var baseState = this.find(base);\n        var splitName = name.split("."), i = 0, pathLength = splitName.length, current = baseState;\n        for (; i < pathLength; i++) {\n            if (splitName[i] === "" && i === 0) {\n                current = baseState;\n                continue;\n            }\n            if (splitName[i] === "^") {\n                if (!current.parent)\n                    throw new Error("Path \'" + name + "\' not valid for state \'" + baseState.name + "\'");\n                current = current.parent;\n                continue;\n            }\n            break;\n        }\n        var relName = splitName.slice(i).join(".");\n        return current.name + (current.name && relName ? "." : "") + relName;\n    };\n    return StateMatcher;\n}());\nexports.StateMatcher = StateMatcher;\n//# sourceMappingURL=stateMatcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9zdGF0ZU1hdGNoZXIuanM/NzBhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBAbW9kdWxlIHN0YXRlICovIC8qKiBmb3IgdHlwZWRvYyAqL1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIFN0YXRlTWF0Y2hlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0ZU1hdGNoZXIoX3N0YXRlcykge1xuICAgICAgICB0aGlzLl9zdGF0ZXMgPSBfc3RhdGVzO1xuICAgIH1cbiAgICBTdGF0ZU1hdGNoZXIucHJvdG90eXBlLmlzUmVsYXRpdmUgPSBmdW5jdGlvbiAoc3RhdGVOYW1lKSB7XG4gICAgICAgIHN0YXRlTmFtZSA9IHN0YXRlTmFtZSB8fCBcIlwiO1xuICAgICAgICByZXR1cm4gc3RhdGVOYW1lLmluZGV4T2YoXCIuXCIpID09PSAwIHx8IHN0YXRlTmFtZS5pbmRleE9mKFwiXlwiKSA9PT0gMDtcbiAgICB9O1xuICAgIFN0YXRlTWF0Y2hlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChzdGF0ZU9yTmFtZSwgYmFzZSwgbWF0Y2hHbG9iKSB7XG4gICAgICAgIGlmIChtYXRjaEdsb2IgPT09IHZvaWQgMCkgeyBtYXRjaEdsb2IgPSB0cnVlOyB9XG4gICAgICAgIGlmICghc3RhdGVPck5hbWUgJiYgc3RhdGVPck5hbWUgIT09IFwiXCIpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgaXNTdHIgPSBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoc3RhdGVPck5hbWUpO1xuICAgICAgICB2YXIgbmFtZSA9IGlzU3RyID8gc3RhdGVPck5hbWUgOiBzdGF0ZU9yTmFtZS5uYW1lO1xuICAgICAgICBpZiAodGhpcy5pc1JlbGF0aXZlKG5hbWUpKVxuICAgICAgICAgICAgbmFtZSA9IHRoaXMucmVzb2x2ZVBhdGgobmFtZSwgYmFzZSk7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlc1tuYW1lXTtcbiAgICAgICAgaWYgKHN0YXRlICYmIChpc1N0ciB8fCAoIWlzU3RyICYmIChzdGF0ZSA9PT0gc3RhdGVPck5hbWUgfHwgc3RhdGUuc2VsZiA9PT0gc3RhdGVPck5hbWUpKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1N0ciAmJiBtYXRjaEdsb2IpIHtcbiAgICAgICAgICAgIHZhciBfc3RhdGVzID0gY29tbW9uXzEudmFsdWVzKHRoaXMuX3N0YXRlcyk7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IF9zdGF0ZXMuZmlsdGVyKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5fX3N0YXRlT2JqZWN0Q2FjaGUubmFtZUdsb2IgJiZcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuX19zdGF0ZU9iamVjdENhY2hlLm5hbWVHbG9iLm1hdGNoZXMobmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInN0YXRlTWF0Y2hlci5maW5kOiBGb3VuZCBtdWx0aXBsZSBtYXRjaGVzIGZvciBcIiArIG5hbWUgKyBcIiB1c2luZyBnbG9iOiBcIiwgbWF0Y2hlcy5tYXAoZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBtYXRjaC5uYW1lOyB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlc1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgU3RhdGVNYXRjaGVyLnByb3RvdHlwZS5yZXNvbHZlUGF0aCA9IGZ1bmN0aW9uIChuYW1lLCBiYXNlKSB7XG4gICAgICAgIGlmICghYmFzZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlZmVyZW5jZSBwb2ludCBnaXZlbiBmb3IgcGF0aCAnXCIgKyBuYW1lICsgXCInXCIpO1xuICAgICAgICB2YXIgYmFzZVN0YXRlID0gdGhpcy5maW5kKGJhc2UpO1xuICAgICAgICB2YXIgc3BsaXROYW1lID0gbmFtZS5zcGxpdChcIi5cIiksIGkgPSAwLCBwYXRoTGVuZ3RoID0gc3BsaXROYW1lLmxlbmd0aCwgY3VycmVudCA9IGJhc2VTdGF0ZTtcbiAgICAgICAgZm9yICg7IGkgPCBwYXRoTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzcGxpdE5hbWVbaV0gPT09IFwiXCIgJiYgaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBiYXNlU3RhdGU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3BsaXROYW1lW2ldID09PSBcIl5cIikge1xuICAgICAgICAgICAgICAgIGlmICghY3VycmVudC5wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhdGggJ1wiICsgbmFtZSArIFwiJyBub3QgdmFsaWQgZm9yIHN0YXRlICdcIiArIGJhc2VTdGF0ZS5uYW1lICsgXCInXCIpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWxOYW1lID0gc3BsaXROYW1lLnNsaWNlKGkpLmpvaW4oXCIuXCIpO1xuICAgICAgICByZXR1cm4gY3VycmVudC5uYW1lICsgKGN1cnJlbnQubmFtZSAmJiByZWxOYW1lID8gXCIuXCIgOiBcIlwiKSArIHJlbE5hbWU7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVNYXRjaGVyO1xufSgpKTtcbmV4cG9ydHMuU3RhdGVNYXRjaGVyID0gU3RhdGVNYXRjaGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGVNYXRjaGVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvc3RhdGUvc3RhdGVNYXRjaGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///35\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/** @module state */ /** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ 1);\nvar stateObject_1 = __webpack_require__(/*! ./stateObject */ 24);\nvar hof_1 = __webpack_require__(/*! ../common/hof */ 2);\n/** @internalapi */\nvar StateQueueManager = /** @class */ (function () {\n    function StateQueueManager($registry, $urlRouter, states, builder, listeners) {\n        this.$registry = $registry;\n        this.$urlRouter = $urlRouter;\n        this.states = states;\n        this.builder = builder;\n        this.listeners = listeners;\n        this.queue = [];\n        this.matcher = $registry.matcher;\n    }\n    /** @internalapi */\n    StateQueueManager.prototype.dispose = function () {\n        this.queue = [];\n    };\n    StateQueueManager.prototype.register = function (stateDecl) {\n        var queue = this.queue;\n        var state = stateObject_1.StateObject.create(stateDecl);\n        var name = state.name;\n        if (!predicates_1.isString(name))\n            throw new Error("State must have a valid name");\n        if (this.states.hasOwnProperty(name) || common_1.inArray(queue.map(hof_1.prop(\'name\')), name))\n            throw new Error("State \'" + name + "\' is already defined");\n        queue.push(state);\n        this.flush();\n        return state;\n    };\n    StateQueueManager.prototype.flush = function () {\n        var _this = this;\n        var _a = this, queue = _a.queue, states = _a.states, builder = _a.builder;\n        var registered = [], // states that got registered\n        orphans = [], // states that don\'t yet have a parent registered\n        previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered\n        var getState = function (name) {\n            return _this.states.hasOwnProperty(name) && _this.states[name];\n        };\n        while (queue.length > 0) {\n            var state = queue.shift();\n            var name_1 = state.name;\n            var result = builder.build(state);\n            var orphanIdx = orphans.indexOf(state);\n            if (result) {\n                var existingState = getState(name_1);\n                if (existingState && existingState.name === name_1) {\n                    throw new Error("State \'" + name_1 + "\' is already defined");\n                }\n                var existingFutureState = getState(name_1 + ".**");\n                if (existingFutureState) {\n                    // Remove future state of the same name\n                    this.$registry.deregister(existingFutureState);\n                }\n                states[name_1] = state;\n                this.attachRoute(state);\n                if (orphanIdx >= 0)\n                    orphans.splice(orphanIdx, 1);\n                registered.push(state);\n                continue;\n            }\n            var prev = previousQueueLength[name_1];\n            previousQueueLength[name_1] = queue.length;\n            if (orphanIdx >= 0 && prev === queue.length) {\n                // Wait until two consecutive iterations where no additional states were dequeued successfully.\n                // throw new Error(`Cannot register orphaned state \'${name}\'`);\n                queue.push(state);\n                return states;\n            }\n            else if (orphanIdx < 0) {\n                orphans.push(state);\n            }\n            queue.push(state);\n        }\n        if (registered.length) {\n            this.listeners.forEach(function (listener) { return listener("registered", registered.map(function (s) { return s.self; })); });\n        }\n        return states;\n    };\n    StateQueueManager.prototype.attachRoute = function (state) {\n        if (state.abstract || !state.url)\n            return;\n        this.$urlRouter.rule(this.$urlRouter.urlRuleFactory.create(state));\n    };\n    return StateQueueManager;\n}());\nexports.StateQueueManager = StateQueueManager;\n//# sourceMappingURL=stateQueueManager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9zdGF0ZVF1ZXVlTWFuYWdlci5qcz9iMmRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgc3RhdGUgKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgc3RhdGVPYmplY3RfMSA9IHJlcXVpcmUoXCIuL3N0YXRlT2JqZWN0XCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG4vKiogQGludGVybmFsYXBpICovXG52YXIgU3RhdGVRdWV1ZU1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGVRdWV1ZU1hbmFnZXIoJHJlZ2lzdHJ5LCAkdXJsUm91dGVyLCBzdGF0ZXMsIGJ1aWxkZXIsIGxpc3RlbmVycykge1xuICAgICAgICB0aGlzLiRyZWdpc3RyeSA9ICRyZWdpc3RyeTtcbiAgICAgICAgdGhpcy4kdXJsUm91dGVyID0gJHVybFJvdXRlcjtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBzdGF0ZXM7XG4gICAgICAgIHRoaXMuYnVpbGRlciA9IGJ1aWxkZXI7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMubWF0Y2hlciA9ICRyZWdpc3RyeS5tYXRjaGVyO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsYXBpICovXG4gICAgU3RhdGVRdWV1ZU1hbmFnZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICB9O1xuICAgIFN0YXRlUXVldWVNYW5hZ2VyLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChzdGF0ZURlY2wpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gdGhpcy5xdWV1ZTtcbiAgICAgICAgdmFyIHN0YXRlID0gc3RhdGVPYmplY3RfMS5TdGF0ZU9iamVjdC5jcmVhdGUoc3RhdGVEZWNsKTtcbiAgICAgICAgdmFyIG5hbWUgPSBzdGF0ZS5uYW1lO1xuICAgICAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc1N0cmluZyhuYW1lKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXRlIG11c3QgaGF2ZSBhIHZhbGlkIG5hbWVcIik7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCBjb21tb25fMS5pbkFycmF5KHF1ZXVlLm1hcChob2ZfMS5wcm9wKCduYW1lJykpLCBuYW1lKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXRlICdcIiArIG5hbWUgKyBcIicgaXMgYWxyZWFkeSBkZWZpbmVkXCIpO1xuICAgICAgICBxdWV1ZS5wdXNoKHN0YXRlKTtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfTtcbiAgICBTdGF0ZVF1ZXVlTWFuYWdlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHF1ZXVlID0gX2EucXVldWUsIHN0YXRlcyA9IF9hLnN0YXRlcywgYnVpbGRlciA9IF9hLmJ1aWxkZXI7XG4gICAgICAgIHZhciByZWdpc3RlcmVkID0gW10sIC8vIHN0YXRlcyB0aGF0IGdvdCByZWdpc3RlcmVkXG4gICAgICAgIG9ycGhhbnMgPSBbXSwgLy8gc3RhdGVzIHRoYXQgZG9uJ3QgeWV0IGhhdmUgYSBwYXJlbnQgcmVnaXN0ZXJlZFxuICAgICAgICBwcmV2aW91c1F1ZXVlTGVuZ3RoID0ge307IC8vIGtlZXAgdHJhY2sgb2YgaG93IGxvbmcgdGhlIHF1ZXVlIHdoZW4gYW4gb3JwaGFuIHdhcyBmaXJzdCBlbmNvdW50ZXJlZFxuICAgICAgICB2YXIgZ2V0U3RhdGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnN0YXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBfdGhpcy5zdGF0ZXNbbmFtZV07XG4gICAgICAgIH07XG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgdmFyIG5hbWVfMSA9IHN0YXRlLm5hbWU7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gYnVpbGRlci5idWlsZChzdGF0ZSk7XG4gICAgICAgICAgICB2YXIgb3JwaGFuSWR4ID0gb3JwaGFucy5pbmRleE9mKHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdTdGF0ZSA9IGdldFN0YXRlKG5hbWVfMSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nU3RhdGUgJiYgZXhpc3RpbmdTdGF0ZS5uYW1lID09PSBuYW1lXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhdGUgJ1wiICsgbmFtZV8xICsgXCInIGlzIGFscmVhZHkgZGVmaW5lZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nRnV0dXJlU3RhdGUgPSBnZXRTdGF0ZShuYW1lXzEgKyBcIi4qKlwiKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdGdXR1cmVTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZnV0dXJlIHN0YXRlIG9mIHRoZSBzYW1lIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kcmVnaXN0cnkuZGVyZWdpc3RlcihleGlzdGluZ0Z1dHVyZVN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGVzW25hbWVfMV0gPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaFJvdXRlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBpZiAob3JwaGFuSWR4ID49IDApXG4gICAgICAgICAgICAgICAgICAgIG9ycGhhbnMuc3BsaWNlKG9ycGhhbklkeCwgMSk7XG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJlZC5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2ID0gcHJldmlvdXNRdWV1ZUxlbmd0aFtuYW1lXzFdO1xuICAgICAgICAgICAgcHJldmlvdXNRdWV1ZUxlbmd0aFtuYW1lXzFdID0gcXVldWUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG9ycGhhbklkeCA+PSAwICYmIHByZXYgPT09IHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIFdhaXQgdW50aWwgdHdvIGNvbnNlY3V0aXZlIGl0ZXJhdGlvbnMgd2hlcmUgbm8gYWRkaXRpb25hbCBzdGF0ZXMgd2VyZSBkZXF1ZXVlZCBzdWNjZXNzZnVsbHkuXG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVnaXN0ZXIgb3JwaGFuZWQgc3RhdGUgJyR7bmFtZX0nYCk7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaChzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9ycGhhbklkeCA8IDApIHtcbiAgICAgICAgICAgICAgICBvcnBoYW5zLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVldWUucHVzaChzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZ2lzdGVyZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gbGlzdGVuZXIoXCJyZWdpc3RlcmVkXCIsIHJlZ2lzdGVyZWQubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnNlbGY7IH0pKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlcztcbiAgICB9O1xuICAgIFN0YXRlUXVldWVNYW5hZ2VyLnByb3RvdHlwZS5hdHRhY2hSb3V0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUuYWJzdHJhY3QgfHwgIXN0YXRlLnVybClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kdXJsUm91dGVyLnJ1bGUodGhpcy4kdXJsUm91dGVyLnVybFJ1bGVGYWN0b3J5LmNyZWF0ZShzdGF0ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRlUXVldWVNYW5hZ2VyO1xufSgpKTtcbmV4cG9ydHMuU3RhdGVRdWV1ZU1hbmFnZXIgPSBTdGF0ZVF1ZXVlTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlUXVldWVNYW5hZ2VyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvc3RhdGUvc3RhdGVRdWV1ZU1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///36\n')},function(module,exports,__webpack_require__){"use strict";eval("\n/**\n * @coreapi\n * @module state\n */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar stateMatcher_1 = __webpack_require__(/*! ./stateMatcher */ 35);\nvar stateBuilder_1 = __webpack_require__(/*! ./stateBuilder */ 34);\nvar stateQueueManager_1 = __webpack_require__(/*! ./stateQueueManager */ 36);\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar hof_1 = __webpack_require__(/*! ../common/hof */ 2);\nvar StateRegistry = /** @class */ (function () {\n    /** @internalapi */\n    function StateRegistry(_router) {\n        this._router = _router;\n        this.states = {};\n        this.listeners = [];\n        this.matcher = new stateMatcher_1.StateMatcher(this.states);\n        this.builder = new stateBuilder_1.StateBuilder(this.matcher, _router.urlMatcherFactory);\n        this.stateQueue = new stateQueueManager_1.StateQueueManager(this, _router.urlRouter, this.states, this.builder, this.listeners);\n        this._registerRoot();\n    }\n    /** @internalapi */\n    StateRegistry.prototype._registerRoot = function () {\n        var rootStateDef = {\n            name: '',\n            url: '^',\n            views: null,\n            params: {\n                '#': { value: null, type: 'hash', dynamic: true }\n            },\n            abstract: true\n        };\n        var _root = this._root = this.stateQueue.register(rootStateDef);\n        _root.navigable = null;\n    };\n    /** @internalapi */\n    StateRegistry.prototype.dispose = function () {\n        var _this = this;\n        this.stateQueue.dispose();\n        this.listeners = [];\n        this.get().forEach(function (state) { return _this.get(state) && _this.deregister(state); });\n    };\n    /**\n     * Listen for a State Registry events\n     *\n     * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.\n     *\n     * #### Example:\n     * ```js\n     * let allStates = registry.get();\n     *\n     * // Later, invoke deregisterFn() to remove the listener\n     * let deregisterFn = registry.onStatesChanged((event, states) => {\n     *   switch(event) {\n     *     case: 'registered':\n     *       states.forEach(state => allStates.push(state));\n     *       break;\n     *     case: 'deregistered':\n     *       states.forEach(state => {\n     *         let idx = allStates.indexOf(state);\n     *         if (idx !== -1) allStates.splice(idx, 1);\n     *       });\n     *       break;\n     *   }\n     * });\n     * ```\n     *\n     * @param listener a callback function invoked when the registered states changes.\n     *        The function receives two parameters, `event` and `state`.\n     *        See [[StateRegistryListener]]\n     * @return a function that deregisters the listener\n     */\n    StateRegistry.prototype.onStatesChanged = function (listener) {\n        this.listeners.push(listener);\n        return function deregisterListener() {\n            common_1.removeFrom(this.listeners)(listener);\n        }.bind(this);\n    };\n    /**\n     * Gets the implicit root state\n     *\n     * Gets the root of the state tree.\n     * The root state is implicitly created by UI-Router.\n     * Note: this returns the internal [[StateObject]] representation, not a [[StateDeclaration]]\n     *\n     * @return the root [[StateObject]]\n     */\n    StateRegistry.prototype.root = function () {\n        return this._root;\n    };\n    /**\n     * Adds a state to the registry\n     *\n     * Registers a [[StateDeclaration]] or queues it for registration.\n     *\n     * Note: a state will be queued if the state's parent isn't yet registered.\n     *\n     * @param stateDefinition the definition of the state to register.\n     * @returns the internal [[StateObject]] object.\n     *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).\n     *          If the state was only queued, then the object is not fully built.\n     */\n    StateRegistry.prototype.register = function (stateDefinition) {\n        return this.stateQueue.register(stateDefinition);\n    };\n    /** @hidden */\n    StateRegistry.prototype._deregisterTree = function (state) {\n        var _this = this;\n        var all = this.get().map(function (s) { return s.$$state(); });\n        var getChildren = function (states) {\n            var children = all.filter(function (s) { return states.indexOf(s.parent) !== -1; });\n            return children.length === 0 ? children : children.concat(getChildren(children));\n        };\n        var children = getChildren([state]);\n        var deregistered = [state].concat(children).reverse();\n        deregistered.forEach(function (state) {\n            var $ur = _this._router.urlRouter;\n            // Remove URL rule\n            $ur.rules().filter(hof_1.propEq(\"state\", state)).forEach($ur.removeRule.bind($ur));\n            // Remove state from registry\n            delete _this.states[state.name];\n        });\n        return deregistered;\n    };\n    /**\n     * Removes a state from the registry\n     *\n     * This removes a state from the registry.\n     * If the state has children, they are are also removed from the registry.\n     *\n     * @param stateOrName the state's name or object representation\n     * @returns {StateObject[]} a list of removed states\n     */\n    StateRegistry.prototype.deregister = function (stateOrName) {\n        var _state = this.get(stateOrName);\n        if (!_state)\n            throw new Error(\"Can't deregister state; not found: \" + stateOrName);\n        var deregisteredStates = this._deregisterTree(_state.$$state());\n        this.listeners.forEach(function (listener) { return listener(\"deregistered\", deregisteredStates.map(function (s) { return s.self; })); });\n        return deregisteredStates;\n    };\n    StateRegistry.prototype.get = function (stateOrName, base) {\n        var _this = this;\n        if (arguments.length === 0)\n            return Object.keys(this.states).map(function (name) { return _this.states[name].self; });\n        var found = this.matcher.find(stateOrName, base);\n        return found && found.self || null;\n    };\n    StateRegistry.prototype.decorator = function (name, func) {\n        return this.builder.builder(name, func);\n    };\n    return StateRegistry;\n}());\nexports.StateRegistry = StateRegistry;\n//# sourceMappingURL=stateRegistry.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9zdGF0ZVJlZ2lzdHJ5LmpzPzI1OGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHN0YXRlXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc3RhdGVNYXRjaGVyXzEgPSByZXF1aXJlKFwiLi9zdGF0ZU1hdGNoZXJcIik7XG52YXIgc3RhdGVCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9zdGF0ZUJ1aWxkZXJcIik7XG52YXIgc3RhdGVRdWV1ZU1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL3N0YXRlUXVldWVNYW5hZ2VyXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciBTdGF0ZVJlZ2lzdHJ5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICBmdW5jdGlvbiBTdGF0ZVJlZ2lzdHJ5KF9yb3V0ZXIpIHtcbiAgICAgICAgdGhpcy5fcm91dGVyID0gX3JvdXRlcjtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5tYXRjaGVyID0gbmV3IHN0YXRlTWF0Y2hlcl8xLlN0YXRlTWF0Y2hlcih0aGlzLnN0YXRlcyk7XG4gICAgICAgIHRoaXMuYnVpbGRlciA9IG5ldyBzdGF0ZUJ1aWxkZXJfMS5TdGF0ZUJ1aWxkZXIodGhpcy5tYXRjaGVyLCBfcm91dGVyLnVybE1hdGNoZXJGYWN0b3J5KTtcbiAgICAgICAgdGhpcy5zdGF0ZVF1ZXVlID0gbmV3IHN0YXRlUXVldWVNYW5hZ2VyXzEuU3RhdGVRdWV1ZU1hbmFnZXIodGhpcywgX3JvdXRlci51cmxSb3V0ZXIsIHRoaXMuc3RhdGVzLCB0aGlzLmJ1aWxkZXIsIHRoaXMubGlzdGVuZXJzKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJSb290KCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICBTdGF0ZVJlZ2lzdHJ5LnByb3RvdHlwZS5fcmVnaXN0ZXJSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm9vdFN0YXRlRGVmID0ge1xuICAgICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgICB1cmw6ICdeJyxcbiAgICAgICAgICAgIHZpZXdzOiBudWxsLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgJyMnOiB7IHZhbHVlOiBudWxsLCB0eXBlOiAnaGFzaCcsIGR5bmFtaWM6IHRydWUgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFic3RyYWN0OiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfcm9vdCA9IHRoaXMuX3Jvb3QgPSB0aGlzLnN0YXRlUXVldWUucmVnaXN0ZXIocm9vdFN0YXRlRGVmKTtcbiAgICAgICAgX3Jvb3QubmF2aWdhYmxlID0gbnVsbDtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICBTdGF0ZVJlZ2lzdHJ5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnN0YXRlUXVldWUuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLmdldCgpLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBfdGhpcy5nZXQoc3RhdGUpICYmIF90aGlzLmRlcmVnaXN0ZXIoc3RhdGUpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExpc3RlbiBmb3IgYSBTdGF0ZSBSZWdpc3RyeSBldmVudHNcbiAgICAgKlxuICAgICAqIEFkZHMgYSBjYWxsYmFjayB0aGF0IGlzIGludm9rZWQgd2hlbiBzdGF0ZXMgYXJlIHJlZ2lzdGVyZWQgb3IgZGVyZWdpc3RlcmVkIHdpdGggdGhlIFN0YXRlUmVnaXN0cnkuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBsZXQgYWxsU3RhdGVzID0gcmVnaXN0cnkuZ2V0KCk7XG4gICAgICpcbiAgICAgKiAvLyBMYXRlciwgaW52b2tlIGRlcmVnaXN0ZXJGbigpIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXJcbiAgICAgKiBsZXQgZGVyZWdpc3RlckZuID0gcmVnaXN0cnkub25TdGF0ZXNDaGFuZ2VkKChldmVudCwgc3RhdGVzKSA9PiB7XG4gICAgICogICBzd2l0Y2goZXZlbnQpIHtcbiAgICAgKiAgICAgY2FzZTogJ3JlZ2lzdGVyZWQnOlxuICAgICAqICAgICAgIHN0YXRlcy5mb3JFYWNoKHN0YXRlID0+IGFsbFN0YXRlcy5wdXNoKHN0YXRlKSk7XG4gICAgICogICAgICAgYnJlYWs7XG4gICAgICogICAgIGNhc2U6ICdkZXJlZ2lzdGVyZWQnOlxuICAgICAqICAgICAgIHN0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICAgKiAgICAgICAgIGxldCBpZHggPSBhbGxTdGF0ZXMuaW5kZXhPZihzdGF0ZSk7XG4gICAgICogICAgICAgICBpZiAoaWR4ICE9PSAtMSkgYWxsU3RhdGVzLnNwbGljZShpZHgsIDEpO1xuICAgICAqICAgICAgIH0pO1xuICAgICAqICAgICAgIGJyZWFrO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIGEgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCB3aGVuIHRoZSByZWdpc3RlcmVkIHN0YXRlcyBjaGFuZ2VzLlxuICAgICAqICAgICAgICBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIHBhcmFtZXRlcnMsIGBldmVudGAgYW5kIGBzdGF0ZWAuXG4gICAgICogICAgICAgIFNlZSBbW1N0YXRlUmVnaXN0cnlMaXN0ZW5lcl1dXG4gICAgICogQHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgZGVyZWdpc3RlcnMgdGhlIGxpc3RlbmVyXG4gICAgICovXG4gICAgU3RhdGVSZWdpc3RyeS5wcm90b3R5cGUub25TdGF0ZXNDaGFuZ2VkID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZGVyZWdpc3Rlckxpc3RlbmVyKCkge1xuICAgICAgICAgICAgY29tbW9uXzEucmVtb3ZlRnJvbSh0aGlzLmxpc3RlbmVycykobGlzdGVuZXIpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbXBsaWNpdCByb290IHN0YXRlXG4gICAgICpcbiAgICAgKiBHZXRzIHRoZSByb290IG9mIHRoZSBzdGF0ZSB0cmVlLlxuICAgICAqIFRoZSByb290IHN0YXRlIGlzIGltcGxpY2l0bHkgY3JlYXRlZCBieSBVSS1Sb3V0ZXIuXG4gICAgICogTm90ZTogdGhpcyByZXR1cm5zIHRoZSBpbnRlcm5hbCBbW1N0YXRlT2JqZWN0XV0gcmVwcmVzZW50YXRpb24sIG5vdCBhIFtbU3RhdGVEZWNsYXJhdGlvbl1dXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoZSByb290IFtbU3RhdGVPYmplY3RdXVxuICAgICAqL1xuICAgIFN0YXRlUmVnaXN0cnkucHJvdG90eXBlLnJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHN0YXRlIHRvIHRoZSByZWdpc3RyeVxuICAgICAqXG4gICAgICogUmVnaXN0ZXJzIGEgW1tTdGF0ZURlY2xhcmF0aW9uXV0gb3IgcXVldWVzIGl0IGZvciByZWdpc3RyYXRpb24uXG4gICAgICpcbiAgICAgKiBOb3RlOiBhIHN0YXRlIHdpbGwgYmUgcXVldWVkIGlmIHRoZSBzdGF0ZSdzIHBhcmVudCBpc24ndCB5ZXQgcmVnaXN0ZXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZURlZmluaXRpb24gdGhlIGRlZmluaXRpb24gb2YgdGhlIHN0YXRlIHRvIHJlZ2lzdGVyLlxuICAgICAqIEByZXR1cm5zIHRoZSBpbnRlcm5hbCBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0LlxuICAgICAqICAgICAgICAgIElmIHRoZSBzdGF0ZSB3YXMgc3VjY2Vzc2Z1bGx5IHJlZ2lzdGVyZWQsIHRoZW4gdGhlIG9iamVjdCBpcyBmdWxseSBidWlsdCAoU2VlOiBbW1N0YXRlQnVpbGRlcl1dKS5cbiAgICAgKiAgICAgICAgICBJZiB0aGUgc3RhdGUgd2FzIG9ubHkgcXVldWVkLCB0aGVuIHRoZSBvYmplY3QgaXMgbm90IGZ1bGx5IGJ1aWx0LlxuICAgICAqL1xuICAgIFN0YXRlUmVnaXN0cnkucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHN0YXRlRGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZVF1ZXVlLnJlZ2lzdGVyKHN0YXRlRGVmaW5pdGlvbik7XG4gICAgfTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFN0YXRlUmVnaXN0cnkucHJvdG90eXBlLl9kZXJlZ2lzdGVyVHJlZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYWxsID0gdGhpcy5nZXQoKS5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMuJCRzdGF0ZSgpOyB9KTtcbiAgICAgICAgdmFyIGdldENoaWxkcmVuID0gZnVuY3Rpb24gKHN0YXRlcykge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gYWxsLmZpbHRlcihmdW5jdGlvbiAocykgeyByZXR1cm4gc3RhdGVzLmluZGV4T2Yocy5wYXJlbnQpICE9PSAtMTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRyZW4ubGVuZ3RoID09PSAwID8gY2hpbGRyZW4gOiBjaGlsZHJlbi5jb25jYXQoZ2V0Q2hpbGRyZW4oY2hpbGRyZW4pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oW3N0YXRlXSk7XG4gICAgICAgIHZhciBkZXJlZ2lzdGVyZWQgPSBbc3RhdGVdLmNvbmNhdChjaGlsZHJlbikucmV2ZXJzZSgpO1xuICAgICAgICBkZXJlZ2lzdGVyZWQuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciAkdXIgPSBfdGhpcy5fcm91dGVyLnVybFJvdXRlcjtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBVUkwgcnVsZVxuICAgICAgICAgICAgJHVyLnJ1bGVzKCkuZmlsdGVyKGhvZl8xLnByb3BFcShcInN0YXRlXCIsIHN0YXRlKSkuZm9yRWFjaCgkdXIucmVtb3ZlUnVsZS5iaW5kKCR1cikpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHN0YXRlIGZyb20gcmVnaXN0cnlcbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5zdGF0ZXNbc3RhdGUubmFtZV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVyZWdpc3RlcmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHN0YXRlIGZyb20gdGhlIHJlZ2lzdHJ5XG4gICAgICpcbiAgICAgKiBUaGlzIHJlbW92ZXMgYSBzdGF0ZSBmcm9tIHRoZSByZWdpc3RyeS5cbiAgICAgKiBJZiB0aGUgc3RhdGUgaGFzIGNoaWxkcmVuLCB0aGV5IGFyZSBhcmUgYWxzbyByZW1vdmVkIGZyb20gdGhlIHJlZ2lzdHJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlT3JOYW1lIHRoZSBzdGF0ZSdzIG5hbWUgb3Igb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAgICogQHJldHVybnMge1N0YXRlT2JqZWN0W119IGEgbGlzdCBvZiByZW1vdmVkIHN0YXRlc1xuICAgICAqL1xuICAgIFN0YXRlUmVnaXN0cnkucHJvdG90eXBlLmRlcmVnaXN0ZXIgPSBmdW5jdGlvbiAoc3RhdGVPck5hbWUpIHtcbiAgICAgICAgdmFyIF9zdGF0ZSA9IHRoaXMuZ2V0KHN0YXRlT3JOYW1lKTtcbiAgICAgICAgaWYgKCFfc3RhdGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBkZXJlZ2lzdGVyIHN0YXRlOyBub3QgZm91bmQ6IFwiICsgc3RhdGVPck5hbWUpO1xuICAgICAgICB2YXIgZGVyZWdpc3RlcmVkU3RhdGVzID0gdGhpcy5fZGVyZWdpc3RlclRyZWUoX3N0YXRlLiQkc3RhdGUoKSk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBsaXN0ZW5lcihcImRlcmVnaXN0ZXJlZFwiLCBkZXJlZ2lzdGVyZWRTdGF0ZXMubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnNlbGY7IH0pKTsgfSk7XG4gICAgICAgIHJldHVybiBkZXJlZ2lzdGVyZWRTdGF0ZXM7XG4gICAgfTtcbiAgICBTdGF0ZVJlZ2lzdHJ5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoc3RhdGVPck5hbWUsIGJhc2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zdGF0ZXMpLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gX3RoaXMuc3RhdGVzW25hbWVdLnNlbGY7IH0pO1xuICAgICAgICB2YXIgZm91bmQgPSB0aGlzLm1hdGNoZXIuZmluZChzdGF0ZU9yTmFtZSwgYmFzZSk7XG4gICAgICAgIHJldHVybiBmb3VuZCAmJiBmb3VuZC5zZWxmIHx8IG51bGw7XG4gICAgfTtcbiAgICBTdGF0ZVJlZ2lzdHJ5LnByb3RvdHlwZS5kZWNvcmF0b3IgPSBmdW5jdGlvbiAobmFtZSwgZnVuYykge1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZGVyLmJ1aWxkZXIobmFtZSwgZnVuYyk7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVSZWdpc3RyeTtcbn0oKSk7XG5leHBvcnRzLlN0YXRlUmVnaXN0cnkgPSBTdGF0ZVJlZ2lzdHJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGVSZWdpc3RyeS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlUmVnaXN0cnkuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///37\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module state\n */\n/** */\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ 1);\nvar queue_1 = __webpack_require__(/*! ../common/queue */ 21);\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ 3);\nvar pathFactory_1 = __webpack_require__(/*! ../path/pathFactory */ 16);\nvar pathNode_1 = __webpack_require__(/*! ../path/pathNode */ 23);\nvar transitionService_1 = __webpack_require__(/*! ../transition/transitionService */ 26);\nvar rejectFactory_1 = __webpack_require__(/*! ../transition/rejectFactory */ 12);\nvar targetState_1 = __webpack_require__(/*! ./targetState */ 9);\nvar param_1 = __webpack_require__(/*! ../params/param */ 8);\nvar glob_1 = __webpack_require__(/*! ../common/glob */ 15);\nvar resolveContext_1 = __webpack_require__(/*! ../resolve/resolveContext */ 17);\nvar lazyLoad_1 = __webpack_require__(/*! ../hooks/lazyLoad */ 29);\nvar hof_1 = __webpack_require__(/*! ../common/hof */ 2);\n/**\n * Provides state related service functions\n *\n * This class provides services related to ui-router states.\n * An instance of this class is located on the global [[UIRouter]] object.\n */\nvar StateService = /** @class */ (function () {\n    /** @internalapi */\n    function StateService(router) {\n        this.router = router;\n        /** @internalapi */\n        this.invalidCallbacks = [];\n        /** @hidden */\n        this._defaultErrorHandler = function $defaultErrorHandler($error$) {\n            if ($error$ instanceof Error && $error$.stack) {\n                console.error($error$);\n                console.error($error$.stack);\n            }\n            else if ($error$ instanceof rejectFactory_1.Rejection) {\n                console.error($error$.toString());\n                if ($error$.detail && $error$.detail.stack)\n                    console.error($error$.detail.stack);\n            }\n            else {\n                console.error($error$);\n            }\n        };\n        var getters = ['current', '$current', 'params', 'transition'];\n        var boundFns = Object.keys(StateService.prototype).filter(hof_1.not(common_1.inArray(getters)));\n        common_1.createProxyFunctions(hof_1.val(StateService.prototype), this, hof_1.val(this), boundFns);\n    }\n    Object.defineProperty(StateService.prototype, \"transition\", {\n        /**\n         * The [[Transition]] currently in progress (or null)\n         *\n         * This is a passthrough through to [[UIRouterGlobals.transition]]\n         */\n        get: function () { return this.router.globals.transition; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"params\", {\n        /**\n         * The latest successful state parameters\n         *\n         * This is a passthrough through to [[UIRouterGlobals.params]]\n         */\n        get: function () { return this.router.globals.params; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"current\", {\n        /**\n         * The current [[StateDeclaration]]\n         *\n         * This is a passthrough through to [[UIRouterGlobals.current]]\n         */\n        get: function () { return this.router.globals.current; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"$current\", {\n        /**\n         * The current [[StateObject]]\n         *\n         * This is a passthrough through to [[UIRouterGlobals.$current]]\n         */\n        get: function () { return this.router.globals.$current; },\n        enumerable: true,\n        configurable: true\n    });\n    /** @internalapi */\n    StateService.prototype.dispose = function () {\n        this.defaultErrorHandler(common_1.noop);\n        this.invalidCallbacks = [];\n    };\n    /**\n     * Handler for when [[transitionTo]] is called with an invalid state.\n     *\n     * Invokes the [[onInvalid]] callbacks, in natural order.\n     * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.\n     * The results of the callbacks are wrapped in $q.when(), so the callbacks may return promises.\n     *\n     * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.\n     *\n     * @internalapi\n     */\n    StateService.prototype._handleInvalidTargetState = function (fromPath, toState) {\n        var _this = this;\n        var fromState = pathFactory_1.PathUtils.makeTargetState(this.router.stateRegistry, fromPath);\n        var globals = this.router.globals;\n        var latestThing = function () { return globals.transitionHistory.peekTail(); };\n        var latest = latestThing();\n        var callbackQueue = new queue_1.Queue(this.invalidCallbacks.slice());\n        var injector = new resolveContext_1.ResolveContext(fromPath).injector();\n        var checkForRedirect = function (result) {\n            if (!(result instanceof targetState_1.TargetState)) {\n                return;\n            }\n            var target = result;\n            // Recreate the TargetState, in case the state is now defined.\n            target = _this.target(target.identifier(), target.params(), target.options());\n            if (!target.valid()) {\n                return rejectFactory_1.Rejection.invalid(target.error()).toPromise();\n            }\n            if (latestThing() !== latest) {\n                return rejectFactory_1.Rejection.superseded().toPromise();\n            }\n            return _this.transitionTo(target.identifier(), target.params(), target.options());\n        };\n        function invokeNextCallback() {\n            var nextCallback = callbackQueue.dequeue();\n            if (nextCallback === undefined)\n                return rejectFactory_1.Rejection.invalid(toState.error()).toPromise();\n            var callbackResult = coreservices_1.services.$q.when(nextCallback(toState, fromState, injector));\n            return callbackResult.then(checkForRedirect).then(function (result) { return result || invokeNextCallback(); });\n        }\n        return invokeNextCallback();\n    };\n    /**\n     * Registers an Invalid State handler\n     *\n     * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]\n     * has been called with an invalid state reference parameter\n     *\n     * Example:\n     * ```js\n     * stateService.onInvalid(function(to, from, injector) {\n     *   if (to.name() === 'foo') {\n     *     let lazyLoader = injector.get('LazyLoadService');\n     *     return lazyLoader.load('foo')\n     *         .then(() => stateService.target('foo'));\n     *   }\n     * });\n     * ```\n     *\n     * @param {function} callback invoked when the toState is invalid\n     *   This function receives the (invalid) toState, the fromState, and an injector.\n     *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.\n     *   If one is returned, it is treated as a redirect.\n     *\n     * @returns a function which deregisters the callback\n     */\n    StateService.prototype.onInvalid = function (callback) {\n        this.invalidCallbacks.push(callback);\n        return function deregisterListener() {\n            common_1.removeFrom(this.invalidCallbacks)(callback);\n        }.bind(this);\n    };\n    /**\n     * Reloads the current state\n     *\n     * A method that force reloads the current state, or a partial state hierarchy.\n     * All resolves are re-resolved, and components reinstantiated.\n     *\n     * #### Example:\n     * ```js\n     * let app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * ```\n     *\n     * Note: `reload()` is just an alias for:\n     *\n     * ```js\n     * $state.transitionTo($state.current, $state.params, {\n     *   reload: true, inherit: false\n     * });\n     * ```\n     *\n     * @param reloadState A state name or a state object.\n     *    If present, this state and all its children will be reloaded, but ancestors will not reload.\n     *\n     * #### Example:\n     * ```js\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'\n     * //and current state is 'contacts.detail.item'\n     * let app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and nested 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * ```\n     *\n     * @returns A promise representing the state of the new transition. See [[StateService.go]]\n     */\n    StateService.prototype.reload = function (reloadState) {\n        return this.transitionTo(this.current, this.params, {\n            reload: predicates_1.isDefined(reloadState) ? reloadState : true,\n            inherit: false,\n            notify: false,\n        });\n    };\n    ;\n    /**\n     * Transition to a different state and/or parameters\n     *\n     * Convenience method for transitioning to a new state.\n     *\n     * `$state.go` calls `$state.transitionTo` internally but automatically sets options to\n     * `{ location: true, inherit: true, relative: router.globals.$current, notify: true }`.\n     * This allows you to use either an absolute or relative `to` argument (because of `relative: router.globals.$current`).\n     * It also allows you to specify * only the parameters you'd like to update, while letting unspecified parameters\n     * inherit from the current parameter values (because of `inherit: true`).\n     *\n     * #### Example:\n     * ```js\n     * let app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * ```\n     *\n     * @param to Absolute state name, state object, or relative state path (relative to current state).\n     *\n     * Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to the parent state\n     * - `$state.go('^.sibling')` - if current state is `home.child`, will go to the `home.sibling` state\n     * - `$state.go('.child.grandchild')` - if current state is home, will go to the `home.child.grandchild` state\n     *\n     * @param params A map of the parameters that will be sent to the state, will populate $stateParams.\n     *\n     *    Any parameters that are not specified will be inherited from current parameter values (because of `inherit: true`).\n     *    This allows, for example, going to a sibling state that shares parameters defined by a parent state.\n     *\n     * @param options Transition options\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     */\n    StateService.prototype.go = function (to, params, options) {\n        var defautGoOpts = { relative: this.$current, inherit: true };\n        var transOpts = common_1.defaults(options, defautGoOpts, transitionService_1.defaultTransOpts);\n        return this.transitionTo(to, params, transOpts);\n    };\n    ;\n    /**\n     * Creates a [[TargetState]]\n     *\n     * This is a factory method for creating a TargetState\n     *\n     * This may be returned from a Transition Hook to redirect a transition, for example.\n     */\n    StateService.prototype.target = function (identifier, params, options) {\n        if (options === void 0) { options = {}; }\n        // If we're reloading, find the state object to reload from\n        if (predicates_1.isObject(options.reload) && !options.reload.name)\n            throw new Error('Invalid reload state object');\n        var reg = this.router.stateRegistry;\n        options.reloadState = options.reload === true ? reg.root() : reg.matcher.find(options.reload, options.relative);\n        if (options.reload && !options.reloadState)\n            throw new Error(\"No such reload state '\" + (predicates_1.isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        return new targetState_1.TargetState(this.router.stateRegistry, identifier, params, options);\n    };\n    ;\n    StateService.prototype.getCurrentPath = function () {\n        var _this = this;\n        var globals = this.router.globals;\n        var latestSuccess = globals.successfulTransitions.peekTail();\n        var rootPath = function () { return [new pathNode_1.PathNode(_this.router.stateRegistry.root())]; };\n        return latestSuccess ? latestSuccess.treeChanges().to : rootPath();\n    };\n    /**\n     * Low-level method for transitioning to a new state.\n     *\n     * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.\n     *\n     * #### Example:\n     * ```js\n     * let app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * ```\n     *\n     * @param to State name or state object.\n     * @param toParams A map of the parameters that will be sent to the state,\n     *      will populate $stateParams.\n     * @param options Transition options\n     *\n     * @returns A promise representing the state of the new transition. See [[go]]\n     */\n    StateService.prototype.transitionTo = function (to, toParams, options) {\n        var _this = this;\n        if (toParams === void 0) { toParams = {}; }\n        if (options === void 0) { options = {}; }\n        var router = this.router;\n        var globals = router.globals;\n        options = common_1.defaults(options, transitionService_1.defaultTransOpts);\n        var getCurrent = function () {\n            return globals.transition;\n        };\n        options = common_1.extend(options, { current: getCurrent });\n        var ref = this.target(to, toParams, options);\n        var currentPath = this.getCurrentPath();\n        if (!ref.exists())\n            return this._handleInvalidTargetState(currentPath, ref);\n        if (!ref.valid())\n            return common_1.silentRejection(ref.error());\n        /**\n         * Special handling for Ignored, Aborted, and Redirected transitions\n         *\n         * The semantics for the transition.run() promise and the StateService.transitionTo()\n         * promise differ. For instance, the run() promise may be rejected because it was\n         * IGNORED, but the transitionTo() promise is resolved because from the user perspective\n         * no error occurred.  Likewise, the transition.run() promise may be rejected because of\n         * a Redirect, but the transitionTo() promise is chained to the new Transition's promise.\n         */\n        var rejectedTransitionHandler = function (transition) { return function (error) {\n            if (error instanceof rejectFactory_1.Rejection) {\n                var isLatest = router.globals.lastStartedTransitionId === transition.$id;\n                if (error.type === rejectFactory_1.RejectType.IGNORED) {\n                    isLatest && router.urlRouter.update();\n                    // Consider ignored `Transition.run()` as a successful `transitionTo`\n                    return coreservices_1.services.$q.when(globals.current);\n                }\n                var detail = error.detail;\n                if (error.type === rejectFactory_1.RejectType.SUPERSEDED && error.redirected && detail instanceof targetState_1.TargetState) {\n                    // If `Transition.run()` was redirected, allow the `transitionTo()` promise to resolve successfully\n                    // by returning the promise for the new (redirect) `Transition.run()`.\n                    var redirect = transition.redirect(detail);\n                    return redirect.run().catch(rejectedTransitionHandler(redirect));\n                }\n                if (error.type === rejectFactory_1.RejectType.ABORTED) {\n                    isLatest && router.urlRouter.update();\n                    return coreservices_1.services.$q.reject(error);\n                }\n            }\n            var errorHandler = _this.defaultErrorHandler();\n            errorHandler(error);\n            return coreservices_1.services.$q.reject(error);\n        }; };\n        var transition = this.router.transitionService.create(currentPath, ref);\n        var transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));\n        common_1.silenceUncaughtInPromise(transitionToPromise); // issue #2676\n        // Return a promise for the transition, which also has the transition object on it.\n        return common_1.extend(transitionToPromise, { transition: transition });\n    };\n    ;\n    /**\n     * Checks if the current state *is* the provided state\n     *\n     * Similar to [[includes]] but only checks for the full state name.\n     * If params is supplied then it will be tested for strict equality against the current\n     * active params object, so all params must match with none missing and no extras.\n     *\n     * #### Example:\n     * ```js\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     * ```\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * ```html\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * ```\n     *\n     * @param stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param options An options object. The options are:\n     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     *     test relative to `options.relative` state (or name).\n     *\n     * @returns Returns true if it is the state.\n     */\n    StateService.prototype.is = function (stateOrName, params, options) {\n        options = common_1.defaults(options, { relative: this.$current });\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n        if (!predicates_1.isDefined(state))\n            return undefined;\n        if (this.$current !== state)\n            return false;\n        if (!params)\n            return true;\n        var schema = state.parameters({ inherit: true, matchingKeys: params });\n        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n    };\n    ;\n    /**\n     * Checks if the current state *includes* the provided state\n     *\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * #### Example when `$state.$current.name === 'contacts.details.item'`\n     * ```js\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     * ```\n     *\n     * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:\n     * ```js\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * ```\n     *\n     * @param stateOrName A partial name, relative name, glob pattern,\n     *   or state object to be searched for within the current state name.\n     * @param params A param object, e.g. `{sectionId: section.id}`,\n     *   that you'd like to test against the current active state.\n     * @param options An options object. The options are:\n     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     *     test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    StateService.prototype.includes = function (stateOrName, params, options) {\n        options = common_1.defaults(options, { relative: this.$current });\n        var glob = predicates_1.isString(stateOrName) && glob_1.Glob.fromString(stateOrName);\n        if (glob) {\n            if (!glob.matches(this.$current.name))\n                return false;\n            stateOrName = this.$current.name;\n        }\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative), include = this.$current.includes;\n        if (!predicates_1.isDefined(state))\n            return undefined;\n        if (!predicates_1.isDefined(include[state.name]))\n            return false;\n        if (!params)\n            return true;\n        var schema = state.parameters({ inherit: true, matchingKeys: params });\n        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n    };\n    ;\n    /**\n     * Generates a URL for a state and parameters\n     *\n     * Returns the url for the given state populated with the given params.\n     *\n     * #### Example:\n     * ```js\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * ```\n     *\n     * @param stateOrName The state name or state object you'd like to generate a url from.\n     * @param params An object of parameter values to fill the state's required parameters.\n     * @param options Options object. The options are:\n     *\n     * @returns {string} compiled state url\n     */\n    StateService.prototype.href = function (stateOrName, params, options) {\n        var defaultHrefOpts = {\n            lossy: true,\n            inherit: true,\n            absolute: false,\n            relative: this.$current,\n        };\n        options = common_1.defaults(options, defaultHrefOpts);\n        params = params || {};\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n        if (!predicates_1.isDefined(state))\n            return null;\n        if (options.inherit)\n            params = this.params.$inherit(params, this.$current, state);\n        var nav = (state && options.lossy) ? state.navigable : state;\n        if (!nav || nav.url === undefined || nav.url === null) {\n            return null;\n        }\n        return this.router.urlRouter.href(nav.url, params, {\n            absolute: options.absolute,\n        });\n    };\n    ;\n    /**\n     * Sets or gets the default [[transitionTo]] error handler.\n     *\n     * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.\n     * This includes errors caused by resolves and transition hooks.\n     *\n     * Note:\n     * This handler does not receive certain Transition rejections.\n     * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].\n     *\n     * The built-in default error handler logs the error to the console.\n     *\n     * You can provide your own custom handler.\n     *\n     * #### Example:\n     * ```js\n     * stateService.defaultErrorHandler(function() {\n     *   // Do not log transitionTo errors\n     * });\n     * ```\n     *\n     * @param handler a global error handler function\n     * @returns the current global error handler\n     */\n    StateService.prototype.defaultErrorHandler = function (handler) {\n        return this._defaultErrorHandler = handler || this._defaultErrorHandler;\n    };\n    StateService.prototype.get = function (stateOrName, base) {\n        var reg = this.router.stateRegistry;\n        if (arguments.length === 0)\n            return reg.get();\n        return reg.get(stateOrName, base || this.$current);\n    };\n    /**\n     * Lazy loads a state\n     *\n     * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.\n     *\n     * @param stateOrName the state that should be lazy loaded\n     * @param transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)\n     * Note: If no transition is provided, a noop transition is created using the from the current state to the current state.\n     * This noop transition is not actually run.\n     *\n     * @returns a promise to lazy load\n     */\n    StateService.prototype.lazyLoad = function (stateOrName, transition) {\n        var state = this.get(stateOrName);\n        if (!state || !state.lazyLoad)\n            throw new Error(\"Can not lazy load \" + stateOrName);\n        var currentPath = this.getCurrentPath();\n        var target = pathFactory_1.PathUtils.makeTargetState(this.router.stateRegistry, currentPath);\n        transition = transition || this.router.transitionService.create(currentPath, target);\n        return lazyLoad_1.lazyLoadState(transition, state);\n    };\n    return StateService;\n}());\nexports.StateService = StateService;\n//# sourceMappingURL=stateService.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9zdGF0ZVNlcnZpY2UuanM/ZTYyYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgc3RhdGVcbiAqL1xuLyoqICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgcXVldWVfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcXVldWVcIik7XG52YXIgY29yZXNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvcmVzZXJ2aWNlc1wiKTtcbnZhciBwYXRoRmFjdG9yeV8xID0gcmVxdWlyZShcIi4uL3BhdGgvcGF0aEZhY3RvcnlcIik7XG52YXIgcGF0aE5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wYXRoL3BhdGhOb2RlXCIpO1xudmFyIHRyYW5zaXRpb25TZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uU2VydmljZVwiKTtcbnZhciByZWplY3RGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi4vdHJhbnNpdGlvbi9yZWplY3RGYWN0b3J5XCIpO1xudmFyIHRhcmdldFN0YXRlXzEgPSByZXF1aXJlKFwiLi90YXJnZXRTdGF0ZVwiKTtcbnZhciBwYXJhbV8xID0gcmVxdWlyZShcIi4uL3BhcmFtcy9wYXJhbVwiKTtcbnZhciBnbG9iXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2dsb2JcIik7XG52YXIgcmVzb2x2ZUNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9yZXNvbHZlL3Jlc29sdmVDb250ZXh0XCIpO1xudmFyIGxhenlMb2FkXzEgPSByZXF1aXJlKFwiLi4vaG9va3MvbGF6eUxvYWRcIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbi8qKlxuICogUHJvdmlkZXMgc3RhdGUgcmVsYXRlZCBzZXJ2aWNlIGZ1bmN0aW9uc1xuICpcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgc2VydmljZXMgcmVsYXRlZCB0byB1aS1yb3V0ZXIgc3RhdGVzLlxuICogQW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBpcyBsb2NhdGVkIG9uIHRoZSBnbG9iYWwgW1tVSVJvdXRlcl1dIG9iamVjdC5cbiAqL1xudmFyIFN0YXRlU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQGludGVybmFsYXBpICovXG4gICAgZnVuY3Rpb24gU3RhdGVTZXJ2aWNlKHJvdXRlcikge1xuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgICAgICB0aGlzLmludmFsaWRDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgdGhpcy5fZGVmYXVsdEVycm9ySGFuZGxlciA9IGZ1bmN0aW9uICRkZWZhdWx0RXJyb3JIYW5kbGVyKCRlcnJvciQpIHtcbiAgICAgICAgICAgIGlmICgkZXJyb3IkIGluc3RhbmNlb2YgRXJyb3IgJiYgJGVycm9yJC5zdGFjaykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJGVycm9yJCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigkZXJyb3IkLnN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCRlcnJvciQgaW5zdGFuY2VvZiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigkZXJyb3IkLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGlmICgkZXJyb3IkLmRldGFpbCAmJiAkZXJyb3IkLmRldGFpbC5zdGFjaylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigkZXJyb3IkLmRldGFpbC5zdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCRlcnJvciQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZ2V0dGVycyA9IFsnY3VycmVudCcsICckY3VycmVudCcsICdwYXJhbXMnLCAndHJhbnNpdGlvbiddO1xuICAgICAgICB2YXIgYm91bmRGbnMgPSBPYmplY3Qua2V5cyhTdGF0ZVNlcnZpY2UucHJvdG90eXBlKS5maWx0ZXIoaG9mXzEubm90KGNvbW1vbl8xLmluQXJyYXkoZ2V0dGVycykpKTtcbiAgICAgICAgY29tbW9uXzEuY3JlYXRlUHJveHlGdW5jdGlvbnMoaG9mXzEudmFsKFN0YXRlU2VydmljZS5wcm90b3R5cGUpLCB0aGlzLCBob2ZfMS52YWwodGhpcyksIGJvdW5kRm5zKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YXRlU2VydmljZS5wcm90b3R5cGUsIFwidHJhbnNpdGlvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgW1tUcmFuc2l0aW9uXV0gY3VycmVudGx5IGluIHByb2dyZXNzIChvciBudWxsKVxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIGEgcGFzc3Rocm91Z2ggdGhyb3VnaCB0byBbW1VJUm91dGVyR2xvYmFscy50cmFuc2l0aW9uXV1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5yb3V0ZXIuZ2xvYmFscy50cmFuc2l0aW9uOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhdGVTZXJ2aWNlLnByb3RvdHlwZSwgXCJwYXJhbXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxhdGVzdCBzdWNjZXNzZnVsIHN0YXRlIHBhcmFtZXRlcnNcbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyBhIHBhc3N0aHJvdWdoIHRocm91Z2ggdG8gW1tVSVJvdXRlckdsb2JhbHMucGFyYW1zXV1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5yb3V0ZXIuZ2xvYmFscy5wYXJhbXM7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0ZVNlcnZpY2UucHJvdG90eXBlLCBcImN1cnJlbnRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgW1tTdGF0ZURlY2xhcmF0aW9uXV1cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyBhIHBhc3N0aHJvdWdoIHRocm91Z2ggdG8gW1tVSVJvdXRlckdsb2JhbHMuY3VycmVudF1dXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucm91dGVyLmdsb2JhbHMuY3VycmVudDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YXRlU2VydmljZS5wcm90b3R5cGUsIFwiJGN1cnJlbnRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgW1tTdGF0ZU9iamVjdF1dXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgYSBwYXNzdGhyb3VnaCB0aHJvdWdoIHRvIFtbVUlSb3V0ZXJHbG9iYWxzLiRjdXJyZW50XV1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5yb3V0ZXIuZ2xvYmFscy4kY3VycmVudDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0RXJyb3JIYW5kbGVyKGNvbW1vbl8xLm5vb3ApO1xuICAgICAgICB0aGlzLmludmFsaWRDYWxsYmFja3MgPSBbXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yIHdoZW4gW1t0cmFuc2l0aW9uVG9dXSBpcyBjYWxsZWQgd2l0aCBhbiBpbnZhbGlkIHN0YXRlLlxuICAgICAqXG4gICAgICogSW52b2tlcyB0aGUgW1tvbkludmFsaWRdXSBjYWxsYmFja3MsIGluIG5hdHVyYWwgb3JkZXIuXG4gICAgICogRWFjaCBjYWxsYmFjaydzIHJldHVybiB2YWx1ZSBpcyBjaGVja2VkIGluIHNlcXVlbmNlIHVudGlsIG9uZSBvZiB0aGVtIHJldHVybnMgYW4gaW5zdGFuY2Ugb2YgVGFyZ2V0U3RhdGUuXG4gICAgICogVGhlIHJlc3VsdHMgb2YgdGhlIGNhbGxiYWNrcyBhcmUgd3JhcHBlZCBpbiAkcS53aGVuKCksIHNvIHRoZSBjYWxsYmFja3MgbWF5IHJldHVybiBwcm9taXNlcy5cbiAgICAgKlxuICAgICAqIElmIGEgY2FsbGJhY2sgcmV0dXJucyBhbiBUYXJnZXRTdGF0ZSwgdGhlbiBpdCBpcyB1c2VkIGFzIGFyZ3VtZW50cyB0byAkc3RhdGUudHJhbnNpdGlvblRvKCkgYW5kIHRoZSByZXN1bHQgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxhcGlcbiAgICAgKi9cbiAgICBTdGF0ZVNlcnZpY2UucHJvdG90eXBlLl9oYW5kbGVJbnZhbGlkVGFyZ2V0U3RhdGUgPSBmdW5jdGlvbiAoZnJvbVBhdGgsIHRvU3RhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGZyb21TdGF0ZSA9IHBhdGhGYWN0b3J5XzEuUGF0aFV0aWxzLm1ha2VUYXJnZXRTdGF0ZSh0aGlzLnJvdXRlci5zdGF0ZVJlZ2lzdHJ5LCBmcm9tUGF0aCk7XG4gICAgICAgIHZhciBnbG9iYWxzID0gdGhpcy5yb3V0ZXIuZ2xvYmFscztcbiAgICAgICAgdmFyIGxhdGVzdFRoaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2xvYmFscy50cmFuc2l0aW9uSGlzdG9yeS5wZWVrVGFpbCgpOyB9O1xuICAgICAgICB2YXIgbGF0ZXN0ID0gbGF0ZXN0VGhpbmcoKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrUXVldWUgPSBuZXcgcXVldWVfMS5RdWV1ZSh0aGlzLmludmFsaWRDYWxsYmFja3Muc2xpY2UoKSk7XG4gICAgICAgIHZhciBpbmplY3RvciA9IG5ldyByZXNvbHZlQ29udGV4dF8xLlJlc29sdmVDb250ZXh0KGZyb21QYXRoKS5pbmplY3RvcigpO1xuICAgICAgICB2YXIgY2hlY2tGb3JSZWRpcmVjdCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICghKHJlc3VsdCBpbnN0YW5jZW9mIHRhcmdldFN0YXRlXzEuVGFyZ2V0U3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHJlc3VsdDtcbiAgICAgICAgICAgIC8vIFJlY3JlYXRlIHRoZSBUYXJnZXRTdGF0ZSwgaW4gY2FzZSB0aGUgc3RhdGUgaXMgbm93IGRlZmluZWQuXG4gICAgICAgICAgICB0YXJnZXQgPSBfdGhpcy50YXJnZXQodGFyZ2V0LmlkZW50aWZpZXIoKSwgdGFyZ2V0LnBhcmFtcygpLCB0YXJnZXQub3B0aW9ucygpKTtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0LnZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0RmFjdG9yeV8xLlJlamVjdGlvbi5pbnZhbGlkKHRhcmdldC5lcnJvcigpKS50b1Byb21pc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXRlc3RUaGluZygpICE9PSBsYXRlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0RmFjdG9yeV8xLlJlamVjdGlvbi5zdXBlcnNlZGVkKCkudG9Qcm9taXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNpdGlvblRvKHRhcmdldC5pZGVudGlmaWVyKCksIHRhcmdldC5wYXJhbXMoKSwgdGFyZ2V0Lm9wdGlvbnMoKSk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIGludm9rZU5leHRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIHZhciBuZXh0Q2FsbGJhY2sgPSBjYWxsYmFja1F1ZXVlLmRlcXVldWUoKTtcbiAgICAgICAgICAgIGlmIChuZXh0Q2FsbGJhY2sgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0RmFjdG9yeV8xLlJlamVjdGlvbi5pbnZhbGlkKHRvU3RhdGUuZXJyb3IoKSkudG9Qcm9taXNlKCk7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2tSZXN1bHQgPSBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS53aGVuKG5leHRDYWxsYmFjayh0b1N0YXRlLCBmcm9tU3RhdGUsIGluamVjdG9yKSk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2tSZXN1bHQudGhlbihjaGVja0ZvclJlZGlyZWN0KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdCB8fCBpbnZva2VOZXh0Q2FsbGJhY2soKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludm9rZU5leHRDYWxsYmFjaygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGFuIEludmFsaWQgU3RhdGUgaGFuZGxlclxuICAgICAqXG4gICAgICogUmVnaXN0ZXJzIGEgW1tPbkludmFsaWRDYWxsYmFja11dIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbiBbW1N0YXRlU2VydmljZS50cmFuc2l0aW9uVG9dXVxuICAgICAqIGhhcyBiZWVuIGNhbGxlZCB3aXRoIGFuIGludmFsaWQgc3RhdGUgcmVmZXJlbmNlIHBhcmFtZXRlclxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIHN0YXRlU2VydmljZS5vbkludmFsaWQoZnVuY3Rpb24odG8sIGZyb20sIGluamVjdG9yKSB7XG4gICAgICogICBpZiAodG8ubmFtZSgpID09PSAnZm9vJykge1xuICAgICAqICAgICBsZXQgbGF6eUxvYWRlciA9IGluamVjdG9yLmdldCgnTGF6eUxvYWRTZXJ2aWNlJyk7XG4gICAgICogICAgIHJldHVybiBsYXp5TG9hZGVyLmxvYWQoJ2ZvbycpXG4gICAgICogICAgICAgICAudGhlbigoKSA9PiBzdGF0ZVNlcnZpY2UudGFyZ2V0KCdmb28nKSk7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBpbnZva2VkIHdoZW4gdGhlIHRvU3RhdGUgaXMgaW52YWxpZFxuICAgICAqICAgVGhpcyBmdW5jdGlvbiByZWNlaXZlcyB0aGUgKGludmFsaWQpIHRvU3RhdGUsIHRoZSBmcm9tU3RhdGUsIGFuZCBhbiBpbmplY3Rvci5cbiAgICAgKiAgIFRoZSBmdW5jdGlvbiBtYXkgb3B0aW9uYWxseSByZXR1cm4gYSBbW1RhcmdldFN0YXRlXV0gb3IgYSBQcm9taXNlIGZvciBhIFRhcmdldFN0YXRlLlxuICAgICAqICAgSWYgb25lIGlzIHJldHVybmVkLCBpdCBpcyB0cmVhdGVkIGFzIGEgcmVkaXJlY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGRlcmVnaXN0ZXJzIHRoZSBjYWxsYmFja1xuICAgICAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUub25JbnZhbGlkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuaW52YWxpZENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGRlcmVnaXN0ZXJMaXN0ZW5lcigpIHtcbiAgICAgICAgICAgIGNvbW1vbl8xLnJlbW92ZUZyb20odGhpcy5pbnZhbGlkQ2FsbGJhY2tzKShjYWxsYmFjayk7XG4gICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbG9hZHMgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICAgKlxuICAgICAqIEEgbWV0aG9kIHRoYXQgZm9yY2UgcmVsb2FkcyB0aGUgY3VycmVudCBzdGF0ZSwgb3IgYSBwYXJ0aWFsIHN0YXRlIGhpZXJhcmNoeS5cbiAgICAgKiBBbGwgcmVzb2x2ZXMgYXJlIHJlLXJlc29sdmVkLCBhbmQgY29tcG9uZW50cyByZWluc3RhbnRpYXRlZC5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIGxldCBhcHAgYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyJ10pO1xuICAgICAqXG4gICAgICogYXBwLmNvbnRyb2xsZXIoJ2N0cmwnLCBmdW5jdGlvbiAoJHNjb3BlLCAkc3RhdGUpIHtcbiAgICAgKiAgICRzY29wZS5yZWxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAqICAgICAkc3RhdGUucmVsb2FkKCk7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBOb3RlOiBgcmVsb2FkKClgIGlzIGp1c3QgYW4gYWxpYXMgZm9yOlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiAkc3RhdGUudHJhbnNpdGlvblRvKCRzdGF0ZS5jdXJyZW50LCAkc3RhdGUucGFyYW1zLCB7XG4gICAgICogICByZWxvYWQ6IHRydWUsIGluaGVyaXQ6IGZhbHNlXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVsb2FkU3RhdGUgQSBzdGF0ZSBuYW1lIG9yIGEgc3RhdGUgb2JqZWN0LlxuICAgICAqICAgIElmIHByZXNlbnQsIHRoaXMgc3RhdGUgYW5kIGFsbCBpdHMgY2hpbGRyZW4gd2lsbCBiZSByZWxvYWRlZCwgYnV0IGFuY2VzdG9ycyB3aWxsIG5vdCByZWxvYWQuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiAvL2Fzc3VtaW5nIGFwcCBhcHBsaWNhdGlvbiBjb25zaXN0cyBvZiAzIHN0YXRlczogJ2NvbnRhY3RzJywgJ2NvbnRhY3RzLmRldGFpbCcsICdjb250YWN0cy5kZXRhaWwuaXRlbSdcbiAgICAgKiAvL2FuZCBjdXJyZW50IHN0YXRlIGlzICdjb250YWN0cy5kZXRhaWwuaXRlbSdcbiAgICAgKiBsZXQgYXBwIGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlciddKTtcbiAgICAgKlxuICAgICAqIGFwcC5jb250cm9sbGVyKCdjdHJsJywgZnVuY3Rpb24gKCRzY29wZSwgJHN0YXRlKSB7XG4gICAgICogICAkc2NvcGUucmVsb2FkID0gZnVuY3Rpb24oKXtcbiAgICAgKiAgICAgLy93aWxsIHJlbG9hZCAnY29udGFjdC5kZXRhaWwnIGFuZCBuZXN0ZWQgJ2NvbnRhY3QuZGV0YWlsLml0ZW0nIHN0YXRlc1xuICAgICAqICAgICAkc3RhdGUucmVsb2FkKCdjb250YWN0LmRldGFpbCcpO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHJlcHJlc2VudGluZyB0aGUgc3RhdGUgb2YgdGhlIG5ldyB0cmFuc2l0aW9uLiBTZWUgW1tTdGF0ZVNlcnZpY2UuZ29dXVxuICAgICAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUucmVsb2FkID0gZnVuY3Rpb24gKHJlbG9hZFN0YXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyh0aGlzLmN1cnJlbnQsIHRoaXMucGFyYW1zLCB7XG4gICAgICAgICAgICByZWxvYWQ6IHByZWRpY2F0ZXNfMS5pc0RlZmluZWQocmVsb2FkU3RhdGUpID8gcmVsb2FkU3RhdGUgOiB0cnVlLFxuICAgICAgICAgICAgaW5oZXJpdDogZmFsc2UsXG4gICAgICAgICAgICBub3RpZnk6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBUcmFuc2l0aW9uIHRvIGEgZGlmZmVyZW50IHN0YXRlIGFuZC9vciBwYXJhbWV0ZXJzXG4gICAgICpcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIHRyYW5zaXRpb25pbmcgdG8gYSBuZXcgc3RhdGUuXG4gICAgICpcbiAgICAgKiBgJHN0YXRlLmdvYCBjYWxscyBgJHN0YXRlLnRyYW5zaXRpb25Ub2AgaW50ZXJuYWxseSBidXQgYXV0b21hdGljYWxseSBzZXRzIG9wdGlvbnMgdG9cbiAgICAgKiBgeyBsb2NhdGlvbjogdHJ1ZSwgaW5oZXJpdDogdHJ1ZSwgcmVsYXRpdmU6IHJvdXRlci5nbG9iYWxzLiRjdXJyZW50LCBub3RpZnk6IHRydWUgfWAuXG4gICAgICogVGhpcyBhbGxvd3MgeW91IHRvIHVzZSBlaXRoZXIgYW4gYWJzb2x1dGUgb3IgcmVsYXRpdmUgYHRvYCBhcmd1bWVudCAoYmVjYXVzZSBvZiBgcmVsYXRpdmU6IHJvdXRlci5nbG9iYWxzLiRjdXJyZW50YCkuXG4gICAgICogSXQgYWxzbyBhbGxvd3MgeW91IHRvIHNwZWNpZnkgKiBvbmx5IHRoZSBwYXJhbWV0ZXJzIHlvdSdkIGxpa2UgdG8gdXBkYXRlLCB3aGlsZSBsZXR0aW5nIHVuc3BlY2lmaWVkIHBhcmFtZXRlcnNcbiAgICAgKiBpbmhlcml0IGZyb20gdGhlIGN1cnJlbnQgcGFyYW1ldGVyIHZhbHVlcyAoYmVjYXVzZSBvZiBgaW5oZXJpdDogdHJ1ZWApLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogbGV0IGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlciddKTtcbiAgICAgKlxuICAgICAqIGFwcC5jb250cm9sbGVyKCdjdHJsJywgZnVuY3Rpb24gKCRzY29wZSwgJHN0YXRlKSB7XG4gICAgICogICAkc2NvcGUuY2hhbmdlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICogICAgICRzdGF0ZS5nbygnY29udGFjdC5kZXRhaWwnKTtcbiAgICAgKiAgIH07XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG8gQWJzb2x1dGUgc3RhdGUgbmFtZSwgc3RhdGUgb2JqZWN0LCBvciByZWxhdGl2ZSBzdGF0ZSBwYXRoIChyZWxhdGl2ZSB0byBjdXJyZW50IHN0YXRlKS5cbiAgICAgKlxuICAgICAqIFNvbWUgZXhhbXBsZXM6XG4gICAgICpcbiAgICAgKiAtIGAkc3RhdGUuZ28oJ2NvbnRhY3QuZGV0YWlsJylgIC0gd2lsbCBnbyB0byB0aGUgYGNvbnRhY3QuZGV0YWlsYCBzdGF0ZVxuICAgICAqIC0gYCRzdGF0ZS5nbygnXicpYCAtIHdpbGwgZ28gdG8gdGhlIHBhcmVudCBzdGF0ZVxuICAgICAqIC0gYCRzdGF0ZS5nbygnXi5zaWJsaW5nJylgIC0gaWYgY3VycmVudCBzdGF0ZSBpcyBgaG9tZS5jaGlsZGAsIHdpbGwgZ28gdG8gdGhlIGBob21lLnNpYmxpbmdgIHN0YXRlXG4gICAgICogLSBgJHN0YXRlLmdvKCcuY2hpbGQuZ3JhbmRjaGlsZCcpYCAtIGlmIGN1cnJlbnQgc3RhdGUgaXMgaG9tZSwgd2lsbCBnbyB0byB0aGUgYGhvbWUuY2hpbGQuZ3JhbmRjaGlsZGAgc3RhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgQSBtYXAgb2YgdGhlIHBhcmFtZXRlcnMgdGhhdCB3aWxsIGJlIHNlbnQgdG8gdGhlIHN0YXRlLCB3aWxsIHBvcHVsYXRlICRzdGF0ZVBhcmFtcy5cbiAgICAgKlxuICAgICAqICAgIEFueSBwYXJhbWV0ZXJzIHRoYXQgYXJlIG5vdCBzcGVjaWZpZWQgd2lsbCBiZSBpbmhlcml0ZWQgZnJvbSBjdXJyZW50IHBhcmFtZXRlciB2YWx1ZXMgKGJlY2F1c2Ugb2YgYGluaGVyaXQ6IHRydWVgKS5cbiAgICAgKiAgICBUaGlzIGFsbG93cywgZm9yIGV4YW1wbGUsIGdvaW5nIHRvIGEgc2libGluZyBzdGF0ZSB0aGF0IHNoYXJlcyBwYXJhbWV0ZXJzIGRlZmluZWQgYnkgYSBwYXJlbnQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUcmFuc2l0aW9uIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtwcm9taXNlfSBBIHByb21pc2UgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGUgbmV3IHRyYW5zaXRpb24uXG4gICAgICovXG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uICh0bywgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBkZWZhdXRHb09wdHMgPSB7IHJlbGF0aXZlOiB0aGlzLiRjdXJyZW50LCBpbmhlcml0OiB0cnVlIH07XG4gICAgICAgIHZhciB0cmFuc09wdHMgPSBjb21tb25fMS5kZWZhdWx0cyhvcHRpb25zLCBkZWZhdXRHb09wdHMsIHRyYW5zaXRpb25TZXJ2aWNlXzEuZGVmYXVsdFRyYW5zT3B0cyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyh0bywgcGFyYW1zLCB0cmFuc09wdHMpO1xuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBbW1RhcmdldFN0YXRlXV1cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBmYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBUYXJnZXRTdGF0ZVxuICAgICAqXG4gICAgICogVGhpcyBtYXkgYmUgcmV0dXJuZWQgZnJvbSBhIFRyYW5zaXRpb24gSG9vayB0byByZWRpcmVjdCBhIHRyYW5zaXRpb24sIGZvciBleGFtcGxlLlxuICAgICAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUudGFyZ2V0ID0gZnVuY3Rpb24gKGlkZW50aWZpZXIsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAvLyBJZiB3ZSdyZSByZWxvYWRpbmcsIGZpbmQgdGhlIHN0YXRlIG9iamVjdCB0byByZWxvYWQgZnJvbVxuICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzT2JqZWN0KG9wdGlvbnMucmVsb2FkKSAmJiAhb3B0aW9ucy5yZWxvYWQubmFtZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZWxvYWQgc3RhdGUgb2JqZWN0Jyk7XG4gICAgICAgIHZhciByZWcgPSB0aGlzLnJvdXRlci5zdGF0ZVJlZ2lzdHJ5O1xuICAgICAgICBvcHRpb25zLnJlbG9hZFN0YXRlID0gb3B0aW9ucy5yZWxvYWQgPT09IHRydWUgPyByZWcucm9vdCgpIDogcmVnLm1hdGNoZXIuZmluZChvcHRpb25zLnJlbG9hZCwgb3B0aW9ucy5yZWxhdGl2ZSk7XG4gICAgICAgIGlmIChvcHRpb25zLnJlbG9hZCAmJiAhb3B0aW9ucy5yZWxvYWRTdGF0ZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHN1Y2ggcmVsb2FkIHN0YXRlICdcIiArIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcob3B0aW9ucy5yZWxvYWQpID8gb3B0aW9ucy5yZWxvYWQgOiBvcHRpb25zLnJlbG9hZC5uYW1lKSArIFwiJ1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0YXJnZXRTdGF0ZV8xLlRhcmdldFN0YXRlKHRoaXMucm91dGVyLnN0YXRlUmVnaXN0cnksIGlkZW50aWZpZXIsIHBhcmFtcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICA7XG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5nZXRDdXJyZW50UGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGdsb2JhbHMgPSB0aGlzLnJvdXRlci5nbG9iYWxzO1xuICAgICAgICB2YXIgbGF0ZXN0U3VjY2VzcyA9IGdsb2JhbHMuc3VjY2Vzc2Z1bFRyYW5zaXRpb25zLnBlZWtUYWlsKCk7XG4gICAgICAgIHZhciByb290UGF0aCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtuZXcgcGF0aE5vZGVfMS5QYXRoTm9kZShfdGhpcy5yb3V0ZXIuc3RhdGVSZWdpc3RyeS5yb290KCkpXTsgfTtcbiAgICAgICAgcmV0dXJuIGxhdGVzdFN1Y2Nlc3MgPyBsYXRlc3RTdWNjZXNzLnRyZWVDaGFuZ2VzKCkudG8gOiByb290UGF0aCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG93LWxldmVsIG1ldGhvZCBmb3IgdHJhbnNpdGlvbmluZyB0byBhIG5ldyBzdGF0ZS5cbiAgICAgKlxuICAgICAqIFRoZSBbW2dvXV0gbWV0aG9kICh3aGljaCB1c2VzIGB0cmFuc2l0aW9uVG9gIGludGVybmFsbHkpIGlzIHJlY29tbWVuZGVkIGluIG1vc3Qgc2l0dWF0aW9ucy5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIGxldCBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXInXSk7XG4gICAgICpcbiAgICAgKiBhcHAuY29udHJvbGxlcignY3RybCcsIGZ1bmN0aW9uICgkc2NvcGUsICRzdGF0ZSkge1xuICAgICAqICAgJHNjb3BlLmNoYW5nZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAqICAgICAkc3RhdGUudHJhbnNpdGlvblRvKCdjb250YWN0LmRldGFpbCcpO1xuICAgICAqICAgfTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0byBTdGF0ZSBuYW1lIG9yIHN0YXRlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gdG9QYXJhbXMgQSBtYXAgb2YgdGhlIHBhcmFtZXRlcnMgdGhhdCB3aWxsIGJlIHNlbnQgdG8gdGhlIHN0YXRlLFxuICAgICAqICAgICAgd2lsbCBwb3B1bGF0ZSAkc3RhdGVQYXJhbXMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVHJhbnNpdGlvbiBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGUgbmV3IHRyYW5zaXRpb24uIFNlZSBbW2dvXV1cbiAgICAgKi9cbiAgICBTdGF0ZVNlcnZpY2UucHJvdG90eXBlLnRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uICh0bywgdG9QYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRvUGFyYW1zID09PSB2b2lkIDApIHsgdG9QYXJhbXMgPSB7fTsgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgcm91dGVyID0gdGhpcy5yb3V0ZXI7XG4gICAgICAgIHZhciBnbG9iYWxzID0gcm91dGVyLmdsb2JhbHM7XG4gICAgICAgIG9wdGlvbnMgPSBjb21tb25fMS5kZWZhdWx0cyhvcHRpb25zLCB0cmFuc2l0aW9uU2VydmljZV8xLmRlZmF1bHRUcmFuc09wdHMpO1xuICAgICAgICB2YXIgZ2V0Q3VycmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxzLnRyYW5zaXRpb247XG4gICAgICAgIH07XG4gICAgICAgIG9wdGlvbnMgPSBjb21tb25fMS5leHRlbmQob3B0aW9ucywgeyBjdXJyZW50OiBnZXRDdXJyZW50IH0pO1xuICAgICAgICB2YXIgcmVmID0gdGhpcy50YXJnZXQodG8sIHRvUGFyYW1zLCBvcHRpb25zKTtcbiAgICAgICAgdmFyIGN1cnJlbnRQYXRoID0gdGhpcy5nZXRDdXJyZW50UGF0aCgpO1xuICAgICAgICBpZiAoIXJlZi5leGlzdHMoKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVJbnZhbGlkVGFyZ2V0U3RhdGUoY3VycmVudFBhdGgsIHJlZik7XG4gICAgICAgIGlmICghcmVmLnZhbGlkKCkpXG4gICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuc2lsZW50UmVqZWN0aW9uKHJlZi5lcnJvcigpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpYWwgaGFuZGxpbmcgZm9yIElnbm9yZWQsIEFib3J0ZWQsIGFuZCBSZWRpcmVjdGVkIHRyYW5zaXRpb25zXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBzZW1hbnRpY3MgZm9yIHRoZSB0cmFuc2l0aW9uLnJ1bigpIHByb21pc2UgYW5kIHRoZSBTdGF0ZVNlcnZpY2UudHJhbnNpdGlvblRvKClcbiAgICAgICAgICogcHJvbWlzZSBkaWZmZXIuIEZvciBpbnN0YW5jZSwgdGhlIHJ1bigpIHByb21pc2UgbWF5IGJlIHJlamVjdGVkIGJlY2F1c2UgaXQgd2FzXG4gICAgICAgICAqIElHTk9SRUQsIGJ1dCB0aGUgdHJhbnNpdGlvblRvKCkgcHJvbWlzZSBpcyByZXNvbHZlZCBiZWNhdXNlIGZyb20gdGhlIHVzZXIgcGVyc3BlY3RpdmVcbiAgICAgICAgICogbm8gZXJyb3Igb2NjdXJyZWQuICBMaWtld2lzZSwgdGhlIHRyYW5zaXRpb24ucnVuKCkgcHJvbWlzZSBtYXkgYmUgcmVqZWN0ZWQgYmVjYXVzZSBvZlxuICAgICAgICAgKiBhIFJlZGlyZWN0LCBidXQgdGhlIHRyYW5zaXRpb25UbygpIHByb21pc2UgaXMgY2hhaW5lZCB0byB0aGUgbmV3IFRyYW5zaXRpb24ncyBwcm9taXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHJlamVjdGVkVHJhbnNpdGlvbkhhbmRsZXIgPSBmdW5jdGlvbiAodHJhbnNpdGlvbikgeyByZXR1cm4gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzTGF0ZXN0ID0gcm91dGVyLmdsb2JhbHMubGFzdFN0YXJ0ZWRUcmFuc2l0aW9uSWQgPT09IHRyYW5zaXRpb24uJGlkO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci50eXBlID09PSByZWplY3RGYWN0b3J5XzEuUmVqZWN0VHlwZS5JR05PUkVEKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzTGF0ZXN0ICYmIHJvdXRlci51cmxSb3V0ZXIudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIGlnbm9yZWQgYFRyYW5zaXRpb24ucnVuKClgIGFzIGEgc3VjY2Vzc2Z1bCBgdHJhbnNpdGlvblRvYFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEud2hlbihnbG9iYWxzLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZGV0YWlsID0gZXJyb3IuZGV0YWlsO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci50eXBlID09PSByZWplY3RGYWN0b3J5XzEuUmVqZWN0VHlwZS5TVVBFUlNFREVEICYmIGVycm9yLnJlZGlyZWN0ZWQgJiYgZGV0YWlsIGluc3RhbmNlb2YgdGFyZ2V0U3RhdGVfMS5UYXJnZXRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBgVHJhbnNpdGlvbi5ydW4oKWAgd2FzIHJlZGlyZWN0ZWQsIGFsbG93IHRoZSBgdHJhbnNpdGlvblRvKClgIHByb21pc2UgdG8gcmVzb2x2ZSBzdWNjZXNzZnVsbHlcbiAgICAgICAgICAgICAgICAgICAgLy8gYnkgcmV0dXJuaW5nIHRoZSBwcm9taXNlIGZvciB0aGUgbmV3IChyZWRpcmVjdCkgYFRyYW5zaXRpb24ucnVuKClgLlxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVkaXJlY3QgPSB0cmFuc2l0aW9uLnJlZGlyZWN0KGRldGFpbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWRpcmVjdC5ydW4oKS5jYXRjaChyZWplY3RlZFRyYW5zaXRpb25IYW5kbGVyKHJlZGlyZWN0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnJvci50eXBlID09PSByZWplY3RGYWN0b3J5XzEuUmVqZWN0VHlwZS5BQk9SVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzTGF0ZXN0ICYmIHJvdXRlci51cmxSb3V0ZXIudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlcnJvckhhbmRsZXIgPSBfdGhpcy5kZWZhdWx0RXJyb3JIYW5kbGVyKCk7XG4gICAgICAgICAgICBlcnJvckhhbmRsZXIoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLnJlamVjdChlcnJvcik7XG4gICAgICAgIH07IH07XG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gdGhpcy5yb3V0ZXIudHJhbnNpdGlvblNlcnZpY2UuY3JlYXRlKGN1cnJlbnRQYXRoLCByZWYpO1xuICAgICAgICB2YXIgdHJhbnNpdGlvblRvUHJvbWlzZSA9IHRyYW5zaXRpb24ucnVuKCkuY2F0Y2gocmVqZWN0ZWRUcmFuc2l0aW9uSGFuZGxlcih0cmFuc2l0aW9uKSk7XG4gICAgICAgIGNvbW1vbl8xLnNpbGVuY2VVbmNhdWdodEluUHJvbWlzZSh0cmFuc2l0aW9uVG9Qcm9taXNlKTsgLy8gaXNzdWUgIzI2NzZcbiAgICAgICAgLy8gUmV0dXJuIGEgcHJvbWlzZSBmb3IgdGhlIHRyYW5zaXRpb24sIHdoaWNoIGFsc28gaGFzIHRoZSB0cmFuc2l0aW9uIG9iamVjdCBvbiBpdC5cbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZCh0cmFuc2l0aW9uVG9Qcm9taXNlLCB7IHRyYW5zaXRpb246IHRyYW5zaXRpb24gfSk7XG4gICAgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHN0YXRlICppcyogdGhlIHByb3ZpZGVkIHN0YXRlXG4gICAgICpcbiAgICAgKiBTaW1pbGFyIHRvIFtbaW5jbHVkZXNdXSBidXQgb25seSBjaGVja3MgZm9yIHRoZSBmdWxsIHN0YXRlIG5hbWUuXG4gICAgICogSWYgcGFyYW1zIGlzIHN1cHBsaWVkIHRoZW4gaXQgd2lsbCBiZSB0ZXN0ZWQgZm9yIHN0cmljdCBlcXVhbGl0eSBhZ2FpbnN0IHRoZSBjdXJyZW50XG4gICAgICogYWN0aXZlIHBhcmFtcyBvYmplY3QsIHNvIGFsbCBwYXJhbXMgbXVzdCBtYXRjaCB3aXRoIG5vbmUgbWlzc2luZyBhbmQgbm8gZXh0cmFzLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogJHN0YXRlLiRjdXJyZW50Lm5hbWUgPSAnY29udGFjdHMuZGV0YWlscy5pdGVtJztcbiAgICAgKlxuICAgICAqIC8vIGFic29sdXRlIG5hbWVcbiAgICAgKiAkc3RhdGUuaXMoJ2NvbnRhY3QuZGV0YWlscy5pdGVtJyk7IC8vIHJldHVybnMgdHJ1ZVxuICAgICAqICRzdGF0ZS5pcyhjb250YWN0RGV0YWlsSXRlbVN0YXRlT2JqZWN0KTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAvLyByZWxhdGl2ZSBuYW1lICguIGFuZCBeKSwgdHlwaWNhbGx5IGZyb20gYSB0ZW1wbGF0ZVxuICAgICAqIC8vIEUuZy4gZnJvbSB0aGUgJ2NvbnRhY3RzLmRldGFpbHMnIHRlbXBsYXRlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgbmctY2xhc3M9XCJ7aGlnaGxpZ2h0ZWQ6ICRzdGF0ZS5pcygnLml0ZW0nKX1cIj5JdGVtPC9kaXY+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGVPck5hbWUgVGhlIHN0YXRlIG5hbWUgKGFic29sdXRlIG9yIHJlbGF0aXZlKSBvciBzdGF0ZSBvYmplY3QgeW91J2QgbGlrZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIEEgcGFyYW0gb2JqZWN0LCBlLmcuIGB7c2VjdGlvbklkOiBzZWN0aW9uLmlkfWAsIHRoYXQgeW91J2QgbGlrZVxuICAgICAqIHRvIHRlc3QgYWdhaW5zdCB0aGUgY3VycmVudCBhY3RpdmUgc3RhdGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQW4gb3B0aW9ucyBvYmplY3QuIFRoZSBvcHRpb25zIGFyZTpcbiAgICAgKiAgIC0gYHJlbGF0aXZlYDogSWYgYHN0YXRlT3JOYW1lYCBpcyBhIHJlbGF0aXZlIHN0YXRlIG5hbWUgYW5kIGBvcHRpb25zLnJlbGF0aXZlYCBpcyBzZXQsIC5pcyB3aWxsXG4gICAgICogICAgIHRlc3QgcmVsYXRpdmUgdG8gYG9wdGlvbnMucmVsYXRpdmVgIHN0YXRlIChvciBuYW1lKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdHJ1ZSBpZiBpdCBpcyB0aGUgc3RhdGUuXG4gICAgICovXG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5pcyA9IGZ1bmN0aW9uIChzdGF0ZU9yTmFtZSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBjb21tb25fMS5kZWZhdWx0cyhvcHRpb25zLCB7IHJlbGF0aXZlOiB0aGlzLiRjdXJyZW50IH0pO1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnJvdXRlci5zdGF0ZVJlZ2lzdHJ5Lm1hdGNoZXIuZmluZChzdGF0ZU9yTmFtZSwgb3B0aW9ucy5yZWxhdGl2ZSk7XG4gICAgICAgIGlmICghcHJlZGljYXRlc18xLmlzRGVmaW5lZChzdGF0ZSkpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy4kY3VycmVudCAhPT0gc3RhdGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghcGFyYW1zKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHZhciBzY2hlbWEgPSBzdGF0ZS5wYXJhbWV0ZXJzKHsgaW5oZXJpdDogdHJ1ZSwgbWF0Y2hpbmdLZXlzOiBwYXJhbXMgfSk7XG4gICAgICAgIHJldHVybiBwYXJhbV8xLlBhcmFtLmVxdWFscyhzY2hlbWEsIHBhcmFtXzEuUGFyYW0udmFsdWVzKHNjaGVtYSwgcGFyYW1zKSwgdGhpcy5wYXJhbXMpO1xuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBzdGF0ZSAqaW5jbHVkZXMqIHRoZSBwcm92aWRlZCBzdGF0ZVxuICAgICAqXG4gICAgICogQSBtZXRob2QgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW50IGFjdGl2ZSBzdGF0ZSBpcyBlcXVhbCB0byBvciBpcyB0aGUgY2hpbGQgb2YgdGhlXG4gICAgICogc3RhdGUgc3RhdGVOYW1lLiBJZiBhbnkgcGFyYW1zIGFyZSBwYXNzZWQgdGhlbiB0aGV5IHdpbGwgYmUgdGVzdGVkIGZvciBhIG1hdGNoIGFzIHdlbGwuXG4gICAgICogTm90IGFsbCB0aGUgcGFyYW1ldGVycyBuZWVkIHRvIGJlIHBhc3NlZCwganVzdCB0aGUgb25lcyB5b3UnZCBsaWtlIHRvIHRlc3QgZm9yIGVxdWFsaXR5LlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlIHdoZW4gYCRzdGF0ZS4kY3VycmVudC5uYW1lID09PSAnY29udGFjdHMuZGV0YWlscy5pdGVtJ2BcbiAgICAgKiBgYGBqc1xuICAgICAqIC8vIFVzaW5nIHBhcnRpYWwgbmFtZXNcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCJjb250YWN0c1wiKTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiY29udGFjdHMuZGV0YWlsc1wiKTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiY29udGFjdHMuZGV0YWlscy5pdGVtXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCJjb250YWN0cy5saXN0XCIpOyAvLyByZXR1cm5zIGZhbHNlXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiYWJvdXRcIik7IC8vIHJldHVybnMgZmFsc2VcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyMgR2xvYiBFeGFtcGxlcyB3aGVuIGAqICRzdGF0ZS4kY3VycmVudC5uYW1lID09PSAnY29udGFjdHMuZGV0YWlscy5pdGVtLnVybCdgOlxuICAgICAqIGBgYGpzXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiKi5kZXRhaWxzLiouKlwiKTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiKi5kZXRhaWxzLioqXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCIqKi5pdGVtLioqXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCIqLmRldGFpbHMuaXRlbS51cmxcIik7IC8vIHJldHVybnMgdHJ1ZVxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcIiouZGV0YWlscy4qLnVybFwiKTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiKi5kZXRhaWxzLipcIik7IC8vIHJldHVybnMgZmFsc2VcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCJpdGVtLioqXCIpOyAvLyByZXR1cm5zIGZhbHNlXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGVPck5hbWUgQSBwYXJ0aWFsIG5hbWUsIHJlbGF0aXZlIG5hbWUsIGdsb2IgcGF0dGVybixcbiAgICAgKiAgIG9yIHN0YXRlIG9iamVjdCB0byBiZSBzZWFyY2hlZCBmb3Igd2l0aGluIHRoZSBjdXJyZW50IHN0YXRlIG5hbWUuXG4gICAgICogQHBhcmFtIHBhcmFtcyBBIHBhcmFtIG9iamVjdCwgZS5nLiBge3NlY3Rpb25JZDogc2VjdGlvbi5pZH1gLFxuICAgICAqICAgdGhhdCB5b3UnZCBsaWtlIHRvIHRlc3QgYWdhaW5zdCB0aGUgY3VycmVudCBhY3RpdmUgc3RhdGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQW4gb3B0aW9ucyBvYmplY3QuIFRoZSBvcHRpb25zIGFyZTpcbiAgICAgKiAgIC0gYHJlbGF0aXZlYDogSWYgYHN0YXRlT3JOYW1lYCBpcyBhIHJlbGF0aXZlIHN0YXRlIG5hbWUgYW5kIGBvcHRpb25zLnJlbGF0aXZlYCBpcyBzZXQsIC5pcyB3aWxsXG4gICAgICogICAgIHRlc3QgcmVsYXRpdmUgdG8gYG9wdGlvbnMucmVsYXRpdmVgIHN0YXRlIChvciBuYW1lKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgaXQgZG9lcyBpbmNsdWRlIHRoZSBzdGF0ZVxuICAgICAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiAoc3RhdGVPck5hbWUsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gY29tbW9uXzEuZGVmYXVsdHMob3B0aW9ucywgeyByZWxhdGl2ZTogdGhpcy4kY3VycmVudCB9KTtcbiAgICAgICAgdmFyIGdsb2IgPSBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoc3RhdGVPck5hbWUpICYmIGdsb2JfMS5HbG9iLmZyb21TdHJpbmcoc3RhdGVPck5hbWUpO1xuICAgICAgICBpZiAoZ2xvYikge1xuICAgICAgICAgICAgaWYgKCFnbG9iLm1hdGNoZXModGhpcy4kY3VycmVudC5uYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBzdGF0ZU9yTmFtZSA9IHRoaXMuJGN1cnJlbnQubmFtZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnJvdXRlci5zdGF0ZVJlZ2lzdHJ5Lm1hdGNoZXIuZmluZChzdGF0ZU9yTmFtZSwgb3B0aW9ucy5yZWxhdGl2ZSksIGluY2x1ZGUgPSB0aGlzLiRjdXJyZW50LmluY2x1ZGVzO1xuICAgICAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc0RlZmluZWQoc3RhdGUpKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKGluY2x1ZGVbc3RhdGUubmFtZV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXBhcmFtcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB2YXIgc2NoZW1hID0gc3RhdGUucGFyYW1ldGVycyh7IGluaGVyaXQ6IHRydWUsIG1hdGNoaW5nS2V5czogcGFyYW1zIH0pO1xuICAgICAgICByZXR1cm4gcGFyYW1fMS5QYXJhbS5lcXVhbHMoc2NoZW1hLCBwYXJhbV8xLlBhcmFtLnZhbHVlcyhzY2hlbWEsIHBhcmFtcyksIHRoaXMucGFyYW1zKTtcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBVUkwgZm9yIGEgc3RhdGUgYW5kIHBhcmFtZXRlcnNcbiAgICAgKlxuICAgICAqIFJldHVybnMgdGhlIHVybCBmb3IgdGhlIGdpdmVuIHN0YXRlIHBvcHVsYXRlZCB3aXRoIHRoZSBnaXZlbiBwYXJhbXMuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBleHBlY3QoJHN0YXRlLmhyZWYoXCJhYm91dC5wZXJzb25cIiwgeyBwZXJzb246IFwiYm9iXCIgfSkpLnRvRXF1YWwoXCIvYWJvdXQvYm9iXCIpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlT3JOYW1lIFRoZSBzdGF0ZSBuYW1lIG9yIHN0YXRlIG9iamVjdCB5b3UnZCBsaWtlIHRvIGdlbmVyYXRlIGEgdXJsIGZyb20uXG4gICAgICogQHBhcmFtIHBhcmFtcyBBbiBvYmplY3Qgb2YgcGFyYW1ldGVyIHZhbHVlcyB0byBmaWxsIHRoZSBzdGF0ZSdzIHJlcXVpcmVkIHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBvYmplY3QuIFRoZSBvcHRpb25zIGFyZTpcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGNvbXBpbGVkIHN0YXRlIHVybFxuICAgICAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUuaHJlZiA9IGZ1bmN0aW9uIChzdGF0ZU9yTmFtZSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBkZWZhdWx0SHJlZk9wdHMgPSB7XG4gICAgICAgICAgICBsb3NzeTogdHJ1ZSxcbiAgICAgICAgICAgIGluaGVyaXQ6IHRydWUsXG4gICAgICAgICAgICBhYnNvbHV0ZTogZmFsc2UsXG4gICAgICAgICAgICByZWxhdGl2ZTogdGhpcy4kY3VycmVudCxcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucyA9IGNvbW1vbl8xLmRlZmF1bHRzKG9wdGlvbnMsIGRlZmF1bHRIcmVmT3B0cyk7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5yb3V0ZXIuc3RhdGVSZWdpc3RyeS5tYXRjaGVyLmZpbmQoc3RhdGVPck5hbWUsIG9wdGlvbnMucmVsYXRpdmUpO1xuICAgICAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc0RlZmluZWQoc3RhdGUpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChvcHRpb25zLmluaGVyaXQpXG4gICAgICAgICAgICBwYXJhbXMgPSB0aGlzLnBhcmFtcy4kaW5oZXJpdChwYXJhbXMsIHRoaXMuJGN1cnJlbnQsIHN0YXRlKTtcbiAgICAgICAgdmFyIG5hdiA9IChzdGF0ZSAmJiBvcHRpb25zLmxvc3N5KSA/IHN0YXRlLm5hdmlnYWJsZSA6IHN0YXRlO1xuICAgICAgICBpZiAoIW5hdiB8fCBuYXYudXJsID09PSB1bmRlZmluZWQgfHwgbmF2LnVybCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucm91dGVyLnVybFJvdXRlci5ocmVmKG5hdi51cmwsIHBhcmFtcywge1xuICAgICAgICAgICAgYWJzb2x1dGU6IG9wdGlvbnMuYWJzb2x1dGUsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldHMgb3IgZ2V0cyB0aGUgZGVmYXVsdCBbW3RyYW5zaXRpb25Ub11dIGVycm9yIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBUaGUgZXJyb3IgaGFuZGxlciBpcyBjYWxsZWQgd2hlbiBhIFtbVHJhbnNpdGlvbl1dIGlzIHJlamVjdGVkIG9yIHdoZW4gYW55IGVycm9yIG9jY3VycmVkIGR1cmluZyB0aGUgVHJhbnNpdGlvbi5cbiAgICAgKiBUaGlzIGluY2x1ZGVzIGVycm9ycyBjYXVzZWQgYnkgcmVzb2x2ZXMgYW5kIHRyYW5zaXRpb24gaG9va3MuXG4gICAgICpcbiAgICAgKiBOb3RlOlxuICAgICAqIFRoaXMgaGFuZGxlciBkb2VzIG5vdCByZWNlaXZlIGNlcnRhaW4gVHJhbnNpdGlvbiByZWplY3Rpb25zLlxuICAgICAqIFJlZGlyZWN0ZWQgYW5kIElnbm9yZWQgVHJhbnNpdGlvbnMgYXJlIG5vdCBjb25zaWRlcmVkIHRvIGJlIGVycm9ycyBieSBbW1N0YXRlU2VydmljZS50cmFuc2l0aW9uVG9dXS5cbiAgICAgKlxuICAgICAqIFRoZSBidWlsdC1pbiBkZWZhdWx0IGVycm9yIGhhbmRsZXIgbG9ncyB0aGUgZXJyb3IgdG8gdGhlIGNvbnNvbGUuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIHByb3ZpZGUgeW91ciBvd24gY3VzdG9tIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBzdGF0ZVNlcnZpY2UuZGVmYXVsdEVycm9ySGFuZGxlcihmdW5jdGlvbigpIHtcbiAgICAgKiAgIC8vIERvIG5vdCBsb2cgdHJhbnNpdGlvblRvIGVycm9yc1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGhhbmRsZXIgYSBnbG9iYWwgZXJyb3IgaGFuZGxlciBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IGdsb2JhbCBlcnJvciBoYW5kbGVyXG4gICAgICovXG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5kZWZhdWx0RXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRFcnJvckhhbmRsZXIgPSBoYW5kbGVyIHx8IHRoaXMuX2RlZmF1bHRFcnJvckhhbmRsZXI7XG4gICAgfTtcbiAgICBTdGF0ZVNlcnZpY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChzdGF0ZU9yTmFtZSwgYmFzZSkge1xuICAgICAgICB2YXIgcmVnID0gdGhpcy5yb3V0ZXIuc3RhdGVSZWdpc3RyeTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gcmVnLmdldCgpO1xuICAgICAgICByZXR1cm4gcmVnLmdldChzdGF0ZU9yTmFtZSwgYmFzZSB8fCB0aGlzLiRjdXJyZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExhenkgbG9hZHMgYSBzdGF0ZVxuICAgICAqXG4gICAgICogRXhwbGljaXRseSBydW5zIGEgc3RhdGUncyBbW1N0YXRlRGVjbGFyYXRpb24ubGF6eUxvYWRdXSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZU9yTmFtZSB0aGUgc3RhdGUgdGhhdCBzaG91bGQgYmUgbGF6eSBsb2FkZWRcbiAgICAgKiBAcGFyYW0gdHJhbnNpdGlvbiB0aGUgb3B0aW9uYWwgVHJhbnNpdGlvbiBjb250ZXh0IHRvIHVzZSAoaWYgdGhlIGxhenlMb2FkIGZ1bmN0aW9uIHJlcXVpcmVzIGFuIGluamVjdG9yLCBldGMpXG4gICAgICogTm90ZTogSWYgbm8gdHJhbnNpdGlvbiBpcyBwcm92aWRlZCwgYSBub29wIHRyYW5zaXRpb24gaXMgY3JlYXRlZCB1c2luZyB0aGUgZnJvbSB0aGUgY3VycmVudCBzdGF0ZSB0byB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAgKiBUaGlzIG5vb3AgdHJhbnNpdGlvbiBpcyBub3QgYWN0dWFsbHkgcnVuLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBwcm9taXNlIHRvIGxhenkgbG9hZFxuICAgICAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUubGF6eUxvYWQgPSBmdW5jdGlvbiAoc3RhdGVPck5hbWUsIHRyYW5zaXRpb24pIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXQoc3RhdGVPck5hbWUpO1xuICAgICAgICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5sYXp5TG9hZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgbGF6eSBsb2FkIFwiICsgc3RhdGVPck5hbWUpO1xuICAgICAgICB2YXIgY3VycmVudFBhdGggPSB0aGlzLmdldEN1cnJlbnRQYXRoKCk7XG4gICAgICAgIHZhciB0YXJnZXQgPSBwYXRoRmFjdG9yeV8xLlBhdGhVdGlscy5tYWtlVGFyZ2V0U3RhdGUodGhpcy5yb3V0ZXIuc3RhdGVSZWdpc3RyeSwgY3VycmVudFBhdGgpO1xuICAgICAgICB0cmFuc2l0aW9uID0gdHJhbnNpdGlvbiB8fCB0aGlzLnJvdXRlci50cmFuc2l0aW9uU2VydmljZS5jcmVhdGUoY3VycmVudFBhdGgsIHRhcmdldCk7XG4gICAgICAgIHJldHVybiBsYXp5TG9hZF8xLmxhenlMb2FkU3RhdGUodHJhbnNpdGlvbiwgc3RhdGUpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRlU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLlN0YXRlU2VydmljZSA9IFN0YXRlU2VydmljZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlU2VydmljZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlU2VydmljZS5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///38\n")},function(module,exports,__webpack_require__){"use strict";eval("\n/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ 1);\nvar interface_1 = __webpack_require__(/*! ./interface */ 10);\nvar transitionHook_1 = __webpack_require__(/*! ./transitionHook */ 13);\n/**\n * This class returns applicable TransitionHooks for a specific Transition instance.\n *\n * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.\n * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is\n * determined by the type of hook)\n *\n * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.\n *\n * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder\n * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private\n * in the Transition class, so we must also provide the Transition's _treeChanges)\n *\n */\nvar HookBuilder = /** @class */ (function () {\n    function HookBuilder(transition) {\n        this.transition = transition;\n    }\n    HookBuilder.prototype.buildHooksForPhase = function (phase) {\n        var _this = this;\n        var $transitions = this.transition.router.transitionService;\n        return $transitions._pluginapi._getEvents(phase)\n            .map(function (type) { return _this.buildHooks(type); })\n            .reduce(common_1.unnestR, [])\n            .filter(common_1.identity);\n    };\n    /**\n     * Returns an array of newly built TransitionHook objects.\n     *\n     * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].\n     * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)\n     * - For each of the [[PathNode]]s, creates a TransitionHook\n     *\n     * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.\n     */\n    HookBuilder.prototype.buildHooks = function (hookType) {\n        var transition = this.transition;\n        var treeChanges = transition.treeChanges();\n        // Find all the matching registered hooks for a given hook type\n        var matchingHooks = this.getMatchingHooks(hookType, treeChanges);\n        if (!matchingHooks)\n            return [];\n        var baseHookOptions = {\n            transition: transition,\n            current: transition.options().current\n        };\n        var makeTransitionHooks = function (hook) {\n            // Fetch the Nodes that caused this hook to match.\n            var matches = hook.matches(treeChanges);\n            // Select the PathNode[] that will be used as TransitionHook context objects\n            var matchingNodes = matches[hookType.criteriaMatchPath.name];\n            // Return an array of HookTuples\n            return matchingNodes.map(function (node) {\n                var _options = common_1.extend({\n                    bind: hook.bind,\n                    traceData: { hookType: hookType.name, context: node }\n                }, baseHookOptions);\n                var state = hookType.criteriaMatchPath.scope === interface_1.TransitionHookScope.STATE ? node.state.self : null;\n                var transitionHook = new transitionHook_1.TransitionHook(transition, state, hook, _options);\n                return { hook: hook, node: node, transitionHook: transitionHook };\n            });\n        };\n        return matchingHooks.map(makeTransitionHooks)\n            .reduce(common_1.unnestR, [])\n            .sort(tupleSort(hookType.reverseSort))\n            .map(function (tuple) { return tuple.transitionHook; });\n    };\n    /**\n     * Finds all RegisteredHooks from:\n     * - The Transition object instance hook registry\n     * - The TransitionService ($transitions) global hook registry\n     *\n     * which matched:\n     * - the eventType\n     * - the matchCriteria (to, from, exiting, retained, entering)\n     *\n     * @returns an array of matched [[RegisteredHook]]s\n     */\n    HookBuilder.prototype.getMatchingHooks = function (hookType, treeChanges) {\n        var isCreate = hookType.hookPhase === interface_1.TransitionHookPhase.CREATE;\n        // Instance and Global hook registries\n        var $transitions = this.transition.router.transitionService;\n        var registries = isCreate ? [$transitions] : [this.transition, $transitions];\n        return registries.map(function (reg) { return reg.getHooks(hookType.name); }) // Get named hooks from registries\n            .filter(common_1.assertPredicate(predicates_1.isArray, \"broken event named: \" + hookType.name)) // Sanity check\n            .reduce(common_1.unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array\n            .filter(function (hook) { return hook.matches(treeChanges); }); // Only those satisfying matchCriteria\n    };\n    return HookBuilder;\n}());\nexports.HookBuilder = HookBuilder;\n/**\n * A factory for a sort function for HookTuples.\n *\n * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares\n * the EventHook priority.\n *\n * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth\n * @returns a tuple sort function\n */\nfunction tupleSort(reverseDepthSort) {\n    if (reverseDepthSort === void 0) { reverseDepthSort = false; }\n    return function nodeDepthThenPriority(l, r) {\n        var factor = reverseDepthSort ? -1 : 1;\n        var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;\n        return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;\n    };\n}\n//# sourceMappingURL=hookBuilder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL2hvb2tCdWlsZGVyLmpzPzcxOGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHRyYW5zaXRpb25cbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBpbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL2ludGVyZmFjZVwiKTtcbnZhciB0cmFuc2l0aW9uSG9va18xID0gcmVxdWlyZShcIi4vdHJhbnNpdGlvbkhvb2tcIik7XG4vKipcbiAqIFRoaXMgY2xhc3MgcmV0dXJucyBhcHBsaWNhYmxlIFRyYW5zaXRpb25Ib29rcyBmb3IgYSBzcGVjaWZpYyBUcmFuc2l0aW9uIGluc3RhbmNlLlxuICpcbiAqIEhvb2tzIChbW1JlZ2lzdGVyZWRIb29rXV0pIG1heSBiZSByZWdpc3RlcmVkIGdsb2JhbGx5LCBlLmcuLCAkdHJhbnNpdGlvbnMub25FbnRlciguLi4pLCBvciBsb2NhbGx5LCBlLmcuXG4gKiBteVRyYW5zaXRpb24ub25FbnRlciguLi4pLiAgVGhlIEhvb2tCdWlsZGVyIGZpbmRzIG1hdGNoaW5nIFJlZ2lzdGVyZWRIb29rcyAod2hlcmUgdGhlIG1hdGNoIGNyaXRlcmlhIGlzXG4gKiBkZXRlcm1pbmVkIGJ5IHRoZSB0eXBlIG9mIGhvb2spXG4gKlxuICogVGhlIEhvb2tCdWlsZGVyIGFsc28gY29udmVydHMgUmVnaXN0ZXJlZEhvb2tzIG9iamVjdHMgdG8gVHJhbnNpdGlvbkhvb2sgb2JqZWN0cywgd2hpY2ggYXJlIHVzZWQgdG8gcnVuIGEgVHJhbnNpdGlvbi5cbiAqXG4gKiBUaGUgSG9va0J1aWxkZXIgY29uc3RydWN0b3IgaXMgZ2l2ZW4gdGhlICR0cmFuc2l0aW9ucyBzZXJ2aWNlIGFuZCBhIFRyYW5zaXRpb24gaW5zdGFuY2UuICBUaHVzLCBhIEhvb2tCdWlsZGVyXG4gKiBpbnN0YW5jZSBtYXkgb25seSBiZSB1c2VkIGZvciBvbmUgc3BlY2lmaWMgVHJhbnNpdGlvbiBvYmplY3QuIChzaWRlIG5vdGU6IHRoZSBfdHJlZUNoYW5nZXMgYWNjZXNzb3IgaXMgcHJpdmF0ZVxuICogaW4gdGhlIFRyYW5zaXRpb24gY2xhc3MsIHNvIHdlIG11c3QgYWxzbyBwcm92aWRlIHRoZSBUcmFuc2l0aW9uJ3MgX3RyZWVDaGFuZ2VzKVxuICpcbiAqL1xudmFyIEhvb2tCdWlsZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhvb2tCdWlsZGVyKHRyYW5zaXRpb24pIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcbiAgICB9XG4gICAgSG9va0J1aWxkZXIucHJvdG90eXBlLmJ1aWxkSG9va3NGb3JQaGFzZSA9IGZ1bmN0aW9uIChwaGFzZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgJHRyYW5zaXRpb25zID0gdGhpcy50cmFuc2l0aW9uLnJvdXRlci50cmFuc2l0aW9uU2VydmljZTtcbiAgICAgICAgcmV0dXJuICR0cmFuc2l0aW9ucy5fcGx1Z2luYXBpLl9nZXRFdmVudHMocGhhc2UpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBfdGhpcy5idWlsZEhvb2tzKHR5cGUpOyB9KVxuICAgICAgICAgICAgLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSlcbiAgICAgICAgICAgIC5maWx0ZXIoY29tbW9uXzEuaWRlbnRpdHkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBuZXdseSBidWlsdCBUcmFuc2l0aW9uSG9vayBvYmplY3RzLlxuICAgICAqXG4gICAgICogLSBGaW5kcyBhbGwgUmVnaXN0ZXJlZEhvb2tzIHJlZ2lzdGVyZWQgZm9yIHRoZSBnaXZlbiBgaG9va1R5cGVgIHdoaWNoIG1hdGNoZWQgdGhlIHRyYW5zaXRpb24ncyBbW1RyZWVDaGFuZ2VzXV0uXG4gICAgICogLSBGaW5kcyBbW1BhdGhOb2RlXV0gKG9yIGBQYXRoTm9kZVtdYCkgdG8gdXNlIGFzIHRoZSBUcmFuc2l0aW9uSG9vayBjb250ZXh0KHMpXG4gICAgICogLSBGb3IgZWFjaCBvZiB0aGUgW1tQYXRoTm9kZV1dcywgY3JlYXRlcyBhIFRyYW5zaXRpb25Ib29rXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaG9va1R5cGUgdGhlIHR5cGUgb2YgdGhlIGhvb2sgcmVnaXN0cmF0aW9uIGZ1bmN0aW9uLCBlLmcuLCAnb25FbnRlcicsICdvbkZpbmlzaCcuXG4gICAgICovXG4gICAgSG9va0J1aWxkZXIucHJvdG90eXBlLmJ1aWxkSG9va3MgPSBmdW5jdGlvbiAoaG9va1R5cGUpIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzLnRyYW5zaXRpb247XG4gICAgICAgIHZhciB0cmVlQ2hhbmdlcyA9IHRyYW5zaXRpb24udHJlZUNoYW5nZXMoKTtcbiAgICAgICAgLy8gRmluZCBhbGwgdGhlIG1hdGNoaW5nIHJlZ2lzdGVyZWQgaG9va3MgZm9yIGEgZ2l2ZW4gaG9vayB0eXBlXG4gICAgICAgIHZhciBtYXRjaGluZ0hvb2tzID0gdGhpcy5nZXRNYXRjaGluZ0hvb2tzKGhvb2tUeXBlLCB0cmVlQ2hhbmdlcyk7XG4gICAgICAgIGlmICghbWF0Y2hpbmdIb29rcylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgdmFyIGJhc2VIb29rT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb24sXG4gICAgICAgICAgICBjdXJyZW50OiB0cmFuc2l0aW9uLm9wdGlvbnMoKS5jdXJyZW50XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtYWtlVHJhbnNpdGlvbkhvb2tzID0gZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgICAgICAgIC8vIEZldGNoIHRoZSBOb2RlcyB0aGF0IGNhdXNlZCB0aGlzIGhvb2sgdG8gbWF0Y2guXG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IGhvb2subWF0Y2hlcyh0cmVlQ2hhbmdlcyk7XG4gICAgICAgICAgICAvLyBTZWxlY3QgdGhlIFBhdGhOb2RlW10gdGhhdCB3aWxsIGJlIHVzZWQgYXMgVHJhbnNpdGlvbkhvb2sgY29udGV4dCBvYmplY3RzXG4gICAgICAgICAgICB2YXIgbWF0Y2hpbmdOb2RlcyA9IG1hdGNoZXNbaG9va1R5cGUuY3JpdGVyaWFNYXRjaFBhdGgubmFtZV07XG4gICAgICAgICAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgSG9va1R1cGxlc1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoaW5nTm9kZXMubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9vcHRpb25zID0gY29tbW9uXzEuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgYmluZDogaG9vay5iaW5kLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZURhdGE6IHsgaG9va1R5cGU6IGhvb2tUeXBlLm5hbWUsIGNvbnRleHQ6IG5vZGUgfVxuICAgICAgICAgICAgICAgIH0sIGJhc2VIb29rT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gaG9va1R5cGUuY3JpdGVyaWFNYXRjaFBhdGguc2NvcGUgPT09IGludGVyZmFjZV8xLlRyYW5zaXRpb25Ib29rU2NvcGUuU1RBVEUgPyBub2RlLnN0YXRlLnNlbGYgOiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uSG9vayA9IG5ldyB0cmFuc2l0aW9uSG9va18xLlRyYW5zaXRpb25Ib29rKHRyYW5zaXRpb24sIHN0YXRlLCBob29rLCBfb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaG9vazogaG9vaywgbm9kZTogbm9kZSwgdHJhbnNpdGlvbkhvb2s6IHRyYW5zaXRpb25Ib29rIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1hdGNoaW5nSG9va3MubWFwKG1ha2VUcmFuc2l0aW9uSG9va3MpXG4gICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKVxuICAgICAgICAgICAgLnNvcnQodHVwbGVTb3J0KGhvb2tUeXBlLnJldmVyc2VTb3J0KSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHR1cGxlKSB7IHJldHVybiB0dXBsZS50cmFuc2l0aW9uSG9vazsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaW5kcyBhbGwgUmVnaXN0ZXJlZEhvb2tzIGZyb206XG4gICAgICogLSBUaGUgVHJhbnNpdGlvbiBvYmplY3QgaW5zdGFuY2UgaG9vayByZWdpc3RyeVxuICAgICAqIC0gVGhlIFRyYW5zaXRpb25TZXJ2aWNlICgkdHJhbnNpdGlvbnMpIGdsb2JhbCBob29rIHJlZ2lzdHJ5XG4gICAgICpcbiAgICAgKiB3aGljaCBtYXRjaGVkOlxuICAgICAqIC0gdGhlIGV2ZW50VHlwZVxuICAgICAqIC0gdGhlIG1hdGNoQ3JpdGVyaWEgKHRvLCBmcm9tLCBleGl0aW5nLCByZXRhaW5lZCwgZW50ZXJpbmcpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBtYXRjaGVkIFtbUmVnaXN0ZXJlZEhvb2tdXXNcbiAgICAgKi9cbiAgICBIb29rQnVpbGRlci5wcm90b3R5cGUuZ2V0TWF0Y2hpbmdIb29rcyA9IGZ1bmN0aW9uIChob29rVHlwZSwgdHJlZUNoYW5nZXMpIHtcbiAgICAgICAgdmFyIGlzQ3JlYXRlID0gaG9va1R5cGUuaG9va1BoYXNlID09PSBpbnRlcmZhY2VfMS5UcmFuc2l0aW9uSG9va1BoYXNlLkNSRUFURTtcbiAgICAgICAgLy8gSW5zdGFuY2UgYW5kIEdsb2JhbCBob29rIHJlZ2lzdHJpZXNcbiAgICAgICAgdmFyICR0cmFuc2l0aW9ucyA9IHRoaXMudHJhbnNpdGlvbi5yb3V0ZXIudHJhbnNpdGlvblNlcnZpY2U7XG4gICAgICAgIHZhciByZWdpc3RyaWVzID0gaXNDcmVhdGUgPyBbJHRyYW5zaXRpb25zXSA6IFt0aGlzLnRyYW5zaXRpb24sICR0cmFuc2l0aW9uc107XG4gICAgICAgIHJldHVybiByZWdpc3RyaWVzLm1hcChmdW5jdGlvbiAocmVnKSB7IHJldHVybiByZWcuZ2V0SG9va3MoaG9va1R5cGUubmFtZSk7IH0pIC8vIEdldCBuYW1lZCBob29rcyBmcm9tIHJlZ2lzdHJpZXNcbiAgICAgICAgICAgIC5maWx0ZXIoY29tbW9uXzEuYXNzZXJ0UHJlZGljYXRlKHByZWRpY2F0ZXNfMS5pc0FycmF5LCBcImJyb2tlbiBldmVudCBuYW1lZDogXCIgKyBob29rVHlwZS5uYW1lKSkgLy8gU2FuaXR5IGNoZWNrXG4gICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKSAvLyBVbi1uZXN0IFJlZ2lzdGVyZWRIb29rW11bXSB0byBSZWdpc3RlcmVkSG9va1tdIGFycmF5XG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChob29rKSB7IHJldHVybiBob29rLm1hdGNoZXModHJlZUNoYW5nZXMpOyB9KTsgLy8gT25seSB0aG9zZSBzYXRpc2Z5aW5nIG1hdGNoQ3JpdGVyaWFcbiAgICB9O1xuICAgIHJldHVybiBIb29rQnVpbGRlcjtcbn0oKSk7XG5leHBvcnRzLkhvb2tCdWlsZGVyID0gSG9va0J1aWxkZXI7XG4vKipcbiAqIEEgZmFjdG9yeSBmb3IgYSBzb3J0IGZ1bmN0aW9uIGZvciBIb29rVHVwbGVzLlxuICpcbiAqIFRoZSBzb3J0IGZ1bmN0aW9uIGZpcnN0IGNvbXBhcmVzIHRoZSBQYXRoTm9kZSBkZXB0aCAoaG93IGRlZXAgaW4gdGhlIHN0YXRlIHRyZWUgYSBub2RlIGlzKSwgdGhlbiBjb21wYXJlc1xuICogdGhlIEV2ZW50SG9vayBwcmlvcml0eS5cbiAqXG4gKiBAcGFyYW0gcmV2ZXJzZURlcHRoU29ydCBhIGJvb2xlYW4sIHdoZW4gdHJ1ZSwgcmV2ZXJzZXMgdGhlIHNvcnQgb3JkZXIgZm9yIHRoZSBub2RlIGRlcHRoXG4gKiBAcmV0dXJucyBhIHR1cGxlIHNvcnQgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gdHVwbGVTb3J0KHJldmVyc2VEZXB0aFNvcnQpIHtcbiAgICBpZiAocmV2ZXJzZURlcHRoU29ydCA9PT0gdm9pZCAwKSB7IHJldmVyc2VEZXB0aFNvcnQgPSBmYWxzZTsgfVxuICAgIHJldHVybiBmdW5jdGlvbiBub2RlRGVwdGhUaGVuUHJpb3JpdHkobCwgcikge1xuICAgICAgICB2YXIgZmFjdG9yID0gcmV2ZXJzZURlcHRoU29ydCA/IC0xIDogMTtcbiAgICAgICAgdmFyIGRlcHRoRGVsdGEgPSAobC5ub2RlLnN0YXRlLnBhdGgubGVuZ3RoIC0gci5ub2RlLnN0YXRlLnBhdGgubGVuZ3RoKSAqIGZhY3RvcjtcbiAgICAgICAgcmV0dXJuIGRlcHRoRGVsdGEgIT09IDAgPyBkZXB0aERlbHRhIDogci5ob29rLnByaW9yaXR5IC0gbC5ob29rLnByaW9yaXR5O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob29rQnVpbGRlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vaG9va0J1aWxkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///39\n")},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nvar transitionHook_1 = __webpack_require__(/*! ./transitionHook */ 13);\n/**\n * This class defines a type of hook, such as `onBefore` or `onEnter`.\n * Plugins can define custom hook types, such as sticky states does for `onInactive`.\n *\n * @interalapi\n */\nvar TransitionEventType = /** @class */ (function () {\n    function TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {\n        if (reverseSort === void 0) { reverseSort = false; }\n        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n        if (synchronous === void 0) { synchronous = false; }\n        this.name = name;\n        this.hookPhase = hookPhase;\n        this.hookOrder = hookOrder;\n        this.criteriaMatchPath = criteriaMatchPath;\n        this.reverseSort = reverseSort;\n        this.getResultHandler = getResultHandler;\n        this.getErrorHandler = getErrorHandler;\n        this.synchronous = synchronous;\n    }\n    return TransitionEventType;\n}());\nexports.TransitionEventType = TransitionEventType;\n//# sourceMappingURL=transitionEventType.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL3RyYW5zaXRpb25FdmVudFR5cGUuanM/MWRkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0cmFuc2l0aW9uSG9va18xID0gcmVxdWlyZShcIi4vdHJhbnNpdGlvbkhvb2tcIik7XG4vKipcbiAqIFRoaXMgY2xhc3MgZGVmaW5lcyBhIHR5cGUgb2YgaG9vaywgc3VjaCBhcyBgb25CZWZvcmVgIG9yIGBvbkVudGVyYC5cbiAqIFBsdWdpbnMgY2FuIGRlZmluZSBjdXN0b20gaG9vayB0eXBlcywgc3VjaCBhcyBzdGlja3kgc3RhdGVzIGRvZXMgZm9yIGBvbkluYWN0aXZlYC5cbiAqXG4gKiBAaW50ZXJhbGFwaVxuICovXG52YXIgVHJhbnNpdGlvbkV2ZW50VHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmFuc2l0aW9uRXZlbnRUeXBlKG5hbWUsIGhvb2tQaGFzZSwgaG9va09yZGVyLCBjcml0ZXJpYU1hdGNoUGF0aCwgcmV2ZXJzZVNvcnQsIGdldFJlc3VsdEhhbmRsZXIsIGdldEVycm9ySGFuZGxlciwgc3luY2hyb25vdXMpIHtcbiAgICAgICAgaWYgKHJldmVyc2VTb3J0ID09PSB2b2lkIDApIHsgcmV2ZXJzZVNvcnQgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoZ2V0UmVzdWx0SGFuZGxlciA9PT0gdm9pZCAwKSB7IGdldFJlc3VsdEhhbmRsZXIgPSB0cmFuc2l0aW9uSG9va18xLlRyYW5zaXRpb25Ib29rLkhBTkRMRV9SRVNVTFQ7IH1cbiAgICAgICAgaWYgKGdldEVycm9ySGFuZGxlciA9PT0gdm9pZCAwKSB7IGdldEVycm9ySGFuZGxlciA9IHRyYW5zaXRpb25Ib29rXzEuVHJhbnNpdGlvbkhvb2suUkVKRUNUX0VSUk9SOyB9XG4gICAgICAgIGlmIChzeW5jaHJvbm91cyA9PT0gdm9pZCAwKSB7IHN5bmNocm9ub3VzID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5ob29rUGhhc2UgPSBob29rUGhhc2U7XG4gICAgICAgIHRoaXMuaG9va09yZGVyID0gaG9va09yZGVyO1xuICAgICAgICB0aGlzLmNyaXRlcmlhTWF0Y2hQYXRoID0gY3JpdGVyaWFNYXRjaFBhdGg7XG4gICAgICAgIHRoaXMucmV2ZXJzZVNvcnQgPSByZXZlcnNlU29ydDtcbiAgICAgICAgdGhpcy5nZXRSZXN1bHRIYW5kbGVyID0gZ2V0UmVzdWx0SGFuZGxlcjtcbiAgICAgICAgdGhpcy5nZXRFcnJvckhhbmRsZXIgPSBnZXRFcnJvckhhbmRsZXI7XG4gICAgICAgIHRoaXMuc3luY2hyb25vdXMgPSBzeW5jaHJvbm91cztcbiAgICB9XG4gICAgcmV0dXJuIFRyYW5zaXRpb25FdmVudFR5cGU7XG59KCkpO1xuZXhwb3J0cy5UcmFuc2l0aW9uRXZlbnRUeXBlID0gVHJhbnNpdGlvbkV2ZW50VHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zaXRpb25FdmVudFR5cGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL3RyYW5zaXRpb25FdmVudFR5cGUuanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///40\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @internalapi\n * @module url\n */ /** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ 1);\nvar urlMatcher_1 = __webpack_require__(/*! ./urlMatcher */ 19);\nvar param_1 = __webpack_require__(/*! ../params/param */ 8);\nvar paramTypes_1 = __webpack_require__(/*! ../params/paramTypes */ 30);\n/**\n * Factory for [[UrlMatcher]] instances.\n *\n * The factory is available to ng1 services as\n * `$urlMatcherFactory` or ng1 providers as `$urlMatcherFactoryProvider`.\n */\nvar UrlMatcherFactory = /** @class */ (function () {\n    function UrlMatcherFactory() {\n        var _this = this;\n        /** @hidden */ this.paramTypes = new paramTypes_1.ParamTypes();\n        /** @hidden */ this._isCaseInsensitive = false;\n        /** @hidden */ this._isStrictMode = true;\n        /** @hidden */ this._defaultSquashPolicy = false;\n        /** @hidden */\n        this._getConfig = function (config) {\n            return common_1.extend({ strict: _this._isStrictMode, caseInsensitive: _this._isCaseInsensitive }, config);\n        };\n        /** @internalapi Creates a new [[Param]] for a given location (DefType) */\n        this.paramFactory = {\n            /** Creates a new [[Param]] from a CONFIG block */\n            fromConfig: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.CONFIG, _this);\n            },\n            /** Creates a new [[Param]] from a url PATH */\n            fromPath: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.PATH, _this);\n            },\n            /** Creates a new [[Param]] from a url SEARCH */\n            fromSearch: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.SEARCH, _this);\n            },\n        };\n        common_1.extend(this, { UrlMatcher: urlMatcher_1.UrlMatcher, Param: param_1.Param });\n    }\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.caseInsensitive = function (value) {\n        return this._isCaseInsensitive = predicates_1.isDefined(value) ? value : this._isCaseInsensitive;\n    };\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.strictMode = function (value) {\n        return this._isStrictMode = predicates_1.isDefined(value) ? value : this._isStrictMode;\n    };\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.defaultSquashPolicy = function (value) {\n        if (predicates_1.isDefined(value) && value !== true && value !== false && !predicates_1.isString(value))\n            throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");\n        return this._defaultSquashPolicy = predicates_1.isDefined(value) ? value : this._defaultSquashPolicy;\n    };\n    /**\n     * Creates a [[UrlMatcher]] for the specified pattern.\n     *\n     * @param pattern  The URL pattern.\n     * @param config  The config object hash.\n     * @returns The UrlMatcher.\n     */\n    UrlMatcherFactory.prototype.compile = function (pattern, config) {\n        return new urlMatcher_1.UrlMatcher(pattern, this.paramTypes, this.paramFactory, this._getConfig(config));\n    };\n    /**\n     * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.\n     *\n     * @param object  The object to perform the type check against.\n     * @returns `true` if the object matches the `UrlMatcher` interface, by\n     *          implementing all the same methods.\n     */\n    UrlMatcherFactory.prototype.isMatcher = function (object) {\n        // TODO: typeof?\n        if (!predicates_1.isObject(object))\n            return false;\n        var result = true;\n        common_1.forEach(urlMatcher_1.UrlMatcher.prototype, function (val, name) {\n            if (predicates_1.isFunction(val))\n                result = result && (predicates_1.isDefined(object[name]) && predicates_1.isFunction(object[name]));\n        });\n        return result;\n    };\n    ;\n    /**\n     * Creates and registers a custom [[ParamType]] object\n     *\n     * A [[ParamType]] can be used to generate URLs with typed parameters.\n     *\n     * @param name  The type name.\n     * @param definition The type definition. See [[ParamTypeDefinition]] for information on the values accepted.\n     * @param definitionFn A function that is injected before the app runtime starts.\n     *        The result of this function should be a [[ParamTypeDefinition]].\n     *        The result is merged into the existing `definition`.\n     *        See [[ParamType]] for information on the values accepted.\n     *\n     * @returns - if a type was registered: the [[UrlMatcherFactory]]\n     *   - if only the `name` parameter was specified: the currently registered [[ParamType]] object, or undefined\n     *\n     * Note: Register custom types *before using them* in a state definition.\n     *\n     * See [[ParamTypeDefinition]] for examples\n     */\n    UrlMatcherFactory.prototype.type = function (name, definition, definitionFn) {\n        var type = this.paramTypes.type(name, definition, definitionFn);\n        return !predicates_1.isDefined(definition) ? type : this;\n    };\n    ;\n    /** @hidden */\n    UrlMatcherFactory.prototype.$get = function () {\n        this.paramTypes.enqueue = false;\n        this.paramTypes._flushTypeQueue();\n        return this;\n    };\n    ;\n    /** @internalapi */\n    UrlMatcherFactory.prototype.dispose = function () {\n        this.paramTypes.dispose();\n    };\n    return UrlMatcherFactory;\n}());\nexports.UrlMatcherFactory = UrlMatcherFactory;\n//# sourceMappingURL=urlMatcherFactory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi91cmwvdXJsTWF0Y2hlckZhY3RvcnkuanM/OWNjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGludGVybmFsYXBpXG4gKiBAbW9kdWxlIHVybFxuICovIC8qKiBmb3IgdHlwZWRvYyAqL1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIHVybE1hdGNoZXJfMSA9IHJlcXVpcmUoXCIuL3VybE1hdGNoZXJcIik7XG52YXIgcGFyYW1fMSA9IHJlcXVpcmUoXCIuLi9wYXJhbXMvcGFyYW1cIik7XG52YXIgcGFyYW1UeXBlc18xID0gcmVxdWlyZShcIi4uL3BhcmFtcy9wYXJhbVR5cGVzXCIpO1xuLyoqXG4gKiBGYWN0b3J5IGZvciBbW1VybE1hdGNoZXJdXSBpbnN0YW5jZXMuXG4gKlxuICogVGhlIGZhY3RvcnkgaXMgYXZhaWxhYmxlIHRvIG5nMSBzZXJ2aWNlcyBhc1xuICogYCR1cmxNYXRjaGVyRmFjdG9yeWAgb3IgbmcxIHByb3ZpZGVycyBhcyBgJHVybE1hdGNoZXJGYWN0b3J5UHJvdmlkZXJgLlxuICovXG52YXIgVXJsTWF0Y2hlckZhY3RvcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVXJsTWF0Y2hlckZhY3RvcnkoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qKiBAaGlkZGVuICovIHRoaXMucGFyYW1UeXBlcyA9IG5ldyBwYXJhbVR5cGVzXzEuUGFyYW1UeXBlcygpO1xuICAgICAgICAvKiogQGhpZGRlbiAqLyB0aGlzLl9pc0Nhc2VJbnNlbnNpdGl2ZSA9IGZhbHNlO1xuICAgICAgICAvKiogQGhpZGRlbiAqLyB0aGlzLl9pc1N0cmljdE1vZGUgPSB0cnVlO1xuICAgICAgICAvKiogQGhpZGRlbiAqLyB0aGlzLl9kZWZhdWx0U3F1YXNoUG9saWN5ID0gZmFsc2U7XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuX2dldENvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21tb25fMS5leHRlbmQoeyBzdHJpY3Q6IF90aGlzLl9pc1N0cmljdE1vZGUsIGNhc2VJbnNlbnNpdGl2ZTogX3RoaXMuX2lzQ2FzZUluc2Vuc2l0aXZlIH0sIGNvbmZpZyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWxhcGkgQ3JlYXRlcyBhIG5ldyBbW1BhcmFtXV0gZm9yIGEgZ2l2ZW4gbG9jYXRpb24gKERlZlR5cGUpICovXG4gICAgICAgIHRoaXMucGFyYW1GYWN0b3J5ID0ge1xuICAgICAgICAgICAgLyoqIENyZWF0ZXMgYSBuZXcgW1tQYXJhbV1dIGZyb20gYSBDT05GSUcgYmxvY2sgKi9cbiAgICAgICAgICAgIGZyb21Db25maWc6IGZ1bmN0aW9uIChpZCwgdHlwZSwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBwYXJhbV8xLlBhcmFtKGlkLCB0eXBlLCBjb25maWcsIHBhcmFtXzEuRGVmVHlwZS5DT05GSUcsIF90aGlzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKiogQ3JlYXRlcyBhIG5ldyBbW1BhcmFtXV0gZnJvbSBhIHVybCBQQVRIICovXG4gICAgICAgICAgICBmcm9tUGF0aDogZnVuY3Rpb24gKGlkLCB0eXBlLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHBhcmFtXzEuUGFyYW0oaWQsIHR5cGUsIGNvbmZpZywgcGFyYW1fMS5EZWZUeXBlLlBBVEgsIF90aGlzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKiogQ3JlYXRlcyBhIG5ldyBbW1BhcmFtXV0gZnJvbSBhIHVybCBTRUFSQ0ggKi9cbiAgICAgICAgICAgIGZyb21TZWFyY2g6IGZ1bmN0aW9uIChpZCwgdHlwZSwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBwYXJhbV8xLlBhcmFtKGlkLCB0eXBlLCBjb25maWcsIHBhcmFtXzEuRGVmVHlwZS5TRUFSQ0gsIF90aGlzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbW1vbl8xLmV4dGVuZCh0aGlzLCB7IFVybE1hdGNoZXI6IHVybE1hdGNoZXJfMS5VcmxNYXRjaGVyLCBQYXJhbTogcGFyYW1fMS5QYXJhbSB9KTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsTWF0Y2hlckZhY3RvcnkucHJvdG90eXBlLmNhc2VJbnNlbnNpdGl2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNDYXNlSW5zZW5zaXRpdmUgPSBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHZhbHVlKSA/IHZhbHVlIDogdGhpcy5faXNDYXNlSW5zZW5zaXRpdmU7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxNYXRjaGVyRmFjdG9yeS5wcm90b3R5cGUuc3RyaWN0TW9kZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNTdHJpY3RNb2RlID0gcHJlZGljYXRlc18xLmlzRGVmaW5lZCh2YWx1ZSkgPyB2YWx1ZSA6IHRoaXMuX2lzU3RyaWN0TW9kZTtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybE1hdGNoZXJGYWN0b3J5LnByb3RvdHlwZS5kZWZhdWx0U3F1YXNoUG9saWN5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHZhbHVlKSAmJiB2YWx1ZSAhPT0gdHJ1ZSAmJiB2YWx1ZSAhPT0gZmFsc2UgJiYgIXByZWRpY2F0ZXNfMS5pc1N0cmluZyh2YWx1ZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNxdWFzaCBwb2xpY3k6IFwiICsgdmFsdWUgKyBcIi4gVmFsaWQgcG9saWNpZXM6IGZhbHNlLCB0cnVlLCBhcmJpdHJhcnktc3RyaW5nXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdFNxdWFzaFBvbGljeSA9IHByZWRpY2F0ZXNfMS5pc0RlZmluZWQodmFsdWUpID8gdmFsdWUgOiB0aGlzLl9kZWZhdWx0U3F1YXNoUG9saWN5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFtbVXJsTWF0Y2hlcl1dIGZvciB0aGUgc3BlY2lmaWVkIHBhdHRlcm4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0dGVybiAgVGhlIFVSTCBwYXR0ZXJuLlxuICAgICAqIEBwYXJhbSBjb25maWcgIFRoZSBjb25maWcgb2JqZWN0IGhhc2guXG4gICAgICogQHJldHVybnMgVGhlIFVybE1hdGNoZXIuXG4gICAgICovXG4gICAgVXJsTWF0Y2hlckZhY3RvcnkucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbiAocGF0dGVybiwgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgdXJsTWF0Y2hlcl8xLlVybE1hdGNoZXIocGF0dGVybiwgdGhpcy5wYXJhbVR5cGVzLCB0aGlzLnBhcmFtRmFjdG9yeSwgdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGlzIGEgW1tVcmxNYXRjaGVyXV0sIG9yIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvYmplY3QgIFRoZSBvYmplY3QgdG8gcGVyZm9ybSB0aGUgdHlwZSBjaGVjayBhZ2FpbnN0LlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0IG1hdGNoZXMgdGhlIGBVcmxNYXRjaGVyYCBpbnRlcmZhY2UsIGJ5XG4gICAgICogICAgICAgICAgaW1wbGVtZW50aW5nIGFsbCB0aGUgc2FtZSBtZXRob2RzLlxuICAgICAqL1xuICAgIFVybE1hdGNoZXJGYWN0b3J5LnByb3RvdHlwZS5pc01hdGNoZXIgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgIC8vIFRPRE86IHR5cGVvZj9cbiAgICAgICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNPYmplY3Qob2JqZWN0KSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICAgIGNvbW1vbl8xLmZvckVhY2godXJsTWF0Y2hlcl8xLlVybE1hdGNoZXIucHJvdG90eXBlLCBmdW5jdGlvbiAodmFsLCBuYW1lKSB7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzRnVuY3Rpb24odmFsKSlcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgJiYgKHByZWRpY2F0ZXNfMS5pc0RlZmluZWQob2JqZWN0W25hbWVdKSAmJiBwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihvYmplY3RbbmFtZV0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgcmVnaXN0ZXJzIGEgY3VzdG9tIFtbUGFyYW1UeXBlXV0gb2JqZWN0XG4gICAgICpcbiAgICAgKiBBIFtbUGFyYW1UeXBlXV0gY2FuIGJlIHVzZWQgdG8gZ2VuZXJhdGUgVVJMcyB3aXRoIHR5cGVkIHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSAgVGhlIHR5cGUgbmFtZS5cbiAgICAgKiBAcGFyYW0gZGVmaW5pdGlvbiBUaGUgdHlwZSBkZWZpbml0aW9uLiBTZWUgW1tQYXJhbVR5cGVEZWZpbml0aW9uXV0gZm9yIGluZm9ybWF0aW9uIG9uIHRoZSB2YWx1ZXMgYWNjZXB0ZWQuXG4gICAgICogQHBhcmFtIGRlZmluaXRpb25GbiBBIGZ1bmN0aW9uIHRoYXQgaXMgaW5qZWN0ZWQgYmVmb3JlIHRoZSBhcHAgcnVudGltZSBzdGFydHMuXG4gICAgICogICAgICAgIFRoZSByZXN1bHQgb2YgdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgYSBbW1BhcmFtVHlwZURlZmluaXRpb25dXS5cbiAgICAgKiAgICAgICAgVGhlIHJlc3VsdCBpcyBtZXJnZWQgaW50byB0aGUgZXhpc3RpbmcgYGRlZmluaXRpb25gLlxuICAgICAqICAgICAgICBTZWUgW1tQYXJhbVR5cGVdXSBmb3IgaW5mb3JtYXRpb24gb24gdGhlIHZhbHVlcyBhY2NlcHRlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gaWYgYSB0eXBlIHdhcyByZWdpc3RlcmVkOiB0aGUgW1tVcmxNYXRjaGVyRmFjdG9yeV1dXG4gICAgICogICAtIGlmIG9ubHkgdGhlIGBuYW1lYCBwYXJhbWV0ZXIgd2FzIHNwZWNpZmllZDogdGhlIGN1cnJlbnRseSByZWdpc3RlcmVkIFtbUGFyYW1UeXBlXV0gb2JqZWN0LCBvciB1bmRlZmluZWRcbiAgICAgKlxuICAgICAqIE5vdGU6IFJlZ2lzdGVyIGN1c3RvbSB0eXBlcyAqYmVmb3JlIHVzaW5nIHRoZW0qIGluIGEgc3RhdGUgZGVmaW5pdGlvbi5cbiAgICAgKlxuICAgICAqIFNlZSBbW1BhcmFtVHlwZURlZmluaXRpb25dXSBmb3IgZXhhbXBsZXNcbiAgICAgKi9cbiAgICBVcmxNYXRjaGVyRmFjdG9yeS5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uIChuYW1lLCBkZWZpbml0aW9uLCBkZWZpbml0aW9uRm4pIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnBhcmFtVHlwZXMudHlwZShuYW1lLCBkZWZpbml0aW9uLCBkZWZpbml0aW9uRm4pO1xuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZXNfMS5pc0RlZmluZWQoZGVmaW5pdGlvbikgPyB0eXBlIDogdGhpcztcbiAgICB9O1xuICAgIDtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFVybE1hdGNoZXJGYWN0b3J5LnByb3RvdHlwZS4kZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBhcmFtVHlwZXMuZW5xdWV1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhcmFtVHlwZXMuX2ZsdXNoVHlwZVF1ZXVlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgO1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICBVcmxNYXRjaGVyRmFjdG9yeS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wYXJhbVR5cGVzLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBVcmxNYXRjaGVyRmFjdG9yeTtcbn0oKSk7XG5leHBvcnRzLlVybE1hdGNoZXJGYWN0b3J5ID0gVXJsTWF0Y2hlckZhY3Rvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmxNYXRjaGVyRmFjdG9yeS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL3VybC91cmxNYXRjaGVyRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///41\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @internalapi\n * @module url\n */\n/** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ 1);\nvar urlMatcher_1 = __webpack_require__(/*! ./urlMatcher */ 19);\nvar hof_1 = __webpack_require__(/*! ../common/hof */ 2);\nvar urlRule_1 = __webpack_require__(/*! ./urlRule */ 43);\nvar targetState_1 = __webpack_require__(/*! ../state/targetState */ 9);\nvar common_2 = __webpack_require__(/*! ../common */ 5);\n/** @hidden */\nfunction appendBasePath(url, isHtml5, absolute, baseHref) {\n    if (baseHref === \'/\')\n        return url;\n    if (isHtml5)\n        return common_2.stripFile(baseHref) + url;\n    if (absolute)\n        return baseHref.slice(1) + url;\n    return url;\n}\n/** @hidden */\nvar prioritySort = function (a, b) {\n    return (b.priority || 0) - (a.priority || 0);\n};\n/** @hidden */\nvar typeSort = function (a, b) {\n    var weights = { "STATE": 4, "URLMATCHER": 4, "REGEXP": 3, "RAW": 2, "OTHER": 1 };\n    return (weights[a.type] || 0) - (weights[b.type] || 0);\n};\n/** @hidden */\nvar urlMatcherSort = function (a, b) {\n    return !a.urlMatcher || !b.urlMatcher ? 0 : urlMatcher_1.UrlMatcher.compare(a.urlMatcher, b.urlMatcher);\n};\n/** @hidden */\nvar idSort = function (a, b) {\n    // Identically sorted STATE and URLMATCHER best rule will be chosen by `matchPriority` after each rule matches the URL\n    var useMatchPriority = { STATE: true, URLMATCHER: true };\n    var equal = useMatchPriority[a.type] && useMatchPriority[b.type];\n    return equal ? 0 : (a.$id || 0) - (b.$id || 0);\n};\n/**\n * Default rule priority sorting function.\n *\n * Sorts rules by:\n *\n * - Explicit priority (set rule priority using [[UrlRulesApi.when]])\n * - Rule type (STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1)\n * - `UrlMatcher` specificity ([[UrlMatcher.compare]]): works for STATE and URLMATCHER types to pick the most specific rule.\n * - Rule registration order (for rule types other than STATE and URLMATCHER)\n *   - Equally sorted State and UrlMatcher rules will each match the URL.\n *     Then, the *best* match is chosen based on how many parameter values were matched.\n *\n * @coreapi\n */\nvar defaultRuleSortFn;\ndefaultRuleSortFn = function (a, b) {\n    var cmp = prioritySort(a, b);\n    if (cmp !== 0)\n        return cmp;\n    cmp = typeSort(a, b);\n    if (cmp !== 0)\n        return cmp;\n    cmp = urlMatcherSort(a, b);\n    if (cmp !== 0)\n        return cmp;\n    return idSort(a, b);\n};\n/**\n * Updates URL and responds to URL changes\n *\n * ### Deprecation warning:\n * This class is now considered to be an internal API\n * Use the [[UrlService]] instead.\n * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].\n *\n * This class updates the URL when the state changes.\n * It also responds to changes in the URL.\n */\nvar UrlRouter = /** @class */ (function () {\n    /** @hidden */\n    function UrlRouter(router) {\n        /** @hidden */ this._sortFn = defaultRuleSortFn;\n        /** @hidden */ this._rules = [];\n        /** @hidden */ this.interceptDeferred = false;\n        /** @hidden */ this._id = 0;\n        /** @hidden */ this._sorted = false;\n        this._router = router;\n        this.urlRuleFactory = new urlRule_1.UrlRuleFactory(router);\n        common_1.createProxyFunctions(hof_1.val(UrlRouter.prototype), this, hof_1.val(this));\n    }\n    /** @internalapi */\n    UrlRouter.prototype.dispose = function () {\n        this.listen(false);\n        this._rules = [];\n        delete this._otherwiseFn;\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.sort = function (compareFn) {\n        this._rules = this.stableSort(this._rules, this._sortFn = compareFn || this._sortFn);\n        this._sorted = true;\n    };\n    UrlRouter.prototype.ensureSorted = function () {\n        this._sorted || this.sort();\n    };\n    UrlRouter.prototype.stableSort = function (arr, compareFn) {\n        var arrOfWrapper = arr.map(function (elem, idx) { return ({ elem: elem, idx: idx }); });\n        arrOfWrapper.sort(function (wrapperA, wrapperB) {\n            var cmpDiff = compareFn(wrapperA.elem, wrapperB.elem);\n            return cmpDiff === 0\n                ? wrapperA.idx - wrapperB.idx\n                : cmpDiff;\n        });\n        return arrOfWrapper.map(function (wrapper) { return wrapper.elem; });\n    };\n    /**\n     * Given a URL, check all rules and return the best [[MatchResult]]\n     * @param url\n     * @returns {MatchResult}\n     */\n    UrlRouter.prototype.match = function (url) {\n        var _this = this;\n        this.ensureSorted();\n        url = common_1.extend({ path: \'\', search: {}, hash: \'\' }, url);\n        var rules = this.rules();\n        if (this._otherwiseFn)\n            rules.push(this._otherwiseFn);\n        // Checks a single rule. Returns { rule: rule, match: match, weight: weight } if it matched, or undefined\n        var checkRule = function (rule) {\n            var match = rule.match(url, _this._router);\n            return match && { match: match, rule: rule, weight: rule.matchPriority(match) };\n        };\n        // The rules are pre-sorted.\n        // - Find the first matching rule.\n        // - Find any other matching rule that sorted *exactly the same*, according to `.sort()`.\n        // - Choose the rule with the highest match weight.\n        var best;\n        for (var i = 0; i < rules.length; i++) {\n            // Stop when there is a \'best\' rule and the next rule sorts differently than it.\n            if (best && this._sortFn(rules[i], best.rule) !== 0)\n                break;\n            var current = checkRule(rules[i]);\n            // Pick the best MatchResult\n            best = (!best || current && current.weight > best.weight) ? current : best;\n        }\n        return best;\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.sync = function (evt) {\n        if (evt && evt.defaultPrevented)\n            return;\n        var router = this._router, $url = router.urlService, $state = router.stateService;\n        var url = {\n            path: $url.path(), search: $url.search(), hash: $url.hash(),\n        };\n        var best = this.match(url);\n        var applyResult = hof_1.pattern([\n            [predicates_1.isString, function (newurl) { return $url.url(newurl, true); }],\n            [targetState_1.TargetState.isDef, function (def) { return $state.go(def.state, def.params, def.options); }],\n            [hof_1.is(targetState_1.TargetState), function (target) { return $state.go(target.state(), target.params(), target.options()); }],\n        ]);\n        applyResult(best && best.rule.handler(best.match, url, router));\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.listen = function (enabled) {\n        var _this = this;\n        if (enabled === false) {\n            this._stopFn && this._stopFn();\n            delete this._stopFn;\n        }\n        else {\n            return this._stopFn = this._stopFn || this._router.urlService.onChange(function (evt) { return _this.sync(evt); });\n        }\n    };\n    /**\n     * Internal API.\n     * @internalapi\n     */\n    UrlRouter.prototype.update = function (read) {\n        var $url = this._router.locationService;\n        if (read) {\n            this.location = $url.path();\n            return;\n        }\n        if ($url.path() === this.location)\n            return;\n        $url.url(this.location, true);\n    };\n    /**\n     * Internal API.\n     *\n     * Pushes a new location to the browser history.\n     *\n     * @internalapi\n     * @param urlMatcher\n     * @param params\n     * @param options\n     */\n    UrlRouter.prototype.push = function (urlMatcher, params, options) {\n        var replace = options && !!options.replace;\n        this._router.urlService.url(urlMatcher.format(params || {}), replace);\n    };\n    /**\n     * Builds and returns a URL with interpolated parameters\n     *\n     * #### Example:\n     * ```js\n     * matcher = $umf.compile("/about/:person");\n     * params = { person: "bob" };\n     * $bob = $urlRouter.href(matcher, params);\n     * // $bob == "/about/bob";\n     * ```\n     *\n     * @param urlMatcher The [[UrlMatcher]] object which is used as the template of the URL to generate.\n     * @param params An object of parameter values to fill the matcher\'s required parameters.\n     * @param options Options object. The options are:\n     *\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".\n     *\n     * @returns Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n     */\n    UrlRouter.prototype.href = function (urlMatcher, params, options) {\n        var url = urlMatcher.format(params);\n        if (url == null)\n            return null;\n        options = options || { absolute: false };\n        var cfg = this._router.urlService.config;\n        var isHtml5 = cfg.html5Mode();\n        if (!isHtml5 && url !== null) {\n            url = "#" + cfg.hashPrefix() + url;\n        }\n        url = appendBasePath(url, isHtml5, options.absolute, cfg.baseHref());\n        if (!options.absolute || !url) {\n            return url;\n        }\n        var slash = (!isHtml5 && url ? \'/\' : \'\'), port = cfg.port();\n        port = (port === 80 || port === 443 ? \'\' : \':\' + port);\n        return [cfg.protocol(), \'://\', cfg.host(), port, slash, url].join(\'\');\n    };\n    /**\n     * Manually adds a URL Rule.\n     *\n     * Usually, a url rule is added using [[StateDeclaration.url]] or [[when]].\n     * This api can be used directly for more control (to register a [[BaseUrlRule]], for example).\n     * Rules can be created using [[UrlRouter.urlRuleFactory]], or create manually as simple objects.\n     *\n     * A rule should have a `match` function which returns truthy if the rule matched.\n     * It should also have a `handler` function which is invoked if the rule is the best match.\n     *\n     * @return a function that deregisters the rule\n     */\n    UrlRouter.prototype.rule = function (rule) {\n        var _this = this;\n        if (!urlRule_1.UrlRuleFactory.isUrlRule(rule))\n            throw new Error("invalid rule");\n        rule.$id = this._id++;\n        rule.priority = rule.priority || 0;\n        this._rules.push(rule);\n        this._sorted = false;\n        return function () { return _this.removeRule(rule); };\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.removeRule = function (rule) {\n        common_1.removeFrom(this._rules, rule);\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.rules = function () {\n        this.ensureSorted();\n        return this._rules.slice();\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.otherwise = function (handler) {\n        var handlerFn = getHandlerFn(handler);\n        this._otherwiseFn = this.urlRuleFactory.create(hof_1.val(true), handlerFn);\n        this._sorted = false;\n    };\n    ;\n    /** @inheritdoc */\n    UrlRouter.prototype.initial = function (handler) {\n        var handlerFn = getHandlerFn(handler);\n        var matchFn = function (urlParts, router) {\n            return router.globals.transitionHistory.size() === 0 && !!/^\\/?$/.exec(urlParts.path);\n        };\n        this.rule(this.urlRuleFactory.create(matchFn, handlerFn));\n    };\n    ;\n    /** @inheritdoc */\n    UrlRouter.prototype.when = function (matcher, handler, options) {\n        var rule = this.urlRuleFactory.create(matcher, handler);\n        if (predicates_1.isDefined(options && options.priority))\n            rule.priority = options.priority;\n        this.rule(rule);\n        return rule;\n    };\n    ;\n    /** @inheritdoc */\n    UrlRouter.prototype.deferIntercept = function (defer) {\n        if (defer === undefined)\n            defer = true;\n        this.interceptDeferred = defer;\n    };\n    ;\n    return UrlRouter;\n}());\nexports.UrlRouter = UrlRouter;\nfunction getHandlerFn(handler) {\n    if (!predicates_1.isFunction(handler) && !predicates_1.isString(handler) && !hof_1.is(targetState_1.TargetState)(handler) && !targetState_1.TargetState.isDef(handler)) {\n        throw new Error("\'handler\' must be a string, function, TargetState, or have a state: \'newtarget\' property");\n    }\n    return predicates_1.isFunction(handler) ? handler : hof_1.val(handler);\n}\n//# sourceMappingURL=urlRouter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi91cmwvdXJsUm91dGVyLmpzPzQwYjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogQG1vZHVsZSB1cmxcbiAqL1xuLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgdXJsTWF0Y2hlcl8xID0gcmVxdWlyZShcIi4vdXJsTWF0Y2hlclwiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIHVybFJ1bGVfMSA9IHJlcXVpcmUoXCIuL3VybFJ1bGVcIik7XG52YXIgdGFyZ2V0U3RhdGVfMSA9IHJlcXVpcmUoXCIuLi9zdGF0ZS90YXJnZXRTdGF0ZVwiKTtcbnZhciBjb21tb25fMiA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gYXBwZW5kQmFzZVBhdGgodXJsLCBpc0h0bWw1LCBhYnNvbHV0ZSwgYmFzZUhyZWYpIHtcbiAgICBpZiAoYmFzZUhyZWYgPT09ICcvJylcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICBpZiAoaXNIdG1sNSlcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8yLnN0cmlwRmlsZShiYXNlSHJlZikgKyB1cmw7XG4gICAgaWYgKGFic29sdXRlKVxuICAgICAgICByZXR1cm4gYmFzZUhyZWYuc2xpY2UoMSkgKyB1cmw7XG4gICAgcmV0dXJuIHVybDtcbn1cbi8qKiBAaGlkZGVuICovXG52YXIgcHJpb3JpdHlTb3J0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gKGIucHJpb3JpdHkgfHwgMCkgLSAoYS5wcmlvcml0eSB8fCAwKTtcbn07XG4vKiogQGhpZGRlbiAqL1xudmFyIHR5cGVTb3J0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgd2VpZ2h0cyA9IHsgXCJTVEFURVwiOiA0LCBcIlVSTE1BVENIRVJcIjogNCwgXCJSRUdFWFBcIjogMywgXCJSQVdcIjogMiwgXCJPVEhFUlwiOiAxIH07XG4gICAgcmV0dXJuICh3ZWlnaHRzW2EudHlwZV0gfHwgMCkgLSAod2VpZ2h0c1tiLnR5cGVdIHx8IDApO1xufTtcbi8qKiBAaGlkZGVuICovXG52YXIgdXJsTWF0Y2hlclNvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiAhYS51cmxNYXRjaGVyIHx8ICFiLnVybE1hdGNoZXIgPyAwIDogdXJsTWF0Y2hlcl8xLlVybE1hdGNoZXIuY29tcGFyZShhLnVybE1hdGNoZXIsIGIudXJsTWF0Y2hlcik7XG59O1xuLyoqIEBoaWRkZW4gKi9cbnZhciBpZFNvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIC8vIElkZW50aWNhbGx5IHNvcnRlZCBTVEFURSBhbmQgVVJMTUFUQ0hFUiBiZXN0IHJ1bGUgd2lsbCBiZSBjaG9zZW4gYnkgYG1hdGNoUHJpb3JpdHlgIGFmdGVyIGVhY2ggcnVsZSBtYXRjaGVzIHRoZSBVUkxcbiAgICB2YXIgdXNlTWF0Y2hQcmlvcml0eSA9IHsgU1RBVEU6IHRydWUsIFVSTE1BVENIRVI6IHRydWUgfTtcbiAgICB2YXIgZXF1YWwgPSB1c2VNYXRjaFByaW9yaXR5W2EudHlwZV0gJiYgdXNlTWF0Y2hQcmlvcml0eVtiLnR5cGVdO1xuICAgIHJldHVybiBlcXVhbCA/IDAgOiAoYS4kaWQgfHwgMCkgLSAoYi4kaWQgfHwgMCk7XG59O1xuLyoqXG4gKiBEZWZhdWx0IHJ1bGUgcHJpb3JpdHkgc29ydGluZyBmdW5jdGlvbi5cbiAqXG4gKiBTb3J0cyBydWxlcyBieTpcbiAqXG4gKiAtIEV4cGxpY2l0IHByaW9yaXR5IChzZXQgcnVsZSBwcmlvcml0eSB1c2luZyBbW1VybFJ1bGVzQXBpLndoZW5dXSlcbiAqIC0gUnVsZSB0eXBlIChTVEFURTogNCwgVVJMTUFUQ0hFUjogNCwgUkVHRVhQOiAzLCBSQVc6IDIsIE9USEVSOiAxKVxuICogLSBgVXJsTWF0Y2hlcmAgc3BlY2lmaWNpdHkgKFtbVXJsTWF0Y2hlci5jb21wYXJlXV0pOiB3b3JrcyBmb3IgU1RBVEUgYW5kIFVSTE1BVENIRVIgdHlwZXMgdG8gcGljayB0aGUgbW9zdCBzcGVjaWZpYyBydWxlLlxuICogLSBSdWxlIHJlZ2lzdHJhdGlvbiBvcmRlciAoZm9yIHJ1bGUgdHlwZXMgb3RoZXIgdGhhbiBTVEFURSBhbmQgVVJMTUFUQ0hFUilcbiAqICAgLSBFcXVhbGx5IHNvcnRlZCBTdGF0ZSBhbmQgVXJsTWF0Y2hlciBydWxlcyB3aWxsIGVhY2ggbWF0Y2ggdGhlIFVSTC5cbiAqICAgICBUaGVuLCB0aGUgKmJlc3QqIG1hdGNoIGlzIGNob3NlbiBiYXNlZCBvbiBob3cgbWFueSBwYXJhbWV0ZXIgdmFsdWVzIHdlcmUgbWF0Y2hlZC5cbiAqXG4gKiBAY29yZWFwaVxuICovXG52YXIgZGVmYXVsdFJ1bGVTb3J0Rm47XG5kZWZhdWx0UnVsZVNvcnRGbiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGNtcCA9IHByaW9yaXR5U29ydChhLCBiKTtcbiAgICBpZiAoY21wICE9PSAwKVxuICAgICAgICByZXR1cm4gY21wO1xuICAgIGNtcCA9IHR5cGVTb3J0KGEsIGIpO1xuICAgIGlmIChjbXAgIT09IDApXG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgY21wID0gdXJsTWF0Y2hlclNvcnQoYSwgYik7XG4gICAgaWYgKGNtcCAhPT0gMClcbiAgICAgICAgcmV0dXJuIGNtcDtcbiAgICByZXR1cm4gaWRTb3J0KGEsIGIpO1xufTtcbi8qKlxuICogVXBkYXRlcyBVUkwgYW5kIHJlc3BvbmRzIHRvIFVSTCBjaGFuZ2VzXG4gKlxuICogIyMjIERlcHJlY2F0aW9uIHdhcm5pbmc6XG4gKiBUaGlzIGNsYXNzIGlzIG5vdyBjb25zaWRlcmVkIHRvIGJlIGFuIGludGVybmFsIEFQSVxuICogVXNlIHRoZSBbW1VybFNlcnZpY2VdXSBpbnN0ZWFkLlxuICogRm9yIGNvbmZpZ3VyaW5nIFVSTCBydWxlcywgdXNlIHRoZSBbW1VybFJ1bGVzQXBpXV0gd2hpY2ggY2FuIGJlIGZvdW5kIGFzIFtbVXJsU2VydmljZS5ydWxlc11dLlxuICpcbiAqIFRoaXMgY2xhc3MgdXBkYXRlcyB0aGUgVVJMIHdoZW4gdGhlIHN0YXRlIGNoYW5nZXMuXG4gKiBJdCBhbHNvIHJlc3BvbmRzIHRvIGNoYW5nZXMgaW4gdGhlIFVSTC5cbiAqL1xudmFyIFVybFJvdXRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIGZ1bmN0aW9uIFVybFJvdXRlcihyb3V0ZXIpIHtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5fc29ydEZuID0gZGVmYXVsdFJ1bGVTb3J0Rm47XG4gICAgICAgIC8qKiBAaGlkZGVuICovIHRoaXMuX3J1bGVzID0gW107XG4gICAgICAgIC8qKiBAaGlkZGVuICovIHRoaXMuaW50ZXJjZXB0RGVmZXJyZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5faWQgPSAwO1xuICAgICAgICAvKiogQGhpZGRlbiAqLyB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcm91dGVyID0gcm91dGVyO1xuICAgICAgICB0aGlzLnVybFJ1bGVGYWN0b3J5ID0gbmV3IHVybFJ1bGVfMS5VcmxSdWxlRmFjdG9yeShyb3V0ZXIpO1xuICAgICAgICBjb21tb25fMS5jcmVhdGVQcm94eUZ1bmN0aW9ucyhob2ZfMS52YWwoVXJsUm91dGVyLnByb3RvdHlwZSksIHRoaXMsIGhvZl8xLnZhbCh0aGlzKSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGlzdGVuKGZhbHNlKTtcbiAgICAgICAgdGhpcy5fcnVsZXMgPSBbXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX290aGVyd2lzZUZuO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gKGNvbXBhcmVGbikge1xuICAgICAgICB0aGlzLl9ydWxlcyA9IHRoaXMuc3RhYmxlU29ydCh0aGlzLl9ydWxlcywgdGhpcy5fc29ydEZuID0gY29tcGFyZUZuIHx8IHRoaXMuX3NvcnRGbik7XG4gICAgICAgIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gICAgfTtcbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLmVuc3VyZVNvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc29ydGVkIHx8IHRoaXMuc29ydCgpO1xuICAgIH07XG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5zdGFibGVTb3J0ID0gZnVuY3Rpb24gKGFyciwgY29tcGFyZUZuKSB7XG4gICAgICAgIHZhciBhcnJPZldyYXBwZXIgPSBhcnIubWFwKGZ1bmN0aW9uIChlbGVtLCBpZHgpIHsgcmV0dXJuICh7IGVsZW06IGVsZW0sIGlkeDogaWR4IH0pOyB9KTtcbiAgICAgICAgYXJyT2ZXcmFwcGVyLnNvcnQoZnVuY3Rpb24gKHdyYXBwZXJBLCB3cmFwcGVyQikge1xuICAgICAgICAgICAgdmFyIGNtcERpZmYgPSBjb21wYXJlRm4od3JhcHBlckEuZWxlbSwgd3JhcHBlckIuZWxlbSk7XG4gICAgICAgICAgICByZXR1cm4gY21wRGlmZiA9PT0gMFxuICAgICAgICAgICAgICAgID8gd3JhcHBlckEuaWR4IC0gd3JhcHBlckIuaWR4XG4gICAgICAgICAgICAgICAgOiBjbXBEaWZmO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFyck9mV3JhcHBlci5tYXAoZnVuY3Rpb24gKHdyYXBwZXIpIHsgcmV0dXJuIHdyYXBwZXIuZWxlbTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIFVSTCwgY2hlY2sgYWxsIHJ1bGVzIGFuZCByZXR1cm4gdGhlIGJlc3QgW1tNYXRjaFJlc3VsdF1dXG4gICAgICogQHBhcmFtIHVybFxuICAgICAqIEByZXR1cm5zIHtNYXRjaFJlc3VsdH1cbiAgICAgKi9cbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmVuc3VyZVNvcnRlZCgpO1xuICAgICAgICB1cmwgPSBjb21tb25fMS5leHRlbmQoeyBwYXRoOiAnJywgc2VhcmNoOiB7fSwgaGFzaDogJycgfSwgdXJsKTtcbiAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5ydWxlcygpO1xuICAgICAgICBpZiAodGhpcy5fb3RoZXJ3aXNlRm4pXG4gICAgICAgICAgICBydWxlcy5wdXNoKHRoaXMuX290aGVyd2lzZUZuKTtcbiAgICAgICAgLy8gQ2hlY2tzIGEgc2luZ2xlIHJ1bGUuIFJldHVybnMgeyBydWxlOiBydWxlLCBtYXRjaDogbWF0Y2gsIHdlaWdodDogd2VpZ2h0IH0gaWYgaXQgbWF0Y2hlZCwgb3IgdW5kZWZpbmVkXG4gICAgICAgIHZhciBjaGVja1J1bGUgPSBmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gcnVsZS5tYXRjaCh1cmwsIF90aGlzLl9yb3V0ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoICYmIHsgbWF0Y2g6IG1hdGNoLCBydWxlOiBydWxlLCB3ZWlnaHQ6IHJ1bGUubWF0Y2hQcmlvcml0eShtYXRjaCkgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVGhlIHJ1bGVzIGFyZSBwcmUtc29ydGVkLlxuICAgICAgICAvLyAtIEZpbmQgdGhlIGZpcnN0IG1hdGNoaW5nIHJ1bGUuXG4gICAgICAgIC8vIC0gRmluZCBhbnkgb3RoZXIgbWF0Y2hpbmcgcnVsZSB0aGF0IHNvcnRlZCAqZXhhY3RseSB0aGUgc2FtZSosIGFjY29yZGluZyB0byBgLnNvcnQoKWAuXG4gICAgICAgIC8vIC0gQ2hvb3NlIHRoZSBydWxlIHdpdGggdGhlIGhpZ2hlc3QgbWF0Y2ggd2VpZ2h0LlxuICAgICAgICB2YXIgYmVzdDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gU3RvcCB3aGVuIHRoZXJlIGlzIGEgJ2Jlc3QnIHJ1bGUgYW5kIHRoZSBuZXh0IHJ1bGUgc29ydHMgZGlmZmVyZW50bHkgdGhhbiBpdC5cbiAgICAgICAgICAgIGlmIChiZXN0ICYmIHRoaXMuX3NvcnRGbihydWxlc1tpXSwgYmVzdC5ydWxlKSAhPT0gMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gY2hlY2tSdWxlKHJ1bGVzW2ldKTtcbiAgICAgICAgICAgIC8vIFBpY2sgdGhlIGJlc3QgTWF0Y2hSZXN1bHRcbiAgICAgICAgICAgIGJlc3QgPSAoIWJlc3QgfHwgY3VycmVudCAmJiBjdXJyZW50LndlaWdodCA+IGJlc3Qud2VpZ2h0KSA/IGN1cnJlbnQgOiBiZXN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiZXN0O1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBpZiAoZXZ0ICYmIGV2dC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgcm91dGVyID0gdGhpcy5fcm91dGVyLCAkdXJsID0gcm91dGVyLnVybFNlcnZpY2UsICRzdGF0ZSA9IHJvdXRlci5zdGF0ZVNlcnZpY2U7XG4gICAgICAgIHZhciB1cmwgPSB7XG4gICAgICAgICAgICBwYXRoOiAkdXJsLnBhdGgoKSwgc2VhcmNoOiAkdXJsLnNlYXJjaCgpLCBoYXNoOiAkdXJsLmhhc2goKSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJlc3QgPSB0aGlzLm1hdGNoKHVybCk7XG4gICAgICAgIHZhciBhcHBseVJlc3VsdCA9IGhvZl8xLnBhdHRlcm4oW1xuICAgICAgICAgICAgW3ByZWRpY2F0ZXNfMS5pc1N0cmluZywgZnVuY3Rpb24gKG5ld3VybCkgeyByZXR1cm4gJHVybC51cmwobmV3dXJsLCB0cnVlKTsgfV0sXG4gICAgICAgICAgICBbdGFyZ2V0U3RhdGVfMS5UYXJnZXRTdGF0ZS5pc0RlZiwgZnVuY3Rpb24gKGRlZikgeyByZXR1cm4gJHN0YXRlLmdvKGRlZi5zdGF0ZSwgZGVmLnBhcmFtcywgZGVmLm9wdGlvbnMpOyB9XSxcbiAgICAgICAgICAgIFtob2ZfMS5pcyh0YXJnZXRTdGF0ZV8xLlRhcmdldFN0YXRlKSwgZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gJHN0YXRlLmdvKHRhcmdldC5zdGF0ZSgpLCB0YXJnZXQucGFyYW1zKCksIHRhcmdldC5vcHRpb25zKCkpOyB9XSxcbiAgICAgICAgXSk7XG4gICAgICAgIGFwcGx5UmVzdWx0KGJlc3QgJiYgYmVzdC5ydWxlLmhhbmRsZXIoYmVzdC5tYXRjaCwgdXJsLCByb3V0ZXIpKTtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFJvdXRlci5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wRm4gJiYgdGhpcy5fc3RvcEZuKCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc3RvcEZuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BGbiA9IHRoaXMuX3N0b3BGbiB8fCB0aGlzLl9yb3V0ZXIudXJsU2VydmljZS5vbkNoYW5nZShmdW5jdGlvbiAoZXZ0KSB7IHJldHVybiBfdGhpcy5zeW5jKGV2dCk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBBUEkuXG4gICAgICogQGludGVybmFsYXBpXG4gICAgICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAocmVhZCkge1xuICAgICAgICB2YXIgJHVybCA9IHRoaXMuX3JvdXRlci5sb2NhdGlvblNlcnZpY2U7XG4gICAgICAgIGlmIChyZWFkKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gJHVybC5wYXRoKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCR1cmwucGF0aCgpID09PSB0aGlzLmxvY2F0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAkdXJsLnVybCh0aGlzLmxvY2F0aW9uLCB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEludGVybmFsIEFQSS5cbiAgICAgKlxuICAgICAqIFB1c2hlcyBhIG5ldyBsb2NhdGlvbiB0byB0aGUgYnJvd3NlciBoaXN0b3J5LlxuICAgICAqXG4gICAgICogQGludGVybmFsYXBpXG4gICAgICogQHBhcmFtIHVybE1hdGNoZXJcbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodXJsTWF0Y2hlciwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXBsYWNlID0gb3B0aW9ucyAmJiAhIW9wdGlvbnMucmVwbGFjZTtcbiAgICAgICAgdGhpcy5fcm91dGVyLnVybFNlcnZpY2UudXJsKHVybE1hdGNoZXIuZm9ybWF0KHBhcmFtcyB8fCB7fSksIHJlcGxhY2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQnVpbGRzIGFuZCByZXR1cm5zIGEgVVJMIHdpdGggaW50ZXJwb2xhdGVkIHBhcmFtZXRlcnNcbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIG1hdGNoZXIgPSAkdW1mLmNvbXBpbGUoXCIvYWJvdXQvOnBlcnNvblwiKTtcbiAgICAgKiBwYXJhbXMgPSB7IHBlcnNvbjogXCJib2JcIiB9O1xuICAgICAqICRib2IgPSAkdXJsUm91dGVyLmhyZWYobWF0Y2hlciwgcGFyYW1zKTtcbiAgICAgKiAvLyAkYm9iID09IFwiL2Fib3V0L2JvYlwiO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHVybE1hdGNoZXIgVGhlIFtbVXJsTWF0Y2hlcl1dIG9iamVjdCB3aGljaCBpcyB1c2VkIGFzIHRoZSB0ZW1wbGF0ZSBvZiB0aGUgVVJMIHRvIGdlbmVyYXRlLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgQW4gb2JqZWN0IG9mIHBhcmFtZXRlciB2YWx1ZXMgdG8gZmlsbCB0aGUgbWF0Y2hlcidzIHJlcXVpcmVkIHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBvYmplY3QuIFRoZSBvcHRpb25zIGFyZTpcbiAgICAgKlxuICAgICAqIC0gKipgYWJzb2x1dGVgKiogLSB7Ym9vbGVhbj1mYWxzZX0sICBJZiB0cnVlIHdpbGwgZ2VuZXJhdGUgYW4gYWJzb2x1dGUgdXJsLCBlLmcuIFwiaHR0cDovL3d3dy5leGFtcGxlLmNvbS9mdWxsdXJsXCIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBmdWxseSBjb21waWxlZCBVUkwsIG9yIGBudWxsYCBpZiBgcGFyYW1zYCBmYWlsIHZhbGlkYXRpb24gYWdhaW5zdCBgdXJsTWF0Y2hlcmBcbiAgICAgKi9cbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLmhyZWYgPSBmdW5jdGlvbiAodXJsTWF0Y2hlciwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB1cmwgPSB1cmxNYXRjaGVyLmZvcm1hdChwYXJhbXMpO1xuICAgICAgICBpZiAodXJsID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBhYnNvbHV0ZTogZmFsc2UgfTtcbiAgICAgICAgdmFyIGNmZyA9IHRoaXMuX3JvdXRlci51cmxTZXJ2aWNlLmNvbmZpZztcbiAgICAgICAgdmFyIGlzSHRtbDUgPSBjZmcuaHRtbDVNb2RlKCk7XG4gICAgICAgIGlmICghaXNIdG1sNSAmJiB1cmwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVybCA9IFwiI1wiICsgY2ZnLmhhc2hQcmVmaXgoKSArIHVybDtcbiAgICAgICAgfVxuICAgICAgICB1cmwgPSBhcHBlbmRCYXNlUGF0aCh1cmwsIGlzSHRtbDUsIG9wdGlvbnMuYWJzb2x1dGUsIGNmZy5iYXNlSHJlZigpKTtcbiAgICAgICAgaWYgKCFvcHRpb25zLmFic29sdXRlIHx8ICF1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNsYXNoID0gKCFpc0h0bWw1ICYmIHVybCA/ICcvJyA6ICcnKSwgcG9ydCA9IGNmZy5wb3J0KCk7XG4gICAgICAgIHBvcnQgPSAocG9ydCA9PT0gODAgfHwgcG9ydCA9PT0gNDQzID8gJycgOiAnOicgKyBwb3J0KTtcbiAgICAgICAgcmV0dXJuIFtjZmcucHJvdG9jb2woKSwgJzovLycsIGNmZy5ob3N0KCksIHBvcnQsIHNsYXNoLCB1cmxdLmpvaW4oJycpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWFudWFsbHkgYWRkcyBhIFVSTCBSdWxlLlxuICAgICAqXG4gICAgICogVXN1YWxseSwgYSB1cmwgcnVsZSBpcyBhZGRlZCB1c2luZyBbW1N0YXRlRGVjbGFyYXRpb24udXJsXV0gb3IgW1t3aGVuXV0uXG4gICAgICogVGhpcyBhcGkgY2FuIGJlIHVzZWQgZGlyZWN0bHkgZm9yIG1vcmUgY29udHJvbCAodG8gcmVnaXN0ZXIgYSBbW0Jhc2VVcmxSdWxlXV0sIGZvciBleGFtcGxlKS5cbiAgICAgKiBSdWxlcyBjYW4gYmUgY3JlYXRlZCB1c2luZyBbW1VybFJvdXRlci51cmxSdWxlRmFjdG9yeV1dLCBvciBjcmVhdGUgbWFudWFsbHkgYXMgc2ltcGxlIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBBIHJ1bGUgc2hvdWxkIGhhdmUgYSBgbWF0Y2hgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdHJ1dGh5IGlmIHRoZSBydWxlIG1hdGNoZWQuXG4gICAgICogSXQgc2hvdWxkIGFsc28gaGF2ZSBhIGBoYW5kbGVyYCBmdW5jdGlvbiB3aGljaCBpcyBpbnZva2VkIGlmIHRoZSBydWxlIGlzIHRoZSBiZXN0IG1hdGNoLlxuICAgICAqXG4gICAgICogQHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgZGVyZWdpc3RlcnMgdGhlIHJ1bGVcbiAgICAgKi9cbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLnJ1bGUgPSBmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXVybFJ1bGVfMS5VcmxSdWxlRmFjdG9yeS5pc1VybFJ1bGUocnVsZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJ1bGVcIik7XG4gICAgICAgIHJ1bGUuJGlkID0gdGhpcy5faWQrKztcbiAgICAgICAgcnVsZS5wcmlvcml0eSA9IHJ1bGUucHJpb3JpdHkgfHwgMDtcbiAgICAgICAgdGhpcy5fcnVsZXMucHVzaChydWxlKTtcbiAgICAgICAgdGhpcy5fc29ydGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yZW1vdmVSdWxlKHJ1bGUpOyB9O1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5yZW1vdmVSdWxlID0gZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgY29tbW9uXzEucmVtb3ZlRnJvbSh0aGlzLl9ydWxlcywgcnVsZSk7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLnJ1bGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVuc3VyZVNvcnRlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcnVsZXMuc2xpY2UoKTtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFJvdXRlci5wcm90b3R5cGUub3RoZXJ3aXNlID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGhhbmRsZXJGbiA9IGdldEhhbmRsZXJGbihoYW5kbGVyKTtcbiAgICAgICAgdGhpcy5fb3RoZXJ3aXNlRm4gPSB0aGlzLnVybFJ1bGVGYWN0b3J5LmNyZWF0ZShob2ZfMS52YWwodHJ1ZSksIGhhbmRsZXJGbik7XG4gICAgICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgO1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFJvdXRlci5wcm90b3R5cGUuaW5pdGlhbCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHZhciBoYW5kbGVyRm4gPSBnZXRIYW5kbGVyRm4oaGFuZGxlcik7XG4gICAgICAgIHZhciBtYXRjaEZuID0gZnVuY3Rpb24gKHVybFBhcnRzLCByb3V0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiByb3V0ZXIuZ2xvYmFscy50cmFuc2l0aW9uSGlzdG9yeS5zaXplKCkgPT09IDAgJiYgISEvXlxcLz8kLy5leGVjKHVybFBhcnRzLnBhdGgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1bGUodGhpcy51cmxSdWxlRmFjdG9yeS5jcmVhdGUobWF0Y2hGbiwgaGFuZGxlckZuKSk7XG4gICAgfTtcbiAgICA7XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS53aGVuID0gZnVuY3Rpb24gKG1hdGNoZXIsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJ1bGUgPSB0aGlzLnVybFJ1bGVGYWN0b3J5LmNyZWF0ZShtYXRjaGVyLCBoYW5kbGVyKTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc0RlZmluZWQob3B0aW9ucyAmJiBvcHRpb25zLnByaW9yaXR5KSlcbiAgICAgICAgICAgIHJ1bGUucHJpb3JpdHkgPSBvcHRpb25zLnByaW9yaXR5O1xuICAgICAgICB0aGlzLnJ1bGUocnVsZSk7XG4gICAgICAgIHJldHVybiBydWxlO1xuICAgIH07XG4gICAgO1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFJvdXRlci5wcm90b3R5cGUuZGVmZXJJbnRlcmNlcHQgPSBmdW5jdGlvbiAoZGVmZXIpIHtcbiAgICAgICAgaWYgKGRlZmVyID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBkZWZlciA9IHRydWU7XG4gICAgICAgIHRoaXMuaW50ZXJjZXB0RGVmZXJyZWQgPSBkZWZlcjtcbiAgICB9O1xuICAgIDtcbiAgICByZXR1cm4gVXJsUm91dGVyO1xufSgpKTtcbmV4cG9ydHMuVXJsUm91dGVyID0gVXJsUm91dGVyO1xuZnVuY3Rpb24gZ2V0SGFuZGxlckZuKGhhbmRsZXIpIHtcbiAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKGhhbmRsZXIpICYmICFwcmVkaWNhdGVzXzEuaXNTdHJpbmcoaGFuZGxlcikgJiYgIWhvZl8xLmlzKHRhcmdldFN0YXRlXzEuVGFyZ2V0U3RhdGUpKGhhbmRsZXIpICYmICF0YXJnZXRTdGF0ZV8xLlRhcmdldFN0YXRlLmlzRGVmKGhhbmRsZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIidoYW5kbGVyJyBtdXN0IGJlIGEgc3RyaW5nLCBmdW5jdGlvbiwgVGFyZ2V0U3RhdGUsIG9yIGhhdmUgYSBzdGF0ZTogJ25ld3RhcmdldCcgcHJvcGVydHlcIik7XG4gICAgfVxuICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihoYW5kbGVyKSA/IGhhbmRsZXIgOiBob2ZfMS52YWwoaGFuZGxlcik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmxSb3V0ZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0B1aXJvdXRlci9jb3JlL2xpYi91cmwvdXJsUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///42\n')},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module url\n */ /** */\nvar urlMatcher_1 = __webpack_require__(/*! ./urlMatcher */ 19);\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ 1);\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar hof_1 = __webpack_require__(/*! ../common/hof */ 2);\n/**\n * Creates a [[UrlRule]]\n *\n * Creates a [[UrlRule]] from a:\n *\n * - `string`\n * - [[UrlMatcher]]\n * - `RegExp`\n * - [[StateObject]]\n * @internalapi\n */\nvar UrlRuleFactory = /** @class */ (function () {\n    function UrlRuleFactory(router) {\n        this.router = router;\n    }\n    UrlRuleFactory.prototype.compile = function (str) {\n        return this.router.urlMatcherFactory.compile(str);\n    };\n    UrlRuleFactory.prototype.create = function (what, handler) {\n        var _this = this;\n        var makeRule = hof_1.pattern([\n            [predicates_1.isString, function (_what) { return makeRule(_this.compile(_what)); }],\n            [hof_1.is(urlMatcher_1.UrlMatcher), function (_what) { return _this.fromUrlMatcher(_what, handler); }],\n            [predicates_1.isState, function (_what) { return _this.fromState(_what, _this.router); }],\n            [hof_1.is(RegExp), function (_what) { return _this.fromRegExp(_what, handler); }],\n            [predicates_1.isFunction, function (_what) { return new BaseUrlRule(_what, handler); }],\n        ]);\n        var rule = makeRule(what);\n        if (!rule)\n            throw new Error(\"invalid 'what' in when()\");\n        return rule;\n    };\n    /**\n     * A UrlRule which matches based on a UrlMatcher\n     *\n     * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]\n     *\n     * ## Handler as a function\n     *\n     * If `handler` is a function, the function is invoked with:\n     *\n     * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])\n     * - url: the current Url ([[UrlParts]])\n     * - router: the router object ([[UIRouter]])\n     *\n     * #### Example:\n     * ```js\n     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n     * var rule = factory.fromUrlMatcher(urlMatcher, match => \"/home/\" + match.fooId + \"/\" + match.barId);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match); // '/home/123/456'\n     * ```\n     *\n     * ## Handler as UrlMatcher\n     *\n     * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.\n     * The `handler` UrlMatcher is formatted using the matched param from the first matcher.\n     * The url is replaced with the result.\n     *\n     * #### Example:\n     * ```js\n     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n     * var handler = $umf.compile(\"/home/:fooId/:barId\");\n     * var rule = factory.fromUrlMatcher(urlMatcher, handler);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match); // '/home/123/456'\n     * ```\n     */\n    UrlRuleFactory.prototype.fromUrlMatcher = function (urlMatcher, handler) {\n        var _handler = handler;\n        if (predicates_1.isString(handler))\n            handler = this.router.urlMatcherFactory.compile(handler);\n        if (hof_1.is(urlMatcher_1.UrlMatcher)(handler))\n            _handler = function (match) { return handler.format(match); };\n        function match(url) {\n            var match = urlMatcher.exec(url.path, url.search, url.hash);\n            return urlMatcher.validates(match) && match;\n        }\n        // Prioritize URLs, lowest to highest:\n        // - Some optional URL parameters, but none matched\n        // - No optional parameters in URL\n        // - Some optional parameters, some matched\n        // - Some optional parameters, all matched\n        function matchPriority(params) {\n            var optional = urlMatcher.parameters().filter(function (param) { return param.isOptional; });\n            if (!optional.length)\n                return 0.000001;\n            var matched = optional.filter(function (param) { return params[param.id]; });\n            return matched.length / optional.length;\n        }\n        var details = { urlMatcher: urlMatcher, matchPriority: matchPriority, type: \"URLMATCHER\" };\n        return common_1.extend(new BaseUrlRule(match, _handler), details);\n    };\n    /**\n     * A UrlRule which matches a state by its url\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromState($state.get('foo'), router);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match);\n     * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }\n     * ```\n     */\n    UrlRuleFactory.prototype.fromState = function (state, router) {\n        /**\n         * Handles match by transitioning to matched state\n         *\n         * First checks if the router should start a new transition.\n         * A new transition is not required if the current state's URL\n         * and the new URL are already identical\n         */\n        var handler = function (match) {\n            var $state = router.stateService;\n            var globals = router.globals;\n            if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {\n                $state.transitionTo(state, match, { inherit: true, source: \"url\" });\n            }\n        };\n        var details = { state: state, type: \"STATE\" };\n        return common_1.extend(this.fromUrlMatcher(state.url, handler), details);\n    };\n    /**\n     * A UrlRule which matches based on a regular expression\n     *\n     * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.\n     *\n     * ## Handler as a function\n     *\n     * If `handler` is a function, the function is invoked with:\n     *\n     * - regexp match array (from `regexp`)\n     * - url: the current Url ([[UrlParts]])\n     * - router: the router object ([[UIRouter]])\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, match => \"/home/\" + match[1])\n     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n     * var result = rule.handler(match); // '/home/bar'\n     * ```\n     *\n     * ## Handler as string\n     *\n     * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.\n     * The string is first interpolated using `string.replace()` style pattern.\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, \"/home/$1\")\n     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n     * var result = rule.handler(match); // '/home/bar'\n     * ```\n     */\n    UrlRuleFactory.prototype.fromRegExp = function (regexp, handler) {\n        if (regexp.global || regexp.sticky)\n            throw new Error(\"Rule RegExp must not be global or sticky\");\n        /**\n         * If handler is a string, the url will be replaced by the string.\n         * If the string has any String.replace() style variables in it (like `$2`),\n         * they will be replaced by the captures from [[match]]\n         */\n        var redirectUrlTo = function (match) {\n            // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern\n            return handler.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n                return match[what === '$' ? 0 : Number(what)];\n            });\n        };\n        var _handler = predicates_1.isString(handler) ? redirectUrlTo : handler;\n        var match = function (url) {\n            return regexp.exec(url.path);\n        };\n        var details = { regexp: regexp, type: \"REGEXP\" };\n        return common_1.extend(new BaseUrlRule(match, _handler), details);\n    };\n    UrlRuleFactory.isUrlRule = function (obj) {\n        return obj && ['type', 'match', 'handler'].every(function (key) { return predicates_1.isDefined(obj[key]); });\n    };\n    return UrlRuleFactory;\n}());\nexports.UrlRuleFactory = UrlRuleFactory;\n/**\n * A base rule which calls `match`\n *\n * The value from the `match` function is passed through to the `handler`.\n * @internalapi\n */\nvar BaseUrlRule = /** @class */ (function () {\n    function BaseUrlRule(match, handler) {\n        var _this = this;\n        this.match = match;\n        this.type = \"RAW\";\n        this.matchPriority = function (match) { return 0 - _this.$id; };\n        this.handler = handler || common_1.identity;\n    }\n    return BaseUrlRule;\n}());\nexports.BaseUrlRule = BaseUrlRule;\n//# sourceMappingURL=urlRule.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi91cmwvdXJsUnVsZS5qcz9hYWQxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSB1cmxcbiAqLyAvKiogKi9cbnZhciB1cmxNYXRjaGVyXzEgPSByZXF1aXJlKFwiLi91cmxNYXRjaGVyXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG4vKipcbiAqIENyZWF0ZXMgYSBbW1VybFJ1bGVdXVxuICpcbiAqIENyZWF0ZXMgYSBbW1VybFJ1bGVdXSBmcm9tIGE6XG4gKlxuICogLSBgc3RyaW5nYFxuICogLSBbW1VybE1hdGNoZXJdXVxuICogLSBgUmVnRXhwYFxuICogLSBbW1N0YXRlT2JqZWN0XV1cbiAqIEBpbnRlcm5hbGFwaVxuICovXG52YXIgVXJsUnVsZUZhY3RvcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVXJsUnVsZUZhY3Rvcnkocm91dGVyKSB7XG4gICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICAgIH1cbiAgICBVcmxSdWxlRmFjdG9yeS5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm91dGVyLnVybE1hdGNoZXJGYWN0b3J5LmNvbXBpbGUoc3RyKTtcbiAgICB9O1xuICAgIFVybFJ1bGVGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAod2hhdCwgaGFuZGxlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbWFrZVJ1bGUgPSBob2ZfMS5wYXR0ZXJuKFtcbiAgICAgICAgICAgIFtwcmVkaWNhdGVzXzEuaXNTdHJpbmcsIGZ1bmN0aW9uIChfd2hhdCkgeyByZXR1cm4gbWFrZVJ1bGUoX3RoaXMuY29tcGlsZShfd2hhdCkpOyB9XSxcbiAgICAgICAgICAgIFtob2ZfMS5pcyh1cmxNYXRjaGVyXzEuVXJsTWF0Y2hlciksIGZ1bmN0aW9uIChfd2hhdCkgeyByZXR1cm4gX3RoaXMuZnJvbVVybE1hdGNoZXIoX3doYXQsIGhhbmRsZXIpOyB9XSxcbiAgICAgICAgICAgIFtwcmVkaWNhdGVzXzEuaXNTdGF0ZSwgZnVuY3Rpb24gKF93aGF0KSB7IHJldHVybiBfdGhpcy5mcm9tU3RhdGUoX3doYXQsIF90aGlzLnJvdXRlcik7IH1dLFxuICAgICAgICAgICAgW2hvZl8xLmlzKFJlZ0V4cCksIGZ1bmN0aW9uIChfd2hhdCkgeyByZXR1cm4gX3RoaXMuZnJvbVJlZ0V4cChfd2hhdCwgaGFuZGxlcik7IH1dLFxuICAgICAgICAgICAgW3ByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uLCBmdW5jdGlvbiAoX3doYXQpIHsgcmV0dXJuIG5ldyBCYXNlVXJsUnVsZShfd2hhdCwgaGFuZGxlcik7IH1dLFxuICAgICAgICBdKTtcbiAgICAgICAgdmFyIHJ1bGUgPSBtYWtlUnVsZSh3aGF0KTtcbiAgICAgICAgaWYgKCFydWxlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCAnd2hhdCcgaW4gd2hlbigpXCIpO1xuICAgICAgICByZXR1cm4gcnVsZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgVXJsUnVsZSB3aGljaCBtYXRjaGVzIGJhc2VkIG9uIGEgVXJsTWF0Y2hlclxuICAgICAqXG4gICAgICogVGhlIGBoYW5kbGVyYCBtYXkgYmUgZWl0aGVyIGEgYHN0cmluZ2AsIGEgW1tVcmxSdWxlSGFuZGxlckZuXV0gb3IgYW5vdGhlciBbW1VybE1hdGNoZXJdXVxuICAgICAqXG4gICAgICogIyMgSGFuZGxlciBhcyBhIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBJZiBgaGFuZGxlcmAgaXMgYSBmdW5jdGlvbiwgdGhlIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aDpcbiAgICAgKlxuICAgICAqIC0gbWF0Y2hlZCBwYXJhbWV0ZXIgdmFsdWVzIChbW1Jhd1BhcmFtc11dIGZyb20gW1tVcmxNYXRjaGVyLmV4ZWNdXSlcbiAgICAgKiAtIHVybDogdGhlIGN1cnJlbnQgVXJsIChbW1VybFBhcnRzXV0pXG4gICAgICogLSByb3V0ZXI6IHRoZSByb3V0ZXIgb2JqZWN0IChbW1VJUm91dGVyXV0pXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiB2YXIgdXJsTWF0Y2hlciA9ICR1bWYuY29tcGlsZShcIi9mb28vOmZvb0lkLzpiYXJJZFwiKTtcbiAgICAgKiB2YXIgcnVsZSA9IGZhY3RvcnkuZnJvbVVybE1hdGNoZXIodXJsTWF0Y2hlciwgbWF0Y2ggPT4gXCIvaG9tZS9cIiArIG1hdGNoLmZvb0lkICsgXCIvXCIgKyBtYXRjaC5iYXJJZCk7XG4gICAgICogdmFyIG1hdGNoID0gcnVsZS5tYXRjaCgnL2Zvby8xMjMvNDU2Jyk7IC8vIHJlc3VsdHMgaW4geyBmb29JZDogJzEyMycsIGJhcklkOiAnNDU2JyB9XG4gICAgICogdmFyIHJlc3VsdCA9IHJ1bGUuaGFuZGxlcihtYXRjaCk7IC8vICcvaG9tZS8xMjMvNDU2J1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMgSGFuZGxlciBhcyBVcmxNYXRjaGVyXG4gICAgICpcbiAgICAgKiBJZiBgaGFuZGxlcmAgaXMgYSBVcmxNYXRjaGVyLCB0aGUgaGFuZGxlciBtYXRjaGVyIGlzIHVzZWQgdG8gY3JlYXRlIHRoZSBuZXcgdXJsLlxuICAgICAqIFRoZSBgaGFuZGxlcmAgVXJsTWF0Y2hlciBpcyBmb3JtYXR0ZWQgdXNpbmcgdGhlIG1hdGNoZWQgcGFyYW0gZnJvbSB0aGUgZmlyc3QgbWF0Y2hlci5cbiAgICAgKiBUaGUgdXJsIGlzIHJlcGxhY2VkIHdpdGggdGhlIHJlc3VsdC5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIHZhciB1cmxNYXRjaGVyID0gJHVtZi5jb21waWxlKFwiL2Zvby86Zm9vSWQvOmJhcklkXCIpO1xuICAgICAqIHZhciBoYW5kbGVyID0gJHVtZi5jb21waWxlKFwiL2hvbWUvOmZvb0lkLzpiYXJJZFwiKTtcbiAgICAgKiB2YXIgcnVsZSA9IGZhY3RvcnkuZnJvbVVybE1hdGNoZXIodXJsTWF0Y2hlciwgaGFuZGxlcik7XG4gICAgICogdmFyIG1hdGNoID0gcnVsZS5tYXRjaCgnL2Zvby8xMjMvNDU2Jyk7IC8vIHJlc3VsdHMgaW4geyBmb29JZDogJzEyMycsIGJhcklkOiAnNDU2JyB9XG4gICAgICogdmFyIHJlc3VsdCA9IHJ1bGUuaGFuZGxlcihtYXRjaCk7IC8vICcvaG9tZS8xMjMvNDU2J1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIFVybFJ1bGVGYWN0b3J5LnByb3RvdHlwZS5mcm9tVXJsTWF0Y2hlciA9IGZ1bmN0aW9uICh1cmxNYXRjaGVyLCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciBfaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcoaGFuZGxlcikpXG4gICAgICAgICAgICBoYW5kbGVyID0gdGhpcy5yb3V0ZXIudXJsTWF0Y2hlckZhY3RvcnkuY29tcGlsZShoYW5kbGVyKTtcbiAgICAgICAgaWYgKGhvZl8xLmlzKHVybE1hdGNoZXJfMS5VcmxNYXRjaGVyKShoYW5kbGVyKSlcbiAgICAgICAgICAgIF9oYW5kbGVyID0gZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBoYW5kbGVyLmZvcm1hdChtYXRjaCk7IH07XG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoKHVybCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gdXJsTWF0Y2hlci5leGVjKHVybC5wYXRoLCB1cmwuc2VhcmNoLCB1cmwuaGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gdXJsTWF0Y2hlci52YWxpZGF0ZXMobWF0Y2gpICYmIG1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByaW9yaXRpemUgVVJMcywgbG93ZXN0IHRvIGhpZ2hlc3Q6XG4gICAgICAgIC8vIC0gU29tZSBvcHRpb25hbCBVUkwgcGFyYW1ldGVycywgYnV0IG5vbmUgbWF0Y2hlZFxuICAgICAgICAvLyAtIE5vIG9wdGlvbmFsIHBhcmFtZXRlcnMgaW4gVVJMXG4gICAgICAgIC8vIC0gU29tZSBvcHRpb25hbCBwYXJhbWV0ZXJzLCBzb21lIG1hdGNoZWRcbiAgICAgICAgLy8gLSBTb21lIG9wdGlvbmFsIHBhcmFtZXRlcnMsIGFsbCBtYXRjaGVkXG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoUHJpb3JpdHkocGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uYWwgPSB1cmxNYXRjaGVyLnBhcmFtZXRlcnMoKS5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5pc09wdGlvbmFsOyB9KTtcbiAgICAgICAgICAgIGlmICghb3B0aW9uYWwubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiAwLjAwMDAwMTtcbiAgICAgICAgICAgIHZhciBtYXRjaGVkID0gb3B0aW9uYWwuZmlsdGVyKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW1zW3BhcmFtLmlkXTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlZC5sZW5ndGggLyBvcHRpb25hbC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRldGFpbHMgPSB7IHVybE1hdGNoZXI6IHVybE1hdGNoZXIsIG1hdGNoUHJpb3JpdHk6IG1hdGNoUHJpb3JpdHksIHR5cGU6IFwiVVJMTUFUQ0hFUlwiIH07XG4gICAgICAgIHJldHVybiBjb21tb25fMS5leHRlbmQobmV3IEJhc2VVcmxSdWxlKG1hdGNoLCBfaGFuZGxlciksIGRldGFpbHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBVcmxSdWxlIHdoaWNoIG1hdGNoZXMgYSBzdGF0ZSBieSBpdHMgdXJsXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiB2YXIgcnVsZSA9IGZhY3RvcnkuZnJvbVN0YXRlKCRzdGF0ZS5nZXQoJ2ZvbycpLCByb3V0ZXIpO1xuICAgICAqIHZhciBtYXRjaCA9IHJ1bGUubWF0Y2goJy9mb28vMTIzLzQ1NicpOyAvLyByZXN1bHRzIGluIHsgZm9vSWQ6ICcxMjMnLCBiYXJJZDogJzQ1NicgfVxuICAgICAqIHZhciByZXN1bHQgPSBydWxlLmhhbmRsZXIobWF0Y2gpO1xuICAgICAqIC8vIFN0YXJ0cyBhIHRyYW5zaXRpb24gdG8gJ2Zvbycgd2l0aCBwYXJhbXM6IHsgZm9vSWQ6ICcxMjMnLCBiYXJJZDogJzQ1NicgfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIFVybFJ1bGVGYWN0b3J5LnByb3RvdHlwZS5mcm9tU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIHJvdXRlcikge1xuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyBtYXRjaCBieSB0cmFuc2l0aW9uaW5nIHRvIG1hdGNoZWQgc3RhdGVcbiAgICAgICAgICpcbiAgICAgICAgICogRmlyc3QgY2hlY2tzIGlmIHRoZSByb3V0ZXIgc2hvdWxkIHN0YXJ0IGEgbmV3IHRyYW5zaXRpb24uXG4gICAgICAgICAqIEEgbmV3IHRyYW5zaXRpb24gaXMgbm90IHJlcXVpcmVkIGlmIHRoZSBjdXJyZW50IHN0YXRlJ3MgVVJMXG4gICAgICAgICAqIGFuZCB0aGUgbmV3IFVSTCBhcmUgYWxyZWFkeSBpZGVudGljYWxcbiAgICAgICAgICovXG4gICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgJHN0YXRlID0gcm91dGVyLnN0YXRlU2VydmljZTtcbiAgICAgICAgICAgIHZhciBnbG9iYWxzID0gcm91dGVyLmdsb2JhbHM7XG4gICAgICAgICAgICBpZiAoJHN0YXRlLmhyZWYoc3RhdGUsIG1hdGNoKSAhPT0gJHN0YXRlLmhyZWYoZ2xvYmFscy5jdXJyZW50LCBnbG9iYWxzLnBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICAkc3RhdGUudHJhbnNpdGlvblRvKHN0YXRlLCBtYXRjaCwgeyBpbmhlcml0OiB0cnVlLCBzb3VyY2U6IFwidXJsXCIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBkZXRhaWxzID0geyBzdGF0ZTogc3RhdGUsIHR5cGU6IFwiU1RBVEVcIiB9O1xuICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKHRoaXMuZnJvbVVybE1hdGNoZXIoc3RhdGUudXJsLCBoYW5kbGVyKSwgZGV0YWlscyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIFVybFJ1bGUgd2hpY2ggbWF0Y2hlcyBiYXNlZCBvbiBhIHJlZ3VsYXIgZXhwcmVzc2lvblxuICAgICAqXG4gICAgICogVGhlIGBoYW5kbGVyYCBtYXkgYmUgZWl0aGVyIGEgW1tVcmxSdWxlSGFuZGxlckZuXV0gb3IgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiAjIyBIYW5kbGVyIGFzIGEgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIElmIGBoYW5kbGVyYCBpcyBhIGZ1bmN0aW9uLCB0aGUgZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoOlxuICAgICAqXG4gICAgICogLSByZWdleHAgbWF0Y2ggYXJyYXkgKGZyb20gYHJlZ2V4cGApXG4gICAgICogLSB1cmw6IHRoZSBjdXJyZW50IFVybCAoW1tVcmxQYXJ0c11dKVxuICAgICAqIC0gcm91dGVyOiB0aGUgcm91dGVyIG9iamVjdCAoW1tVSVJvdXRlcl1dKVxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIHJ1bGUgPSBmYWN0b3J5LmZyb21SZWdFeHAoL15cXC9mb29cXC8oYmFyfGJheikkLywgbWF0Y2ggPT4gXCIvaG9tZS9cIiArIG1hdGNoWzFdKVxuICAgICAqIHZhciBtYXRjaCA9IHJ1bGUubWF0Y2goJy9mb28vYmFyJyk7IC8vIHJlc3VsdHMgaW4gWyAnL2Zvby9iYXInLCAnYmFyJyBdXG4gICAgICogdmFyIHJlc3VsdCA9IHJ1bGUuaGFuZGxlcihtYXRjaCk7IC8vICcvaG9tZS9iYXInXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyBIYW5kbGVyIGFzIHN0cmluZ1xuICAgICAqXG4gICAgICogSWYgYGhhbmRsZXJgIGlzIGEgc3RyaW5nLCB0aGUgdXJsIGlzICpyZXBsYWNlZCBieSB0aGUgc3RyaW5nKiB3aGVuIHRoZSBSdWxlIGlzIGludm9rZWQuXG4gICAgICogVGhlIHN0cmluZyBpcyBmaXJzdCBpbnRlcnBvbGF0ZWQgdXNpbmcgYHN0cmluZy5yZXBsYWNlKClgIHN0eWxlIHBhdHRlcm4uXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiB2YXIgcnVsZSA9IGZhY3RvcnkuZnJvbVJlZ0V4cCgvXlxcL2Zvb1xcLyhiYXJ8YmF6KSQvLCBcIi9ob21lLyQxXCIpXG4gICAgICogdmFyIG1hdGNoID0gcnVsZS5tYXRjaCgnL2Zvby9iYXInKTsgLy8gcmVzdWx0cyBpbiBbICcvZm9vL2JhcicsICdiYXInIF1cbiAgICAgKiB2YXIgcmVzdWx0ID0gcnVsZS5oYW5kbGVyKG1hdGNoKTsgLy8gJy9ob21lL2JhcidcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBVcmxSdWxlRmFjdG9yeS5wcm90b3R5cGUuZnJvbVJlZ0V4cCA9IGZ1bmN0aW9uIChyZWdleHAsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHJlZ2V4cC5nbG9iYWwgfHwgcmVnZXhwLnN0aWNreSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJ1bGUgUmVnRXhwIG11c3Qgbm90IGJlIGdsb2JhbCBvciBzdGlja3lcIik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBoYW5kbGVyIGlzIGEgc3RyaW5nLCB0aGUgdXJsIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIHN0cmluZy5cbiAgICAgICAgICogSWYgdGhlIHN0cmluZyBoYXMgYW55IFN0cmluZy5yZXBsYWNlKCkgc3R5bGUgdmFyaWFibGVzIGluIGl0IChsaWtlIGAkMmApLFxuICAgICAgICAgKiB0aGV5IHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGNhcHR1cmVzIGZyb20gW1ttYXRjaF1dXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgcmVkaXJlY3RVcmxUbyA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgLy8gSW50ZXJwb2xhdGVzIG1hdGNoZWQgdmFsdWVzIGludG8gJDEgJDIsIGV0YyB1c2luZyBhIFN0cmluZy5yZXBsYWNlKCktc3R5bGUgcGF0dGVyblxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIucmVwbGFjZSgvXFwkKFxcJHxcXGR7MSwyfSkvLCBmdW5jdGlvbiAobSwgd2hhdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaFt3aGF0ID09PSAnJCcgPyAwIDogTnVtYmVyKHdoYXQpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgX2hhbmRsZXIgPSBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoaGFuZGxlcikgPyByZWRpcmVjdFVybFRvIDogaGFuZGxlcjtcbiAgICAgICAgdmFyIG1hdGNoID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2V4cC5leGVjKHVybC5wYXRoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRldGFpbHMgPSB7IHJlZ2V4cDogcmVnZXhwLCB0eXBlOiBcIlJFR0VYUFwiIH07XG4gICAgICAgIHJldHVybiBjb21tb25fMS5leHRlbmQobmV3IEJhc2VVcmxSdWxlKG1hdGNoLCBfaGFuZGxlciksIGRldGFpbHMpO1xuICAgIH07XG4gICAgVXJsUnVsZUZhY3RvcnkuaXNVcmxSdWxlID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIFsndHlwZScsICdtYXRjaCcsICdoYW5kbGVyJ10uZXZlcnkoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gcHJlZGljYXRlc18xLmlzRGVmaW5lZChvYmpba2V5XSk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFVybFJ1bGVGYWN0b3J5O1xufSgpKTtcbmV4cG9ydHMuVXJsUnVsZUZhY3RvcnkgPSBVcmxSdWxlRmFjdG9yeTtcbi8qKlxuICogQSBiYXNlIHJ1bGUgd2hpY2ggY2FsbHMgYG1hdGNoYFxuICpcbiAqIFRoZSB2YWx1ZSBmcm9tIHRoZSBgbWF0Y2hgIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aHJvdWdoIHRvIHRoZSBgaGFuZGxlcmAuXG4gKiBAaW50ZXJuYWxhcGlcbiAqL1xudmFyIEJhc2VVcmxSdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhc2VVcmxSdWxlKG1hdGNoLCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgdGhpcy50eXBlID0gXCJSQVdcIjtcbiAgICAgICAgdGhpcy5tYXRjaFByaW9yaXR5ID0gZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiAwIC0gX3RoaXMuJGlkOyB9O1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyIHx8IGNvbW1vbl8xLmlkZW50aXR5O1xuICAgIH1cbiAgICByZXR1cm4gQmFzZVVybFJ1bGU7XG59KCkpO1xuZXhwb3J0cy5CYXNlVXJsUnVsZSA9IEJhc2VVcmxSdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsUnVsZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL3VybC91cmxSdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///43\n")},function(module,exports,__webpack_require__){"use strict";eval('\n/**\n * @coreapi\n * @module url\n */ /** */\nObject.defineProperty(exports, "__esModule", { value: true });\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ 3);\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\n/** @hidden */\nvar makeStub = function (keys) {\n    return keys.reduce(function (acc, key) { return (acc[key] = coreservices_1.notImplemented(key), acc); }, { dispose: common_1.noop });\n};\n/** @hidden */ var locationServicesFns = ["url", "path", "search", "hash", "onChange"];\n/** @hidden */ var locationConfigFns = ["port", "protocol", "host", "baseHref", "html5Mode", "hashPrefix"];\n/** @hidden */ var umfFns = ["type", "caseInsensitive", "strictMode", "defaultSquashPolicy"];\n/** @hidden */ var rulesFns = ["sort", "when", "initial", "otherwise", "rules", "rule", "removeRule"];\n/** @hidden */ var syncFns = ["deferIntercept", "listen", "sync", "match"];\n/**\n * API for URL management\n */\nvar UrlService = /** @class */ (function () {\n    /** @hidden */\n    function UrlService(router, lateBind) {\n        if (lateBind === void 0) { lateBind = true; }\n        this.router = router;\n        this.rules = {};\n        this.config = {};\n        // proxy function calls from UrlService to the LocationService/LocationConfig\n        var locationServices = function () { return router.locationService; };\n        common_1.createProxyFunctions(locationServices, this, locationServices, locationServicesFns, lateBind);\n        var locationConfig = function () { return router.locationConfig; };\n        common_1.createProxyFunctions(locationConfig, this.config, locationConfig, locationConfigFns, lateBind);\n        var umf = function () { return router.urlMatcherFactory; };\n        common_1.createProxyFunctions(umf, this.config, umf, umfFns);\n        var urlRouter = function () { return router.urlRouter; };\n        common_1.createProxyFunctions(urlRouter, this.rules, urlRouter, rulesFns);\n        common_1.createProxyFunctions(urlRouter, this, urlRouter, syncFns);\n    }\n    UrlService.prototype.url = function (newurl, replace, state) { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.path = function () { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.search = function () { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.hash = function () { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.onChange = function (callback) { return; };\n    ;\n    /**\n     * Returns the current URL parts\n     *\n     * This method returns the current URL components as a [[UrlParts]] object.\n     *\n     * @returns the current url parts\n     */\n    UrlService.prototype.parts = function () {\n        return { path: this.path(), search: this.search(), hash: this.hash() };\n    };\n    UrlService.prototype.dispose = function () { };\n    /** @inheritdoc */\n    UrlService.prototype.sync = function (evt) { return; };\n    /** @inheritdoc */\n    UrlService.prototype.listen = function (enabled) { return; };\n    ;\n    /** @inheritdoc */\n    UrlService.prototype.deferIntercept = function (defer) { return; };\n    /** @inheritdoc */\n    UrlService.prototype.match = function (urlParts) { return; };\n    /** @hidden */\n    UrlService.locationServiceStub = makeStub(locationServicesFns);\n    /** @hidden */\n    UrlService.locationConfigStub = makeStub(locationConfigFns);\n    return UrlService;\n}());\nexports.UrlService = UrlService;\n//# sourceMappingURL=urlService.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi91cmwvdXJsU2VydmljZS5qcz9jZjYzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSB1cmxcbiAqLyAvKiogKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG4vKiogQGhpZGRlbiAqL1xudmFyIG1ha2VTdHViID0gZnVuY3Rpb24gKGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7IHJldHVybiAoYWNjW2tleV0gPSBjb3Jlc2VydmljZXNfMS5ub3RJbXBsZW1lbnRlZChrZXkpLCBhY2MpOyB9LCB7IGRpc3Bvc2U6IGNvbW1vbl8xLm5vb3AgfSk7XG59O1xuLyoqIEBoaWRkZW4gKi8gdmFyIGxvY2F0aW9uU2VydmljZXNGbnMgPSBbXCJ1cmxcIiwgXCJwYXRoXCIsIFwic2VhcmNoXCIsIFwiaGFzaFwiLCBcIm9uQ2hhbmdlXCJdO1xuLyoqIEBoaWRkZW4gKi8gdmFyIGxvY2F0aW9uQ29uZmlnRm5zID0gW1wicG9ydFwiLCBcInByb3RvY29sXCIsIFwiaG9zdFwiLCBcImJhc2VIcmVmXCIsIFwiaHRtbDVNb2RlXCIsIFwiaGFzaFByZWZpeFwiXTtcbi8qKiBAaGlkZGVuICovIHZhciB1bWZGbnMgPSBbXCJ0eXBlXCIsIFwiY2FzZUluc2Vuc2l0aXZlXCIsIFwic3RyaWN0TW9kZVwiLCBcImRlZmF1bHRTcXVhc2hQb2xpY3lcIl07XG4vKiogQGhpZGRlbiAqLyB2YXIgcnVsZXNGbnMgPSBbXCJzb3J0XCIsIFwid2hlblwiLCBcImluaXRpYWxcIiwgXCJvdGhlcndpc2VcIiwgXCJydWxlc1wiLCBcInJ1bGVcIiwgXCJyZW1vdmVSdWxlXCJdO1xuLyoqIEBoaWRkZW4gKi8gdmFyIHN5bmNGbnMgPSBbXCJkZWZlckludGVyY2VwdFwiLCBcImxpc3RlblwiLCBcInN5bmNcIiwgXCJtYXRjaFwiXTtcbi8qKlxuICogQVBJIGZvciBVUkwgbWFuYWdlbWVudFxuICovXG52YXIgVXJsU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIGZ1bmN0aW9uIFVybFNlcnZpY2Uocm91dGVyLCBsYXRlQmluZCkge1xuICAgICAgICBpZiAobGF0ZUJpbmQgPT09IHZvaWQgMCkgeyBsYXRlQmluZCA9IHRydWU7IH1cbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgIHRoaXMucnVsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5jb25maWcgPSB7fTtcbiAgICAgICAgLy8gcHJveHkgZnVuY3Rpb24gY2FsbHMgZnJvbSBVcmxTZXJ2aWNlIHRvIHRoZSBMb2NhdGlvblNlcnZpY2UvTG9jYXRpb25Db25maWdcbiAgICAgICAgdmFyIGxvY2F0aW9uU2VydmljZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXIubG9jYXRpb25TZXJ2aWNlOyB9O1xuICAgICAgICBjb21tb25fMS5jcmVhdGVQcm94eUZ1bmN0aW9ucyhsb2NhdGlvblNlcnZpY2VzLCB0aGlzLCBsb2NhdGlvblNlcnZpY2VzLCBsb2NhdGlvblNlcnZpY2VzRm5zLCBsYXRlQmluZCk7XG4gICAgICAgIHZhciBsb2NhdGlvbkNvbmZpZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvdXRlci5sb2NhdGlvbkNvbmZpZzsgfTtcbiAgICAgICAgY29tbW9uXzEuY3JlYXRlUHJveHlGdW5jdGlvbnMobG9jYXRpb25Db25maWcsIHRoaXMuY29uZmlnLCBsb2NhdGlvbkNvbmZpZywgbG9jYXRpb25Db25maWdGbnMsIGxhdGVCaW5kKTtcbiAgICAgICAgdmFyIHVtZiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvdXRlci51cmxNYXRjaGVyRmFjdG9yeTsgfTtcbiAgICAgICAgY29tbW9uXzEuY3JlYXRlUHJveHlGdW5jdGlvbnModW1mLCB0aGlzLmNvbmZpZywgdW1mLCB1bWZGbnMpO1xuICAgICAgICB2YXIgdXJsUm91dGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLnVybFJvdXRlcjsgfTtcbiAgICAgICAgY29tbW9uXzEuY3JlYXRlUHJveHlGdW5jdGlvbnModXJsUm91dGVyLCB0aGlzLnJ1bGVzLCB1cmxSb3V0ZXIsIHJ1bGVzRm5zKTtcbiAgICAgICAgY29tbW9uXzEuY3JlYXRlUHJveHlGdW5jdGlvbnModXJsUm91dGVyLCB0aGlzLCB1cmxSb3V0ZXIsIHN5bmNGbnMpO1xuICAgIH1cbiAgICBVcmxTZXJ2aWNlLnByb3RvdHlwZS51cmwgPSBmdW5jdGlvbiAobmV3dXJsLCByZXBsYWNlLCBzdGF0ZSkgeyByZXR1cm47IH07XG4gICAgO1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFNlcnZpY2UucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcbiAgICA7XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsU2VydmljZS5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XG4gICAgO1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFNlcnZpY2UucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcbiAgICA7XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsU2VydmljZS5wcm90b3R5cGUub25DaGFuZ2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHsgcmV0dXJuOyB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IFVSTCBwYXJ0c1xuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgY3VycmVudCBVUkwgY29tcG9uZW50cyBhcyBhIFtbVXJsUGFydHNdXSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB1cmwgcGFydHNcbiAgICAgKi9cbiAgICBVcmxTZXJ2aWNlLnByb3RvdHlwZS5wYXJ0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgcGF0aDogdGhpcy5wYXRoKCksIHNlYXJjaDogdGhpcy5zZWFyY2goKSwgaGFzaDogdGhpcy5oYXNoKCkgfTtcbiAgICB9O1xuICAgIFVybFNlcnZpY2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsU2VydmljZS5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uIChldnQpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFNlcnZpY2UucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIChlbmFibGVkKSB7IHJldHVybjsgfTtcbiAgICA7XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsU2VydmljZS5wcm90b3R5cGUuZGVmZXJJbnRlcmNlcHQgPSBmdW5jdGlvbiAoZGVmZXIpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFNlcnZpY2UucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKHVybFBhcnRzKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFVybFNlcnZpY2UubG9jYXRpb25TZXJ2aWNlU3R1YiA9IG1ha2VTdHViKGxvY2F0aW9uU2VydmljZXNGbnMpO1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVXJsU2VydmljZS5sb2NhdGlvbkNvbmZpZ1N0dWIgPSBtYWtlU3R1Yihsb2NhdGlvbkNvbmZpZ0Zucyk7XG4gICAgcmV0dXJuIFVybFNlcnZpY2U7XG59KCkpO1xuZXhwb3J0cy5VcmxTZXJ2aWNlID0gVXJsU2VydmljZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybFNlcnZpY2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0B1aXJvdXRlci9jb3JlL2xpYi91cmwvdXJsU2VydmljZS5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///44\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ 1);\n/** A `LocationConfig` that delegates to the browser\'s `location` object */\nvar BrowserLocationConfig = /** @class */ (function () {\n    function BrowserLocationConfig(router, _isHtml5) {\n        if (_isHtml5 === void 0) { _isHtml5 = false; }\n        this._isHtml5 = _isHtml5;\n        this._baseHref = undefined;\n        this._hashPrefix = "";\n    }\n    BrowserLocationConfig.prototype.port = function () {\n        if (location.port) {\n            return Number(location.port);\n        }\n        return this.protocol() === \'https\' ? 443 : 80;\n    };\n    BrowserLocationConfig.prototype.protocol = function () {\n        return location.protocol.replace(/:/g, \'\');\n    };\n    BrowserLocationConfig.prototype.host = function () {\n        return location.hostname;\n    };\n    BrowserLocationConfig.prototype.html5Mode = function () {\n        return this._isHtml5;\n    };\n    BrowserLocationConfig.prototype.hashPrefix = function (newprefix) {\n        return predicates_1.isDefined(newprefix) ? this._hashPrefix = newprefix : this._hashPrefix;\n    };\n    ;\n    BrowserLocationConfig.prototype.baseHref = function (href) {\n        return predicates_1.isDefined(href) ? this._baseHref = href :\n            predicates_1.isDefined(this._baseHref) ? this._baseHref : this.applyDocumentBaseHref();\n    };\n    BrowserLocationConfig.prototype.applyDocumentBaseHref = function () {\n        var baseTag = document.getElementsByTagName("base")[0];\n        return this._baseHref = baseTag ? baseTag.href.substr(location.origin.length) : "";\n    };\n    BrowserLocationConfig.prototype.dispose = function () { };\n    return BrowserLocationConfig;\n}());\nexports.BrowserLocationConfig = BrowserLocationConfig;\n//# sourceMappingURL=browserLocationConfig.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL2Jyb3dzZXJMb2NhdGlvbkNvbmZpZy5qcz83MmY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxhcGlcbiAqIEBtb2R1bGUgdmFuaWxsYVxuICovXG4vKiogKi9cbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG4vKiogQSBgTG9jYXRpb25Db25maWdgIHRoYXQgZGVsZWdhdGVzIHRvIHRoZSBicm93c2VyJ3MgYGxvY2F0aW9uYCBvYmplY3QgKi9cbnZhciBCcm93c2VyTG9jYXRpb25Db25maWcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnJvd3NlckxvY2F0aW9uQ29uZmlnKHJvdXRlciwgX2lzSHRtbDUpIHtcbiAgICAgICAgaWYgKF9pc0h0bWw1ID09PSB2b2lkIDApIHsgX2lzSHRtbDUgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLl9pc0h0bWw1ID0gX2lzSHRtbDU7XG4gICAgICAgIHRoaXMuX2Jhc2VIcmVmID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9oYXNoUHJlZml4ID0gXCJcIjtcbiAgICB9XG4gICAgQnJvd3NlckxvY2F0aW9uQ29uZmlnLnByb3RvdHlwZS5wb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobG9jYXRpb24ucG9ydCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcihsb2NhdGlvbi5wb3J0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm90b2NvbCgpID09PSAnaHR0cHMnID8gNDQzIDogODA7XG4gICAgfTtcbiAgICBCcm93c2VyTG9jYXRpb25Db25maWcucHJvdG90eXBlLnByb3RvY29sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbG9jYXRpb24ucHJvdG9jb2wucmVwbGFjZSgvOi9nLCAnJyk7XG4gICAgfTtcbiAgICBCcm93c2VyTG9jYXRpb25Db25maWcucHJvdG90eXBlLmhvc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhdGlvbi5ob3N0bmFtZTtcbiAgICB9O1xuICAgIEJyb3dzZXJMb2NhdGlvbkNvbmZpZy5wcm90b3R5cGUuaHRtbDVNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNIdG1sNTtcbiAgICB9O1xuICAgIEJyb3dzZXJMb2NhdGlvbkNvbmZpZy5wcm90b3R5cGUuaGFzaFByZWZpeCA9IGZ1bmN0aW9uIChuZXdwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc0RlZmluZWQobmV3cHJlZml4KSA/IHRoaXMuX2hhc2hQcmVmaXggPSBuZXdwcmVmaXggOiB0aGlzLl9oYXNoUHJlZml4O1xuICAgIH07XG4gICAgO1xuICAgIEJyb3dzZXJMb2NhdGlvbkNvbmZpZy5wcm90b3R5cGUuYmFzZUhyZWYgPSBmdW5jdGlvbiAoaHJlZikge1xuICAgICAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzRGVmaW5lZChocmVmKSA/IHRoaXMuX2Jhc2VIcmVmID0gaHJlZiA6XG4gICAgICAgICAgICBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHRoaXMuX2Jhc2VIcmVmKSA/IHRoaXMuX2Jhc2VIcmVmIDogdGhpcy5hcHBseURvY3VtZW50QmFzZUhyZWYoKTtcbiAgICB9O1xuICAgIEJyb3dzZXJMb2NhdGlvbkNvbmZpZy5wcm90b3R5cGUuYXBwbHlEb2N1bWVudEJhc2VIcmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYmFzZVRhZyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYmFzZVwiKVswXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jhc2VIcmVmID0gYmFzZVRhZyA/IGJhc2VUYWcuaHJlZi5zdWJzdHIobG9jYXRpb24ub3JpZ2luLmxlbmd0aCkgOiBcIlwiO1xuICAgIH07XG4gICAgQnJvd3NlckxvY2F0aW9uQ29uZmlnLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHJldHVybiBCcm93c2VyTG9jYXRpb25Db25maWc7XG59KCkpO1xuZXhwb3J0cy5Ccm93c2VyTG9jYXRpb25Db25maWcgPSBCcm93c2VyTG9jYXRpb25Db25maWc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icm93c2VyTG9jYXRpb25Db25maWcuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL2Jyb3dzZXJMb2NhdGlvbkNvbmZpZy5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///45\n')},function(module,exports,__webpack_require__){"use strict";eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar common_1 = __webpack_require__(/*! ../common */ 5);\nvar baseLocationService_1 = __webpack_require__(/*! ./baseLocationService */ 20);\n/** A `LocationServices` that uses the browser hash \"#\" to get/set the current location */\nvar HashLocationService = /** @class */ (function (_super) {\n    __extends(HashLocationService, _super);\n    function HashLocationService(router) {\n        var _this = _super.call(this, router, false) || this;\n        common_1.root.addEventListener('hashchange', _this._listener, false);\n        return _this;\n    }\n    HashLocationService.prototype._get = function () {\n        return common_1.trimHashVal(this._location.hash);\n    };\n    HashLocationService.prototype._set = function (state, title, url, replace) {\n        this._location.hash = url;\n    };\n    HashLocationService.prototype.dispose = function (router) {\n        _super.prototype.dispose.call(this, router);\n        common_1.root.removeEventListener('hashchange', this._listener);\n    };\n    return HashLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.HashLocationService = HashLocationService;\n//# sourceMappingURL=hashLocationService.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL2hhc2hMb2NhdGlvblNlcnZpY2UuanM/ZmJjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxhcGlcbiAqIEBtb2R1bGUgdmFuaWxsYVxuICovXG4vKiogKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG52YXIgYmFzZUxvY2F0aW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4vYmFzZUxvY2F0aW9uU2VydmljZVwiKTtcbi8qKiBBIGBMb2NhdGlvblNlcnZpY2VzYCB0aGF0IHVzZXMgdGhlIGJyb3dzZXIgaGFzaCBcIiNcIiB0byBnZXQvc2V0IHRoZSBjdXJyZW50IGxvY2F0aW9uICovXG52YXIgSGFzaExvY2F0aW9uU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSGFzaExvY2F0aW9uU2VydmljZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIYXNoTG9jYXRpb25TZXJ2aWNlKHJvdXRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByb3V0ZXIsIGZhbHNlKSB8fCB0aGlzO1xuICAgICAgICBjb21tb25fMS5yb290LmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCBfdGhpcy5fbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBIYXNoTG9jYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEudHJpbUhhc2hWYWwodGhpcy5fbG9jYXRpb24uaGFzaCk7XG4gICAgfTtcbiAgICBIYXNoTG9jYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fc2V0ID0gZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgdXJsLCByZXBsYWNlKSB7XG4gICAgICAgIHRoaXMuX2xvY2F0aW9uLmhhc2ggPSB1cmw7XG4gICAgfTtcbiAgICBIYXNoTG9jYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKHJvdXRlcikge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzLCByb3V0ZXIpO1xuICAgICAgICBjb21tb25fMS5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLl9saXN0ZW5lcik7XG4gICAgfTtcbiAgICByZXR1cm4gSGFzaExvY2F0aW9uU2VydmljZTtcbn0oYmFzZUxvY2F0aW9uU2VydmljZV8xLkJhc2VMb2NhdGlvblNlcnZpY2VzKSk7XG5leHBvcnRzLkhhc2hMb2NhdGlvblNlcnZpY2UgPSBIYXNoTG9jYXRpb25TZXJ2aWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaExvY2F0aW9uU2VydmljZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvaGFzaExvY2F0aW9uU2VydmljZS5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///46\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar index_1 = __webpack_require__(/*! ../common/index */ 5);\n// globally available injectables\nvar globals = {};\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nvar ARGUMENT_NAMES = /([^\\s,]+)/g;\n/**\n * A basic angular1-like injector api\n *\n * This object implements four methods similar to the\n * [angular 1 dependency injector](https://docs.angularjs.org/api/auto/service/$injector)\n *\n * UI-Router evolved from an angular 1 library to a framework agnostic library.\n * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.\n *\n * This object provides a naive implementation of a globally scoped dependency injection system.\n * It supports the following DI approaches:\n *\n * ### Function parameter names\n *\n * A function's `.toString()` is called, and the parameter names are parsed.\n * This only works when the parameter names aren't \"mangled\" by a minifier such as UglifyJS.\n *\n * ```js\n * function injectedFunction(FooService, BarService) {\n *   // FooService and BarService are injected\n * }\n * ```\n *\n * ### Function annotation\n *\n * A function may be annotated with an array of dependency names as the `$inject` property.\n *\n * ```js\n * injectedFunction.$inject = [ 'FooService', 'BarService' ];\n * function injectedFunction(fs, bs) {\n *   // FooService and BarService are injected as fs and bs parameters\n * }\n * ```\n *\n * ### Array notation\n *\n * An array provides the names of the dependencies to inject (as strings).\n * The function is the last element of the array.\n *\n * ```js\n * [ 'FooService', 'BarService', function (fs, bs) {\n *   // FooService and BarService are injected as fs and bs parameters\n * }]\n * ```\n *\n * @type {$InjectorLike}\n */\nexports.$injector = {\n    /** Gets an object from DI based on a string token */\n    get: function (name) { return globals[name]; },\n    /** Returns true if an object named `name` exists in global DI */\n    has: function (name) { return exports.$injector.get(name) != null; },\n    /**\n     * Injects a function\n     *\n     * @param fn the function to inject\n     * @param context the function's `this` binding\n     * @param locals An object with additional DI tokens and values, such as `{ someToken: { foo: 1 } }`\n     */\n    invoke: function (fn, context, locals) {\n        var all = index_1.extend({}, globals, locals || {});\n        var params = exports.$injector.annotate(fn);\n        var ensureExist = index_1.assertPredicate(function (key) { return all.hasOwnProperty(key); }, function (key) { return \"DI can't find injectable: '\" + key + \"'\"; });\n        var args = params.filter(ensureExist).map(function (x) { return all[x]; });\n        if (index_1.isFunction(fn))\n            return fn.apply(context, args);\n        else\n            return fn.slice(-1)[0].apply(context, args);\n    },\n    /**\n     * Returns a function's dependencies\n     *\n     * Analyzes a function (or array) and returns an array of DI tokens that the function requires.\n     * @return an array of `string`s\n     */\n    annotate: function (fn) {\n        if (!index_1.isInjectable(fn))\n            throw new Error(\"Not an injectable function: \" + fn);\n        if (fn && fn.$inject)\n            return fn.$inject;\n        if (index_1.isArray(fn))\n            return fn.slice(0, -1);\n        var fnStr = fn.toString().replace(STRIP_COMMENTS, '');\n        var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\n        return result || [];\n    }\n};\n//# sourceMappingURL=injector.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL2luamVjdG9yLmpzPzU5MTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogQG1vZHVsZSB2YW5pbGxhXG4gKi9cbi8qKiAqL1xudmFyIGluZGV4XzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2luZGV4XCIpO1xuLy8gZ2xvYmFsbHkgYXZhaWxhYmxlIGluamVjdGFibGVzXG52YXIgZ2xvYmFscyA9IHt9O1xudmFyIFNUUklQX0NPTU1FTlRTID0gLygoXFwvXFwvLiokKXwoXFwvXFwqW1xcc1xcU10qP1xcKlxcLykpL21nO1xudmFyIEFSR1VNRU5UX05BTUVTID0gLyhbXlxccyxdKykvZztcbi8qKlxuICogQSBiYXNpYyBhbmd1bGFyMS1saWtlIGluamVjdG9yIGFwaVxuICpcbiAqIFRoaXMgb2JqZWN0IGltcGxlbWVudHMgZm91ciBtZXRob2RzIHNpbWlsYXIgdG8gdGhlXG4gKiBbYW5ndWxhciAxIGRlcGVuZGVuY3kgaW5qZWN0b3JdKGh0dHBzOi8vZG9jcy5hbmd1bGFyanMub3JnL2FwaS9hdXRvL3NlcnZpY2UvJGluamVjdG9yKVxuICpcbiAqIFVJLVJvdXRlciBldm9sdmVkIGZyb20gYW4gYW5ndWxhciAxIGxpYnJhcnkgdG8gYSBmcmFtZXdvcmsgYWdub3N0aWMgbGlicmFyeS5cbiAqIEhvd2V2ZXIsIHNvbWUgb2YgdGhlIGBAdWlyb3V0ZXIvY29yZWAgY29kZSB1c2VzIHRoZXNlIG5nMSBzdHlsZSBBUElzIHRvIHN1cHBvcnQgbmcxIHN0eWxlIGRlcGVuZGVuY3kgaW5qZWN0aW9uLlxuICpcbiAqIFRoaXMgb2JqZWN0IHByb3ZpZGVzIGEgbmFpdmUgaW1wbGVtZW50YXRpb24gb2YgYSBnbG9iYWxseSBzY29wZWQgZGVwZW5kZW5jeSBpbmplY3Rpb24gc3lzdGVtLlxuICogSXQgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBESSBhcHByb2FjaGVzOlxuICpcbiAqICMjIyBGdW5jdGlvbiBwYXJhbWV0ZXIgbmFtZXNcbiAqXG4gKiBBIGZ1bmN0aW9uJ3MgYC50b1N0cmluZygpYCBpcyBjYWxsZWQsIGFuZCB0aGUgcGFyYW1ldGVyIG5hbWVzIGFyZSBwYXJzZWQuXG4gKiBUaGlzIG9ubHkgd29ya3Mgd2hlbiB0aGUgcGFyYW1ldGVyIG5hbWVzIGFyZW4ndCBcIm1hbmdsZWRcIiBieSBhIG1pbmlmaWVyIHN1Y2ggYXMgVWdsaWZ5SlMuXG4gKlxuICogYGBganNcbiAqIGZ1bmN0aW9uIGluamVjdGVkRnVuY3Rpb24oRm9vU2VydmljZSwgQmFyU2VydmljZSkge1xuICogICAvLyBGb29TZXJ2aWNlIGFuZCBCYXJTZXJ2aWNlIGFyZSBpbmplY3RlZFxuICogfVxuICogYGBgXG4gKlxuICogIyMjIEZ1bmN0aW9uIGFubm90YXRpb25cbiAqXG4gKiBBIGZ1bmN0aW9uIG1heSBiZSBhbm5vdGF0ZWQgd2l0aCBhbiBhcnJheSBvZiBkZXBlbmRlbmN5IG5hbWVzIGFzIHRoZSBgJGluamVjdGAgcHJvcGVydHkuXG4gKlxuICogYGBganNcbiAqIGluamVjdGVkRnVuY3Rpb24uJGluamVjdCA9IFsgJ0Zvb1NlcnZpY2UnLCAnQmFyU2VydmljZScgXTtcbiAqIGZ1bmN0aW9uIGluamVjdGVkRnVuY3Rpb24oZnMsIGJzKSB7XG4gKiAgIC8vIEZvb1NlcnZpY2UgYW5kIEJhclNlcnZpY2UgYXJlIGluamVjdGVkIGFzIGZzIGFuZCBicyBwYXJhbWV0ZXJzXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiAjIyMgQXJyYXkgbm90YXRpb25cbiAqXG4gKiBBbiBhcnJheSBwcm92aWRlcyB0aGUgbmFtZXMgb2YgdGhlIGRlcGVuZGVuY2llcyB0byBpbmplY3QgKGFzIHN0cmluZ3MpLlxuICogVGhlIGZ1bmN0aW9uIGlzIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGFycmF5LlxuICpcbiAqIGBgYGpzXG4gKiBbICdGb29TZXJ2aWNlJywgJ0JhclNlcnZpY2UnLCBmdW5jdGlvbiAoZnMsIGJzKSB7XG4gKiAgIC8vIEZvb1NlcnZpY2UgYW5kIEJhclNlcnZpY2UgYXJlIGluamVjdGVkIGFzIGZzIGFuZCBicyBwYXJhbWV0ZXJzXG4gKiB9XVxuICogYGBgXG4gKlxuICogQHR5cGUgeyRJbmplY3Rvckxpa2V9XG4gKi9cbmV4cG9ydHMuJGluamVjdG9yID0ge1xuICAgIC8qKiBHZXRzIGFuIG9iamVjdCBmcm9tIERJIGJhc2VkIG9uIGEgc3RyaW5nIHRva2VuICovXG4gICAgZ2V0OiBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZ2xvYmFsc1tuYW1lXTsgfSxcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIGFuIG9iamVjdCBuYW1lZCBgbmFtZWAgZXhpc3RzIGluIGdsb2JhbCBESSAqL1xuICAgIGhhczogZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGV4cG9ydHMuJGluamVjdG9yLmdldChuYW1lKSAhPSBudWxsOyB9LFxuICAgIC8qKlxuICAgICAqIEluamVjdHMgYSBmdW5jdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIGZuIHRoZSBmdW5jdGlvbiB0byBpbmplY3RcbiAgICAgKiBAcGFyYW0gY29udGV4dCB0aGUgZnVuY3Rpb24ncyBgdGhpc2AgYmluZGluZ1xuICAgICAqIEBwYXJhbSBsb2NhbHMgQW4gb2JqZWN0IHdpdGggYWRkaXRpb25hbCBESSB0b2tlbnMgYW5kIHZhbHVlcywgc3VjaCBhcyBgeyBzb21lVG9rZW46IHsgZm9vOiAxIH0gfWBcbiAgICAgKi9cbiAgICBpbnZva2U6IGZ1bmN0aW9uIChmbiwgY29udGV4dCwgbG9jYWxzKSB7XG4gICAgICAgIHZhciBhbGwgPSBpbmRleF8xLmV4dGVuZCh7fSwgZ2xvYmFscywgbG9jYWxzIHx8IHt9KTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGV4cG9ydHMuJGluamVjdG9yLmFubm90YXRlKGZuKTtcbiAgICAgICAgdmFyIGVuc3VyZUV4aXN0ID0gaW5kZXhfMS5hc3NlcnRQcmVkaWNhdGUoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gYWxsLmhhc093blByb3BlcnR5KGtleSk7IH0sIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIFwiREkgY2FuJ3QgZmluZCBpbmplY3RhYmxlOiAnXCIgKyBrZXkgKyBcIidcIjsgfSk7XG4gICAgICAgIHZhciBhcmdzID0gcGFyYW1zLmZpbHRlcihlbnN1cmVFeGlzdCkubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBhbGxbeF07IH0pO1xuICAgICAgICBpZiAoaW5kZXhfMS5pc0Z1bmN0aW9uKGZuKSlcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGZuLnNsaWNlKC0xKVswXS5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbidzIGRlcGVuZGVuY2llc1xuICAgICAqXG4gICAgICogQW5hbHl6ZXMgYSBmdW5jdGlvbiAob3IgYXJyYXkpIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIERJIHRva2VucyB0aGF0IHRoZSBmdW5jdGlvbiByZXF1aXJlcy5cbiAgICAgKiBAcmV0dXJuIGFuIGFycmF5IG9mIGBzdHJpbmdgc1xuICAgICAqL1xuICAgIGFubm90YXRlOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgaWYgKCFpbmRleF8xLmlzSW5qZWN0YWJsZShmbikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYW4gaW5qZWN0YWJsZSBmdW5jdGlvbjogXCIgKyBmbik7XG4gICAgICAgIGlmIChmbiAmJiBmbi4kaW5qZWN0KVxuICAgICAgICAgICAgcmV0dXJuIGZuLiRpbmplY3Q7XG4gICAgICAgIGlmIChpbmRleF8xLmlzQXJyYXkoZm4pKVxuICAgICAgICAgICAgcmV0dXJuIGZuLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgdmFyIGZuU3RyID0gZm4udG9TdHJpbmcoKS5yZXBsYWNlKFNUUklQX0NPTU1FTlRTLCAnJyk7XG4gICAgICAgIHZhciByZXN1bHQgPSBmblN0ci5zbGljZShmblN0ci5pbmRleE9mKCcoJykgKyAxLCBmblN0ci5pbmRleE9mKCcpJykpLm1hdGNoKEFSR1VNRU5UX05BTUVTKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBbXTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5qZWN0b3IuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL2luamVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///47\n")},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ 1);\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\n/** A `LocationConfig` mock that gets/sets all config from an in-memory object */\nvar MemoryLocationConfig = /** @class */ (function () {\n    function MemoryLocationConfig() {\n        var _this = this;\n        this._baseHref = \'\';\n        this._port = 80;\n        this._protocol = "http";\n        this._host = "localhost";\n        this._hashPrefix = "";\n        this.port = function () { return _this._port; };\n        this.protocol = function () { return _this._protocol; };\n        this.host = function () { return _this._host; };\n        this.baseHref = function () { return _this._baseHref; };\n        this.html5Mode = function () { return false; };\n        this.hashPrefix = function (newval) { return predicates_1.isDefined(newval) ? _this._hashPrefix = newval : _this._hashPrefix; };\n        this.dispose = common_1.noop;\n    }\n    return MemoryLocationConfig;\n}());\nexports.MemoryLocationConfig = MemoryLocationConfig;\n//# sourceMappingURL=memoryLocationConfig.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL21lbW9yeUxvY2F0aW9uQ29uZmlnLmpzPzczMTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG4vKiogQSBgTG9jYXRpb25Db25maWdgIG1vY2sgdGhhdCBnZXRzL3NldHMgYWxsIGNvbmZpZyBmcm9tIGFuIGluLW1lbW9yeSBvYmplY3QgKi9cbnZhciBNZW1vcnlMb2NhdGlvbkNvbmZpZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZW1vcnlMb2NhdGlvbkNvbmZpZygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fYmFzZUhyZWYgPSAnJztcbiAgICAgICAgdGhpcy5fcG9ydCA9IDgwO1xuICAgICAgICB0aGlzLl9wcm90b2NvbCA9IFwiaHR0cFwiO1xuICAgICAgICB0aGlzLl9ob3N0ID0gXCJsb2NhbGhvc3RcIjtcbiAgICAgICAgdGhpcy5faGFzaFByZWZpeCA9IFwiXCI7XG4gICAgICAgIHRoaXMucG9ydCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9wb3J0OyB9O1xuICAgICAgICB0aGlzLnByb3RvY29sID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3Byb3RvY29sOyB9O1xuICAgICAgICB0aGlzLmhvc3QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5faG9zdDsgfTtcbiAgICAgICAgdGhpcy5iYXNlSHJlZiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9iYXNlSHJlZjsgfTtcbiAgICAgICAgdGhpcy5odG1sNU1vZGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICAgICAgdGhpcy5oYXNoUHJlZml4ID0gZnVuY3Rpb24gKG5ld3ZhbCkgeyByZXR1cm4gcHJlZGljYXRlc18xLmlzRGVmaW5lZChuZXd2YWwpID8gX3RoaXMuX2hhc2hQcmVmaXggPSBuZXd2YWwgOiBfdGhpcy5faGFzaFByZWZpeDsgfTtcbiAgICAgICAgdGhpcy5kaXNwb3NlID0gY29tbW9uXzEubm9vcDtcbiAgICB9XG4gICAgcmV0dXJuIE1lbW9yeUxvY2F0aW9uQ29uZmlnO1xufSgpKTtcbmV4cG9ydHMuTWVtb3J5TG9jYXRpb25Db25maWcgPSBNZW1vcnlMb2NhdGlvbkNvbmZpZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lbW9yeUxvY2F0aW9uQ29uZmlnLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9tZW1vcnlMb2NhdGlvbkNvbmZpZy5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///48\n')},function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar baseLocationService_1 = __webpack_require__(/*! ./baseLocationService */ 20);\n/** A `LocationServices` that gets/sets the current location from an in-memory object */\nvar MemoryLocationService = /** @class */ (function (_super) {\n    __extends(MemoryLocationService, _super);\n    function MemoryLocationService(router) {\n        return _super.call(this, router, true) || this;\n    }\n    MemoryLocationService.prototype._get = function () {\n        return this._url;\n    };\n    MemoryLocationService.prototype._set = function (state, title, url, replace) {\n        this._url = url;\n    };\n    return MemoryLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.MemoryLocationService = MemoryLocationService;\n//# sourceMappingURL=memoryLocationService.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL21lbW9yeUxvY2F0aW9uU2VydmljZS5qcz9iMjg4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogQG1vZHVsZSB2YW5pbGxhXG4gKi9cbi8qKiAqL1xudmFyIGJhc2VMb2NhdGlvblNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2Jhc2VMb2NhdGlvblNlcnZpY2VcIik7XG4vKiogQSBgTG9jYXRpb25TZXJ2aWNlc2AgdGhhdCBnZXRzL3NldHMgdGhlIGN1cnJlbnQgbG9jYXRpb24gZnJvbSBhbiBpbi1tZW1vcnkgb2JqZWN0ICovXG52YXIgTWVtb3J5TG9jYXRpb25TZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZW1vcnlMb2NhdGlvblNlcnZpY2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVtb3J5TG9jYXRpb25TZXJ2aWNlKHJvdXRlcikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgcm91dGVyLCB0cnVlKSB8fCB0aGlzO1xuICAgIH1cbiAgICBNZW1vcnlMb2NhdGlvblNlcnZpY2UucHJvdG90eXBlLl9nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91cmw7XG4gICAgfTtcbiAgICBNZW1vcnlMb2NhdGlvblNlcnZpY2UucHJvdG90eXBlLl9zZXQgPSBmdW5jdGlvbiAoc3RhdGUsIHRpdGxlLCB1cmwsIHJlcGxhY2UpIHtcbiAgICAgICAgdGhpcy5fdXJsID0gdXJsO1xuICAgIH07XG4gICAgcmV0dXJuIE1lbW9yeUxvY2F0aW9uU2VydmljZTtcbn0oYmFzZUxvY2F0aW9uU2VydmljZV8xLkJhc2VMb2NhdGlvblNlcnZpY2VzKSk7XG5leHBvcnRzLk1lbW9yeUxvY2F0aW9uU2VydmljZSA9IE1lbW9yeUxvY2F0aW9uU2VydmljZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lbW9yeUxvY2F0aW9uU2VydmljZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvbWVtb3J5TG9jYXRpb25TZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///49\n')},function(module,exports,__webpack_require__){"use strict";eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar baseLocationService_1 = __webpack_require__(/*! ./baseLocationService */ 20);\nvar common_1 = __webpack_require__(/*! ../common */ 5);\n/**\n * A `LocationServices` that gets/sets the current location using the browser's `location` and `history` apis\n *\n * Uses `history.pushState` and `history.replaceState`\n */\nvar PushStateLocationService = /** @class */ (function (_super) {\n    __extends(PushStateLocationService, _super);\n    function PushStateLocationService(router) {\n        var _this = _super.call(this, router, true) || this;\n        _this._config = router.urlService.config;\n        common_1.root.addEventListener('popstate', _this._listener, false);\n        return _this;\n    }\n    ;\n    /**\n     * Gets the base prefix without:\n     * - trailing slash\n     * - trailing filename\n     * - protocol and hostname\n     *\n     * If <base href='/base/index.html'>, this returns '/base'.\n     * If <base href='http://localhost:8080/base/index.html'>, this returns '/base'.\n     *\n     * See: https://html.spec.whatwg.org/dev/semantics.html#the-base-element\n     */\n    PushStateLocationService.prototype._getBasePrefix = function () {\n        return common_1.stripFile(this._config.baseHref());\n    };\n    PushStateLocationService.prototype._get = function () {\n        var _a = this._location, pathname = _a.pathname, hash = _a.hash, search = _a.search;\n        search = common_1.splitQuery(search)[1]; // strip ? if found\n        hash = common_1.splitHash(hash)[1]; // strip # if found\n        var basePrefix = this._getBasePrefix();\n        var exactMatch = pathname === this._config.baseHref();\n        var startsWith = pathname.startsWith(basePrefix);\n        pathname = exactMatch ? '/' : startsWith ? pathname.substring(basePrefix.length) : pathname;\n        return pathname + (search ? '?' + search : '') + (hash ? '#' + hash : '');\n    };\n    PushStateLocationService.prototype._set = function (state, title, url, replace) {\n        var fullUrl = this._getBasePrefix() + url;\n        if (replace) {\n            this._history.replaceState(state, title, fullUrl);\n        }\n        else {\n            this._history.pushState(state, title, fullUrl);\n        }\n    };\n    PushStateLocationService.prototype.dispose = function (router) {\n        _super.prototype.dispose.call(this, router);\n        common_1.root.removeEventListener('popstate', this._listener);\n    };\n    return PushStateLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.PushStateLocationService = PushStateLocationService;\n//# sourceMappingURL=pushStateLocationService.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL3B1c2hTdGF0ZUxvY2F0aW9uU2VydmljZS5qcz9iZjU3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYmFzZUxvY2F0aW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4vYmFzZUxvY2F0aW9uU2VydmljZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG4vKipcbiAqIEEgYExvY2F0aW9uU2VydmljZXNgIHRoYXQgZ2V0cy9zZXRzIHRoZSBjdXJyZW50IGxvY2F0aW9uIHVzaW5nIHRoZSBicm93c2VyJ3MgYGxvY2F0aW9uYCBhbmQgYGhpc3RvcnlgIGFwaXNcbiAqXG4gKiBVc2VzIGBoaXN0b3J5LnB1c2hTdGF0ZWAgYW5kIGBoaXN0b3J5LnJlcGxhY2VTdGF0ZWBcbiAqL1xudmFyIFB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZShyb3V0ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcm91dGVyLCB0cnVlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fY29uZmlnID0gcm91dGVyLnVybFNlcnZpY2UuY29uZmlnO1xuICAgICAgICBjb21tb25fMS5yb290LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgX3RoaXMuX2xpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGJhc2UgcHJlZml4IHdpdGhvdXQ6XG4gICAgICogLSB0cmFpbGluZyBzbGFzaFxuICAgICAqIC0gdHJhaWxpbmcgZmlsZW5hbWVcbiAgICAgKiAtIHByb3RvY29sIGFuZCBob3N0bmFtZVxuICAgICAqXG4gICAgICogSWYgPGJhc2UgaHJlZj0nL2Jhc2UvaW5kZXguaHRtbCc+LCB0aGlzIHJldHVybnMgJy9iYXNlJy5cbiAgICAgKiBJZiA8YmFzZSBocmVmPSdodHRwOi8vbG9jYWxob3N0OjgwODAvYmFzZS9pbmRleC5odG1sJz4sIHRoaXMgcmV0dXJucyAnL2Jhc2UnLlxuICAgICAqXG4gICAgICogU2VlOiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL2Rldi9zZW1hbnRpY3MuaHRtbCN0aGUtYmFzZS1lbGVtZW50XG4gICAgICovXG4gICAgUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fZ2V0QmFzZVByZWZpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLnN0cmlwRmlsZSh0aGlzLl9jb25maWcuYmFzZUhyZWYoKSk7XG4gICAgfTtcbiAgICBQdXNoU3RhdGVMb2NhdGlvblNlcnZpY2UucHJvdG90eXBlLl9nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX2xvY2F0aW9uLCBwYXRobmFtZSA9IF9hLnBhdGhuYW1lLCBoYXNoID0gX2EuaGFzaCwgc2VhcmNoID0gX2Euc2VhcmNoO1xuICAgICAgICBzZWFyY2ggPSBjb21tb25fMS5zcGxpdFF1ZXJ5KHNlYXJjaClbMV07IC8vIHN0cmlwID8gaWYgZm91bmRcbiAgICAgICAgaGFzaCA9IGNvbW1vbl8xLnNwbGl0SGFzaChoYXNoKVsxXTsgLy8gc3RyaXAgIyBpZiBmb3VuZFxuICAgICAgICB2YXIgYmFzZVByZWZpeCA9IHRoaXMuX2dldEJhc2VQcmVmaXgoKTtcbiAgICAgICAgdmFyIGV4YWN0TWF0Y2ggPSBwYXRobmFtZSA9PT0gdGhpcy5fY29uZmlnLmJhc2VIcmVmKCk7XG4gICAgICAgIHZhciBzdGFydHNXaXRoID0gcGF0aG5hbWUuc3RhcnRzV2l0aChiYXNlUHJlZml4KTtcbiAgICAgICAgcGF0aG5hbWUgPSBleGFjdE1hdGNoID8gJy8nIDogc3RhcnRzV2l0aCA/IHBhdGhuYW1lLnN1YnN0cmluZyhiYXNlUHJlZml4Lmxlbmd0aCkgOiBwYXRobmFtZTtcbiAgICAgICAgcmV0dXJuIHBhdGhuYW1lICsgKHNlYXJjaCA/ICc/JyArIHNlYXJjaCA6ICcnKSArIChoYXNoID8gJyMnICsgaGFzaCA6ICcnKTtcbiAgICB9O1xuICAgIFB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZS5wcm90b3R5cGUuX3NldCA9IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHVybCwgcmVwbGFjZSkge1xuICAgICAgICB2YXIgZnVsbFVybCA9IHRoaXMuX2dldEJhc2VQcmVmaXgoKSArIHVybDtcbiAgICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpc3RvcnkucmVwbGFjZVN0YXRlKHN0YXRlLCB0aXRsZSwgZnVsbFVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9oaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgdGl0bGUsIGZ1bGxVcmwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQdXNoU3RhdGVMb2NhdGlvblNlcnZpY2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAocm91dGVyKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMsIHJvdXRlcik7XG4gICAgICAgIGNvbW1vbl8xLnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLl9saXN0ZW5lcik7XG4gICAgfTtcbiAgICByZXR1cm4gUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlO1xufShiYXNlTG9jYXRpb25TZXJ2aWNlXzEuQmFzZUxvY2F0aW9uU2VydmljZXMpKTtcbmV4cG9ydHMuUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlID0gUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9wdXNoU3RhdGVMb2NhdGlvblNlcnZpY2UuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///50\n")},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar index_1 = __webpack_require__(/*! ../common/index */ 5);\n/**\n * An angular1-like promise api\n *\n * This object implements four methods similar to the\n * [angular 1 promise api](https://docs.angularjs.org/api/ng/service/$q)\n *\n * UI-Router evolved from an angular 1 library to a framework agnostic library.\n * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.\n *\n * This API provides native ES6 promise support wrapped as a $q-like API.\n * Internally, UI-Router uses this $q object to perform promise operations.\n * The `angular-ui-router` (ui-router for angular 1) uses the $q API provided by angular.\n *\n * $q-like promise api\n */\nexports.$q = {\n    /** Normalizes a value as a promise */\n    when: function (val) { return new Promise(function (resolve, reject) { return resolve(val); }); },\n    /** Normalizes a value as a promise rejection */\n    reject: function (val) { return new Promise(function (resolve, reject) { reject(val); }); },\n    /** @returns a deferred object, which has `resolve` and `reject` functions */\n    defer: function () {\n        var deferred = {};\n        deferred.promise = new Promise(function (resolve, reject) {\n            deferred.resolve = resolve;\n            deferred.reject = reject;\n        });\n        return deferred;\n    },\n    /** Like Promise.all(), but also supports object key/promise notation like $q */\n    all: function (promises) {\n        if (index_1.isArray(promises)) {\n            return Promise.all(promises);\n        }\n        if (index_1.isObject(promises)) {\n            // Convert promises map to promises array.\n            // When each promise resolves, map it to a tuple { key: key, val: val }\n            var chain = Object.keys(promises)\n                .map(function (key) { return promises[key].then(function (val) { return ({ key: key, val: val }); }); });\n            // Then wait for all promises to resolve, and convert them back to an object\n            return exports.$q.all(chain).then(function (values) {\n                return values.reduce(function (acc, tuple) { acc[tuple.key] = tuple.val; return acc; }, {});\n            });\n        }\n    }\n};\n//# sourceMappingURL=q.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL3EuanM/MGE4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGludGVybmFsYXBpXG4gKiBAbW9kdWxlIHZhbmlsbGFcbiAqL1xuLyoqICovXG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaW5kZXhcIik7XG4vKipcbiAqIEFuIGFuZ3VsYXIxLWxpa2UgcHJvbWlzZSBhcGlcbiAqXG4gKiBUaGlzIG9iamVjdCBpbXBsZW1lbnRzIGZvdXIgbWV0aG9kcyBzaW1pbGFyIHRvIHRoZVxuICogW2FuZ3VsYXIgMSBwcm9taXNlIGFwaV0oaHR0cHM6Ly9kb2NzLmFuZ3VsYXJqcy5vcmcvYXBpL25nL3NlcnZpY2UvJHEpXG4gKlxuICogVUktUm91dGVyIGV2b2x2ZWQgZnJvbSBhbiBhbmd1bGFyIDEgbGlicmFyeSB0byBhIGZyYW1ld29yayBhZ25vc3RpYyBsaWJyYXJ5LlxuICogSG93ZXZlciwgc29tZSBvZiB0aGUgYEB1aXJvdXRlci9jb3JlYCBjb2RlIHVzZXMgdGhlc2UgbmcxIHN0eWxlIEFQSXMgdG8gc3VwcG9ydCBuZzEgc3R5bGUgZGVwZW5kZW5jeSBpbmplY3Rpb24uXG4gKlxuICogVGhpcyBBUEkgcHJvdmlkZXMgbmF0aXZlIEVTNiBwcm9taXNlIHN1cHBvcnQgd3JhcHBlZCBhcyBhICRxLWxpa2UgQVBJLlxuICogSW50ZXJuYWxseSwgVUktUm91dGVyIHVzZXMgdGhpcyAkcSBvYmplY3QgdG8gcGVyZm9ybSBwcm9taXNlIG9wZXJhdGlvbnMuXG4gKiBUaGUgYGFuZ3VsYXItdWktcm91dGVyYCAodWktcm91dGVyIGZvciBhbmd1bGFyIDEpIHVzZXMgdGhlICRxIEFQSSBwcm92aWRlZCBieSBhbmd1bGFyLlxuICpcbiAqICRxLWxpa2UgcHJvbWlzZSBhcGlcbiAqL1xuZXhwb3J0cy4kcSA9IHtcbiAgICAvKiogTm9ybWFsaXplcyBhIHZhbHVlIGFzIGEgcHJvbWlzZSAqL1xuICAgIHdoZW46IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgcmV0dXJuIHJlc29sdmUodmFsKTsgfSk7IH0sXG4gICAgLyoqIE5vcm1hbGl6ZXMgYSB2YWx1ZSBhcyBhIHByb21pc2UgcmVqZWN0aW9uICovXG4gICAgcmVqZWN0OiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHJlamVjdCh2YWwpOyB9KTsgfSxcbiAgICAvKiogQHJldHVybnMgYSBkZWZlcnJlZCBvYmplY3QsIHdoaWNoIGhhcyBgcmVzb2x2ZWAgYW5kIGByZWplY3RgIGZ1bmN0aW9ucyAqL1xuICAgIGRlZmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IHt9O1xuICAgICAgICBkZWZlcnJlZC5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQ7XG4gICAgfSxcbiAgICAvKiogTGlrZSBQcm9taXNlLmFsbCgpLCBidXQgYWxzbyBzdXBwb3J0cyBvYmplY3Qga2V5L3Byb21pc2Ugbm90YXRpb24gbGlrZSAkcSAqL1xuICAgIGFsbDogZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgICAgIGlmIChpbmRleF8xLmlzQXJyYXkocHJvbWlzZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleF8xLmlzT2JqZWN0KHByb21pc2VzKSkge1xuICAgICAgICAgICAgLy8gQ29udmVydCBwcm9taXNlcyBtYXAgdG8gcHJvbWlzZXMgYXJyYXkuXG4gICAgICAgICAgICAvLyBXaGVuIGVhY2ggcHJvbWlzZSByZXNvbHZlcywgbWFwIGl0IHRvIGEgdHVwbGUgeyBrZXk6IGtleSwgdmFsOiB2YWwgfVxuICAgICAgICAgICAgdmFyIGNoYWluID0gT2JqZWN0LmtleXMocHJvbWlzZXMpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBwcm9taXNlc1trZXldLnRoZW4oZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gKHsga2V5OiBrZXksIHZhbDogdmFsIH0pOyB9KTsgfSk7XG4gICAgICAgICAgICAvLyBUaGVuIHdhaXQgZm9yIGFsbCBwcm9taXNlcyB0byByZXNvbHZlLCBhbmQgY29udmVydCB0aGVtIGJhY2sgdG8gYW4gb2JqZWN0XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy4kcS5hbGwoY2hhaW4pLnRoZW4oZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHR1cGxlKSB7IGFjY1t0dXBsZS5rZXldID0gdHVwbGUudmFsOyByZXR1cm4gYWNjOyB9LCB7fSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9xLmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///51\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @coreapi\n * @module view\n */ /** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar hof_1 = __webpack_require__(/*! ../common/hof */ 2);\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ 1);\nvar trace_1 = __webpack_require__(/*! ../common/trace */ 7);\n/**\n * The View service\n *\n * This service pairs existing `ui-view` components (which live in the DOM)\n * with view configs (from the state declaration objects: [[StateDeclaration.views]]).\n *\n * - After a successful Transition, the views from the newly entered states are activated via [[activateViewConfig]].\n *   The views from exited states are deactivated via [[deactivateViewConfig]].\n *   (See: the [[registerActivateViews]] Transition Hook)\n *\n * - As `ui-view` components pop in and out of existence, they register themselves using [[registerUIView]].\n *\n * - When the [[sync]] function is called, the registered `ui-view`(s) ([[ActiveUIView]])\n * are configured with the matching [[ViewConfig]](s)\n *\n */\nvar ViewService = /** @class */ (function () {\n    function ViewService() {\n        var _this = this;\n        this._uiViews = [];\n        this._viewConfigs = [];\n        this._viewConfigFactories = {};\n        this._pluginapi = {\n            _rootViewContext: this._rootViewContext.bind(this),\n            _viewConfigFactory: this._viewConfigFactory.bind(this),\n            _registeredUIViews: function () { return _this._uiViews; },\n            _activeViewConfigs: function () { return _this._viewConfigs; },\n        };\n    }\n    ViewService.prototype._rootViewContext = function (context) {\n        return this._rootContext = context || this._rootContext;\n    };\n    ;\n    ViewService.prototype._viewConfigFactory = function (viewType, factory) {\n        this._viewConfigFactories[viewType] = factory;\n    };\n    ViewService.prototype.createViewConfig = function (path, decl) {\n        var cfgFactory = this._viewConfigFactories[decl.$type];\n        if (!cfgFactory)\n            throw new Error("ViewService: No view config factory registered for type " + decl.$type);\n        var cfgs = cfgFactory(path, decl);\n        return predicates_1.isArray(cfgs) ? cfgs : [cfgs];\n    };\n    /**\n     * Deactivates a ViewConfig.\n     *\n     * This function deactivates a `ViewConfig`.\n     * After calling [[sync]], it will un-pair from any `ui-view` with which it is currently paired.\n     *\n     * @param viewConfig The ViewConfig view to deregister.\n     */\n    ViewService.prototype.deactivateViewConfig = function (viewConfig) {\n        trace_1.trace.traceViewServiceEvent("<- Removing", viewConfig);\n        common_1.removeFrom(this._viewConfigs, viewConfig);\n    };\n    ViewService.prototype.activateViewConfig = function (viewConfig) {\n        trace_1.trace.traceViewServiceEvent("-> Registering", viewConfig);\n        this._viewConfigs.push(viewConfig);\n    };\n    ViewService.prototype.sync = function () {\n        var _this = this;\n        var uiViewsByFqn = this._uiViews.map(function (uiv) { return [uiv.fqn, uiv]; }).reduce(common_1.applyPairs, {});\n        // Return a weighted depth value for a uiView.\n        // The depth is the nesting depth of ui-views (based on FQN; times 10,000)\n        // plus the depth of the state that is populating the uiView\n        function uiViewDepth(uiView) {\n            var stateDepth = function (context) {\n                return context && context.parent ? stateDepth(context.parent) + 1 : 1;\n            };\n            return (uiView.fqn.split(".").length * 10000) + stateDepth(uiView.creationContext);\n        }\n        // Return the ViewConfig\'s context\'s depth in the context tree.\n        function viewConfigDepth(config) {\n            var context = config.viewDecl.$context, count = 0;\n            while (++count && context.parent)\n                context = context.parent;\n            return count;\n        }\n        // Given a depth function, returns a compare function which can return either ascending or descending order\n        var depthCompare = hof_1.curry(function (depthFn, posNeg, left, right) { return posNeg * (depthFn(left) - depthFn(right)); });\n        var matchingConfigPair = function (uiView) {\n            var matchingConfigs = _this._viewConfigs.filter(ViewService.matches(uiViewsByFqn, uiView));\n            if (matchingConfigs.length > 1) {\n                // This is OK.  Child states can target a ui-view that the parent state also targets (the child wins)\n                // Sort by depth and return the match from the deepest child\n                // console.log(`Multiple matching view configs for ${uiView.fqn}`, matchingConfigs);\n                matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending\n            }\n            return [uiView, matchingConfigs[0]];\n        };\n        var configureUIView = function (_a) {\n            var uiView = _a[0], viewConfig = _a[1];\n            // If a parent ui-view is reconfigured, it could destroy child ui-views.\n            // Before configuring a child ui-view, make sure it\'s still in the active uiViews array.\n            if (_this._uiViews.indexOf(uiView) !== -1)\n                uiView.configUpdated(viewConfig);\n        };\n        // Sort views by FQN and state depth. Process uiviews nearest the root first.\n        var pairs = this._uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair);\n        trace_1.trace.traceViewSync(pairs);\n        pairs.forEach(configureUIView);\n    };\n    ;\n    /**\n     * Registers a `ui-view` component\n     *\n     * When a `ui-view` component is created, it uses this method to register itself.\n     * After registration the [[sync]] method is used to ensure all `ui-view` are configured with the proper [[ViewConfig]].\n     *\n     * Note: the `ui-view` component uses the `ViewConfig` to determine what view should be loaded inside the `ui-view`,\n     * and what the view\'s state context is.\n     *\n     * Note: There is no corresponding `deregisterUIView`.\n     *       A `ui-view` should hang on to the return value of `registerUIView` and invoke it to deregister itself.\n     *\n     * @param uiView The metadata for a UIView\n     * @return a de-registration function used when the view is destroyed.\n     */\n    ViewService.prototype.registerUIView = function (uiView) {\n        trace_1.trace.traceViewServiceUIViewEvent("-> Registering", uiView);\n        var uiViews = this._uiViews;\n        var fqnAndTypeMatches = function (uiv) { return uiv.fqn === uiView.fqn && uiv.$type === uiView.$type; };\n        if (uiViews.filter(fqnAndTypeMatches).length)\n            trace_1.trace.traceViewServiceUIViewEvent("!!!! duplicate uiView named:", uiView);\n        uiViews.push(uiView);\n        this.sync();\n        return function () {\n            var idx = uiViews.indexOf(uiView);\n            if (idx === -1) {\n                trace_1.trace.traceViewServiceUIViewEvent("Tried removing non-registered uiView", uiView);\n                return;\n            }\n            trace_1.trace.traceViewServiceUIViewEvent("<- Deregistering", uiView);\n            common_1.removeFrom(uiViews)(uiView);\n        };\n    };\n    ;\n    /**\n     * Returns the list of views currently available on the page, by fully-qualified name.\n     *\n     * @return {Array} Returns an array of fully-qualified view names.\n     */\n    ViewService.prototype.available = function () {\n        return this._uiViews.map(hof_1.prop("fqn"));\n    };\n    /**\n     * Returns the list of views on the page containing loaded content.\n     *\n     * @return {Array} Returns an array of fully-qualified view names.\n     */\n    ViewService.prototype.active = function () {\n        return this._uiViews.filter(hof_1.prop("$config")).map(hof_1.prop("name"));\n    };\n    /**\n     * Normalizes a view\'s name from a state.views configuration block.\n     *\n     * This should be used by a framework implementation to calculate the values for\n     * [[_ViewDeclaration.$uiViewName]] and [[_ViewDeclaration.$uiViewContextAnchor]].\n     *\n     * @param context the context object (state declaration) that the view belongs to\n     * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]\n     *\n     * @returns the normalized uiViewName and uiViewContextAnchor that the view targets\n     */\n    ViewService.normalizeUIViewTarget = function (context, rawViewName) {\n        if (rawViewName === void 0) { rawViewName = ""; }\n        // TODO: Validate incoming view name with a regexp to allow:\n        // ex: "view.name@foo.bar" , "^.^.view.name" , "view.name@^.^" , "" ,\n        // "@" , "$default@^" , "!$default.$default" , "!foo.bar"\n        var viewAtContext = rawViewName.split("@");\n        var uiViewName = viewAtContext[0] || "$default"; // default to unnamed view\n        var uiViewContextAnchor = predicates_1.isString(viewAtContext[1]) ? viewAtContext[1] : "^"; // default to parent context\n        // Handle relative view-name sugar syntax.\n        // Matches rawViewName "^.^.^.foo.bar" into array: ["^.^.^.foo.bar", "^.^.^", "foo.bar"],\n        var relativeViewNameSugar = /^(\\^(?:\\.\\^)*)\\.(.*$)/.exec(uiViewName);\n        if (relativeViewNameSugar) {\n            // Clobbers existing contextAnchor (rawViewName validation will fix this)\n            uiViewContextAnchor = relativeViewNameSugar[1]; // set anchor to "^.^.^"\n            uiViewName = relativeViewNameSugar[2]; // set view-name to "foo.bar"\n        }\n        if (uiViewName.charAt(0) === \'!\') {\n            uiViewName = uiViewName.substr(1);\n            uiViewContextAnchor = ""; // target absolutely from root\n        }\n        // handle parent relative targeting "^.^.^"\n        var relativeMatch = /^(\\^(?:\\.\\^)*)$/;\n        if (relativeMatch.exec(uiViewContextAnchor)) {\n            var anchor = uiViewContextAnchor.split(".").reduce((function (anchor, x) { return anchor.parent; }), context);\n            uiViewContextAnchor = anchor.name;\n        }\n        else if (uiViewContextAnchor === \'.\') {\n            uiViewContextAnchor = context.name;\n        }\n        return { uiViewName: uiViewName, uiViewContextAnchor: uiViewContextAnchor };\n    };\n    /**\n     * Given a ui-view and a ViewConfig, determines if they "match".\n     *\n     * A ui-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in\n     * the DOM, describing its nesting relationship to any parent ui-view tags it is nested inside of.\n     *\n     * A ViewConfig has a target ui-view name and a context anchor.  The ui-view name can be a simple name, or\n     * can be a segmented ui-view path, describing a portion of a ui-view fqn.\n     *\n     * In order for a ui-view to match ViewConfig, ui-view\'s $type must match the ViewConfig\'s $type\n     *\n     * If the ViewConfig\'s target ui-view name is a simple name (no dots), then a ui-view matches if:\n     * - the ui-view\'s name matches the ViewConfig\'s target name\n     * - the ui-view\'s context matches the ViewConfig\'s anchor\n     *\n     * If the ViewConfig\'s target ui-view name is a segmented name (with dots), then a ui-view matches if:\n     * - There exists a parent ui-view where:\n     *    - the parent ui-view\'s name matches the first segment (index 0) of the ViewConfig\'s target name\n     *    - the parent ui-view\'s context matches the ViewConfig\'s anchor\n     * - And the remaining segments (index 1..n) of the ViewConfig\'s target name match the tail of the ui-view\'s fqn\n     *\n     * Example:\n     *\n     * DOM:\n     * <ui-view>                        \x3c!-- created in the root context (name: "") --\x3e\n     *   <ui-view name="foo">                \x3c!-- created in the context named: "A"      --\x3e\n     *     <ui-view>                    \x3c!-- created in the context named: "A.B"    --\x3e\n     *       <ui-view name="bar">            \x3c!-- created in the context named: "A.B.C"  --\x3e\n     *       </ui-view>\n     *     </ui-view>\n     *   </ui-view>\n     * </ui-view>\n     *\n     * uiViews: [\n     *  { fqn: "$default",                  creationContext: { name: "" } },\n     *  { fqn: "$default.foo",              creationContext: { name: "A" } },\n     *  { fqn: "$default.foo.$default",     creationContext: { name: "A.B" } }\n     *  { fqn: "$default.foo.$default.bar", creationContext: { name: "A.B.C" } }\n     * ]\n     *\n     * These four view configs all match the ui-view with the fqn: "$default.foo.$default.bar":\n     *\n     * - ViewConfig1: { uiViewName: "bar",                       uiViewContextAnchor: "A.B.C" }\n     * - ViewConfig2: { uiViewName: "$default.bar",              uiViewContextAnchor: "A.B" }\n     * - ViewConfig3: { uiViewName: "foo.$default.bar",          uiViewContextAnchor: "A" }\n     * - ViewConfig4: { uiViewName: "$default.foo.$default.bar", uiViewContextAnchor: "" }\n     *\n     * Using ViewConfig3 as an example, it matches the ui-view with fqn "$default.foo.$default.bar" because:\n     * - The ViewConfig\'s segmented target name is: [ "foo", "$default", "bar" ]\n     * - There exists a parent ui-view (which has fqn: "$default.foo") where:\n     *    - the parent ui-view\'s name "foo" matches the first segment "foo" of the ViewConfig\'s target name\n     *    - the parent ui-view\'s context "A" matches the ViewConfig\'s anchor context "A"\n     * - And the remaining segments [ "$default", "bar" ].join("."_ of the ViewConfig\'s target name match\n     *   the tail of the ui-view\'s fqn "default.bar"\n     *\n     * @internalapi\n     */\n    ViewService.matches = function (uiViewsByFqn, uiView) { return function (viewConfig) {\n        // Don\'t supply an ng1 ui-view with an ng2 ViewConfig, etc\n        if (uiView.$type !== viewConfig.viewDecl.$type)\n            return false;\n        // Split names apart from both viewConfig and uiView into segments\n        var vc = viewConfig.viewDecl;\n        var vcSegments = vc.$uiViewName.split(".");\n        var uivSegments = uiView.fqn.split(".");\n        // Check if the tails of the segment arrays match. ex, these arrays\' tails match:\n        // vc: ["foo", "bar"], uiv fqn: ["$default", "foo", "bar"]\n        if (!common_1.equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))\n            return false;\n        // Now check if the fqn ending at the first segment of the viewConfig matches the context:\n        // ["$default", "foo"].join(".") == "$default.foo", does the ui-view $default.foo context match?\n        var negOffset = (1 - vcSegments.length) || undefined;\n        var fqnToFirstSegment = uivSegments.slice(0, negOffset).join(".");\n        var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;\n        return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name);\n    }; };\n    return ViewService;\n}());\nexports.ViewService = ViewService;\n//# sourceMappingURL=view.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi92aWV3L3ZpZXcuanM/YmU4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgdmlld1xuICovIC8qKiBmb3IgdHlwZWRvYyAqL1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgdHJhY2VfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vdHJhY2VcIik7XG4vKipcbiAqIFRoZSBWaWV3IHNlcnZpY2VcbiAqXG4gKiBUaGlzIHNlcnZpY2UgcGFpcnMgZXhpc3RpbmcgYHVpLXZpZXdgIGNvbXBvbmVudHMgKHdoaWNoIGxpdmUgaW4gdGhlIERPTSlcbiAqIHdpdGggdmlldyBjb25maWdzIChmcm9tIHRoZSBzdGF0ZSBkZWNsYXJhdGlvbiBvYmplY3RzOiBbW1N0YXRlRGVjbGFyYXRpb24udmlld3NdXSkuXG4gKlxuICogLSBBZnRlciBhIHN1Y2Nlc3NmdWwgVHJhbnNpdGlvbiwgdGhlIHZpZXdzIGZyb20gdGhlIG5ld2x5IGVudGVyZWQgc3RhdGVzIGFyZSBhY3RpdmF0ZWQgdmlhIFtbYWN0aXZhdGVWaWV3Q29uZmlnXV0uXG4gKiAgIFRoZSB2aWV3cyBmcm9tIGV4aXRlZCBzdGF0ZXMgYXJlIGRlYWN0aXZhdGVkIHZpYSBbW2RlYWN0aXZhdGVWaWV3Q29uZmlnXV0uXG4gKiAgIChTZWU6IHRoZSBbW3JlZ2lzdGVyQWN0aXZhdGVWaWV3c11dIFRyYW5zaXRpb24gSG9vaylcbiAqXG4gKiAtIEFzIGB1aS12aWV3YCBjb21wb25lbnRzIHBvcCBpbiBhbmQgb3V0IG9mIGV4aXN0ZW5jZSwgdGhleSByZWdpc3RlciB0aGVtc2VsdmVzIHVzaW5nIFtbcmVnaXN0ZXJVSVZpZXddXS5cbiAqXG4gKiAtIFdoZW4gdGhlIFtbc3luY11dIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIHJlZ2lzdGVyZWQgYHVpLXZpZXdgKHMpIChbW0FjdGl2ZVVJVmlld11dKVxuICogYXJlIGNvbmZpZ3VyZWQgd2l0aCB0aGUgbWF0Y2hpbmcgW1tWaWV3Q29uZmlnXV0ocylcbiAqXG4gKi9cbnZhciBWaWV3U2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaWV3U2VydmljZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fdWlWaWV3cyA9IFtdO1xuICAgICAgICB0aGlzLl92aWV3Q29uZmlncyA9IFtdO1xuICAgICAgICB0aGlzLl92aWV3Q29uZmlnRmFjdG9yaWVzID0ge307XG4gICAgICAgIHRoaXMuX3BsdWdpbmFwaSA9IHtcbiAgICAgICAgICAgIF9yb290Vmlld0NvbnRleHQ6IHRoaXMuX3Jvb3RWaWV3Q29udGV4dC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgX3ZpZXdDb25maWdGYWN0b3J5OiB0aGlzLl92aWV3Q29uZmlnRmFjdG9yeS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgX3JlZ2lzdGVyZWRVSVZpZXdzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fdWlWaWV3czsgfSxcbiAgICAgICAgICAgIF9hY3RpdmVWaWV3Q29uZmlnczogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3ZpZXdDb25maWdzOyB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBWaWV3U2VydmljZS5wcm90b3R5cGUuX3Jvb3RWaWV3Q29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290Q29udGV4dCA9IGNvbnRleHQgfHwgdGhpcy5fcm9vdENvbnRleHQ7XG4gICAgfTtcbiAgICA7XG4gICAgVmlld1NlcnZpY2UucHJvdG90eXBlLl92aWV3Q29uZmlnRmFjdG9yeSA9IGZ1bmN0aW9uICh2aWV3VHlwZSwgZmFjdG9yeSkge1xuICAgICAgICB0aGlzLl92aWV3Q29uZmlnRmFjdG9yaWVzW3ZpZXdUeXBlXSA9IGZhY3Rvcnk7XG4gICAgfTtcbiAgICBWaWV3U2VydmljZS5wcm90b3R5cGUuY3JlYXRlVmlld0NvbmZpZyA9IGZ1bmN0aW9uIChwYXRoLCBkZWNsKSB7XG4gICAgICAgIHZhciBjZmdGYWN0b3J5ID0gdGhpcy5fdmlld0NvbmZpZ0ZhY3Rvcmllc1tkZWNsLiR0eXBlXTtcbiAgICAgICAgaWYgKCFjZmdGYWN0b3J5KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmlld1NlcnZpY2U6IE5vIHZpZXcgY29uZmlnIGZhY3RvcnkgcmVnaXN0ZXJlZCBmb3IgdHlwZSBcIiArIGRlY2wuJHR5cGUpO1xuICAgICAgICB2YXIgY2ZncyA9IGNmZ0ZhY3RvcnkocGF0aCwgZGVjbCk7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNBcnJheShjZmdzKSA/IGNmZ3MgOiBbY2Znc107XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWFjdGl2YXRlcyBhIFZpZXdDb25maWcuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGRlYWN0aXZhdGVzIGEgYFZpZXdDb25maWdgLlxuICAgICAqIEFmdGVyIGNhbGxpbmcgW1tzeW5jXV0sIGl0IHdpbGwgdW4tcGFpciBmcm9tIGFueSBgdWktdmlld2Agd2l0aCB3aGljaCBpdCBpcyBjdXJyZW50bHkgcGFpcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZpZXdDb25maWcgVGhlIFZpZXdDb25maWcgdmlldyB0byBkZXJlZ2lzdGVyLlxuICAgICAqL1xuICAgIFZpZXdTZXJ2aWNlLnByb3RvdHlwZS5kZWFjdGl2YXRlVmlld0NvbmZpZyA9IGZ1bmN0aW9uICh2aWV3Q29uZmlnKSB7XG4gICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VWaWV3U2VydmljZUV2ZW50KFwiPC0gUmVtb3ZpbmdcIiwgdmlld0NvbmZpZyk7XG4gICAgICAgIGNvbW1vbl8xLnJlbW92ZUZyb20odGhpcy5fdmlld0NvbmZpZ3MsIHZpZXdDb25maWcpO1xuICAgIH07XG4gICAgVmlld1NlcnZpY2UucHJvdG90eXBlLmFjdGl2YXRlVmlld0NvbmZpZyA9IGZ1bmN0aW9uICh2aWV3Q29uZmlnKSB7XG4gICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VWaWV3U2VydmljZUV2ZW50KFwiLT4gUmVnaXN0ZXJpbmdcIiwgdmlld0NvbmZpZyk7XG4gICAgICAgIHRoaXMuX3ZpZXdDb25maWdzLnB1c2godmlld0NvbmZpZyk7XG4gICAgfTtcbiAgICBWaWV3U2VydmljZS5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHVpVmlld3NCeUZxbiA9IHRoaXMuX3VpVmlld3MubWFwKGZ1bmN0aW9uICh1aXYpIHsgcmV0dXJuIFt1aXYuZnFuLCB1aXZdOyB9KS5yZWR1Y2UoY29tbW9uXzEuYXBwbHlQYWlycywge30pO1xuICAgICAgICAvLyBSZXR1cm4gYSB3ZWlnaHRlZCBkZXB0aCB2YWx1ZSBmb3IgYSB1aVZpZXcuXG4gICAgICAgIC8vIFRoZSBkZXB0aCBpcyB0aGUgbmVzdGluZyBkZXB0aCBvZiB1aS12aWV3cyAoYmFzZWQgb24gRlFOOyB0aW1lcyAxMCwwMDApXG4gICAgICAgIC8vIHBsdXMgdGhlIGRlcHRoIG9mIHRoZSBzdGF0ZSB0aGF0IGlzIHBvcHVsYXRpbmcgdGhlIHVpVmlld1xuICAgICAgICBmdW5jdGlvbiB1aVZpZXdEZXB0aCh1aVZpZXcpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZURlcHRoID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dCAmJiBjb250ZXh0LnBhcmVudCA/IHN0YXRlRGVwdGgoY29udGV4dC5wYXJlbnQpICsgMSA6IDE7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuICh1aVZpZXcuZnFuLnNwbGl0KFwiLlwiKS5sZW5ndGggKiAxMDAwMCkgKyBzdGF0ZURlcHRoKHVpVmlldy5jcmVhdGlvbkNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB0aGUgVmlld0NvbmZpZydzIGNvbnRleHQncyBkZXB0aCBpbiB0aGUgY29udGV4dCB0cmVlLlxuICAgICAgICBmdW5jdGlvbiB2aWV3Q29uZmlnRGVwdGgoY29uZmlnKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGNvbmZpZy52aWV3RGVjbC4kY29udGV4dCwgY291bnQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKCsrY291bnQgJiYgY29udGV4dC5wYXJlbnQpXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQucGFyZW50O1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIEdpdmVuIGEgZGVwdGggZnVuY3Rpb24sIHJldHVybnMgYSBjb21wYXJlIGZ1bmN0aW9uIHdoaWNoIGNhbiByZXR1cm4gZWl0aGVyIGFzY2VuZGluZyBvciBkZXNjZW5kaW5nIG9yZGVyXG4gICAgICAgIHZhciBkZXB0aENvbXBhcmUgPSBob2ZfMS5jdXJyeShmdW5jdGlvbiAoZGVwdGhGbiwgcG9zTmVnLCBsZWZ0LCByaWdodCkgeyByZXR1cm4gcG9zTmVnICogKGRlcHRoRm4obGVmdCkgLSBkZXB0aEZuKHJpZ2h0KSk7IH0pO1xuICAgICAgICB2YXIgbWF0Y2hpbmdDb25maWdQYWlyID0gZnVuY3Rpb24gKHVpVmlldykge1xuICAgICAgICAgICAgdmFyIG1hdGNoaW5nQ29uZmlncyA9IF90aGlzLl92aWV3Q29uZmlncy5maWx0ZXIoVmlld1NlcnZpY2UubWF0Y2hlcyh1aVZpZXdzQnlGcW4sIHVpVmlldykpO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nQ29uZmlncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBPSy4gIENoaWxkIHN0YXRlcyBjYW4gdGFyZ2V0IGEgdWktdmlldyB0aGF0IHRoZSBwYXJlbnQgc3RhdGUgYWxzbyB0YXJnZXRzICh0aGUgY2hpbGQgd2lucylcbiAgICAgICAgICAgICAgICAvLyBTb3J0IGJ5IGRlcHRoIGFuZCByZXR1cm4gdGhlIG1hdGNoIGZyb20gdGhlIGRlZXBlc3QgY2hpbGRcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgTXVsdGlwbGUgbWF0Y2hpbmcgdmlldyBjb25maWdzIGZvciAke3VpVmlldy5mcW59YCwgbWF0Y2hpbmdDb25maWdzKTtcbiAgICAgICAgICAgICAgICBtYXRjaGluZ0NvbmZpZ3Muc29ydChkZXB0aENvbXBhcmUodmlld0NvbmZpZ0RlcHRoLCAtMSkpOyAvLyBkZXNjZW5kaW5nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3VpVmlldywgbWF0Y2hpbmdDb25maWdzWzBdXTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNvbmZpZ3VyZVVJVmlldyA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHVpVmlldyA9IF9hWzBdLCB2aWV3Q29uZmlnID0gX2FbMV07XG4gICAgICAgICAgICAvLyBJZiBhIHBhcmVudCB1aS12aWV3IGlzIHJlY29uZmlndXJlZCwgaXQgY291bGQgZGVzdHJveSBjaGlsZCB1aS12aWV3cy5cbiAgICAgICAgICAgIC8vIEJlZm9yZSBjb25maWd1cmluZyBhIGNoaWxkIHVpLXZpZXcsIG1ha2Ugc3VyZSBpdCdzIHN0aWxsIGluIHRoZSBhY3RpdmUgdWlWaWV3cyBhcnJheS5cbiAgICAgICAgICAgIGlmIChfdGhpcy5fdWlWaWV3cy5pbmRleE9mKHVpVmlldykgIT09IC0xKVxuICAgICAgICAgICAgICAgIHVpVmlldy5jb25maWdVcGRhdGVkKHZpZXdDb25maWcpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBTb3J0IHZpZXdzIGJ5IEZRTiBhbmQgc3RhdGUgZGVwdGguIFByb2Nlc3MgdWl2aWV3cyBuZWFyZXN0IHRoZSByb290IGZpcnN0LlxuICAgICAgICB2YXIgcGFpcnMgPSB0aGlzLl91aVZpZXdzLnNvcnQoZGVwdGhDb21wYXJlKHVpVmlld0RlcHRoLCAxKSkubWFwKG1hdGNoaW5nQ29uZmlnUGFpcik7XG4gICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VWaWV3U3luYyhwYWlycyk7XG4gICAgICAgIHBhaXJzLmZvckVhY2goY29uZmlndXJlVUlWaWV3KTtcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBgdWktdmlld2AgY29tcG9uZW50XG4gICAgICpcbiAgICAgKiBXaGVuIGEgYHVpLXZpZXdgIGNvbXBvbmVudCBpcyBjcmVhdGVkLCBpdCB1c2VzIHRoaXMgbWV0aG9kIHRvIHJlZ2lzdGVyIGl0c2VsZi5cbiAgICAgKiBBZnRlciByZWdpc3RyYXRpb24gdGhlIFtbc3luY11dIG1ldGhvZCBpcyB1c2VkIHRvIGVuc3VyZSBhbGwgYHVpLXZpZXdgIGFyZSBjb25maWd1cmVkIHdpdGggdGhlIHByb3BlciBbW1ZpZXdDb25maWddXS5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoZSBgdWktdmlld2AgY29tcG9uZW50IHVzZXMgdGhlIGBWaWV3Q29uZmlnYCB0byBkZXRlcm1pbmUgd2hhdCB2aWV3IHNob3VsZCBiZSBsb2FkZWQgaW5zaWRlIHRoZSBgdWktdmlld2AsXG4gICAgICogYW5kIHdoYXQgdGhlIHZpZXcncyBzdGF0ZSBjb250ZXh0IGlzLlxuICAgICAqXG4gICAgICogTm90ZTogVGhlcmUgaXMgbm8gY29ycmVzcG9uZGluZyBgZGVyZWdpc3RlclVJVmlld2AuXG4gICAgICogICAgICAgQSBgdWktdmlld2Agc2hvdWxkIGhhbmcgb24gdG8gdGhlIHJldHVybiB2YWx1ZSBvZiBgcmVnaXN0ZXJVSVZpZXdgIGFuZCBpbnZva2UgaXQgdG8gZGVyZWdpc3RlciBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdWlWaWV3IFRoZSBtZXRhZGF0YSBmb3IgYSBVSVZpZXdcbiAgICAgKiBAcmV0dXJuIGEgZGUtcmVnaXN0cmF0aW9uIGZ1bmN0aW9uIHVzZWQgd2hlbiB0aGUgdmlldyBpcyBkZXN0cm95ZWQuXG4gICAgICovXG4gICAgVmlld1NlcnZpY2UucHJvdG90eXBlLnJlZ2lzdGVyVUlWaWV3ID0gZnVuY3Rpb24gKHVpVmlldykge1xuICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlVmlld1NlcnZpY2VVSVZpZXdFdmVudChcIi0+IFJlZ2lzdGVyaW5nXCIsIHVpVmlldyk7XG4gICAgICAgIHZhciB1aVZpZXdzID0gdGhpcy5fdWlWaWV3cztcbiAgICAgICAgdmFyIGZxbkFuZFR5cGVNYXRjaGVzID0gZnVuY3Rpb24gKHVpdikgeyByZXR1cm4gdWl2LmZxbiA9PT0gdWlWaWV3LmZxbiAmJiB1aXYuJHR5cGUgPT09IHVpVmlldy4kdHlwZTsgfTtcbiAgICAgICAgaWYgKHVpVmlld3MuZmlsdGVyKGZxbkFuZFR5cGVNYXRjaGVzKS5sZW5ndGgpXG4gICAgICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlVmlld1NlcnZpY2VVSVZpZXdFdmVudChcIiEhISEgZHVwbGljYXRlIHVpVmlldyBuYW1lZDpcIiwgdWlWaWV3KTtcbiAgICAgICAgdWlWaWV3cy5wdXNoKHVpVmlldyk7XG4gICAgICAgIHRoaXMuc3luYygpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlkeCA9IHVpVmlld3MuaW5kZXhPZih1aVZpZXcpO1xuICAgICAgICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlVmlld1NlcnZpY2VVSVZpZXdFdmVudChcIlRyaWVkIHJlbW92aW5nIG5vbi1yZWdpc3RlcmVkIHVpVmlld1wiLCB1aVZpZXcpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VWaWV3U2VydmljZVVJVmlld0V2ZW50KFwiPC0gRGVyZWdpc3RlcmluZ1wiLCB1aVZpZXcpO1xuICAgICAgICAgICAgY29tbW9uXzEucmVtb3ZlRnJvbSh1aVZpZXdzKSh1aVZpZXcpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2Ygdmlld3MgY3VycmVudGx5IGF2YWlsYWJsZSBvbiB0aGUgcGFnZSwgYnkgZnVsbHktcXVhbGlmaWVkIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBmdWxseS1xdWFsaWZpZWQgdmlldyBuYW1lcy5cbiAgICAgKi9cbiAgICBWaWV3U2VydmljZS5wcm90b3R5cGUuYXZhaWxhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdWlWaWV3cy5tYXAoaG9mXzEucHJvcChcImZxblwiKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHZpZXdzIG9uIHRoZSBwYWdlIGNvbnRhaW5pbmcgbG9hZGVkIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBmdWxseS1xdWFsaWZpZWQgdmlldyBuYW1lcy5cbiAgICAgKi9cbiAgICBWaWV3U2VydmljZS5wcm90b3R5cGUuYWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdWlWaWV3cy5maWx0ZXIoaG9mXzEucHJvcChcIiRjb25maWdcIikpLm1hcChob2ZfMS5wcm9wKFwibmFtZVwiKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemVzIGEgdmlldydzIG5hbWUgZnJvbSBhIHN0YXRlLnZpZXdzIGNvbmZpZ3VyYXRpb24gYmxvY2suXG4gICAgICpcbiAgICAgKiBUaGlzIHNob3VsZCBiZSB1c2VkIGJ5IGEgZnJhbWV3b3JrIGltcGxlbWVudGF0aW9uIHRvIGNhbGN1bGF0ZSB0aGUgdmFsdWVzIGZvclxuICAgICAqIFtbX1ZpZXdEZWNsYXJhdGlvbi4kdWlWaWV3TmFtZV1dIGFuZCBbW19WaWV3RGVjbGFyYXRpb24uJHVpVmlld0NvbnRleHRBbmNob3JdXS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250ZXh0IHRoZSBjb250ZXh0IG9iamVjdCAoc3RhdGUgZGVjbGFyYXRpb24pIHRoYXQgdGhlIHZpZXcgYmVsb25ncyB0b1xuICAgICAqIEBwYXJhbSByYXdWaWV3TmFtZSB0aGUgbmFtZSBvZiB0aGUgdmlldywgYXMgZGVjbGFyZWQgaW4gdGhlIFtbU3RhdGVEZWNsYXJhdGlvbi52aWV3c11dXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgbm9ybWFsaXplZCB1aVZpZXdOYW1lIGFuZCB1aVZpZXdDb250ZXh0QW5jaG9yIHRoYXQgdGhlIHZpZXcgdGFyZ2V0c1xuICAgICAqL1xuICAgIFZpZXdTZXJ2aWNlLm5vcm1hbGl6ZVVJVmlld1RhcmdldCA9IGZ1bmN0aW9uIChjb250ZXh0LCByYXdWaWV3TmFtZSkge1xuICAgICAgICBpZiAocmF3Vmlld05hbWUgPT09IHZvaWQgMCkgeyByYXdWaWV3TmFtZSA9IFwiXCI7IH1cbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgaW5jb21pbmcgdmlldyBuYW1lIHdpdGggYSByZWdleHAgdG8gYWxsb3c6XG4gICAgICAgIC8vIGV4OiBcInZpZXcubmFtZUBmb28uYmFyXCIgLCBcIl4uXi52aWV3Lm5hbWVcIiAsIFwidmlldy5uYW1lQF4uXlwiICwgXCJcIiAsXG4gICAgICAgIC8vIFwiQFwiICwgXCIkZGVmYXVsdEBeXCIgLCBcIiEkZGVmYXVsdC4kZGVmYXVsdFwiICwgXCIhZm9vLmJhclwiXG4gICAgICAgIHZhciB2aWV3QXRDb250ZXh0ID0gcmF3Vmlld05hbWUuc3BsaXQoXCJAXCIpO1xuICAgICAgICB2YXIgdWlWaWV3TmFtZSA9IHZpZXdBdENvbnRleHRbMF0gfHwgXCIkZGVmYXVsdFwiOyAvLyBkZWZhdWx0IHRvIHVubmFtZWQgdmlld1xuICAgICAgICB2YXIgdWlWaWV3Q29udGV4dEFuY2hvciA9IHByZWRpY2F0ZXNfMS5pc1N0cmluZyh2aWV3QXRDb250ZXh0WzFdKSA/IHZpZXdBdENvbnRleHRbMV0gOiBcIl5cIjsgLy8gZGVmYXVsdCB0byBwYXJlbnQgY29udGV4dFxuICAgICAgICAvLyBIYW5kbGUgcmVsYXRpdmUgdmlldy1uYW1lIHN1Z2FyIHN5bnRheC5cbiAgICAgICAgLy8gTWF0Y2hlcyByYXdWaWV3TmFtZSBcIl4uXi5eLmZvby5iYXJcIiBpbnRvIGFycmF5OiBbXCJeLl4uXi5mb28uYmFyXCIsIFwiXi5eLl5cIiwgXCJmb28uYmFyXCJdLFxuICAgICAgICB2YXIgcmVsYXRpdmVWaWV3TmFtZVN1Z2FyID0gL14oXFxeKD86XFwuXFxeKSopXFwuKC4qJCkvLmV4ZWModWlWaWV3TmFtZSk7XG4gICAgICAgIGlmIChyZWxhdGl2ZVZpZXdOYW1lU3VnYXIpIHtcbiAgICAgICAgICAgIC8vIENsb2JiZXJzIGV4aXN0aW5nIGNvbnRleHRBbmNob3IgKHJhd1ZpZXdOYW1lIHZhbGlkYXRpb24gd2lsbCBmaXggdGhpcylcbiAgICAgICAgICAgIHVpVmlld0NvbnRleHRBbmNob3IgPSByZWxhdGl2ZVZpZXdOYW1lU3VnYXJbMV07IC8vIHNldCBhbmNob3IgdG8gXCJeLl4uXlwiXG4gICAgICAgICAgICB1aVZpZXdOYW1lID0gcmVsYXRpdmVWaWV3TmFtZVN1Z2FyWzJdOyAvLyBzZXQgdmlldy1uYW1lIHRvIFwiZm9vLmJhclwiXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVpVmlld05hbWUuY2hhckF0KDApID09PSAnIScpIHtcbiAgICAgICAgICAgIHVpVmlld05hbWUgPSB1aVZpZXdOYW1lLnN1YnN0cigxKTtcbiAgICAgICAgICAgIHVpVmlld0NvbnRleHRBbmNob3IgPSBcIlwiOyAvLyB0YXJnZXQgYWJzb2x1dGVseSBmcm9tIHJvb3RcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgcGFyZW50IHJlbGF0aXZlIHRhcmdldGluZyBcIl4uXi5eXCJcbiAgICAgICAgdmFyIHJlbGF0aXZlTWF0Y2ggPSAvXihcXF4oPzpcXC5cXF4pKikkLztcbiAgICAgICAgaWYgKHJlbGF0aXZlTWF0Y2guZXhlYyh1aVZpZXdDb250ZXh0QW5jaG9yKSkge1xuICAgICAgICAgICAgdmFyIGFuY2hvciA9IHVpVmlld0NvbnRleHRBbmNob3Iuc3BsaXQoXCIuXCIpLnJlZHVjZSgoZnVuY3Rpb24gKGFuY2hvciwgeCkgeyByZXR1cm4gYW5jaG9yLnBhcmVudDsgfSksIGNvbnRleHQpO1xuICAgICAgICAgICAgdWlWaWV3Q29udGV4dEFuY2hvciA9IGFuY2hvci5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVpVmlld0NvbnRleHRBbmNob3IgPT09ICcuJykge1xuICAgICAgICAgICAgdWlWaWV3Q29udGV4dEFuY2hvciA9IGNvbnRleHQubmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB1aVZpZXdOYW1lOiB1aVZpZXdOYW1lLCB1aVZpZXdDb250ZXh0QW5jaG9yOiB1aVZpZXdDb250ZXh0QW5jaG9yIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHVpLXZpZXcgYW5kIGEgVmlld0NvbmZpZywgZGV0ZXJtaW5lcyBpZiB0aGV5IFwibWF0Y2hcIi5cbiAgICAgKlxuICAgICAqIEEgdWktdmlldyBoYXMgYSBmdWxseSBxdWFsaWZpZWQgbmFtZSAoZnFuKSBhbmQgYSBjb250ZXh0IG9iamVjdC4gIFRoZSBmcW4gaXMgYnVpbHQgZnJvbSBpdHMgb3ZlcmFsbCBsb2NhdGlvbiBpblxuICAgICAqIHRoZSBET00sIGRlc2NyaWJpbmcgaXRzIG5lc3RpbmcgcmVsYXRpb25zaGlwIHRvIGFueSBwYXJlbnQgdWktdmlldyB0YWdzIGl0IGlzIG5lc3RlZCBpbnNpZGUgb2YuXG4gICAgICpcbiAgICAgKiBBIFZpZXdDb25maWcgaGFzIGEgdGFyZ2V0IHVpLXZpZXcgbmFtZSBhbmQgYSBjb250ZXh0IGFuY2hvci4gIFRoZSB1aS12aWV3IG5hbWUgY2FuIGJlIGEgc2ltcGxlIG5hbWUsIG9yXG4gICAgICogY2FuIGJlIGEgc2VnbWVudGVkIHVpLXZpZXcgcGF0aCwgZGVzY3JpYmluZyBhIHBvcnRpb24gb2YgYSB1aS12aWV3IGZxbi5cbiAgICAgKlxuICAgICAqIEluIG9yZGVyIGZvciBhIHVpLXZpZXcgdG8gbWF0Y2ggVmlld0NvbmZpZywgdWktdmlldydzICR0eXBlIG11c3QgbWF0Y2ggdGhlIFZpZXdDb25maWcncyAkdHlwZVxuICAgICAqXG4gICAgICogSWYgdGhlIFZpZXdDb25maWcncyB0YXJnZXQgdWktdmlldyBuYW1lIGlzIGEgc2ltcGxlIG5hbWUgKG5vIGRvdHMpLCB0aGVuIGEgdWktdmlldyBtYXRjaGVzIGlmOlxuICAgICAqIC0gdGhlIHVpLXZpZXcncyBuYW1lIG1hdGNoZXMgdGhlIFZpZXdDb25maWcncyB0YXJnZXQgbmFtZVxuICAgICAqIC0gdGhlIHVpLXZpZXcncyBjb250ZXh0IG1hdGNoZXMgdGhlIFZpZXdDb25maWcncyBhbmNob3JcbiAgICAgKlxuICAgICAqIElmIHRoZSBWaWV3Q29uZmlnJ3MgdGFyZ2V0IHVpLXZpZXcgbmFtZSBpcyBhIHNlZ21lbnRlZCBuYW1lICh3aXRoIGRvdHMpLCB0aGVuIGEgdWktdmlldyBtYXRjaGVzIGlmOlxuICAgICAqIC0gVGhlcmUgZXhpc3RzIGEgcGFyZW50IHVpLXZpZXcgd2hlcmU6XG4gICAgICogICAgLSB0aGUgcGFyZW50IHVpLXZpZXcncyBuYW1lIG1hdGNoZXMgdGhlIGZpcnN0IHNlZ21lbnQgKGluZGV4IDApIG9mIHRoZSBWaWV3Q29uZmlnJ3MgdGFyZ2V0IG5hbWVcbiAgICAgKiAgICAtIHRoZSBwYXJlbnQgdWktdmlldydzIGNvbnRleHQgbWF0Y2hlcyB0aGUgVmlld0NvbmZpZydzIGFuY2hvclxuICAgICAqIC0gQW5kIHRoZSByZW1haW5pbmcgc2VnbWVudHMgKGluZGV4IDEuLm4pIG9mIHRoZSBWaWV3Q29uZmlnJ3MgdGFyZ2V0IG5hbWUgbWF0Y2ggdGhlIHRhaWwgb2YgdGhlIHVpLXZpZXcncyBmcW5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBET006XG4gICAgICogPHVpLXZpZXc+ICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBjcmVhdGVkIGluIHRoZSByb290IGNvbnRleHQgKG5hbWU6IFwiXCIpIC0tPlxuICAgICAqICAgPHVpLXZpZXcgbmFtZT1cImZvb1wiPiAgICAgICAgICAgICAgICA8IS0tIGNyZWF0ZWQgaW4gdGhlIGNvbnRleHQgbmFtZWQ6IFwiQVwiICAgICAgLS0+XG4gICAgICogICAgIDx1aS12aWV3PiAgICAgICAgICAgICAgICAgICAgPCEtLSBjcmVhdGVkIGluIHRoZSBjb250ZXh0IG5hbWVkOiBcIkEuQlwiICAgIC0tPlxuICAgICAqICAgICAgIDx1aS12aWV3IG5hbWU9XCJiYXJcIj4gICAgICAgICAgICA8IS0tIGNyZWF0ZWQgaW4gdGhlIGNvbnRleHQgbmFtZWQ6IFwiQS5CLkNcIiAgLS0+XG4gICAgICogICAgICAgPC91aS12aWV3PlxuICAgICAqICAgICA8L3VpLXZpZXc+XG4gICAgICogICA8L3VpLXZpZXc+XG4gICAgICogPC91aS12aWV3PlxuICAgICAqXG4gICAgICogdWlWaWV3czogW1xuICAgICAqICB7IGZxbjogXCIkZGVmYXVsdFwiLCAgICAgICAgICAgICAgICAgIGNyZWF0aW9uQ29udGV4dDogeyBuYW1lOiBcIlwiIH0gfSxcbiAgICAgKiAgeyBmcW46IFwiJGRlZmF1bHQuZm9vXCIsICAgICAgICAgICAgICBjcmVhdGlvbkNvbnRleHQ6IHsgbmFtZTogXCJBXCIgfSB9LFxuICAgICAqICB7IGZxbjogXCIkZGVmYXVsdC5mb28uJGRlZmF1bHRcIiwgICAgIGNyZWF0aW9uQ29udGV4dDogeyBuYW1lOiBcIkEuQlwiIH0gfVxuICAgICAqICB7IGZxbjogXCIkZGVmYXVsdC5mb28uJGRlZmF1bHQuYmFyXCIsIGNyZWF0aW9uQ29udGV4dDogeyBuYW1lOiBcIkEuQi5DXCIgfSB9XG4gICAgICogXVxuICAgICAqXG4gICAgICogVGhlc2UgZm91ciB2aWV3IGNvbmZpZ3MgYWxsIG1hdGNoIHRoZSB1aS12aWV3IHdpdGggdGhlIGZxbjogXCIkZGVmYXVsdC5mb28uJGRlZmF1bHQuYmFyXCI6XG4gICAgICpcbiAgICAgKiAtIFZpZXdDb25maWcxOiB7IHVpVmlld05hbWU6IFwiYmFyXCIsICAgICAgICAgICAgICAgICAgICAgICB1aVZpZXdDb250ZXh0QW5jaG9yOiBcIkEuQi5DXCIgfVxuICAgICAqIC0gVmlld0NvbmZpZzI6IHsgdWlWaWV3TmFtZTogXCIkZGVmYXVsdC5iYXJcIiwgICAgICAgICAgICAgIHVpVmlld0NvbnRleHRBbmNob3I6IFwiQS5CXCIgfVxuICAgICAqIC0gVmlld0NvbmZpZzM6IHsgdWlWaWV3TmFtZTogXCJmb28uJGRlZmF1bHQuYmFyXCIsICAgICAgICAgIHVpVmlld0NvbnRleHRBbmNob3I6IFwiQVwiIH1cbiAgICAgKiAtIFZpZXdDb25maWc0OiB7IHVpVmlld05hbWU6IFwiJGRlZmF1bHQuZm9vLiRkZWZhdWx0LmJhclwiLCB1aVZpZXdDb250ZXh0QW5jaG9yOiBcIlwiIH1cbiAgICAgKlxuICAgICAqIFVzaW5nIFZpZXdDb25maWczIGFzIGFuIGV4YW1wbGUsIGl0IG1hdGNoZXMgdGhlIHVpLXZpZXcgd2l0aCBmcW4gXCIkZGVmYXVsdC5mb28uJGRlZmF1bHQuYmFyXCIgYmVjYXVzZTpcbiAgICAgKiAtIFRoZSBWaWV3Q29uZmlnJ3Mgc2VnbWVudGVkIHRhcmdldCBuYW1lIGlzOiBbIFwiZm9vXCIsIFwiJGRlZmF1bHRcIiwgXCJiYXJcIiBdXG4gICAgICogLSBUaGVyZSBleGlzdHMgYSBwYXJlbnQgdWktdmlldyAod2hpY2ggaGFzIGZxbjogXCIkZGVmYXVsdC5mb29cIikgd2hlcmU6XG4gICAgICogICAgLSB0aGUgcGFyZW50IHVpLXZpZXcncyBuYW1lIFwiZm9vXCIgbWF0Y2hlcyB0aGUgZmlyc3Qgc2VnbWVudCBcImZvb1wiIG9mIHRoZSBWaWV3Q29uZmlnJ3MgdGFyZ2V0IG5hbWVcbiAgICAgKiAgICAtIHRoZSBwYXJlbnQgdWktdmlldydzIGNvbnRleHQgXCJBXCIgbWF0Y2hlcyB0aGUgVmlld0NvbmZpZydzIGFuY2hvciBjb250ZXh0IFwiQVwiXG4gICAgICogLSBBbmQgdGhlIHJlbWFpbmluZyBzZWdtZW50cyBbIFwiJGRlZmF1bHRcIiwgXCJiYXJcIiBdLmpvaW4oXCIuXCJfIG9mIHRoZSBWaWV3Q29uZmlnJ3MgdGFyZ2V0IG5hbWUgbWF0Y2hcbiAgICAgKiAgIHRoZSB0YWlsIG9mIHRoZSB1aS12aWV3J3MgZnFuIFwiZGVmYXVsdC5iYXJcIlxuICAgICAqXG4gICAgICogQGludGVybmFsYXBpXG4gICAgICovXG4gICAgVmlld1NlcnZpY2UubWF0Y2hlcyA9IGZ1bmN0aW9uICh1aVZpZXdzQnlGcW4sIHVpVmlldykgeyByZXR1cm4gZnVuY3Rpb24gKHZpZXdDb25maWcpIHtcbiAgICAgICAgLy8gRG9uJ3Qgc3VwcGx5IGFuIG5nMSB1aS12aWV3IHdpdGggYW4gbmcyIFZpZXdDb25maWcsIGV0Y1xuICAgICAgICBpZiAodWlWaWV3LiR0eXBlICE9PSB2aWV3Q29uZmlnLnZpZXdEZWNsLiR0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBTcGxpdCBuYW1lcyBhcGFydCBmcm9tIGJvdGggdmlld0NvbmZpZyBhbmQgdWlWaWV3IGludG8gc2VnbWVudHNcbiAgICAgICAgdmFyIHZjID0gdmlld0NvbmZpZy52aWV3RGVjbDtcbiAgICAgICAgdmFyIHZjU2VnbWVudHMgPSB2Yy4kdWlWaWV3TmFtZS5zcGxpdChcIi5cIik7XG4gICAgICAgIHZhciB1aXZTZWdtZW50cyA9IHVpVmlldy5mcW4uc3BsaXQoXCIuXCIpO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgdGFpbHMgb2YgdGhlIHNlZ21lbnQgYXJyYXlzIG1hdGNoLiBleCwgdGhlc2UgYXJyYXlzJyB0YWlscyBtYXRjaDpcbiAgICAgICAgLy8gdmM6IFtcImZvb1wiLCBcImJhclwiXSwgdWl2IGZxbjogW1wiJGRlZmF1bHRcIiwgXCJmb29cIiwgXCJiYXJcIl1cbiAgICAgICAgaWYgKCFjb21tb25fMS5lcXVhbHModmNTZWdtZW50cywgdWl2U2VnbWVudHMuc2xpY2UoMCAtIHZjU2VnbWVudHMubGVuZ3RoKSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIE5vdyBjaGVjayBpZiB0aGUgZnFuIGVuZGluZyBhdCB0aGUgZmlyc3Qgc2VnbWVudCBvZiB0aGUgdmlld0NvbmZpZyBtYXRjaGVzIHRoZSBjb250ZXh0OlxuICAgICAgICAvLyBbXCIkZGVmYXVsdFwiLCBcImZvb1wiXS5qb2luKFwiLlwiKSA9PSBcIiRkZWZhdWx0LmZvb1wiLCBkb2VzIHRoZSB1aS12aWV3ICRkZWZhdWx0LmZvbyBjb250ZXh0IG1hdGNoP1xuICAgICAgICB2YXIgbmVnT2Zmc2V0ID0gKDEgLSB2Y1NlZ21lbnRzLmxlbmd0aCkgfHwgdW5kZWZpbmVkO1xuICAgICAgICB2YXIgZnFuVG9GaXJzdFNlZ21lbnQgPSB1aXZTZWdtZW50cy5zbGljZSgwLCBuZWdPZmZzZXQpLmpvaW4oXCIuXCIpO1xuICAgICAgICB2YXIgdWlWaWV3Q29udGV4dCA9IHVpVmlld3NCeUZxbltmcW5Ub0ZpcnN0U2VnbWVudF0uY3JlYXRpb25Db250ZXh0O1xuICAgICAgICByZXR1cm4gdmMuJHVpVmlld0NvbnRleHRBbmNob3IgPT09ICh1aVZpZXdDb250ZXh0ICYmIHVpVmlld0NvbnRleHQubmFtZSk7XG4gICAgfTsgfTtcbiAgICByZXR1cm4gVmlld1NlcnZpY2U7XG59KCkpO1xuZXhwb3J0cy5WaWV3U2VydmljZSA9IFZpZXdTZXJ2aWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlldy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL3ZpZXcvdmlldy5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///52\n')},function(module,exports,__webpack_require__){eval("/**\n * State-based routing for AngularJS 1.x\n * This bundle requires the ui-router-core.js bundle from the @uirouter/core package.\n * @version v1.0.11\n * @link https://ui-router.github.io\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n(function (global, factory) {\n\t true ? factory(exports, __webpack_require__(/*! angular */ 14), __webpack_require__(/*! @uirouter/core */ 68)) :\n\ttypeof define === 'function' && define.amd ? define(['exports', 'angular', '@uirouter/core'], factory) :\n\t(factory((global['@uirouter/angularjs'] = {}),global.angular,global['@uirouter/core']));\n}(this, (function (exports,ng_from_import,core) { 'use strict';\n\nvar ng_from_global = angular;\nvar ng = (ng_from_import && ng_from_import.module) ? ng_from_import : ng_from_global;\n\nfunction getNg1ViewConfigFactory() {\n    var templateFactory = null;\n    return function (path, view) {\n        templateFactory = templateFactory || core.services.$injector.get(\"$templateFactory\");\n        return [new Ng1ViewConfig(path, view, templateFactory)];\n    };\n}\nvar hasAnyKey = function (keys, obj) {\n    return keys.reduce(function (acc, key) { return acc || core.isDefined(obj[key]); }, false);\n};\n/**\n * This is a [[StateBuilder.builder]] function for angular1 `views`.\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * handles the `views` property with logic specific to @uirouter/angularjs (ng1).\n *\n * If no `views: {}` property exists on the [[StateDeclaration]], then it creates the `views` object\n * and applies the state-level configuration to a view named `$default`.\n */\nfunction ng1ViewsBuilder(state) {\n    // Do not process root state\n    if (!state.parent)\n        return {};\n    var tplKeys = ['templateProvider', 'templateUrl', 'template', 'notify', 'async'], ctrlKeys = ['controller', 'controllerProvider', 'controllerAs', 'resolveAs'], compKeys = ['component', 'bindings', 'componentProvider'], nonCompKeys = tplKeys.concat(ctrlKeys), allViewKeys = compKeys.concat(nonCompKeys);\n    // Do not allow a state to have both state-level props and also a `views: {}` property.\n    // A state without a `views: {}` property can declare properties for the `$default` view as properties of the state.\n    // However, the `$default` approach should not be mixed with a separate `views: ` block.\n    if (core.isDefined(state.views) && hasAnyKey(allViewKeys, state)) {\n        throw new Error(\"State '\" + state.name + \"' has a 'views' object. \" +\n            \"It cannot also have \\\"view properties\\\" at the state level.  \" +\n            \"Move the following properties into a view (in the 'views' object): \" +\n            (\" \" + allViewKeys.filter(function (key) { return core.isDefined(state[key]); }).join(\", \")));\n    }\n    var views = {}, viewsObject = state.views || { \"$default\": core.pick(state, allViewKeys) };\n    core.forEach(viewsObject, function (config, name) {\n        // Account for views: { \"\": { template... } }\n        name = name || \"$default\";\n        // Account for views: { header: \"headerComponent\" }\n        if (core.isString(config))\n            config = { component: config };\n        // Make a shallow copy of the config object\n        config = core.extend({}, config);\n        // Do not allow a view to mix props for component-style view with props for template/controller-style view\n        if (hasAnyKey(compKeys, config) && hasAnyKey(nonCompKeys, config)) {\n            throw new Error(\"Cannot combine: \" + compKeys.join(\"|\") + \" with: \" + nonCompKeys.join(\"|\") + \" in stateview: '\" + name + \"@\" + state.name + \"'\");\n        }\n        config.resolveAs = config.resolveAs || '$resolve';\n        config.$type = \"ng1\";\n        config.$context = state;\n        config.$name = name;\n        var normalized = core.ViewService.normalizeUIViewTarget(config.$context, config.$name);\n        config.$uiViewName = normalized.uiViewName;\n        config.$uiViewContextAnchor = normalized.uiViewContextAnchor;\n        views[name] = config;\n    });\n    return views;\n}\nvar id = 0;\nvar Ng1ViewConfig = /** @class */ (function () {\n    function Ng1ViewConfig(path, viewDecl, factory) {\n        var _this = this;\n        this.path = path;\n        this.viewDecl = viewDecl;\n        this.factory = factory;\n        this.$id = id++;\n        this.loaded = false;\n        this.getTemplate = function (uiView, context) {\n            return _this.component ? _this.factory.makeComponentTemplate(uiView, context, _this.component, _this.viewDecl.bindings) : _this.template;\n        };\n    }\n    Ng1ViewConfig.prototype.load = function () {\n        var _this = this;\n        var $q = core.services.$q;\n        var context = new core.ResolveContext(this.path);\n        var params = this.path.reduce(function (acc, node) { return core.extend(acc, node.paramValues); }, {});\n        var promises = {\n            template: $q.when(this.factory.fromConfig(this.viewDecl, params, context)),\n            controller: $q.when(this.getController(context))\n        };\n        return $q.all(promises).then(function (results) {\n            core.trace.traceViewServiceEvent(\"Loaded\", _this);\n            _this.controller = results.controller;\n            core.extend(_this, results.template); // Either { template: \"tpl\" } or { component: \"cmpName\" }\n            return _this;\n        });\n    };\n    /**\n     * Gets the controller for a view configuration.\n     *\n     * @returns {Function|Promise.<Function>} Returns a controller, or a promise that resolves to a controller.\n     */\n    Ng1ViewConfig.prototype.getController = function (context) {\n        var provider = this.viewDecl.controllerProvider;\n        if (!core.isInjectable(provider))\n            return this.viewDecl.controller;\n        var deps = core.services.$injector.annotate(provider);\n        var providerFn = core.isArray(provider) ? core.tail(provider) : provider;\n        var resolvable = new core.Resolvable(\"\", providerFn, deps);\n        return resolvable.get(context);\n    };\n    return Ng1ViewConfig;\n}());\n\n/** @module view */\n/** for typedoc */\n/**\n * Service which manages loading of templates from a ViewConfig.\n */\nvar TemplateFactory = /** @class */ (function () {\n    function TemplateFactory() {\n        var _this = this;\n        /** @hidden */ this._useHttp = ng.version.minor < 3;\n        /** @hidden */ this.$get = ['$http', '$templateCache', '$injector', function ($http, $templateCache, $injector) {\n                _this.$templateRequest = $injector.has && $injector.has('$templateRequest') && $injector.get('$templateRequest');\n                _this.$http = $http;\n                _this.$templateCache = $templateCache;\n                return _this;\n            }];\n    }\n    /** @hidden */\n    TemplateFactory.prototype.useHttpService = function (value) {\n        this._useHttp = value;\n    };\n    \n    /**\n     * Creates a template from a configuration object.\n     *\n     * @param config Configuration object for which to load a template.\n     * The following properties are search in the specified order, and the first one\n     * that is defined is used to create the template:\n     *\n     * @param params  Parameters to pass to the template function.\n     * @param context The resolve context associated with the template's view\n     *\n     * @return {string|object}  The template html as a string, or a promise for\n     * that string,or `null` if no template is configured.\n     */\n    TemplateFactory.prototype.fromConfig = function (config, params, context) {\n        var defaultTemplate = \"<ui-view></ui-view>\";\n        var asTemplate = function (result) { return core.services.$q.when(result).then(function (str) { return ({ template: str }); }); };\n        var asComponent = function (result) { return core.services.$q.when(result).then(function (str) { return ({ component: str }); }); };\n        return (core.isDefined(config.template) ? asTemplate(this.fromString(config.template, params)) :\n            core.isDefined(config.templateUrl) ? asTemplate(this.fromUrl(config.templateUrl, params)) :\n                core.isDefined(config.templateProvider) ? asTemplate(this.fromProvider(config.templateProvider, params, context)) :\n                    core.isDefined(config.component) ? asComponent(config.component) :\n                        core.isDefined(config.componentProvider) ? asComponent(this.fromComponentProvider(config.componentProvider, params, context)) :\n                            asTemplate(defaultTemplate));\n    };\n    \n    /**\n     * Creates a template from a string or a function returning a string.\n     *\n     * @param template html template as a string or function that returns an html template as a string.\n     * @param params Parameters to pass to the template function.\n     *\n     * @return {string|object} The template html as a string, or a promise for that\n     * string.\n     */\n    TemplateFactory.prototype.fromString = function (template, params) {\n        return core.isFunction(template) ? template(params) : template;\n    };\n    \n    /**\n     * Loads a template from the a URL via `$http` and `$templateCache`.\n     *\n     * @param {string|Function} url url of the template to load, or a function\n     * that returns a url.\n     * @param {Object} params Parameters to pass to the url function.\n     * @return {string|Promise.<string>} The template html as a string, or a promise\n     * for that string.\n     */\n    TemplateFactory.prototype.fromUrl = function (url, params) {\n        if (core.isFunction(url))\n            url = url(params);\n        if (url == null)\n            return null;\n        if (this._useHttp) {\n            return this.$http.get(url, { cache: this.$templateCache, headers: { Accept: 'text/html' } })\n                .then(function (response) {\n                return response.data;\n            });\n        }\n        return this.$templateRequest(url);\n    };\n    \n    /**\n     * Creates a template by invoking an injectable provider function.\n     *\n     * @param provider Function to invoke via `locals`\n     * @param {Function} injectFn a function used to invoke the template provider\n     * @return {string|Promise.<string>} The template html as a string, or a promise\n     * for that string.\n     */\n    TemplateFactory.prototype.fromProvider = function (provider, params, context) {\n        var deps = core.services.$injector.annotate(provider);\n        var providerFn = core.isArray(provider) ? core.tail(provider) : provider;\n        var resolvable = new core.Resolvable(\"\", providerFn, deps);\n        return resolvable.get(context);\n    };\n    \n    /**\n     * Creates a component's template by invoking an injectable provider function.\n     *\n     * @param provider Function to invoke via `locals`\n     * @param {Function} injectFn a function used to invoke the template provider\n     * @return {string} The template html as a string: \"<component-name input1='::$resolve.foo'></component-name>\".\n     */\n    TemplateFactory.prototype.fromComponentProvider = function (provider, params, context) {\n        var deps = core.services.$injector.annotate(provider);\n        var providerFn = core.isArray(provider) ? core.tail(provider) : provider;\n        var resolvable = new core.Resolvable(\"\", providerFn, deps);\n        return resolvable.get(context);\n    };\n    \n    /**\n     * Creates a template from a component's name\n     *\n     * This implements route-to-component.\n     * It works by retrieving the component (directive) metadata from the injector.\n     * It analyses the component's bindings, then constructs a template that instantiates the component.\n     * The template wires input and output bindings to resolves or from the parent component.\n     *\n     * @param uiView {object} The parent ui-view (for binding outputs to callbacks)\n     * @param context The ResolveContext (for binding outputs to callbacks returned from resolves)\n     * @param component {string} Component's name in camel case.\n     * @param bindings An object defining the component's bindings: {foo: '<'}\n     * @return {string} The template as a string: \"<component-name input1='::$resolve.foo'></component-name>\".\n     */\n    TemplateFactory.prototype.makeComponentTemplate = function (uiView, context, component, bindings) {\n        bindings = bindings || {};\n        // Bind once prefix\n        var prefix = ng.version.minor >= 3 ? \"::\" : \"\";\n        // Convert to kebob name. Add x- prefix if the string starts with `x-` or `data-`\n        var kebob = function (camelCase) {\n            var kebobed = core.kebobString(camelCase);\n            return /^(x|data)-/.exec(kebobed) ? \"x-\" + kebobed : kebobed;\n        };\n        var attributeTpl = function (input) {\n            var name = input.name, type = input.type;\n            var attrName = kebob(name);\n            // If the ui-view has an attribute which matches a binding on the routed component\n            // then pass that attribute through to the routed component template.\n            // Prefer ui-view wired mappings to resolve data, unless the resolve was explicitly bound using `bindings:`\n            if (uiView.attr(attrName) && !bindings[name])\n                return attrName + \"='\" + uiView.attr(attrName) + \"'\";\n            var resolveName = bindings[name] || name;\n            // Pre-evaluate the expression for \"@\" bindings by enclosing in {{ }}\n            // some-attr=\"{{ ::$resolve.someResolveName }}\"\n            if (type === '@')\n                return attrName + \"='{{\" + prefix + \"$resolve.\" + resolveName + \"}}'\";\n            // Wire \"&\" callbacks to resolves that return a callback function\n            // Get the result of the resolve (should be a function) and annotate it to get its arguments.\n            // some-attr=\"$resolve.someResolveResultName(foo, bar)\"\n            if (type === '&') {\n                var res = context.getResolvable(resolveName);\n                var fn = res && res.data;\n                var args = fn && core.services.$injector.annotate(fn) || [];\n                // account for array style injection, i.e., ['foo', function(foo) {}]\n                var arrayIdxStr = core.isArray(fn) ? \"[\" + (fn.length - 1) + \"]\" : '';\n                return attrName + \"='$resolve.\" + resolveName + arrayIdxStr + \"(\" + args.join(\",\") + \")'\";\n            }\n            // some-attr=\"::$resolve.someResolveName\"\n            return attrName + \"='\" + prefix + \"$resolve.\" + resolveName + \"'\";\n        };\n        var attrs = getComponentBindings(component).map(attributeTpl).join(\" \");\n        var kebobName = kebob(component);\n        return \"<\" + kebobName + \" \" + attrs + \"></\" + kebobName + \">\";\n    };\n    \n    return TemplateFactory;\n}());\n// Gets all the directive(s)' inputs ('@', '=', and '<') and outputs ('&')\nfunction getComponentBindings(name) {\n    var cmpDefs = core.services.$injector.get(name + \"Directive\"); // could be multiple\n    if (!cmpDefs || !cmpDefs.length)\n        throw new Error(\"Unable to find component named '\" + name + \"'\");\n    return cmpDefs.map(getBindings).reduce(core.unnestR, []);\n}\n// Given a directive definition, find its object input attributes\n// Use different properties, depending on the type of directive (component, bindToController, normal)\nvar getBindings = function (def) {\n    if (core.isObject(def.bindToController))\n        return scopeBindings(def.bindToController);\n    return scopeBindings(def.scope);\n};\n// for ng 1.2 style, process the scope: { input: \"=foo\" }\n// for ng 1.3 through ng 1.5, process the component's bindToController: { input: \"=foo\" } object\nvar scopeBindings = function (bindingsObj) { return Object.keys(bindingsObj || {})\n    .map(function (key) { return [key, /^([=<@&])[?]?(.*)/.exec(bindingsObj[key])]; })\n    .filter(function (tuple) { return core.isDefined(tuple) && core.isArray(tuple[1]); })\n    .map(function (tuple) { return ({ name: tuple[1][2] || tuple[0], type: tuple[1][1] }); }); };\n\n/** @module ng1 */ /** for typedoc */\n/**\n * The Angular 1 `StateProvider`\n *\n * The `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\nvar StateProvider = /** @class */ (function () {\n    function StateProvider(stateRegistry, stateService) {\n        this.stateRegistry = stateRegistry;\n        this.stateService = stateService;\n        core.createProxyFunctions(core.val(StateProvider.prototype), this, core.val(this));\n    }\n    /**\n     * Decorates states when they are registered\n     *\n     * Allows you to extend (carefully) or override (at your own peril) the\n     * `stateBuilder` object used internally by [[StateRegistry]].\n     * This can be used to add custom functionality to ui-router,\n     * for example inferring templateUrl based on the state name.\n     *\n     * When passing only a name, it returns the current (original or decorated) builder\n     * function that matches `name`.\n     *\n     * The builder functions that can be decorated are listed below. Though not all\n     * necessarily have a good use case for decoration, that is up to you to decide.\n     *\n     * In addition, users can attach custom decorators, which will generate new\n     * properties within the state's internal definition. There is currently no clear\n     * use-case for this beyond accessing internal states (i.e. $state.$current),\n     * however, expect this to become increasingly relevant as we introduce additional\n     * meta-programming features.\n     *\n     * **Warning**: Decorators should not be interdependent because the order of\n     * execution of the builder functions in non-deterministic. Builder functions\n     * should only be dependent on the state definition object and super function.\n     *\n     *\n     * Existing builder functions and current return values:\n     *\n     * - **parent** `{object}` - returns the parent state object.\n     * - **data** `{object}` - returns state data, including any inherited data that is not\n     *   overridden by own values (if any).\n     * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n     *   or `null`.\n     * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is\n     *   navigable).\n     * - **params** `{object}` - returns an array of state params that are ensured to\n     *   be a super-set of parent's params.\n     * - **views** `{object}` - returns a views object where each key is an absolute view\n     *   name (i.e. \"viewName@stateName\") and each value is the config object\n     *   (template, controller) for the view. Even when you don't use the views object\n     *   explicitly on a state config, one is still created for you internally.\n     *   So by decorating this builder function you have access to decorating template\n     *   and controller properties.\n     * - **ownParams** `{object}` - returns an array of params that belong to the state,\n     *   not including any params defined by ancestor states.\n     * - **path** `{string}` - returns the full path from the root down to this state.\n     *   Needed for state activation.\n     * - **includes** `{object}` - returns an object that includes every state that\n     *   would pass a `$state.includes()` test.\n     *\n     * #### Example:\n     * Override the internal 'views' builder with a function that takes the state\n     * definition, and a reference to the internal function being overridden:\n     * ```js\n     * $stateProvider.decorator('views', function (state, parent) {\n     *   let result = {},\n     *       views = parent(state);\n     *\n     *   angular.forEach(views, function (config, name) {\n     *     let autoName = (state.name + '.' + name).replace('.', '/');\n     *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n     *     result[name] = config;\n     *   });\n     *   return result;\n     * });\n     *\n     * $stateProvider.state('home', {\n     *   views: {\n     *     'contact.list': { controller: 'ListController' },\n     *     'contact.item': { controller: 'ItemController' }\n     *   }\n     * });\n     * ```\n     *\n     *\n     * ```js\n     * // Auto-populates list and item views with /partials/home/contact/list.html,\n     * // and /partials/home/contact/item.html, respectively.\n     * $state.go('home');\n     * ```\n     *\n     * @param {string} name The name of the builder function to decorate.\n     * @param {object} func A function that is responsible for decorating the original\n     * builder function. The function receives two parameters:\n     *\n     *   - `{object}` - state - The state config object.\n     *   - `{object}` - super - The original builder function.\n     *\n     * @return {object} $stateProvider - $stateProvider instance\n     */\n    StateProvider.prototype.decorator = function (name, func) {\n        return this.stateRegistry.decorator(name, func) || this;\n    };\n    StateProvider.prototype.state = function (name, definition) {\n        if (core.isObject(name)) {\n            definition = name;\n        }\n        else {\n            definition.name = name;\n        }\n        this.stateRegistry.register(definition);\n        return this;\n    };\n    /**\n     * Registers an invalid state handler\n     *\n     * This is a passthrough to [[StateService.onInvalid]] for ng1.\n     */\n    StateProvider.prototype.onInvalid = function (callback) {\n        return this.stateService.onInvalid(callback);\n    };\n    return StateProvider;\n}());\n\n/** @module ng1 */ /** */\n/**\n * This is a [[StateBuilder.builder]] function for angular1 `onEnter`, `onExit`,\n * `onRetain` callback hooks on a [[Ng1StateDeclaration]].\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * ensures that those hooks are injectable for @uirouter/angularjs (ng1).\n */\nvar getStateHookBuilder = function (hookName) {\n    return function stateHookBuilder(state, parentFn) {\n        var hook = state[hookName];\n        var pathname = hookName === 'onExit' ? 'from' : 'to';\n        function decoratedNg1Hook(trans, state) {\n            var resolveContext = new core.ResolveContext(trans.treeChanges(pathname));\n            var locals = core.extend(getLocals(resolveContext), { $state$: state, $transition$: trans });\n            return core.services.$injector.invoke(hook, this, locals);\n        }\n        return hook ? decoratedNg1Hook : undefined;\n    };\n};\n\n/**\n * Implements UI-Router LocationServices and LocationConfig using Angular 1's $location service\n */\nvar Ng1LocationServices = /** @class */ (function () {\n    function Ng1LocationServices($locationProvider) {\n        // .onChange() registry\n        this._urlListeners = [];\n        this.$locationProvider = $locationProvider;\n        var _lp = core.val($locationProvider);\n        core.createProxyFunctions(_lp, this, _lp, ['hashPrefix']);\n    }\n    Ng1LocationServices.prototype.dispose = function () { };\n    Ng1LocationServices.prototype.onChange = function (callback) {\n        var _this = this;\n        this._urlListeners.push(callback);\n        return function () { return core.removeFrom(_this._urlListeners)(callback); };\n    };\n    Ng1LocationServices.prototype.html5Mode = function () {\n        var html5Mode = this.$locationProvider.html5Mode();\n        html5Mode = core.isObject(html5Mode) ? html5Mode.enabled : html5Mode;\n        return html5Mode && this.$sniffer.history;\n    };\n    Ng1LocationServices.prototype.url = function (newUrl, replace, state) {\n        if (replace === void 0) { replace = false; }\n        if (newUrl)\n            this.$location.url(newUrl);\n        if (replace)\n            this.$location.replace();\n        if (state)\n            this.$location.state(state);\n        return this.$location.url();\n    };\n    Ng1LocationServices.prototype._runtimeServices = function ($rootScope, $location, $sniffer, $browser) {\n        var _this = this;\n        this.$location = $location;\n        this.$sniffer = $sniffer;\n        // Bind $locationChangeSuccess to the listeners registered in LocationService.onChange\n        $rootScope.$on(\"$locationChangeSuccess\", function (evt) { return _this._urlListeners.forEach(function (fn) { return fn(evt); }); });\n        var _loc = core.val($location);\n        var _browser = core.val($browser);\n        // Bind these LocationService functions to $location\n        core.createProxyFunctions(_loc, this, _loc, [\"replace\", \"path\", \"search\", \"hash\"]);\n        // Bind these LocationConfig functions to $location\n        core.createProxyFunctions(_loc, this, _loc, ['port', 'protocol', 'host']);\n        // Bind these LocationConfig functions to $browser\n        core.createProxyFunctions(_browser, this, _browser, ['baseHref']);\n    };\n    /**\n     * Applys ng1-specific path parameter encoding\n     *\n     * The Angular 1 `$location` service is a bit weird.\n     * It doesn't allow slashes to be encoded/decoded bi-directionally.\n     *\n     * See the writeup at https://github.com/angular-ui/ui-router/issues/2598\n     *\n     * This code patches the `path` parameter type so it encoded/decodes slashes as ~2F\n     *\n     * @param router\n     */\n    Ng1LocationServices.monkeyPatchPathParameterType = function (router) {\n        var pathType = router.urlMatcherFactory.type('path');\n        pathType.encode = function (val$$1) {\n            return val$$1 != null ? val$$1.toString().replace(/(~|\\/)/g, function (m) { return ({ '~': '~~', '/': '~2F' }[m]); }) : val$$1;\n        };\n        pathType.decode = function (val$$1) {\n            return val$$1 != null ? val$$1.toString().replace(/(~~|~2F)/g, function (m) { return ({ '~~': '~', '~2F': '/' }[m]); }) : val$$1;\n        };\n    };\n    return Ng1LocationServices;\n}());\n\n/** @module url */ /** */\n/**\n * Manages rules for client-side URL\n *\n * ### Deprecation warning:\n * This class is now considered to be an internal API\n * Use the [[UrlService]] instead.\n * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].\n *\n * This class manages the router rules for what to do when the URL changes.\n *\n * This provider remains for backwards compatibility.\n *\n * @deprecated\n */\nvar UrlRouterProvider = /** @class */ (function () {\n    /** @hidden */\n    function UrlRouterProvider(router) {\n        this._router = router;\n        this._urlRouter = router.urlRouter;\n    }\n    /** @hidden */\n    UrlRouterProvider.prototype.$get = function () {\n        var urlRouter = this._urlRouter;\n        urlRouter.update(true);\n        if (!urlRouter.interceptDeferred)\n            urlRouter.listen();\n        return urlRouter;\n    };\n    /**\n     * Registers a url handler function.\n     *\n     * Registers a low level url handler (a `rule`).\n     * A rule detects specific URL patterns and returns a redirect, or performs some action.\n     *\n     * If a rule returns a string, the URL is replaced with the string, and all rules are fired again.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   // Here's an example of how you might allow case insensitive urls\n     *   $urlRouterProvider.rule(function ($injector, $location) {\n     *     var path = $location.path(),\n     *         normalized = path.toLowerCase();\n     *\n     *     if (path !== normalized) {\n     *       return normalized;\n     *     }\n     *   });\n     * });\n     * ```\n     *\n     * @param ruleFn\n     * Handler function that takes `$injector` and `$location` services as arguments.\n     * You can use them to detect a url and return a different url as a string.\n     *\n     * @return [[UrlRouterProvider]] (`this`)\n     */\n    UrlRouterProvider.prototype.rule = function (ruleFn) {\n        var _this = this;\n        if (!core.isFunction(ruleFn))\n            throw new Error(\"'rule' must be a function\");\n        var match = function () {\n            return ruleFn(core.services.$injector, _this._router.locationService);\n        };\n        var rule = new core.BaseUrlRule(match, core.identity);\n        this._urlRouter.rule(rule);\n        return this;\n    };\n    \n    /**\n     * Defines the path or behavior to use when no url can be matched.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   // if the path doesn't match any of the urls you configured\n     *   // otherwise will take care of routing the user to the\n     *   // specified url\n     *   $urlRouterProvider.otherwise('/index');\n     *\n     *   // Example of using function rule as param\n     *   $urlRouterProvider.otherwise(function ($injector, $location) {\n     *     return '/a/valid/url';\n     *   });\n     * });\n     * ```\n     *\n     * @param rule\n     * The url path you want to redirect to or a function rule that returns the url path or performs a `$state.go()`.\n     * The function version is passed two params: `$injector` and `$location` services, and should return a url string.\n     *\n     * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n     */\n    UrlRouterProvider.prototype.otherwise = function (rule) {\n        var _this = this;\n        var urlRouter = this._urlRouter;\n        if (core.isString(rule)) {\n            urlRouter.otherwise(rule);\n        }\n        else if (core.isFunction(rule)) {\n            urlRouter.otherwise(function () { return rule(core.services.$injector, _this._router.locationService); });\n        }\n        else {\n            throw new Error(\"'rule' must be a string or function\");\n        }\n        return this;\n    };\n    \n    /**\n     * Registers a handler for a given url matching.\n     *\n     * If the handler is a string, it is\n     * treated as a redirect, and is interpolated according to the syntax of match\n     * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n     *\n     * If the handler is a function, it is injectable.\n     * It gets invoked if `$location` matches.\n     * You have the option of inject the match object as `$match`.\n     *\n     * The handler can return\n     *\n     * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n     *   will continue trying to find another one that matches.\n     * - **string** which is treated as a redirect and passed to `$location.url()`\n     * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n     *     if ($state.$current.navigable !== state ||\n     *         !equalForKeys($match, $stateParams) {\n     *      $state.transitionTo(state, $match, false);\n     *     }\n     *   });\n     * });\n     * ```\n     *\n     * @param what A pattern string to match, compiled as a [[UrlMatcher]].\n     * @param handler The path (or function that returns a path) that you want to redirect your user to.\n     * @param ruleCallback [optional] A callback that receives the `rule` registered with [[UrlMatcher.rule]]\n     *\n     * Note: the handler may also invoke arbitrary code, such as `$state.go()`\n     */\n    UrlRouterProvider.prototype.when = function (what, handler) {\n        if (core.isArray(handler) || core.isFunction(handler)) {\n            handler = UrlRouterProvider.injectableHandler(this._router, handler);\n        }\n        this._urlRouter.when(what, handler);\n        return this;\n    };\n    \n    UrlRouterProvider.injectableHandler = function (router, handler) {\n        return function (match) {\n            return core.services.$injector.invoke(handler, null, { $match: match, $stateParams: router.globals.params });\n        };\n    };\n    /**\n     * Disables monitoring of the URL.\n     *\n     * Call this method before UI-Router has bootstrapped.\n     * It will stop UI-Router from performing the initial url sync.\n     *\n     * This can be useful to perform some asynchronous initialization before the router starts.\n     * Once the initialization is complete, call [[listen]] to tell UI-Router to start watching and synchronizing the URL.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   // Prevent $urlRouter from automatically intercepting URL changes;\n     *   $urlRouterProvider.deferIntercept();\n     * })\n     *\n     * app.run(function (MyService, $urlRouter, $http) {\n     *   $http.get(\"/stuff\").then(function(resp) {\n     *     MyService.doStuff(resp.data);\n     *     $urlRouter.listen();\n     *     $urlRouter.sync();\n     *   });\n     * });\n     * ```\n     *\n     * @param defer Indicates whether to defer location change interception.\n     *        Passing no parameter is equivalent to `true`.\n     */\n    UrlRouterProvider.prototype.deferIntercept = function (defer) {\n        this._urlRouter.deferIntercept(defer);\n    };\n    \n    return UrlRouterProvider;\n}());\n\n/**\n * # Angular 1 types\n *\n * UI-Router core provides various Typescript types which you can use for code completion and validating parameter values, etc.\n * The customizations to the core types for Angular UI-Router are documented here.\n *\n * The optional [[$resolve]] service is also documented here.\n *\n * @module ng1\n * @preferred\n */\n/** for typedoc */\nng.module(\"ui.router.angular1\", []);\nvar mod_init = ng.module('ui.router.init', []);\nvar mod_util = ng.module('ui.router.util', ['ng', 'ui.router.init']);\nvar mod_rtr = ng.module('ui.router.router', ['ui.router.util']);\nvar mod_state = ng.module('ui.router.state', ['ui.router.router', 'ui.router.util', 'ui.router.angular1']);\nvar mod_main = ng.module('ui.router', ['ui.router.init', 'ui.router.state', 'ui.router.angular1']);\nvar mod_cmpt = ng.module('ui.router.compat', ['ui.router']); // tslint:disable-line\nvar router = null;\n$uiRouter.$inject = ['$locationProvider'];\n/** This angular 1 provider instantiates a Router and exposes its services via the angular injector */\nfunction $uiRouter($locationProvider) {\n    // Create a new instance of the Router when the $uiRouterProvider is initialized\n    router = this.router = new core.UIRouter();\n    router.stateProvider = new StateProvider(router.stateRegistry, router.stateService);\n    // Apply ng1 specific StateBuilder code for `views`, `resolve`, and `onExit/Retain/Enter` properties\n    router.stateRegistry.decorator(\"views\", ng1ViewsBuilder);\n    router.stateRegistry.decorator(\"onExit\", getStateHookBuilder(\"onExit\"));\n    router.stateRegistry.decorator(\"onRetain\", getStateHookBuilder(\"onRetain\"));\n    router.stateRegistry.decorator(\"onEnter\", getStateHookBuilder(\"onEnter\"));\n    router.viewService._pluginapi._viewConfigFactory('ng1', getNg1ViewConfigFactory());\n    var ng1LocationService = router.locationService = router.locationConfig = new Ng1LocationServices($locationProvider);\n    Ng1LocationServices.monkeyPatchPathParameterType(router);\n    // backwards compat: also expose router instance as $uiRouterProvider.router\n    router['router'] = router;\n    router['$get'] = $get;\n    $get.$inject = ['$location', '$browser', '$sniffer', '$rootScope', '$http', '$templateCache'];\n    function $get($location, $browser, $sniffer, $rootScope, $http, $templateCache) {\n        ng1LocationService._runtimeServices($rootScope, $location, $sniffer, $browser);\n        delete router['router'];\n        delete router['$get'];\n        return router;\n    }\n    return router;\n}\nvar getProviderFor = function (serviceName) { return ['$uiRouterProvider', function ($urp) {\n        var service = $urp.router[serviceName];\n        service[\"$get\"] = function () { return service; };\n        return service;\n    }]; };\n// This effectively calls $get() on `$uiRouterProvider` to trigger init (when ng enters runtime)\nrunBlock.$inject = ['$injector', '$q', '$uiRouter'];\nfunction runBlock($injector, $q, $uiRouter) {\n    core.services.$injector = $injector;\n    core.services.$q = $q;\n    // The $injector is now available.\n    // Find any resolvables that had dependency annotation deferred\n    $uiRouter.stateRegistry.get()\n        .map(function (x) { return x.$$state().resolvables; })\n        .reduce(core.unnestR, [])\n        .filter(function (x) { return x.deps === \"deferred\"; })\n        .forEach(function (resolvable) { return resolvable.deps = $injector.annotate(resolvable.resolveFn, $injector.strictDi); });\n}\n// $urlRouter service and $urlRouterProvider\nvar getUrlRouterProvider = function (uiRouter) {\n    return uiRouter.urlRouterProvider = new UrlRouterProvider(uiRouter);\n};\n// $state service and $stateProvider\n// $urlRouter service and $urlRouterProvider\nvar getStateProvider = function () {\n    return core.extend(router.stateProvider, { $get: function () { return router.stateService; } });\n};\nwatchDigests.$inject = ['$rootScope'];\nfunction watchDigests($rootScope) {\n    $rootScope.$watch(function () { core.trace.approximateDigests++; });\n}\nmod_init.provider(\"$uiRouter\", $uiRouter);\nmod_rtr.provider('$urlRouter', ['$uiRouterProvider', getUrlRouterProvider]);\nmod_util.provider('$urlService', getProviderFor('urlService'));\nmod_util.provider('$urlMatcherFactory', ['$uiRouterProvider', function () { return router.urlMatcherFactory; }]);\nmod_util.provider('$templateFactory', function () { return new TemplateFactory(); });\nmod_state.provider('$stateRegistry', getProviderFor('stateRegistry'));\nmod_state.provider('$uiRouterGlobals', getProviderFor('globals'));\nmod_state.provider('$transitions', getProviderFor('transitionService'));\nmod_state.provider('$state', ['$uiRouterProvider', getStateProvider]);\nmod_state.factory('$stateParams', ['$uiRouter', function ($uiRouter) { return $uiRouter.globals.params; }]);\nmod_main.factory('$view', function () { return router.viewService; });\nmod_main.service(\"$trace\", function () { return core.trace; });\nmod_main.run(watchDigests);\nmod_util.run(['$urlMatcherFactory', function ($urlMatcherFactory) { }]);\nmod_state.run(['$state', function ($state) { }]);\nmod_rtr.run(['$urlRouter', function ($urlRouter) { }]);\nmod_init.run(runBlock);\n/** @hidden TODO: find a place to move this */\nvar getLocals = function (ctx) {\n    var tokens = ctx.getTokens().filter(core.isString);\n    var tuples = tokens.map(function (key) {\n        var resolvable = ctx.getResolvable(key);\n        var waitPolicy = ctx.getPolicy(resolvable).async;\n        return [key, waitPolicy === 'NOWAIT' ? resolvable.promise : resolvable.data];\n    });\n    return tuples.reduce(core.applyPairs, {});\n};\n\n/**\n * # Angular 1 injectable services\n *\n * This is a list of the objects which can be injected using angular's injector.\n *\n * There are three different kind of injectable objects:\n *\n * ## **Provider** objects\n * #### injectable into a `.config()` block during configtime\n *\n * - [[$uiRouterProvider]]: The UI-Router instance\n * - [[$stateProvider]]: State registration\n * - [[$transitionsProvider]]: Transition hooks\n * - [[$urlServiceProvider]]: All URL related public APIs\n *\n * - [[$uiViewScrollProvider]]: Disable ui-router view scrolling\n * - [[$urlRouterProvider]]: (deprecated) Url matching rules\n * - [[$urlMatcherFactoryProvider]]: (deprecated) Url parsing config\n *\n * ## **Service** objects\n * #### injectable globally during runtime\n *\n * - [[$uiRouter]]: The UI-Router instance\n * - [[$trace]]: Enable transition trace/debug\n * - [[$transitions]]: Transition hooks\n * - [[$state]]: Imperative state related APIs\n * - [[$stateRegistry]]: State registration\n * - [[$urlService]]: All URL related public APIs\n * - [[$uiRouterGlobals]]: Global variables\n * - [[$uiViewScroll]]: Scroll an element into view\n *\n * - [[$stateParams]]: (deprecated) Global state param values\n * - [[$urlRouter]]: (deprecated) URL synchronization\n * - [[$urlMatcherFactory]]: (deprecated) URL parsing config\n *\n * ## **Per-Transition** objects\n *\n * - These kind of objects are injectable into:\n *   - Resolves ([[Ng1StateDeclaration.resolve]]),\n *   - Transition Hooks ([[TransitionService.onStart]], etc),\n *   - Routed Controllers ([[Ng1ViewDeclaration.controller]])\n *\n * #### Different instances are injected based on the [[Transition]]\n *\n * - [[$transition$]]: The current Transition object\n * - [[$stateParams]]: State param values for pending Transition (deprecated)\n * - Any resolve data defined using [[Ng1StateDeclaration.resolve]]\n *\n * @ng1api\n * @preferred\n * @module injectables\n */ /** */\n/**\n * The current (or pending) State Parameters\n *\n * An injectable global **Service Object** which holds the state parameters for the latest **SUCCESSFUL** transition.\n *\n * The values are not updated until *after* a `Transition` successfully completes.\n *\n * **Also:** an injectable **Per-Transition Object** object which holds the pending state parameters for the pending `Transition` currently running.\n *\n * ### Deprecation warning:\n *\n * The value injected for `$stateParams` is different depending on where it is injected.\n *\n * - When injected into an angular service, the object injected is the global **Service Object** with the parameter values for the latest successful `Transition`.\n * - When injected into transition hooks, resolves, or view controllers, the object is the **Per-Transition Object** with the parameter values for the running `Transition`.\n *\n * Because of these confusing details, this service is deprecated.\n *\n * ### Instead of using the global `$stateParams` service object,\n * inject [[$uiRouterGlobals]] and use [[UIRouterGlobals.params]]\n *\n * ```js\n * MyService.$inject = ['$uiRouterGlobals'];\n * function MyService($uiRouterGlobals) {\n *   return {\n *     paramValues: function () {\n *       return $uiRouterGlobals.params;\n *     }\n *   }\n * }\n * ```\n *\n * ### Instead of using the per-transition `$stateParams` object,\n * inject the current `Transition` (as [[$transition$]]) and use [[Transition.params]]\n *\n * ```js\n * MyController.$inject = ['$transition$'];\n * function MyController($transition$) {\n *   var username = $transition$.params().username;\n *   // .. do something with username\n * }\n * ```\n *\n * ---\n *\n * This object can be injected into other services.\n *\n * #### Deprecated Example:\n * ```js\n * SomeService.$inject = ['$http', '$stateParams'];\n * function SomeService($http, $stateParams) {\n *   return {\n *     getUser: function() {\n *       return $http.get('/api/users/' + $stateParams.username);\n *     }\n *   }\n * };\n * angular.service('SomeService', SomeService);\n * ```\n * @deprecated\n */\n\n/**\n * # Angular 1 Directives\n *\n * These are the directives included in UI-Router for Angular 1.\n * These directives are used in templates to create viewports and link/navigate to states.\n *\n * @ng1api\n * @preferred\n * @module directives\n */ /** for typedoc */\n/** @hidden */\nfunction parseStateRef(ref) {\n    var paramsOnly = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n    if (paramsOnly)\n        ref = '(' + paramsOnly[1] + ')';\n    parsed = ref.replace(/\\n/g, \" \").match(/^\\s*([^(]*?)\\s*(\\((.*)\\))?\\s*$/);\n    if (!parsed || parsed.length !== 4)\n        throw new Error(\"Invalid state ref '\" + ref + \"'\");\n    return { state: parsed[1] || null, paramExpr: parsed[3] || null };\n}\n/** @hidden */\nfunction stateContext(el) {\n    var $uiView = el.parent().inheritedData('$uiView');\n    var path = core.parse('$cfg.path')($uiView);\n    return path ? core.tail(path).state.name : undefined;\n}\n/** @hidden */\nfunction processedDef($state, $element, def) {\n    var uiState = def.uiState || $state.current.name;\n    var uiStateOpts = core.extend(defaultOpts($element, $state), def.uiStateOpts || {});\n    var href = $state.href(uiState, def.uiStateParams, uiStateOpts);\n    return { uiState: uiState, uiStateParams: def.uiStateParams, uiStateOpts: uiStateOpts, href: href };\n}\n/** @hidden */\nfunction getTypeInfo(el) {\n    // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n    var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n    var isForm = el[0].nodeName === \"FORM\";\n    return {\n        attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n        isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n        clickable: !isForm\n    };\n}\n/** @hidden */\nfunction clickHook(el, $state, $timeout, type, getDef) {\n    return function (e) {\n        var button = e.which || e.button, target = getDef();\n        if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n            // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n            var transition = $timeout(function () {\n                $state.go(target.uiState, target.uiStateParams, target.uiStateOpts);\n            });\n            e.preventDefault();\n            // if the state has no URL, ignore one preventDefault from the <a> directive.\n            var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;\n            e.preventDefault = function () {\n                if (ignorePreventDefaultCount-- <= 0)\n                    $timeout.cancel(transition);\n            };\n        }\n    };\n}\n/** @hidden */\nfunction defaultOpts(el, $state) {\n    return {\n        relative: stateContext(el) || $state.$current,\n        inherit: true,\n        source: \"sref\"\n    };\n}\n/** @hidden */\nfunction bindEvents(element, scope, hookFn, uiStateOpts) {\n    var events;\n    if (uiStateOpts) {\n        events = uiStateOpts.events;\n    }\n    if (!core.isArray(events)) {\n        events = ['click'];\n    }\n    var on = element.on ? 'on' : 'bind';\n    for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {\n        var event_1 = events_1[_i];\n        element[on](event_1, hookFn);\n    }\n    scope.$on('$destroy', function () {\n        var off = element.off ? 'off' : 'unbind';\n        for (var _i = 0, events_2 = events; _i < events_2.length; _i++) {\n            var event_2 = events_2[_i];\n            element[off](event_2, hookFn);\n        }\n    });\n}\n/**\n * `ui-sref`: A directive for linking to a state\n *\n * A directive which links to a state (and optionally, parameters).\n * When clicked, this directive activates the linked state with the supplied parameter values.\n *\n * ### Linked State\n * The attribute value of the `ui-sref` is the name of the state to link to.\n *\n * #### Example:\n * This will activate the `home` state when the link is clicked.\n * ```html\n * <a ui-sref=\"home\">Home</a>\n * ```\n *\n * ### Relative Links\n * You can also use relative state paths within `ui-sref`, just like a relative path passed to `$state.go()` ([[StateService.go]]).\n * You just need to be aware that the path is relative to the state that *created* the link.\n * This allows a state to create a relative `ui-sref` which always targets the same destination.\n *\n * #### Example:\n * Both these links are relative to the parent state, even when a child state is currently active.\n * ```html\n * <a ui-sref=\".child1\">child 1 state</a>\n * <a ui-sref=\".child2\">child 2 state</a>\n * ```\n *\n * This link activates the parent state.\n * ```html\n * <a ui-sref=\"^\">Return</a>\n * ```\n *\n * ### hrefs\n * If the linked state has a URL, the directive will automatically generate and\n * update the `href` attribute (using the [[StateService.href]]  method).\n *\n * #### Example:\n * Assuming the `users` state has a url of `/users/`\n * ```html\n * <a ui-sref=\"users\" href=\"/users/\">Users</a>\n * ```\n *\n * ### Parameter Values\n * In addition to the state name, a `ui-sref` can include parameter values which are applied when activating the state.\n * Param values can be provided in the `ui-sref` value after the state name, enclosed by parentheses.\n * The content inside the parentheses is an expression, evaluated to the parameter values.\n *\n * #### Example:\n * This example renders a list of links to users.\n * The state's `userId` parameter value comes from each user's `user.id` property.\n * ```html\n * <li ng-repeat=\"user in users\">\n *   <a ui-sref=\"users.detail({ userId: user.id })\">{{ user.displayName }}</a>\n * </li>\n * ```\n *\n * Note:\n * The parameter values expression is `$watch`ed for updates.\n *\n * ### Transition Options\n * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-sref-opts` attribute.\n * Options are restricted to `location`, `inherit`, and `reload`.\n *\n * #### Example:\n * ```html\n * <a ui-sref=\"home\" ui-sref-opts=\"{ reload: true }\">Home</a>\n * ```\n *\n * ### Other DOM Events\n *\n * You can also customize which DOM events to respond to (instead of `click`) by\n * providing an `events` array in the `ui-sref-opts` attribute.\n *\n * #### Example:\n * ```html\n * <input type=\"text\" ui-sref=\"contacts\" ui-sref-opts=\"{ events: ['change', 'blur'] }\">\n * ```\n *\n * ### Highlighting the active link\n * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.\n *\n * ### Examples\n * If you have the following template:\n *\n * ```html\n * <a ui-sref=\"home\">Home</a>\n * <a ui-sref=\"about\">About</a>\n * <a ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * ```\n *\n * Then (assuming the current state is `contacts`) the rendered html including hrefs would be:\n *\n * ```html\n * <a href=\"#/home\" ui-sref=\"home\">Home</a>\n * <a href=\"#/about\" ui-sref=\"about\">About</a>\n * <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a href=\"#/home\" ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * ```\n *\n * ### Notes\n *\n * - You can use `ui-sref` to change **only the parameter values** by omitting the state name and parentheses.\n * #### Example:\n * Sets the `lang` parameter to `en` and remains on the same state.\n *\n * ```html\n * <a ui-sref=\"{ lang: 'en' }\">English</a>\n * ```\n *\n * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.\n *\n * - Unlike the parameter values expression, the state name is not `$watch`ed (for performance reasons).\n * If you need to dynamically update the state being linked to, use the fully dynamic [[uiState]] directive.\n */\nvar uiSref;\nuiSref = ['$uiRouter', '$timeout',\n    function $StateRefDirective($uiRouter, $timeout) {\n        var $state = $uiRouter.stateService;\n        return {\n            restrict: 'A',\n            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n            link: function (scope, element, attrs, uiSrefActive) {\n                var type = getTypeInfo(element);\n                var active = uiSrefActive[1] || uiSrefActive[0];\n                var unlinkInfoFn = null;\n                var hookFn;\n                var rawDef = {};\n                var getDef = function () { return processedDef($state, element, rawDef); };\n                var ref = parseStateRef(attrs.uiSref);\n                rawDef.uiState = ref.state;\n                rawDef.uiStateOpts = attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {};\n                function update() {\n                    var def = getDef();\n                    if (unlinkInfoFn)\n                        unlinkInfoFn();\n                    if (active)\n                        unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);\n                    if (def.href != null)\n                        attrs.$set(type.attr, def.href);\n                }\n                if (ref.paramExpr) {\n                    scope.$watch(ref.paramExpr, function (val$$1) {\n                        rawDef.uiStateParams = core.extend({}, val$$1);\n                        update();\n                    }, true);\n                    rawDef.uiStateParams = core.extend({}, scope.$eval(ref.paramExpr));\n                }\n                update();\n                scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));\n                scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));\n                if (!type.clickable)\n                    return;\n                hookFn = clickHook(element, $state, $timeout, type, getDef);\n                bindEvents(element, scope, hookFn, rawDef.uiStateOpts);\n            }\n        };\n    }];\n/**\n * `ui-state`: A fully dynamic directive for linking to a state\n *\n * A directive which links to a state (and optionally, parameters).\n * When clicked, this directive activates the linked state with the supplied parameter values.\n *\n * **This directive is very similar to [[uiSref]], but it `$observe`s and `$watch`es/evaluates all its inputs.**\n *\n * A directive which links to a state (and optionally, parameters).\n * When clicked, this directive activates the linked state with the supplied parameter values.\n *\n * ### Linked State\n * The attribute value of `ui-state` is an expression which is `$watch`ed and evaluated as the state to link to.\n * **This is in contrast with `ui-sref`, which takes a state name as a string literal.**\n *\n * #### Example:\n * Create a list of links.\n * ```html\n * <li ng-repeat=\"link in navlinks\">\n *   <a ui-state=\"link.state\">{{ link.displayName }}</a>\n * </li>\n * ```\n *\n * ### Relative Links\n * If the expression evaluates to a relative path, it is processed like [[uiSref]].\n * You just need to be aware that the path is relative to the state that *created* the link.\n * This allows a state to create relative `ui-state` which always targets the same destination.\n *\n * ### hrefs\n * If the linked state has a URL, the directive will automatically generate and\n * update the `href` attribute (using the [[StateService.href]]  method).\n *\n * ### Parameter Values\n * In addition to the state name expression, a `ui-state` can include parameter values which are applied when activating the state.\n * Param values should be provided using the `ui-state-params` attribute.\n * The `ui-state-params` attribute value is `$watch`ed and evaluated as an expression.\n *\n * #### Example:\n * This example renders a list of links with param values.\n * The state's `userId` parameter value comes from each user's `user.id` property.\n * ```html\n * <li ng-repeat=\"link in navlinks\">\n *   <a ui-state=\"link.state\" ui-state-params=\"link.params\">{{ link.displayName }}</a>\n * </li>\n * ```\n *\n * ### Transition Options\n * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-state-opts` attribute.\n * Options are restricted to `location`, `inherit`, and `reload`.\n * The value of the `ui-state-opts` is `$watch`ed and evaluated as an expression.\n *\n * #### Example:\n * ```html\n * <a ui-state=\"returnto.state\" ui-state-opts=\"{ reload: true }\">Home</a>\n * ```\n *\n * ### Other DOM Events\n *\n * You can also customize which DOM events to respond to (instead of `click`) by\n * providing an `events` array in the `ui-state-opts` attribute.\n *\n * #### Example:\n * ```html\n * <input type=\"text\" ui-state=\"contacts\" ui-state-opts=\"{ events: ['change', 'blur'] }\">\n * ```\n *\n * ### Highlighting the active link\n * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.\n *\n * ### Notes\n *\n * - You can use `ui-params` to change **only the parameter values** by omitting the state name and supplying only `ui-state-params`.\n *   However, it might be simpler to use [[uiSref]] parameter-only links.\n *\n * #### Example:\n * Sets the `lang` parameter to `en` and remains on the same state.\n *\n * ```html\n * <a ui-state=\"\" ui-state-params=\"{ lang: 'en' }\">English</a>\n * ```\n *\n * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.\n * ```\n */\nvar uiState;\nuiState = ['$uiRouter', '$timeout',\n    function $StateRefDynamicDirective($uiRouter, $timeout) {\n        var $state = $uiRouter.stateService;\n        return {\n            restrict: 'A',\n            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n            link: function (scope, element, attrs, uiSrefActive) {\n                var type = getTypeInfo(element);\n                var active = uiSrefActive[1] || uiSrefActive[0];\n                var unlinkInfoFn = null;\n                var hookFn;\n                var rawDef = {};\n                var getDef = function () { return processedDef($state, element, rawDef); };\n                var inputAttrs = ['uiState', 'uiStateParams', 'uiStateOpts'];\n                var watchDeregFns = inputAttrs.reduce(function (acc, attr) { return (acc[attr] = core.noop, acc); }, {});\n                function update() {\n                    var def = getDef();\n                    if (unlinkInfoFn)\n                        unlinkInfoFn();\n                    if (active)\n                        unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);\n                    if (def.href != null)\n                        attrs.$set(type.attr, def.href);\n                }\n                inputAttrs.forEach(function (field) {\n                    rawDef[field] = attrs[field] ? scope.$eval(attrs[field]) : null;\n                    attrs.$observe(field, function (expr) {\n                        watchDeregFns[field]();\n                        watchDeregFns[field] = scope.$watch(expr, function (newval) {\n                            rawDef[field] = newval;\n                            update();\n                        }, true);\n                    });\n                });\n                update();\n                scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));\n                scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));\n                if (!type.clickable)\n                    return;\n                hookFn = clickHook(element, $state, $timeout, type, getDef);\n                bindEvents(element, scope, hookFn, rawDef.uiStateOpts);\n            }\n        };\n    }];\n/**\n * `ui-sref-active` and `ui-sref-active-eq`: A directive that adds a CSS class when a `ui-sref` is active\n *\n * A directive working alongside [[uiSref]] and [[uiState]] to add classes to an element when the\n * related directive's state is active (and remove them when it is inactive).\n *\n * The primary use-case is to highlight the active link in navigation menus,\n * distinguishing it from the inactive menu items.\n *\n * ### Linking to a `ui-sref` or `ui-state`\n * `ui-sref-active` can live on the same element as `ui-sref`/`ui-state`, or it can be on a parent element.\n * If a `ui-sref-active` is a parent to more than one `ui-sref`/`ui-state`, it will apply the CSS class when **any of the links are active**.\n *\n * ### Matching\n *\n * The `ui-sref-active` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state **or any child state is active**.\n * This is a \"fuzzy match\" which uses [[StateService.includes]].\n *\n * The `ui-sref-active-eq` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state is directly active (not when child states are active).\n * This is an \"exact match\" which uses [[StateService.is]].\n *\n * ### Parameter values\n * If the `ui-sref`/`ui-state` includes parameter values, the current parameter values must match the link's values for the link to be highlighted.\n * This allows a list of links to the same state with different parameters to be rendered, and the correct one highlighted.\n *\n * #### Example:\n * ```html\n * <li ng-repeat=\"user in users\" ui-sref-active=\"active\">\n *   <a ui-sref=\"user.details({ userId: user.id })\">{{ user.lastName }}</a>\n * </li>\n * ```\n *\n * ### Examples\n *\n * Given the following template:\n * #### Example:\n * ```html\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * ```\n *\n * When the app state is `app.user` (or any child state),\n * and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n *\n * ```html\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * ```\n *\n * ### Glob mode\n *\n * It is possible to pass `ui-sref-active` an expression that evaluates to an object.\n * The objects keys represent active class names and values represent the respective state names/globs.\n * `ui-sref-active` will match if the current active state **includes** any of\n * the specified state names/globs, even the abstract ones.\n *\n * #### Example:\n * Given the following template, with \"admin\" being an abstract state:\n * ```html\n * <div ui-sref-active=\"{'active': 'admin.**'}\">\n *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n * </div>\n * ```\n *\n * When the current state is \"admin.roles\" the \"active\" class will be applied to both the <div> and <a> elements.\n * It is important to note that the state names/globs passed to `ui-sref-active` override any state provided by a linked `ui-sref`.\n *\n * ### Notes:\n *\n * - The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * - Multiple classes may be specified in a space-separated format: `ui-sref-active='class1 class2 class3'`\n */\nvar uiSrefActive;\nuiSrefActive = ['$state', '$stateParams', '$interpolate', '$uiRouter',\n    function $StateRefActiveDirective($state, $stateParams, $interpolate, $uiRouter) {\n        return {\n            restrict: \"A\",\n            controller: ['$scope', '$element', '$attrs',\n                function ($scope, $element, $attrs) {\n                    var states = [], activeEqClass, uiSrefActive;\n                    // There probably isn't much point in $observing this\n                    // uiSrefActive and uiSrefActiveEq share the same directive object with some\n                    // slight difference in logic routing\n                    activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n                    try {\n                        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n                    }\n                    catch (e) {\n                        // Do nothing. uiSrefActive is not a valid expression.\n                        // Fall back to using $interpolate below\n                    }\n                    uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n                    if (core.isObject(uiSrefActive)) {\n                        core.forEach(uiSrefActive, function (stateOrName, activeClass) {\n                            if (core.isString(stateOrName)) {\n                                var ref = parseStateRef(stateOrName);\n                                addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n                            }\n                        });\n                    }\n                    // Allow uiSref to communicate with uiSrefActive[Equals]\n                    this.$$addStateInfo = function (newState, newParams) {\n                        // we already got an explicit state provided by ui-sref-active, so we\n                        // shadow the one that comes from ui-sref\n                        if (core.isObject(uiSrefActive) && states.length > 0) {\n                            return;\n                        }\n                        var deregister = addState(newState, newParams, uiSrefActive);\n                        update();\n                        return deregister;\n                    };\n                    function updateAfterTransition(trans) {\n                        trans.promise.then(update, core.noop);\n                    }\n                    $scope.$on('$stateChangeSuccess', update);\n                    $scope.$on('$destroy', $uiRouter.transitionService.onStart({}, updateAfterTransition));\n                    if ($uiRouter.globals.transition) {\n                        updateAfterTransition($uiRouter.globals.transition);\n                    }\n                    function addState(stateName, stateParams, activeClass) {\n                        var state = $state.get(stateName, stateContext($element));\n                        var stateInfo = {\n                            state: state || { name: stateName },\n                            params: stateParams,\n                            activeClass: activeClass\n                        };\n                        states.push(stateInfo);\n                        return function removeState() {\n                            core.removeFrom(states)(stateInfo);\n                        };\n                    }\n                    // Update route state\n                    function update() {\n                        var splitClasses = function (str) {\n                            return str.split(/\\s/).filter(core.identity);\n                        };\n                        var getClasses = function (stateList) {\n                            return stateList.map(function (x) { return x.activeClass; }).map(splitClasses).reduce(core.unnestR, []);\n                        };\n                        var allClasses = getClasses(states).concat(splitClasses(activeEqClass)).reduce(core.uniqR, []);\n                        var fuzzyClasses = getClasses(states.filter(function (x) { return $state.includes(x.state.name, x.params); }));\n                        var exactlyMatchesAny = !!states.filter(function (x) { return $state.is(x.state.name, x.params); }).length;\n                        var exactClasses = exactlyMatchesAny ? splitClasses(activeEqClass) : [];\n                        var addClasses = fuzzyClasses.concat(exactClasses).reduce(core.uniqR, []);\n                        var removeClasses = allClasses.filter(function (cls) { return !core.inArray(addClasses, cls); });\n                        $scope.$evalAsync(function () {\n                            addClasses.forEach(function (className) { return $element.addClass(className); });\n                            removeClasses.forEach(function (className) { return $element.removeClass(className); });\n                        });\n                    }\n                    update();\n                }]\n        };\n    }];\nng.module('ui.router.state')\n    .directive('uiSref', uiSref)\n    .directive('uiSrefActive', uiSrefActive)\n    .directive('uiSrefActiveEq', uiSrefActive)\n    .directive('uiState', uiState);\n\n/** @module ng1 */ /** for typedoc */\n/**\n * `isState` Filter: truthy if the current state is the parameter\n *\n * Translates to [[StateService.is]] `$state.is(\"stateName\")`.\n *\n * #### Example:\n * ```html\n * <div ng-if=\"'stateName' | isState\">show if state is 'stateName'</div>\n * ```\n */\n$IsStateFilter.$inject = ['$state'];\nfunction $IsStateFilter($state) {\n    var isFilter = function (state, params, options) {\n        return $state.is(state, params, options);\n    };\n    isFilter.$stateful = true;\n    return isFilter;\n}\n/**\n * `includedByState` Filter: truthy if the current state includes the parameter\n *\n * Translates to [[StateService.includes]]` $state.is(\"fullOrPartialStateName\")`.\n *\n * #### Example:\n * ```html\n * <div ng-if=\"'fullOrPartialStateName' | includedByState\">show if state includes 'fullOrPartialStateName'</div>\n * ```\n */\n$IncludedByStateFilter.$inject = ['$state'];\nfunction $IncludedByStateFilter($state) {\n    var includesFilter = function (state, params, options) {\n        return $state.includes(state, params, options);\n    };\n    includesFilter.$stateful = true;\n    return includesFilter;\n}\nng.module('ui.router.state')\n    .filter('isState', $IsStateFilter)\n    .filter('includedByState', $IncludedByStateFilter);\n\n/**\n * @ng1api\n * @module directives\n */ /** for typedoc */\n/**\n * `ui-view`: A viewport directive which is filled in by a view from the active state.\n *\n * ### Attributes\n *\n * - `name`: (Optional) A view name.\n *   The name should be unique amongst the other views in the same state.\n *   You can have views of the same name that live in different states.\n *   The ui-view can be targeted in a View using the name ([[Ng1StateDeclaration.views]]).\n *\n * - `autoscroll`: an expression. When it evaluates to true, the `ui-view` will be scrolled into view when it is activated.\n *   Uses [[$uiViewScroll]] to do the scrolling.\n *\n * - `onload`: Expression to evaluate whenever the view updates.\n *\n * #### Example:\n * A view can be unnamed or named.\n * ```html\n * \x3c!-- Unnamed --\x3e\n * <div ui-view></div>\n *\n * \x3c!-- Named --\x3e\n * <div ui-view=\"viewName\"></div>\n *\n * \x3c!-- Named (different style) --\x3e\n * <ui-view name=\"viewName\"></ui-view>\n * ```\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a\n * single view and it is unnamed then you can populate it like so:\n *\n * ```html\n * <div ui-view></div>\n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * ```\n *\n * The above is a convenient shortcut equivalent to specifying your view explicitly with the\n * [[Ng1StateDeclaration.views]] config property, by name, in this case an empty name:\n *\n * ```js\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }\n * })\n * ```\n *\n * But typically you'll only use the views property if you name your view or have more than one view\n * in the same template. There's not really a compelling reason to name a view if its the only one,\n * but you could if you wanted, like so:\n *\n * ```html\n * <div ui-view=\"main\"></div>\n * ```\n *\n * ```js\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }\n * })\n * ```\n *\n * Really though, you'll use views to set up multiple views:\n *\n * ```html\n * <div ui-view></div>\n * <div ui-view=\"chart\"></div>\n * <div ui-view=\"data\"></div>\n * ```\n *\n * ```js\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }\n * })\n * ```\n *\n * #### Examples for `autoscroll`:\n * ```html\n * \x3c!-- If autoscroll present with no expression,\n *      then scroll ui-view into view --\x3e\n * <ui-view autoscroll/>\n *\n * \x3c!-- If autoscroll present with valid expression,\n *      then scroll ui-view into view if expression evaluates to true --\x3e\n * <ui-view autoscroll='true'/>\n * <ui-view autoscroll='false'/>\n * <ui-view autoscroll='scopeVariable'/>\n * ```\n *\n * Resolve data:\n *\n * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this\n * can be customized using [[Ng1ViewDeclaration.resolveAs]]).  This can be then accessed from the template.\n *\n * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the\n * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which\n * depends on `$resolve` data.\n *\n * #### Example:\n * ```js\n * $stateProvider.state('home', {\n *   template: '<my-component user=\"$resolve.user\"></my-component>',\n *   resolve: {\n *     user: function(UserService) { return UserService.fetchUser(); }\n *   }\n * });\n * ```\n */\nvar uiView;\nuiView = ['$view', '$animate', '$uiViewScroll', '$interpolate', '$q',\n    function $ViewDirective($view, $animate, $uiViewScroll, $interpolate, $q) {\n        function getRenderer(attrs, scope) {\n            return {\n                enter: function (element, target, cb) {\n                    if (ng.version.minor > 2) {\n                        $animate.enter(element, null, target).then(cb);\n                    }\n                    else {\n                        $animate.enter(element, null, target, cb);\n                    }\n                },\n                leave: function (element, cb) {\n                    if (ng.version.minor > 2) {\n                        $animate.leave(element).then(cb);\n                    }\n                    else {\n                        $animate.leave(element, cb);\n                    }\n                }\n            };\n        }\n        function configsEqual(config1, config2) {\n            return config1 === config2;\n        }\n        var rootData = {\n            $cfg: { viewDecl: { $context: $view._pluginapi._rootViewContext() } },\n            $uiView: {}\n        };\n        var directive = {\n            count: 0,\n            restrict: 'ECA',\n            terminal: true,\n            priority: 400,\n            transclude: 'element',\n            compile: function (tElement, tAttrs, $transclude) {\n                return function (scope, $element, attrs) {\n                    var previousEl, currentEl, currentScope, unregister, onloadExp = attrs['onload'] || '', autoScrollExp = attrs['autoscroll'], renderer = getRenderer(attrs, scope), viewConfig = undefined, inherited = $element.inheritedData('$uiView') || rootData, name = $interpolate(attrs['uiView'] || attrs['name'] || '')(scope) || '$default';\n                    var activeUIView = {\n                        $type: 'ng1',\n                        id: directive.count++,\n                        name: name,\n                        fqn: inherited.$uiView.fqn ? inherited.$uiView.fqn + \".\" + name : name,\n                        config: null,\n                        configUpdated: configUpdatedCallback,\n                        get creationContext() {\n                            var fromParentTagConfig = core.parse('$cfg.viewDecl.$context')(inherited);\n                            // Allow <ui-view name=\"foo\"><ui-view name=\"bar\"></ui-view></ui-view>\n                            // See https://github.com/angular-ui/ui-router/issues/3355\n                            var fromParentTag = core.parse('$uiView.creationContext')(inherited);\n                            return fromParentTagConfig || fromParentTag;\n                        }\n                    };\n                    core.trace.traceUIViewEvent(\"Linking\", activeUIView);\n                    function configUpdatedCallback(config) {\n                        if (config && !(config instanceof Ng1ViewConfig))\n                            return;\n                        if (configsEqual(viewConfig, config))\n                            return;\n                        core.trace.traceUIViewConfigUpdated(activeUIView, config && config.viewDecl && config.viewDecl.$context);\n                        viewConfig = config;\n                        updateView(config);\n                    }\n                    $element.data('$uiView', { $uiView: activeUIView });\n                    updateView();\n                    unregister = $view.registerUIView(activeUIView);\n                    scope.$on(\"$destroy\", function () {\n                        core.trace.traceUIViewEvent(\"Destroying/Unregistering\", activeUIView);\n                        unregister();\n                    });\n                    function cleanupLastView() {\n                        if (previousEl) {\n                            core.trace.traceUIViewEvent(\"Removing (previous) el\", previousEl.data('$uiView'));\n                            previousEl.remove();\n                            previousEl = null;\n                        }\n                        if (currentScope) {\n                            core.trace.traceUIViewEvent(\"Destroying scope\", activeUIView);\n                            currentScope.$destroy();\n                            currentScope = null;\n                        }\n                        if (currentEl) {\n                            var _viewData_1 = currentEl.data('$uiViewAnim');\n                            core.trace.traceUIViewEvent(\"Animate out\", _viewData_1);\n                            renderer.leave(currentEl, function () {\n                                _viewData_1.$$animLeave.resolve();\n                                previousEl = null;\n                            });\n                            previousEl = currentEl;\n                            currentEl = null;\n                        }\n                    }\n                    function updateView(config) {\n                        var newScope = scope.$new();\n                        var animEnter = $q.defer(), animLeave = $q.defer();\n                        var $uiViewData = {\n                            $cfg: config,\n                            $uiView: activeUIView,\n                        };\n                        var $uiViewAnim = {\n                            $animEnter: animEnter.promise,\n                            $animLeave: animLeave.promise,\n                            $$animLeave: animLeave\n                        };\n                        /**\n                         * @ngdoc event\n                         * @name ui.router.state.directive:ui-view#$viewContentLoading\n                         * @eventOf ui.router.state.directive:ui-view\n                         * @eventType emits on ui-view directive scope\n                         * @description\n                         *\n                         * Fired once the view **begins loading**, *before* the DOM is rendered.\n                         *\n                         * @param {Object} event Event object.\n                         * @param {string} viewName Name of the view.\n                         */\n                        newScope.$emit('$viewContentLoading', name);\n                        var cloned = $transclude(newScope, function (clone) {\n                            clone.data('$uiViewAnim', $uiViewAnim);\n                            clone.data('$uiView', $uiViewData);\n                            renderer.enter(clone, $element, function onUIViewEnter() {\n                                animEnter.resolve();\n                                if (currentScope)\n                                    currentScope.$emit('$viewContentAnimationEnded');\n                                if (core.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                                    $uiViewScroll(clone);\n                                }\n                            });\n                            cleanupLastView();\n                        });\n                        currentEl = cloned;\n                        currentScope = newScope;\n                        /**\n                         * @ngdoc event\n                         * @name ui.router.state.directive:ui-view#$viewContentLoaded\n                         * @eventOf ui.router.state.directive:ui-view\n                         * @eventType emits on ui-view directive scope\n                         * @description           *\n                         * Fired once the view is **loaded**, *after* the DOM is rendered.\n                         *\n                         * @param {Object} event Event object.\n                         */\n                        currentScope.$emit('$viewContentLoaded', config || viewConfig);\n                        currentScope.$eval(onloadExp);\n                    }\n                };\n            }\n        };\n        return directive;\n    }];\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$transitions', '$view', '$q', '$timeout'];\n/** @hidden */\nfunction $ViewDirectiveFill($compile, $controller, $transitions, $view, $q, $timeout) {\n    var getControllerAs = core.parse('viewDecl.controllerAs');\n    var getResolveAs = core.parse('viewDecl.resolveAs');\n    return {\n        restrict: 'ECA',\n        priority: -400,\n        compile: function (tElement) {\n            var initial = tElement.html();\n            tElement.empty();\n            return function (scope, $element) {\n                var data = $element.data('$uiView');\n                if (!data) {\n                    $element.html(initial);\n                    $compile($element.contents())(scope);\n                    return;\n                }\n                var cfg = data.$cfg || { viewDecl: {}, getTemplate: core.noop };\n                var resolveCtx = cfg.path && new core.ResolveContext(cfg.path);\n                $element.html(cfg.getTemplate($element, resolveCtx) || initial);\n                core.trace.traceUIViewFill(data.$uiView, $element.html());\n                var link = $compile($element.contents());\n                var controller = cfg.controller;\n                var controllerAs = getControllerAs(cfg);\n                var resolveAs = getResolveAs(cfg);\n                var locals = resolveCtx && getLocals(resolveCtx);\n                scope[resolveAs] = locals;\n                if (controller) {\n                    var controllerInstance = $controller(controller, core.extend({}, locals, { $scope: scope, $element: $element }));\n                    if (controllerAs) {\n                        scope[controllerAs] = controllerInstance;\n                        scope[controllerAs][resolveAs] = locals;\n                    }\n                    // TODO: Use $view service as a central point for registering component-level hooks\n                    // Then, when a component is created, tell the $view service, so it can invoke hooks\n                    // $view.componentLoaded(controllerInstance, { $scope: scope, $element: $element });\n                    // scope.$on('$destroy', () => $view.componentUnloaded(controllerInstance, { $scope: scope, $element: $element }));\n                    $element.data('$ngControllerController', controllerInstance);\n                    $element.children().data('$ngControllerController', controllerInstance);\n                    registerControllerCallbacks($q, $transitions, controllerInstance, scope, cfg);\n                }\n                // Wait for the component to appear in the DOM\n                if (core.isString(cfg.viewDecl.component)) {\n                    var cmp_1 = cfg.viewDecl.component;\n                    var kebobName = core.kebobString(cmp_1);\n                    var tagRegexp_1 = new RegExp(\"^(x-|data-)?\" + kebobName + \"$\", \"i\");\n                    var getComponentController = function () {\n                        var directiveEl = [].slice.call($element[0].children)\n                            .filter(function (el) { return el && el.tagName && tagRegexp_1.exec(el.tagName); });\n                        return directiveEl && ng.element(directiveEl).data(\"$\" + cmp_1 + \"Controller\");\n                    };\n                    var deregisterWatch_1 = scope.$watch(getComponentController, function (ctrlInstance) {\n                        if (!ctrlInstance)\n                            return;\n                        registerControllerCallbacks($q, $transitions, ctrlInstance, scope, cfg);\n                        deregisterWatch_1();\n                    });\n                }\n                link(scope);\n            };\n        }\n    };\n}\n/** @hidden */\nvar hasComponentImpl = typeof ng.module('ui.router')['component'] === 'function';\n/** @hidden incrementing id */\nvar _uiCanExitId = 0;\n/** @hidden TODO: move these callbacks to $view and/or `/hooks/components.ts` or something */\nfunction registerControllerCallbacks($q, $transitions, controllerInstance, $scope, cfg) {\n    // Call $onInit() ASAP\n    if (core.isFunction(controllerInstance.$onInit) && !(cfg.viewDecl.component && hasComponentImpl)) {\n        controllerInstance.$onInit();\n    }\n    var viewState = core.tail(cfg.path).state.self;\n    var hookOptions = { bind: controllerInstance };\n    // Add component-level hook for onParamsChange\n    if (core.isFunction(controllerInstance.uiOnParamsChanged)) {\n        var resolveContext = new core.ResolveContext(cfg.path);\n        var viewCreationTrans_1 = resolveContext.getResolvable('$transition$').data;\n        // Fire callback on any successful transition\n        var paramsUpdated = function ($transition$) {\n            // Exit early if the $transition$ is the same as the view was created within.\n            // Exit early if the $transition$ will exit the state the view is for.\n            if ($transition$ === viewCreationTrans_1 || $transition$.exiting().indexOf(viewState) !== -1)\n                return;\n            var toParams = $transition$.params(\"to\");\n            var fromParams = $transition$.params(\"from\");\n            var toSchema = $transition$.treeChanges().to.map(function (node) { return node.paramSchema; }).reduce(core.unnestR, []);\n            var fromSchema = $transition$.treeChanges().from.map(function (node) { return node.paramSchema; }).reduce(core.unnestR, []);\n            // Find the to params that have different values than the from params\n            var changedToParams = toSchema.filter(function (param) {\n                var idx = fromSchema.indexOf(param);\n                return idx === -1 || !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id]);\n            });\n            // Only trigger callback if a to param has changed or is new\n            if (changedToParams.length) {\n                var changedKeys_1 = changedToParams.map(function (x) { return x.id; });\n                // Filter the params to only changed/new to params.  `$transition$.params()` may be used to get all params.\n                var newValues = core.filter(toParams, function (val$$1, key) { return changedKeys_1.indexOf(key) !== -1; });\n                controllerInstance.uiOnParamsChanged(newValues, $transition$);\n            }\n        };\n        $scope.$on('$destroy', $transitions.onSuccess({}, paramsUpdated, hookOptions));\n    }\n    // Add component-level hook for uiCanExit\n    if (core.isFunction(controllerInstance.uiCanExit)) {\n        var id_1 = _uiCanExitId++;\n        var cacheProp_1 = '_uiCanExitIds';\n        // Returns true if a redirect transition already answered truthy\n        var prevTruthyAnswer_1 = function (trans) {\n            return !!trans && (trans[cacheProp_1] && trans[cacheProp_1][id_1] === true || prevTruthyAnswer_1(trans.redirectedFrom()));\n        };\n        // If a user answered yes, but the transition was later redirected, don't also ask for the new redirect transition\n        var wrappedHook = function (trans) {\n            var promise, ids = trans[cacheProp_1] = trans[cacheProp_1] || {};\n            if (!prevTruthyAnswer_1(trans)) {\n                promise = $q.when(controllerInstance.uiCanExit(trans));\n                promise.then(function (val$$1) { return ids[id_1] = (val$$1 !== false); });\n            }\n            return promise;\n        };\n        var criteria = { exiting: viewState.name };\n        $scope.$on('$destroy', $transitions.onBefore(criteria, wrappedHook, hookOptions));\n    }\n}\nng.module('ui.router.state').directive('uiView', uiView);\nng.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\n/** @module ng1 */ /** */\n/** @hidden */\nfunction $ViewScrollProvider() {\n    var useAnchorScroll = false;\n    this.useAnchorScroll = function () {\n        useAnchorScroll = true;\n    };\n    this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n            if (useAnchorScroll) {\n                return $anchorScroll;\n            }\n            return function ($element) {\n                return $timeout(function () {\n                    $element[0].scrollIntoView();\n                }, 0, false);\n            };\n        }];\n}\nng.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\n/**\n * Main entry point for angular 1.x build\n * @module ng1\n */ /** */\nvar index = \"ui.router\";\n\nexports['default'] = index;\nexports.core = core;\nexports.watchDigests = watchDigests;\nexports.getLocals = getLocals;\nexports.getNg1ViewConfigFactory = getNg1ViewConfigFactory;\nexports.ng1ViewsBuilder = ng1ViewsBuilder;\nexports.Ng1ViewConfig = Ng1ViewConfig;\nexports.StateProvider = StateProvider;\nexports.UrlRouterProvider = UrlRouterProvider;\nObject.keys(core).forEach(function (key) { exports[key] = core[key]; });\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=ui-router-angularjs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9hbmd1bGFyanMvcmVsZWFzZS91aS1yb3V0ZXItYW5ndWxhcmpzLmpzP2E2YmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTdGF0ZS1iYXNlZCByb3V0aW5nIGZvciBBbmd1bGFySlMgMS54XG4gKiBUaGlzIGJ1bmRsZSByZXF1aXJlcyB0aGUgdWktcm91dGVyLWNvcmUuanMgYnVuZGxlIGZyb20gdGhlIEB1aXJvdXRlci9jb3JlIHBhY2thZ2UuXG4gKiBAdmVyc2lvbiB2MS4wLjExXG4gKiBAbGluayBodHRwczovL3VpLXJvdXRlci5naXRodWIuaW9cbiAqIEBsaWNlbnNlIE1JVCBMaWNlbnNlLCBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ2FuZ3VsYXInKSwgcmVxdWlyZSgnQHVpcm91dGVyL2NvcmUnKSkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2FuZ3VsYXInLCAnQHVpcm91dGVyL2NvcmUnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsWydAdWlyb3V0ZXIvYW5ndWxhcmpzJ10gPSB7fSksZ2xvYmFsLmFuZ3VsYXIsZ2xvYmFsWydAdWlyb3V0ZXIvY29yZSddKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxuZ19mcm9tX2ltcG9ydCxjb3JlKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIG5nX2Zyb21fZ2xvYmFsID0gYW5ndWxhcjtcbnZhciBuZyA9IChuZ19mcm9tX2ltcG9ydCAmJiBuZ19mcm9tX2ltcG9ydC5tb2R1bGUpID8gbmdfZnJvbV9pbXBvcnQgOiBuZ19mcm9tX2dsb2JhbDtcblxuZnVuY3Rpb24gZ2V0TmcxVmlld0NvbmZpZ0ZhY3RvcnkoKSB7XG4gICAgdmFyIHRlbXBsYXRlRmFjdG9yeSA9IG51bGw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwYXRoLCB2aWV3KSB7XG4gICAgICAgIHRlbXBsYXRlRmFjdG9yeSA9IHRlbXBsYXRlRmFjdG9yeSB8fCBjb3JlLnNlcnZpY2VzLiRpbmplY3Rvci5nZXQoXCIkdGVtcGxhdGVGYWN0b3J5XCIpO1xuICAgICAgICByZXR1cm4gW25ldyBOZzFWaWV3Q29uZmlnKHBhdGgsIHZpZXcsIHRlbXBsYXRlRmFjdG9yeSldO1xuICAgIH07XG59XG52YXIgaGFzQW55S2V5ID0gZnVuY3Rpb24gKGtleXMsIG9iaikge1xuICAgIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHsgcmV0dXJuIGFjYyB8fCBjb3JlLmlzRGVmaW5lZChvYmpba2V5XSk7IH0sIGZhbHNlKTtcbn07XG4vKipcbiAqIFRoaXMgaXMgYSBbW1N0YXRlQnVpbGRlci5idWlsZGVyXV0gZnVuY3Rpb24gZm9yIGFuZ3VsYXIxIGB2aWV3c2AuXG4gKlxuICogV2hlbiB0aGUgW1tTdGF0ZUJ1aWxkZXJdXSBidWlsZHMgYSBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0IGZyb20gYSByYXcgW1tTdGF0ZURlY2xhcmF0aW9uXV0sIHRoaXMgYnVpbGRlclxuICogaGFuZGxlcyB0aGUgYHZpZXdzYCBwcm9wZXJ0eSB3aXRoIGxvZ2ljIHNwZWNpZmljIHRvIEB1aXJvdXRlci9hbmd1bGFyanMgKG5nMSkuXG4gKlxuICogSWYgbm8gYHZpZXdzOiB7fWAgcHJvcGVydHkgZXhpc3RzIG9uIHRoZSBbW1N0YXRlRGVjbGFyYXRpb25dXSwgdGhlbiBpdCBjcmVhdGVzIHRoZSBgdmlld3NgIG9iamVjdFxuICogYW5kIGFwcGxpZXMgdGhlIHN0YXRlLWxldmVsIGNvbmZpZ3VyYXRpb24gdG8gYSB2aWV3IG5hbWVkIGAkZGVmYXVsdGAuXG4gKi9cbmZ1bmN0aW9uIG5nMVZpZXdzQnVpbGRlcihzdGF0ZSkge1xuICAgIC8vIERvIG5vdCBwcm9jZXNzIHJvb3Qgc3RhdGVcbiAgICBpZiAoIXN0YXRlLnBhcmVudClcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIHZhciB0cGxLZXlzID0gWyd0ZW1wbGF0ZVByb3ZpZGVyJywgJ3RlbXBsYXRlVXJsJywgJ3RlbXBsYXRlJywgJ25vdGlmeScsICdhc3luYyddLCBjdHJsS2V5cyA9IFsnY29udHJvbGxlcicsICdjb250cm9sbGVyUHJvdmlkZXInLCAnY29udHJvbGxlckFzJywgJ3Jlc29sdmVBcyddLCBjb21wS2V5cyA9IFsnY29tcG9uZW50JywgJ2JpbmRpbmdzJywgJ2NvbXBvbmVudFByb3ZpZGVyJ10sIG5vbkNvbXBLZXlzID0gdHBsS2V5cy5jb25jYXQoY3RybEtleXMpLCBhbGxWaWV3S2V5cyA9IGNvbXBLZXlzLmNvbmNhdChub25Db21wS2V5cyk7XG4gICAgLy8gRG8gbm90IGFsbG93IGEgc3RhdGUgdG8gaGF2ZSBib3RoIHN0YXRlLWxldmVsIHByb3BzIGFuZCBhbHNvIGEgYHZpZXdzOiB7fWAgcHJvcGVydHkuXG4gICAgLy8gQSBzdGF0ZSB3aXRob3V0IGEgYHZpZXdzOiB7fWAgcHJvcGVydHkgY2FuIGRlY2xhcmUgcHJvcGVydGllcyBmb3IgdGhlIGAkZGVmYXVsdGAgdmlldyBhcyBwcm9wZXJ0aWVzIG9mIHRoZSBzdGF0ZS5cbiAgICAvLyBIb3dldmVyLCB0aGUgYCRkZWZhdWx0YCBhcHByb2FjaCBzaG91bGQgbm90IGJlIG1peGVkIHdpdGggYSBzZXBhcmF0ZSBgdmlld3M6IGAgYmxvY2suXG4gICAgaWYgKGNvcmUuaXNEZWZpbmVkKHN0YXRlLnZpZXdzKSAmJiBoYXNBbnlLZXkoYWxsVmlld0tleXMsIHN0YXRlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGF0ZSAnXCIgKyBzdGF0ZS5uYW1lICsgXCInIGhhcyBhICd2aWV3cycgb2JqZWN0LiBcIiArXG4gICAgICAgICAgICBcIkl0IGNhbm5vdCBhbHNvIGhhdmUgXFxcInZpZXcgcHJvcGVydGllc1xcXCIgYXQgdGhlIHN0YXRlIGxldmVsLiAgXCIgK1xuICAgICAgICAgICAgXCJNb3ZlIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBpbnRvIGEgdmlldyAoaW4gdGhlICd2aWV3cycgb2JqZWN0KTogXCIgK1xuICAgICAgICAgICAgKFwiIFwiICsgYWxsVmlld0tleXMuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGNvcmUuaXNEZWZpbmVkKHN0YXRlW2tleV0pOyB9KS5qb2luKFwiLCBcIikpKTtcbiAgICB9XG4gICAgdmFyIHZpZXdzID0ge30sIHZpZXdzT2JqZWN0ID0gc3RhdGUudmlld3MgfHwgeyBcIiRkZWZhdWx0XCI6IGNvcmUucGljayhzdGF0ZSwgYWxsVmlld0tleXMpIH07XG4gICAgY29yZS5mb3JFYWNoKHZpZXdzT2JqZWN0LCBmdW5jdGlvbiAoY29uZmlnLCBuYW1lKSB7XG4gICAgICAgIC8vIEFjY291bnQgZm9yIHZpZXdzOiB7IFwiXCI6IHsgdGVtcGxhdGUuLi4gfSB9XG4gICAgICAgIG5hbWUgPSBuYW1lIHx8IFwiJGRlZmF1bHRcIjtcbiAgICAgICAgLy8gQWNjb3VudCBmb3Igdmlld3M6IHsgaGVhZGVyOiBcImhlYWRlckNvbXBvbmVudFwiIH1cbiAgICAgICAgaWYgKGNvcmUuaXNTdHJpbmcoY29uZmlnKSlcbiAgICAgICAgICAgIGNvbmZpZyA9IHsgY29tcG9uZW50OiBjb25maWcgfTtcbiAgICAgICAgLy8gTWFrZSBhIHNoYWxsb3cgY29weSBvZiB0aGUgY29uZmlnIG9iamVjdFxuICAgICAgICBjb25maWcgPSBjb3JlLmV4dGVuZCh7fSwgY29uZmlnKTtcbiAgICAgICAgLy8gRG8gbm90IGFsbG93IGEgdmlldyB0byBtaXggcHJvcHMgZm9yIGNvbXBvbmVudC1zdHlsZSB2aWV3IHdpdGggcHJvcHMgZm9yIHRlbXBsYXRlL2NvbnRyb2xsZXItc3R5bGUgdmlld1xuICAgICAgICBpZiAoaGFzQW55S2V5KGNvbXBLZXlzLCBjb25maWcpICYmIGhhc0FueUtleShub25Db21wS2V5cywgY29uZmlnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbWJpbmU6IFwiICsgY29tcEtleXMuam9pbihcInxcIikgKyBcIiB3aXRoOiBcIiArIG5vbkNvbXBLZXlzLmpvaW4oXCJ8XCIpICsgXCIgaW4gc3RhdGV2aWV3OiAnXCIgKyBuYW1lICsgXCJAXCIgKyBzdGF0ZS5uYW1lICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZy5yZXNvbHZlQXMgPSBjb25maWcucmVzb2x2ZUFzIHx8ICckcmVzb2x2ZSc7XG4gICAgICAgIGNvbmZpZy4kdHlwZSA9IFwibmcxXCI7XG4gICAgICAgIGNvbmZpZy4kY29udGV4dCA9IHN0YXRlO1xuICAgICAgICBjb25maWcuJG5hbWUgPSBuYW1lO1xuICAgICAgICB2YXIgbm9ybWFsaXplZCA9IGNvcmUuVmlld1NlcnZpY2Uubm9ybWFsaXplVUlWaWV3VGFyZ2V0KGNvbmZpZy4kY29udGV4dCwgY29uZmlnLiRuYW1lKTtcbiAgICAgICAgY29uZmlnLiR1aVZpZXdOYW1lID0gbm9ybWFsaXplZC51aVZpZXdOYW1lO1xuICAgICAgICBjb25maWcuJHVpVmlld0NvbnRleHRBbmNob3IgPSBub3JtYWxpemVkLnVpVmlld0NvbnRleHRBbmNob3I7XG4gICAgICAgIHZpZXdzW25hbWVdID0gY29uZmlnO1xuICAgIH0pO1xuICAgIHJldHVybiB2aWV3cztcbn1cbnZhciBpZCA9IDA7XG52YXIgTmcxVmlld0NvbmZpZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZzFWaWV3Q29uZmlnKHBhdGgsIHZpZXdEZWNsLCBmYWN0b3J5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMudmlld0RlY2wgPSB2aWV3RGVjbDtcbiAgICAgICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgdGhpcy4kaWQgPSBpZCsrO1xuICAgICAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmdldFRlbXBsYXRlID0gZnVuY3Rpb24gKHVpVmlldywgY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvbXBvbmVudCA/IF90aGlzLmZhY3RvcnkubWFrZUNvbXBvbmVudFRlbXBsYXRlKHVpVmlldywgY29udGV4dCwgX3RoaXMuY29tcG9uZW50LCBfdGhpcy52aWV3RGVjbC5iaW5kaW5ncykgOiBfdGhpcy50ZW1wbGF0ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTmcxVmlld0NvbmZpZy5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyICRxID0gY29yZS5zZXJ2aWNlcy4kcTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBuZXcgY29yZS5SZXNvbHZlQ29udGV4dCh0aGlzLnBhdGgpO1xuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXRoLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBub2RlKSB7IHJldHVybiBjb3JlLmV4dGVuZChhY2MsIG5vZGUucGFyYW1WYWx1ZXMpOyB9LCB7fSk7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IHtcbiAgICAgICAgICAgIHRlbXBsYXRlOiAkcS53aGVuKHRoaXMuZmFjdG9yeS5mcm9tQ29uZmlnKHRoaXMudmlld0RlY2wsIHBhcmFtcywgY29udGV4dCkpLFxuICAgICAgICAgICAgY29udHJvbGxlcjogJHEud2hlbih0aGlzLmdldENvbnRyb2xsZXIoY29udGV4dCkpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgICAgICAgIGNvcmUudHJhY2UudHJhY2VWaWV3U2VydmljZUV2ZW50KFwiTG9hZGVkXCIsIF90aGlzKTtcbiAgICAgICAgICAgIF90aGlzLmNvbnRyb2xsZXIgPSByZXN1bHRzLmNvbnRyb2xsZXI7XG4gICAgICAgICAgICBjb3JlLmV4dGVuZChfdGhpcywgcmVzdWx0cy50ZW1wbGF0ZSk7IC8vIEVpdGhlciB7IHRlbXBsYXRlOiBcInRwbFwiIH0gb3IgeyBjb21wb25lbnQ6IFwiY21wTmFtZVwiIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb250cm9sbGVyIGZvciBhIHZpZXcgY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxQcm9taXNlLjxGdW5jdGlvbj59IFJldHVybnMgYSBjb250cm9sbGVyLCBvciBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgTmcxVmlld0NvbmZpZy5wcm90b3R5cGUuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHZhciBwcm92aWRlciA9IHRoaXMudmlld0RlY2wuY29udHJvbGxlclByb3ZpZGVyO1xuICAgICAgICBpZiAoIWNvcmUuaXNJbmplY3RhYmxlKHByb3ZpZGVyKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdEZWNsLmNvbnRyb2xsZXI7XG4gICAgICAgIHZhciBkZXBzID0gY29yZS5zZXJ2aWNlcy4kaW5qZWN0b3IuYW5ub3RhdGUocHJvdmlkZXIpO1xuICAgICAgICB2YXIgcHJvdmlkZXJGbiA9IGNvcmUuaXNBcnJheShwcm92aWRlcikgPyBjb3JlLnRhaWwocHJvdmlkZXIpIDogcHJvdmlkZXI7XG4gICAgICAgIHZhciByZXNvbHZhYmxlID0gbmV3IGNvcmUuUmVzb2x2YWJsZShcIlwiLCBwcm92aWRlckZuLCBkZXBzKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmFibGUuZ2V0KGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIE5nMVZpZXdDb25maWc7XG59KCkpO1xuXG4vKiogQG1vZHVsZSB2aWV3ICovXG4vKiogZm9yIHR5cGVkb2MgKi9cbi8qKlxuICogU2VydmljZSB3aGljaCBtYW5hZ2VzIGxvYWRpbmcgb2YgdGVtcGxhdGVzIGZyb20gYSBWaWV3Q29uZmlnLlxuICovXG52YXIgVGVtcGxhdGVGYWN0b3J5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlRmFjdG9yeSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5fdXNlSHR0cCA9IG5nLnZlcnNpb24ubWlub3IgPCAzO1xuICAgICAgICAvKiogQGhpZGRlbiAqLyB0aGlzLiRnZXQgPSBbJyRodHRwJywgJyR0ZW1wbGF0ZUNhY2hlJywgJyRpbmplY3RvcicsIGZ1bmN0aW9uICgkaHR0cCwgJHRlbXBsYXRlQ2FjaGUsICRpbmplY3Rvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLiR0ZW1wbGF0ZVJlcXVlc3QgPSAkaW5qZWN0b3IuaGFzICYmICRpbmplY3Rvci5oYXMoJyR0ZW1wbGF0ZVJlcXVlc3QnKSAmJiAkaW5qZWN0b3IuZ2V0KCckdGVtcGxhdGVSZXF1ZXN0Jyk7XG4gICAgICAgICAgICAgICAgX3RoaXMuJGh0dHAgPSAkaHR0cDtcbiAgICAgICAgICAgICAgICBfdGhpcy4kdGVtcGxhdGVDYWNoZSA9ICR0ZW1wbGF0ZUNhY2hlO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgICAgIH1dO1xuICAgIH1cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFRlbXBsYXRlRmFjdG9yeS5wcm90b3R5cGUudXNlSHR0cFNlcnZpY2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdXNlSHR0cCA9IHZhbHVlO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRlbXBsYXRlIGZyb20gYSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHdoaWNoIHRvIGxvYWQgYSB0ZW1wbGF0ZS5cbiAgICAgKiBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIHNlYXJjaCBpbiB0aGUgc3BlY2lmaWVkIG9yZGVyLCBhbmQgdGhlIGZpcnN0IG9uZVxuICAgICAqIHRoYXQgaXMgZGVmaW5lZCBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgdGVtcGxhdGU6XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zICBQYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSByZXNvbHZlIGNvbnRleHQgYXNzb2NpYXRlZCB3aXRoIHRoZSB0ZW1wbGF0ZSdzIHZpZXdcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ3xvYmplY3R9ICBUaGUgdGVtcGxhdGUgaHRtbCBhcyBhIHN0cmluZywgb3IgYSBwcm9taXNlIGZvclxuICAgICAqIHRoYXQgc3RyaW5nLG9yIGBudWxsYCBpZiBubyB0ZW1wbGF0ZSBpcyBjb25maWd1cmVkLlxuICAgICAqL1xuICAgIFRlbXBsYXRlRmFjdG9yeS5wcm90b3R5cGUuZnJvbUNvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcsIHBhcmFtcywgY29udGV4dCkge1xuICAgICAgICB2YXIgZGVmYXVsdFRlbXBsYXRlID0gXCI8dWktdmlldz48L3VpLXZpZXc+XCI7XG4gICAgICAgIHZhciBhc1RlbXBsYXRlID0gZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gY29yZS5zZXJ2aWNlcy4kcS53aGVuKHJlc3VsdCkudGhlbihmdW5jdGlvbiAoc3RyKSB7IHJldHVybiAoeyB0ZW1wbGF0ZTogc3RyIH0pOyB9KTsgfTtcbiAgICAgICAgdmFyIGFzQ29tcG9uZW50ID0gZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gY29yZS5zZXJ2aWNlcy4kcS53aGVuKHJlc3VsdCkudGhlbihmdW5jdGlvbiAoc3RyKSB7IHJldHVybiAoeyBjb21wb25lbnQ6IHN0ciB9KTsgfSk7IH07XG4gICAgICAgIHJldHVybiAoY29yZS5pc0RlZmluZWQoY29uZmlnLnRlbXBsYXRlKSA/IGFzVGVtcGxhdGUodGhpcy5mcm9tU3RyaW5nKGNvbmZpZy50ZW1wbGF0ZSwgcGFyYW1zKSkgOlxuICAgICAgICAgICAgY29yZS5pc0RlZmluZWQoY29uZmlnLnRlbXBsYXRlVXJsKSA/IGFzVGVtcGxhdGUodGhpcy5mcm9tVXJsKGNvbmZpZy50ZW1wbGF0ZVVybCwgcGFyYW1zKSkgOlxuICAgICAgICAgICAgICAgIGNvcmUuaXNEZWZpbmVkKGNvbmZpZy50ZW1wbGF0ZVByb3ZpZGVyKSA/IGFzVGVtcGxhdGUodGhpcy5mcm9tUHJvdmlkZXIoY29uZmlnLnRlbXBsYXRlUHJvdmlkZXIsIHBhcmFtcywgY29udGV4dCkpIDpcbiAgICAgICAgICAgICAgICAgICAgY29yZS5pc0RlZmluZWQoY29uZmlnLmNvbXBvbmVudCkgPyBhc0NvbXBvbmVudChjb25maWcuY29tcG9uZW50KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JlLmlzRGVmaW5lZChjb25maWcuY29tcG9uZW50UHJvdmlkZXIpID8gYXNDb21wb25lbnQodGhpcy5mcm9tQ29tcG9uZW50UHJvdmlkZXIoY29uZmlnLmNvbXBvbmVudFByb3ZpZGVyLCBwYXJhbXMsIGNvbnRleHQpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNUZW1wbGF0ZShkZWZhdWx0VGVtcGxhdGUpKTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0ZW1wbGF0ZSBmcm9tIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRlbXBsYXRlIGh0bWwgdGVtcGxhdGUgYXMgYSBzdHJpbmcgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGh0bWwgdGVtcGxhdGUgYXMgYSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHBhcmFtcyBQYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7c3RyaW5nfG9iamVjdH0gVGhlIHRlbXBsYXRlIGh0bWwgYXMgYSBzdHJpbmcsIG9yIGEgcHJvbWlzZSBmb3IgdGhhdFxuICAgICAqIHN0cmluZy5cbiAgICAgKi9cbiAgICBUZW1wbGF0ZUZhY3RvcnkucHJvdG90eXBlLmZyb21TdHJpbmcgPSBmdW5jdGlvbiAodGVtcGxhdGUsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gY29yZS5pc0Z1bmN0aW9uKHRlbXBsYXRlKSA/IHRlbXBsYXRlKHBhcmFtcykgOiB0ZW1wbGF0ZTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgdGVtcGxhdGUgZnJvbSB0aGUgYSBVUkwgdmlhIGAkaHR0cGAgYW5kIGAkdGVtcGxhdGVDYWNoZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xGdW5jdGlvbn0gdXJsIHVybCBvZiB0aGUgdGVtcGxhdGUgdG8gbG9hZCwgb3IgYSBmdW5jdGlvblxuICAgICAqIHRoYXQgcmV0dXJucyBhIHVybC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgdXJsIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ3xQcm9taXNlLjxzdHJpbmc+fSBUaGUgdGVtcGxhdGUgaHRtbCBhcyBhIHN0cmluZywgb3IgYSBwcm9taXNlXG4gICAgICogZm9yIHRoYXQgc3RyaW5nLlxuICAgICAqL1xuICAgIFRlbXBsYXRlRmFjdG9yeS5wcm90b3R5cGUuZnJvbVVybCA9IGZ1bmN0aW9uICh1cmwsIHBhcmFtcykge1xuICAgICAgICBpZiAoY29yZS5pc0Z1bmN0aW9uKHVybCkpXG4gICAgICAgICAgICB1cmwgPSB1cmwocGFyYW1zKTtcbiAgICAgICAgaWYgKHVybCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh0aGlzLl91c2VIdHRwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kaHR0cC5nZXQodXJsLCB7IGNhY2hlOiB0aGlzLiR0ZW1wbGF0ZUNhY2hlLCBoZWFkZXJzOiB7IEFjY2VwdDogJ3RleHQvaHRtbCcgfSB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuJHRlbXBsYXRlUmVxdWVzdCh1cmwpO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRlbXBsYXRlIGJ5IGludm9raW5nIGFuIGluamVjdGFibGUgcHJvdmlkZXIgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvdmlkZXIgRnVuY3Rpb24gdG8gaW52b2tlIHZpYSBgbG9jYWxzYFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGluamVjdEZuIGEgZnVuY3Rpb24gdXNlZCB0byBpbnZva2UgdGhlIHRlbXBsYXRlIHByb3ZpZGVyXG4gICAgICogQHJldHVybiB7c3RyaW5nfFByb21pc2UuPHN0cmluZz59IFRoZSB0ZW1wbGF0ZSBodG1sIGFzIGEgc3RyaW5nLCBvciBhIHByb21pc2VcbiAgICAgKiBmb3IgdGhhdCBzdHJpbmcuXG4gICAgICovXG4gICAgVGVtcGxhdGVGYWN0b3J5LnByb3RvdHlwZS5mcm9tUHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIsIHBhcmFtcywgY29udGV4dCkge1xuICAgICAgICB2YXIgZGVwcyA9IGNvcmUuc2VydmljZXMuJGluamVjdG9yLmFubm90YXRlKHByb3ZpZGVyKTtcbiAgICAgICAgdmFyIHByb3ZpZGVyRm4gPSBjb3JlLmlzQXJyYXkocHJvdmlkZXIpID8gY29yZS50YWlsKHByb3ZpZGVyKSA6IHByb3ZpZGVyO1xuICAgICAgICB2YXIgcmVzb2x2YWJsZSA9IG5ldyBjb3JlLlJlc29sdmFibGUoXCJcIiwgcHJvdmlkZXJGbiwgZGVwcyk7XG4gICAgICAgIHJldHVybiByZXNvbHZhYmxlLmdldChjb250ZXh0KTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb21wb25lbnQncyB0ZW1wbGF0ZSBieSBpbnZva2luZyBhbiBpbmplY3RhYmxlIHByb3ZpZGVyIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHByb3ZpZGVyIEZ1bmN0aW9uIHRvIGludm9rZSB2aWEgYGxvY2Fsc2BcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbmplY3RGbiBhIGZ1bmN0aW9uIHVzZWQgdG8gaW52b2tlIHRoZSB0ZW1wbGF0ZSBwcm92aWRlclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHRlbXBsYXRlIGh0bWwgYXMgYSBzdHJpbmc6IFwiPGNvbXBvbmVudC1uYW1lIGlucHV0MT0nOjokcmVzb2x2ZS5mb28nPjwvY29tcG9uZW50LW5hbWU+XCIuXG4gICAgICovXG4gICAgVGVtcGxhdGVGYWN0b3J5LnByb3RvdHlwZS5mcm9tQ29tcG9uZW50UHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIsIHBhcmFtcywgY29udGV4dCkge1xuICAgICAgICB2YXIgZGVwcyA9IGNvcmUuc2VydmljZXMuJGluamVjdG9yLmFubm90YXRlKHByb3ZpZGVyKTtcbiAgICAgICAgdmFyIHByb3ZpZGVyRm4gPSBjb3JlLmlzQXJyYXkocHJvdmlkZXIpID8gY29yZS50YWlsKHByb3ZpZGVyKSA6IHByb3ZpZGVyO1xuICAgICAgICB2YXIgcmVzb2x2YWJsZSA9IG5ldyBjb3JlLlJlc29sdmFibGUoXCJcIiwgcHJvdmlkZXJGbiwgZGVwcyk7XG4gICAgICAgIHJldHVybiByZXNvbHZhYmxlLmdldChjb250ZXh0KTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0ZW1wbGF0ZSBmcm9tIGEgY29tcG9uZW50J3MgbmFtZVxuICAgICAqXG4gICAgICogVGhpcyBpbXBsZW1lbnRzIHJvdXRlLXRvLWNvbXBvbmVudC5cbiAgICAgKiBJdCB3b3JrcyBieSByZXRyaWV2aW5nIHRoZSBjb21wb25lbnQgKGRpcmVjdGl2ZSkgbWV0YWRhdGEgZnJvbSB0aGUgaW5qZWN0b3IuXG4gICAgICogSXQgYW5hbHlzZXMgdGhlIGNvbXBvbmVudCdzIGJpbmRpbmdzLCB0aGVuIGNvbnN0cnVjdHMgYSB0ZW1wbGF0ZSB0aGF0IGluc3RhbnRpYXRlcyB0aGUgY29tcG9uZW50LlxuICAgICAqIFRoZSB0ZW1wbGF0ZSB3aXJlcyBpbnB1dCBhbmQgb3V0cHV0IGJpbmRpbmdzIHRvIHJlc29sdmVzIG9yIGZyb20gdGhlIHBhcmVudCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdWlWaWV3IHtvYmplY3R9IFRoZSBwYXJlbnQgdWktdmlldyAoZm9yIGJpbmRpbmcgb3V0cHV0cyB0byBjYWxsYmFja3MpXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIFJlc29sdmVDb250ZXh0IChmb3IgYmluZGluZyBvdXRwdXRzIHRvIGNhbGxiYWNrcyByZXR1cm5lZCBmcm9tIHJlc29sdmVzKVxuICAgICAqIEBwYXJhbSBjb21wb25lbnQge3N0cmluZ30gQ29tcG9uZW50J3MgbmFtZSBpbiBjYW1lbCBjYXNlLlxuICAgICAqIEBwYXJhbSBiaW5kaW5ncyBBbiBvYmplY3QgZGVmaW5pbmcgdGhlIGNvbXBvbmVudCdzIGJpbmRpbmdzOiB7Zm9vOiAnPCd9XG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdGVtcGxhdGUgYXMgYSBzdHJpbmc6IFwiPGNvbXBvbmVudC1uYW1lIGlucHV0MT0nOjokcmVzb2x2ZS5mb28nPjwvY29tcG9uZW50LW5hbWU+XCIuXG4gICAgICovXG4gICAgVGVtcGxhdGVGYWN0b3J5LnByb3RvdHlwZS5tYWtlQ29tcG9uZW50VGVtcGxhdGUgPSBmdW5jdGlvbiAodWlWaWV3LCBjb250ZXh0LCBjb21wb25lbnQsIGJpbmRpbmdzKSB7XG4gICAgICAgIGJpbmRpbmdzID0gYmluZGluZ3MgfHwge307XG4gICAgICAgIC8vIEJpbmQgb25jZSBwcmVmaXhcbiAgICAgICAgdmFyIHByZWZpeCA9IG5nLnZlcnNpb24ubWlub3IgPj0gMyA/IFwiOjpcIiA6IFwiXCI7XG4gICAgICAgIC8vIENvbnZlcnQgdG8ga2Vib2IgbmFtZS4gQWRkIHgtIHByZWZpeCBpZiB0aGUgc3RyaW5nIHN0YXJ0cyB3aXRoIGB4LWAgb3IgYGRhdGEtYFxuICAgICAgICB2YXIga2Vib2IgPSBmdW5jdGlvbiAoY2FtZWxDYXNlKSB7XG4gICAgICAgICAgICB2YXIga2Vib2JlZCA9IGNvcmUua2Vib2JTdHJpbmcoY2FtZWxDYXNlKTtcbiAgICAgICAgICAgIHJldHVybiAvXih4fGRhdGEpLS8uZXhlYyhrZWJvYmVkKSA/IFwieC1cIiArIGtlYm9iZWQgOiBrZWJvYmVkO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYXR0cmlidXRlVHBsID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGlucHV0Lm5hbWUsIHR5cGUgPSBpbnB1dC50eXBlO1xuICAgICAgICAgICAgdmFyIGF0dHJOYW1lID0ga2Vib2IobmFtZSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdWktdmlldyBoYXMgYW4gYXR0cmlidXRlIHdoaWNoIG1hdGNoZXMgYSBiaW5kaW5nIG9uIHRoZSByb3V0ZWQgY29tcG9uZW50XG4gICAgICAgICAgICAvLyB0aGVuIHBhc3MgdGhhdCBhdHRyaWJ1dGUgdGhyb3VnaCB0byB0aGUgcm91dGVkIGNvbXBvbmVudCB0ZW1wbGF0ZS5cbiAgICAgICAgICAgIC8vIFByZWZlciB1aS12aWV3IHdpcmVkIG1hcHBpbmdzIHRvIHJlc29sdmUgZGF0YSwgdW5sZXNzIHRoZSByZXNvbHZlIHdhcyBleHBsaWNpdGx5IGJvdW5kIHVzaW5nIGBiaW5kaW5nczpgXG4gICAgICAgICAgICBpZiAodWlWaWV3LmF0dHIoYXR0ck5hbWUpICYmICFiaW5kaW5nc1tuYW1lXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYXR0ck5hbWUgKyBcIj0nXCIgKyB1aVZpZXcuYXR0cihhdHRyTmFtZSkgKyBcIidcIjtcbiAgICAgICAgICAgIHZhciByZXNvbHZlTmFtZSA9IGJpbmRpbmdzW25hbWVdIHx8IG5hbWU7XG4gICAgICAgICAgICAvLyBQcmUtZXZhbHVhdGUgdGhlIGV4cHJlc3Npb24gZm9yIFwiQFwiIGJpbmRpbmdzIGJ5IGVuY2xvc2luZyBpbiB7eyB9fVxuICAgICAgICAgICAgLy8gc29tZS1hdHRyPVwie3sgOjokcmVzb2x2ZS5zb21lUmVzb2x2ZU5hbWUgfX1cIlxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdAJylcbiAgICAgICAgICAgICAgICByZXR1cm4gYXR0ck5hbWUgKyBcIj0ne3tcIiArIHByZWZpeCArIFwiJHJlc29sdmUuXCIgKyByZXNvbHZlTmFtZSArIFwifX0nXCI7XG4gICAgICAgICAgICAvLyBXaXJlIFwiJlwiIGNhbGxiYWNrcyB0byByZXNvbHZlcyB0aGF0IHJldHVybiBhIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHJlc3VsdCBvZiB0aGUgcmVzb2x2ZSAoc2hvdWxkIGJlIGEgZnVuY3Rpb24pIGFuZCBhbm5vdGF0ZSBpdCB0byBnZXQgaXRzIGFyZ3VtZW50cy5cbiAgICAgICAgICAgIC8vIHNvbWUtYXR0cj1cIiRyZXNvbHZlLnNvbWVSZXNvbHZlUmVzdWx0TmFtZShmb28sIGJhcilcIlxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICcmJykge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBjb250ZXh0LmdldFJlc29sdmFibGUocmVzb2x2ZU5hbWUpO1xuICAgICAgICAgICAgICAgIHZhciBmbiA9IHJlcyAmJiByZXMuZGF0YTtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGZuICYmIGNvcmUuc2VydmljZXMuJGluamVjdG9yLmFubm90YXRlKGZuKSB8fCBbXTtcbiAgICAgICAgICAgICAgICAvLyBhY2NvdW50IGZvciBhcnJheSBzdHlsZSBpbmplY3Rpb24sIGkuZS4sIFsnZm9vJywgZnVuY3Rpb24oZm9vKSB7fV1cbiAgICAgICAgICAgICAgICB2YXIgYXJyYXlJZHhTdHIgPSBjb3JlLmlzQXJyYXkoZm4pID8gXCJbXCIgKyAoZm4ubGVuZ3RoIC0gMSkgKyBcIl1cIiA6ICcnO1xuICAgICAgICAgICAgICAgIHJldHVybiBhdHRyTmFtZSArIFwiPSckcmVzb2x2ZS5cIiArIHJlc29sdmVOYW1lICsgYXJyYXlJZHhTdHIgKyBcIihcIiArIGFyZ3Muam9pbihcIixcIikgKyBcIiknXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzb21lLWF0dHI9XCI6OiRyZXNvbHZlLnNvbWVSZXNvbHZlTmFtZVwiXG4gICAgICAgICAgICByZXR1cm4gYXR0ck5hbWUgKyBcIj0nXCIgKyBwcmVmaXggKyBcIiRyZXNvbHZlLlwiICsgcmVzb2x2ZU5hbWUgKyBcIidcIjtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGF0dHJzID0gZ2V0Q29tcG9uZW50QmluZGluZ3MoY29tcG9uZW50KS5tYXAoYXR0cmlidXRlVHBsKS5qb2luKFwiIFwiKTtcbiAgICAgICAgdmFyIGtlYm9iTmFtZSA9IGtlYm9iKGNvbXBvbmVudCk7XG4gICAgICAgIHJldHVybiBcIjxcIiArIGtlYm9iTmFtZSArIFwiIFwiICsgYXR0cnMgKyBcIj48L1wiICsga2Vib2JOYW1lICsgXCI+XCI7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gVGVtcGxhdGVGYWN0b3J5O1xufSgpKTtcbi8vIEdldHMgYWxsIHRoZSBkaXJlY3RpdmUocyknIGlucHV0cyAoJ0AnLCAnPScsIGFuZCAnPCcpIGFuZCBvdXRwdXRzICgnJicpXG5mdW5jdGlvbiBnZXRDb21wb25lbnRCaW5kaW5ncyhuYW1lKSB7XG4gICAgdmFyIGNtcERlZnMgPSBjb3JlLnNlcnZpY2VzLiRpbmplY3Rvci5nZXQobmFtZSArIFwiRGlyZWN0aXZlXCIpOyAvLyBjb3VsZCBiZSBtdWx0aXBsZVxuICAgIGlmICghY21wRGVmcyB8fCAhY21wRGVmcy5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIGNvbXBvbmVudCBuYW1lZCAnXCIgKyBuYW1lICsgXCInXCIpO1xuICAgIHJldHVybiBjbXBEZWZzLm1hcChnZXRCaW5kaW5ncykucmVkdWNlKGNvcmUudW5uZXN0UiwgW10pO1xufVxuLy8gR2l2ZW4gYSBkaXJlY3RpdmUgZGVmaW5pdGlvbiwgZmluZCBpdHMgb2JqZWN0IGlucHV0IGF0dHJpYnV0ZXNcbi8vIFVzZSBkaWZmZXJlbnQgcHJvcGVydGllcywgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIGRpcmVjdGl2ZSAoY29tcG9uZW50LCBiaW5kVG9Db250cm9sbGVyLCBub3JtYWwpXG52YXIgZ2V0QmluZGluZ3MgPSBmdW5jdGlvbiAoZGVmKSB7XG4gICAgaWYgKGNvcmUuaXNPYmplY3QoZGVmLmJpbmRUb0NvbnRyb2xsZXIpKVxuICAgICAgICByZXR1cm4gc2NvcGVCaW5kaW5ncyhkZWYuYmluZFRvQ29udHJvbGxlcik7XG4gICAgcmV0dXJuIHNjb3BlQmluZGluZ3MoZGVmLnNjb3BlKTtcbn07XG4vLyBmb3IgbmcgMS4yIHN0eWxlLCBwcm9jZXNzIHRoZSBzY29wZTogeyBpbnB1dDogXCI9Zm9vXCIgfVxuLy8gZm9yIG5nIDEuMyB0aHJvdWdoIG5nIDEuNSwgcHJvY2VzcyB0aGUgY29tcG9uZW50J3MgYmluZFRvQ29udHJvbGxlcjogeyBpbnB1dDogXCI9Zm9vXCIgfSBvYmplY3RcbnZhciBzY29wZUJpbmRpbmdzID0gZnVuY3Rpb24gKGJpbmRpbmdzT2JqKSB7IHJldHVybiBPYmplY3Qua2V5cyhiaW5kaW5nc09iaiB8fCB7fSlcbiAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIFtrZXksIC9eKFs9PEAmXSlbP10/KC4qKS8uZXhlYyhiaW5kaW5nc09ialtrZXldKV07IH0pXG4gICAgLmZpbHRlcihmdW5jdGlvbiAodHVwbGUpIHsgcmV0dXJuIGNvcmUuaXNEZWZpbmVkKHR1cGxlKSAmJiBjb3JlLmlzQXJyYXkodHVwbGVbMV0pOyB9KVxuICAgIC5tYXAoZnVuY3Rpb24gKHR1cGxlKSB7IHJldHVybiAoeyBuYW1lOiB0dXBsZVsxXVsyXSB8fCB0dXBsZVswXSwgdHlwZTogdHVwbGVbMV1bMV0gfSk7IH0pOyB9O1xuXG4vKiogQG1vZHVsZSBuZzEgKi8gLyoqIGZvciB0eXBlZG9jICovXG4vKipcbiAqIFRoZSBBbmd1bGFyIDEgYFN0YXRlUHJvdmlkZXJgXG4gKlxuICogVGhlIGAkc3RhdGVQcm92aWRlcmAgd29ya3Mgc2ltaWxhciB0byBBbmd1bGFyJ3MgdjEgcm91dGVyLCBidXQgaXQgZm9jdXNlcyBwdXJlbHlcbiAqIG9uIHN0YXRlLlxuICpcbiAqIEEgc3RhdGUgY29ycmVzcG9uZHMgdG8gYSBcInBsYWNlXCIgaW4gdGhlIGFwcGxpY2F0aW9uIGluIHRlcm1zIG9mIHRoZSBvdmVyYWxsIFVJIGFuZFxuICogbmF2aWdhdGlvbi4gQSBzdGF0ZSBkZXNjcmliZXMgKHZpYSB0aGUgY29udHJvbGxlciAvIHRlbXBsYXRlIC8gdmlldyBwcm9wZXJ0aWVzKSB3aGF0XG4gKiB0aGUgVUkgbG9va3MgbGlrZSBhbmQgZG9lcyBhdCB0aGF0IHBsYWNlLlxuICpcbiAqIFN0YXRlcyBvZnRlbiBoYXZlIHRoaW5ncyBpbiBjb21tb24sIGFuZCB0aGUgcHJpbWFyeSB3YXkgb2YgZmFjdG9yaW5nIG91dCB0aGVzZVxuICogY29tbW9uYWxpdGllcyBpbiB0aGlzIG1vZGVsIGlzIHZpYSB0aGUgc3RhdGUgaGllcmFyY2h5LCBpLmUuIHBhcmVudC9jaGlsZCBzdGF0ZXMgYWthXG4gKiBuZXN0ZWQgc3RhdGVzLlxuICpcbiAqIFRoZSBgJHN0YXRlUHJvdmlkZXJgIHByb3ZpZGVzIGludGVyZmFjZXMgdG8gZGVjbGFyZSB0aGVzZSBzdGF0ZXMgZm9yIHlvdXIgYXBwLlxuICovXG52YXIgU3RhdGVQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0ZVByb3ZpZGVyKHN0YXRlUmVnaXN0cnksIHN0YXRlU2VydmljZSkge1xuICAgICAgICB0aGlzLnN0YXRlUmVnaXN0cnkgPSBzdGF0ZVJlZ2lzdHJ5O1xuICAgICAgICB0aGlzLnN0YXRlU2VydmljZSA9IHN0YXRlU2VydmljZTtcbiAgICAgICAgY29yZS5jcmVhdGVQcm94eUZ1bmN0aW9ucyhjb3JlLnZhbChTdGF0ZVByb3ZpZGVyLnByb3RvdHlwZSksIHRoaXMsIGNvcmUudmFsKHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb3JhdGVzIHN0YXRlcyB3aGVuIHRoZXkgYXJlIHJlZ2lzdGVyZWRcbiAgICAgKlxuICAgICAqIEFsbG93cyB5b3UgdG8gZXh0ZW5kIChjYXJlZnVsbHkpIG9yIG92ZXJyaWRlIChhdCB5b3VyIG93biBwZXJpbCkgdGhlXG4gICAgICogYHN0YXRlQnVpbGRlcmAgb2JqZWN0IHVzZWQgaW50ZXJuYWxseSBieSBbW1N0YXRlUmVnaXN0cnldXS5cbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGFkZCBjdXN0b20gZnVuY3Rpb25hbGl0eSB0byB1aS1yb3V0ZXIsXG4gICAgICogZm9yIGV4YW1wbGUgaW5mZXJyaW5nIHRlbXBsYXRlVXJsIGJhc2VkIG9uIHRoZSBzdGF0ZSBuYW1lLlxuICAgICAqXG4gICAgICogV2hlbiBwYXNzaW5nIG9ubHkgYSBuYW1lLCBpdCByZXR1cm5zIHRoZSBjdXJyZW50IChvcmlnaW5hbCBvciBkZWNvcmF0ZWQpIGJ1aWxkZXJcbiAgICAgKiBmdW5jdGlvbiB0aGF0IG1hdGNoZXMgYG5hbWVgLlxuICAgICAqXG4gICAgICogVGhlIGJ1aWxkZXIgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIGRlY29yYXRlZCBhcmUgbGlzdGVkIGJlbG93LiBUaG91Z2ggbm90IGFsbFxuICAgICAqIG5lY2Vzc2FyaWx5IGhhdmUgYSBnb29kIHVzZSBjYXNlIGZvciBkZWNvcmF0aW9uLCB0aGF0IGlzIHVwIHRvIHlvdSB0byBkZWNpZGUuXG4gICAgICpcbiAgICAgKiBJbiBhZGRpdGlvbiwgdXNlcnMgY2FuIGF0dGFjaCBjdXN0b20gZGVjb3JhdG9ycywgd2hpY2ggd2lsbCBnZW5lcmF0ZSBuZXdcbiAgICAgKiBwcm9wZXJ0aWVzIHdpdGhpbiB0aGUgc3RhdGUncyBpbnRlcm5hbCBkZWZpbml0aW9uLiBUaGVyZSBpcyBjdXJyZW50bHkgbm8gY2xlYXJcbiAgICAgKiB1c2UtY2FzZSBmb3IgdGhpcyBiZXlvbmQgYWNjZXNzaW5nIGludGVybmFsIHN0YXRlcyAoaS5lLiAkc3RhdGUuJGN1cnJlbnQpLFxuICAgICAqIGhvd2V2ZXIsIGV4cGVjdCB0aGlzIHRvIGJlY29tZSBpbmNyZWFzaW5nbHkgcmVsZXZhbnQgYXMgd2UgaW50cm9kdWNlIGFkZGl0aW9uYWxcbiAgICAgKiBtZXRhLXByb2dyYW1taW5nIGZlYXR1cmVzLlxuICAgICAqXG4gICAgICogKipXYXJuaW5nKio6IERlY29yYXRvcnMgc2hvdWxkIG5vdCBiZSBpbnRlcmRlcGVuZGVudCBiZWNhdXNlIHRoZSBvcmRlciBvZlxuICAgICAqIGV4ZWN1dGlvbiBvZiB0aGUgYnVpbGRlciBmdW5jdGlvbnMgaW4gbm9uLWRldGVybWluaXN0aWMuIEJ1aWxkZXIgZnVuY3Rpb25zXG4gICAgICogc2hvdWxkIG9ubHkgYmUgZGVwZW5kZW50IG9uIHRoZSBzdGF0ZSBkZWZpbml0aW9uIG9iamVjdCBhbmQgc3VwZXIgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKlxuICAgICAqIEV4aXN0aW5nIGJ1aWxkZXIgZnVuY3Rpb25zIGFuZCBjdXJyZW50IHJldHVybiB2YWx1ZXM6XG4gICAgICpcbiAgICAgKiAtICoqcGFyZW50KiogYHtvYmplY3R9YCAtIHJldHVybnMgdGhlIHBhcmVudCBzdGF0ZSBvYmplY3QuXG4gICAgICogLSAqKmRhdGEqKiBge29iamVjdH1gIC0gcmV0dXJucyBzdGF0ZSBkYXRhLCBpbmNsdWRpbmcgYW55IGluaGVyaXRlZCBkYXRhIHRoYXQgaXMgbm90XG4gICAgICogICBvdmVycmlkZGVuIGJ5IG93biB2YWx1ZXMgKGlmIGFueSkuXG4gICAgICogLSAqKnVybCoqIGB7b2JqZWN0fWAgLSByZXR1cm5zIGEge0BsaW5rIHVpLnJvdXRlci51dGlsLnR5cGU6VXJsTWF0Y2hlciBVcmxNYXRjaGVyfVxuICAgICAqICAgb3IgYG51bGxgLlxuICAgICAqIC0gKipuYXZpZ2FibGUqKiBge29iamVjdH1gIC0gcmV0dXJucyBjbG9zZXN0IGFuY2VzdG9yIHN0YXRlIHRoYXQgaGFzIGEgVVJMIChha2EgaXNcbiAgICAgKiAgIG5hdmlnYWJsZSkuXG4gICAgICogLSAqKnBhcmFtcyoqIGB7b2JqZWN0fWAgLSByZXR1cm5zIGFuIGFycmF5IG9mIHN0YXRlIHBhcmFtcyB0aGF0IGFyZSBlbnN1cmVkIHRvXG4gICAgICogICBiZSBhIHN1cGVyLXNldCBvZiBwYXJlbnQncyBwYXJhbXMuXG4gICAgICogLSAqKnZpZXdzKiogYHtvYmplY3R9YCAtIHJldHVybnMgYSB2aWV3cyBvYmplY3Qgd2hlcmUgZWFjaCBrZXkgaXMgYW4gYWJzb2x1dGUgdmlld1xuICAgICAqICAgbmFtZSAoaS5lLiBcInZpZXdOYW1lQHN0YXRlTmFtZVwiKSBhbmQgZWFjaCB2YWx1ZSBpcyB0aGUgY29uZmlnIG9iamVjdFxuICAgICAqICAgKHRlbXBsYXRlLCBjb250cm9sbGVyKSBmb3IgdGhlIHZpZXcuIEV2ZW4gd2hlbiB5b3UgZG9uJ3QgdXNlIHRoZSB2aWV3cyBvYmplY3RcbiAgICAgKiAgIGV4cGxpY2l0bHkgb24gYSBzdGF0ZSBjb25maWcsIG9uZSBpcyBzdGlsbCBjcmVhdGVkIGZvciB5b3UgaW50ZXJuYWxseS5cbiAgICAgKiAgIFNvIGJ5IGRlY29yYXRpbmcgdGhpcyBidWlsZGVyIGZ1bmN0aW9uIHlvdSBoYXZlIGFjY2VzcyB0byBkZWNvcmF0aW5nIHRlbXBsYXRlXG4gICAgICogICBhbmQgY29udHJvbGxlciBwcm9wZXJ0aWVzLlxuICAgICAqIC0gKipvd25QYXJhbXMqKiBge29iamVjdH1gIC0gcmV0dXJucyBhbiBhcnJheSBvZiBwYXJhbXMgdGhhdCBiZWxvbmcgdG8gdGhlIHN0YXRlLFxuICAgICAqICAgbm90IGluY2x1ZGluZyBhbnkgcGFyYW1zIGRlZmluZWQgYnkgYW5jZXN0b3Igc3RhdGVzLlxuICAgICAqIC0gKipwYXRoKiogYHtzdHJpbmd9YCAtIHJldHVybnMgdGhlIGZ1bGwgcGF0aCBmcm9tIHRoZSByb290IGRvd24gdG8gdGhpcyBzdGF0ZS5cbiAgICAgKiAgIE5lZWRlZCBmb3Igc3RhdGUgYWN0aXZhdGlvbi5cbiAgICAgKiAtICoqaW5jbHVkZXMqKiBge29iamVjdH1gIC0gcmV0dXJucyBhbiBvYmplY3QgdGhhdCBpbmNsdWRlcyBldmVyeSBzdGF0ZSB0aGF0XG4gICAgICogICB3b3VsZCBwYXNzIGEgYCRzdGF0ZS5pbmNsdWRlcygpYCB0ZXN0LlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIE92ZXJyaWRlIHRoZSBpbnRlcm5hbCAndmlld3MnIGJ1aWxkZXIgd2l0aCBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIHN0YXRlXG4gICAgICogZGVmaW5pdGlvbiwgYW5kIGEgcmVmZXJlbmNlIHRvIHRoZSBpbnRlcm5hbCBmdW5jdGlvbiBiZWluZyBvdmVycmlkZGVuOlxuICAgICAqIGBgYGpzXG4gICAgICogJHN0YXRlUHJvdmlkZXIuZGVjb3JhdG9yKCd2aWV3cycsIGZ1bmN0aW9uIChzdGF0ZSwgcGFyZW50KSB7XG4gICAgICogICBsZXQgcmVzdWx0ID0ge30sXG4gICAgICogICAgICAgdmlld3MgPSBwYXJlbnQoc3RhdGUpO1xuICAgICAqXG4gICAgICogICBhbmd1bGFyLmZvckVhY2godmlld3MsIGZ1bmN0aW9uIChjb25maWcsIG5hbWUpIHtcbiAgICAgKiAgICAgbGV0IGF1dG9OYW1lID0gKHN0YXRlLm5hbWUgKyAnLicgKyBuYW1lKS5yZXBsYWNlKCcuJywgJy8nKTtcbiAgICAgKiAgICAgY29uZmlnLnRlbXBsYXRlVXJsID0gY29uZmlnLnRlbXBsYXRlVXJsIHx8ICcvcGFydGlhbHMvJyArIGF1dG9OYW1lICsgJy5odG1sJztcbiAgICAgKiAgICAgcmVzdWx0W25hbWVdID0gY29uZmlnO1xuICAgICAqICAgfSk7XG4gICAgICogICByZXR1cm4gcmVzdWx0O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogJHN0YXRlUHJvdmlkZXIuc3RhdGUoJ2hvbWUnLCB7XG4gICAgICogICB2aWV3czoge1xuICAgICAqICAgICAnY29udGFjdC5saXN0JzogeyBjb250cm9sbGVyOiAnTGlzdENvbnRyb2xsZXInIH0sXG4gICAgICogICAgICdjb250YWN0Lml0ZW0nOiB7IGNvbnRyb2xsZXI6ICdJdGVtQ29udHJvbGxlcicgfVxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIC8vIEF1dG8tcG9wdWxhdGVzIGxpc3QgYW5kIGl0ZW0gdmlld3Mgd2l0aCAvcGFydGlhbHMvaG9tZS9jb250YWN0L2xpc3QuaHRtbCxcbiAgICAgKiAvLyBhbmQgL3BhcnRpYWxzL2hvbWUvY29udGFjdC9pdGVtLmh0bWwsIHJlc3BlY3RpdmVseS5cbiAgICAgKiAkc3RhdGUuZ28oJ2hvbWUnKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBidWlsZGVyIGZ1bmN0aW9uIHRvIGRlY29yYXRlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBmdW5jIEEgZnVuY3Rpb24gdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgZGVjb3JhdGluZyB0aGUgb3JpZ2luYWxcbiAgICAgKiBidWlsZGVyIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIHBhcmFtZXRlcnM6XG4gICAgICpcbiAgICAgKiAgIC0gYHtvYmplY3R9YCAtIHN0YXRlIC0gVGhlIHN0YXRlIGNvbmZpZyBvYmplY3QuXG4gICAgICogICAtIGB7b2JqZWN0fWAgLSBzdXBlciAtIFRoZSBvcmlnaW5hbCBidWlsZGVyIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7b2JqZWN0fSAkc3RhdGVQcm92aWRlciAtICRzdGF0ZVByb3ZpZGVyIGluc3RhbmNlXG4gICAgICovXG4gICAgU3RhdGVQcm92aWRlci5wcm90b3R5cGUuZGVjb3JhdG9yID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVSZWdpc3RyeS5kZWNvcmF0b3IobmFtZSwgZnVuYykgfHwgdGhpcztcbiAgICB9O1xuICAgIFN0YXRlUHJvdmlkZXIucHJvdG90eXBlLnN0YXRlID0gZnVuY3Rpb24gKG5hbWUsIGRlZmluaXRpb24pIHtcbiAgICAgICAgaWYgKGNvcmUuaXNPYmplY3QobmFtZSkpIHtcbiAgICAgICAgICAgIGRlZmluaXRpb24gPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlUmVnaXN0cnkucmVnaXN0ZXIoZGVmaW5pdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGFuIGludmFsaWQgc3RhdGUgaGFuZGxlclxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIHBhc3N0aHJvdWdoIHRvIFtbU3RhdGVTZXJ2aWNlLm9uSW52YWxpZF1dIGZvciBuZzEuXG4gICAgICovXG4gICAgU3RhdGVQcm92aWRlci5wcm90b3R5cGUub25JbnZhbGlkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlU2VydmljZS5vbkludmFsaWQoY2FsbGJhY2spO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRlUHJvdmlkZXI7XG59KCkpO1xuXG4vKiogQG1vZHVsZSBuZzEgKi8gLyoqICovXG4vKipcbiAqIFRoaXMgaXMgYSBbW1N0YXRlQnVpbGRlci5idWlsZGVyXV0gZnVuY3Rpb24gZm9yIGFuZ3VsYXIxIGBvbkVudGVyYCwgYG9uRXhpdGAsXG4gKiBgb25SZXRhaW5gIGNhbGxiYWNrIGhvb2tzIG9uIGEgW1tOZzFTdGF0ZURlY2xhcmF0aW9uXV0uXG4gKlxuICogV2hlbiB0aGUgW1tTdGF0ZUJ1aWxkZXJdXSBidWlsZHMgYSBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0IGZyb20gYSByYXcgW1tTdGF0ZURlY2xhcmF0aW9uXV0sIHRoaXMgYnVpbGRlclxuICogZW5zdXJlcyB0aGF0IHRob3NlIGhvb2tzIGFyZSBpbmplY3RhYmxlIGZvciBAdWlyb3V0ZXIvYW5ndWxhcmpzIChuZzEpLlxuICovXG52YXIgZ2V0U3RhdGVIb29rQnVpbGRlciA9IGZ1bmN0aW9uIChob29rTmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBzdGF0ZUhvb2tCdWlsZGVyKHN0YXRlLCBwYXJlbnRGbikge1xuICAgICAgICB2YXIgaG9vayA9IHN0YXRlW2hvb2tOYW1lXTtcbiAgICAgICAgdmFyIHBhdGhuYW1lID0gaG9va05hbWUgPT09ICdvbkV4aXQnID8gJ2Zyb20nIDogJ3RvJztcbiAgICAgICAgZnVuY3Rpb24gZGVjb3JhdGVkTmcxSG9vayh0cmFucywgc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZlQ29udGV4dCA9IG5ldyBjb3JlLlJlc29sdmVDb250ZXh0KHRyYW5zLnRyZWVDaGFuZ2VzKHBhdGhuYW1lKSk7XG4gICAgICAgICAgICB2YXIgbG9jYWxzID0gY29yZS5leHRlbmQoZ2V0TG9jYWxzKHJlc29sdmVDb250ZXh0KSwgeyAkc3RhdGUkOiBzdGF0ZSwgJHRyYW5zaXRpb24kOiB0cmFucyB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb3JlLnNlcnZpY2VzLiRpbmplY3Rvci5pbnZva2UoaG9vaywgdGhpcywgbG9jYWxzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaG9vayA/IGRlY29yYXRlZE5nMUhvb2sgOiB1bmRlZmluZWQ7XG4gICAgfTtcbn07XG5cbi8qKlxuICogSW1wbGVtZW50cyBVSS1Sb3V0ZXIgTG9jYXRpb25TZXJ2aWNlcyBhbmQgTG9jYXRpb25Db25maWcgdXNpbmcgQW5ndWxhciAxJ3MgJGxvY2F0aW9uIHNlcnZpY2VcbiAqL1xudmFyIE5nMUxvY2F0aW9uU2VydmljZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmcxTG9jYXRpb25TZXJ2aWNlcygkbG9jYXRpb25Qcm92aWRlcikge1xuICAgICAgICAvLyAub25DaGFuZ2UoKSByZWdpc3RyeVxuICAgICAgICB0aGlzLl91cmxMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy4kbG9jYXRpb25Qcm92aWRlciA9ICRsb2NhdGlvblByb3ZpZGVyO1xuICAgICAgICB2YXIgX2xwID0gY29yZS52YWwoJGxvY2F0aW9uUHJvdmlkZXIpO1xuICAgICAgICBjb3JlLmNyZWF0ZVByb3h5RnVuY3Rpb25zKF9scCwgdGhpcywgX2xwLCBbJ2hhc2hQcmVmaXgnXSk7XG4gICAgfVxuICAgIE5nMUxvY2F0aW9uU2VydmljZXMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgTmcxTG9jYXRpb25TZXJ2aWNlcy5wcm90b3R5cGUub25DaGFuZ2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fdXJsTGlzdGVuZXJzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29yZS5yZW1vdmVGcm9tKF90aGlzLl91cmxMaXN0ZW5lcnMpKGNhbGxiYWNrKTsgfTtcbiAgICB9O1xuICAgIE5nMUxvY2F0aW9uU2VydmljZXMucHJvdG90eXBlLmh0bWw1TW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGh0bWw1TW9kZSA9IHRoaXMuJGxvY2F0aW9uUHJvdmlkZXIuaHRtbDVNb2RlKCk7XG4gICAgICAgIGh0bWw1TW9kZSA9IGNvcmUuaXNPYmplY3QoaHRtbDVNb2RlKSA/IGh0bWw1TW9kZS5lbmFibGVkIDogaHRtbDVNb2RlO1xuICAgICAgICByZXR1cm4gaHRtbDVNb2RlICYmIHRoaXMuJHNuaWZmZXIuaGlzdG9yeTtcbiAgICB9O1xuICAgIE5nMUxvY2F0aW9uU2VydmljZXMucHJvdG90eXBlLnVybCA9IGZ1bmN0aW9uIChuZXdVcmwsIHJlcGxhY2UsIHN0YXRlKSB7XG4gICAgICAgIGlmIChyZXBsYWNlID09PSB2b2lkIDApIHsgcmVwbGFjZSA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChuZXdVcmwpXG4gICAgICAgICAgICB0aGlzLiRsb2NhdGlvbi51cmwobmV3VXJsKTtcbiAgICAgICAgaWYgKHJlcGxhY2UpXG4gICAgICAgICAgICB0aGlzLiRsb2NhdGlvbi5yZXBsYWNlKCk7XG4gICAgICAgIGlmIChzdGF0ZSlcbiAgICAgICAgICAgIHRoaXMuJGxvY2F0aW9uLnN0YXRlKHN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGxvY2F0aW9uLnVybCgpO1xuICAgIH07XG4gICAgTmcxTG9jYXRpb25TZXJ2aWNlcy5wcm90b3R5cGUuX3J1bnRpbWVTZXJ2aWNlcyA9IGZ1bmN0aW9uICgkcm9vdFNjb3BlLCAkbG9jYXRpb24sICRzbmlmZmVyLCAkYnJvd3Nlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLiRsb2NhdGlvbiA9ICRsb2NhdGlvbjtcbiAgICAgICAgdGhpcy4kc25pZmZlciA9ICRzbmlmZmVyO1xuICAgICAgICAvLyBCaW5kICRsb2NhdGlvbkNoYW5nZVN1Y2Nlc3MgdG8gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGluIExvY2F0aW9uU2VydmljZS5vbkNoYW5nZVxuICAgICAgICAkcm9vdFNjb3BlLiRvbihcIiRsb2NhdGlvbkNoYW5nZVN1Y2Nlc3NcIiwgZnVuY3Rpb24gKGV2dCkgeyByZXR1cm4gX3RoaXMuX3VybExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oZXZ0KTsgfSk7IH0pO1xuICAgICAgICB2YXIgX2xvYyA9IGNvcmUudmFsKCRsb2NhdGlvbik7XG4gICAgICAgIHZhciBfYnJvd3NlciA9IGNvcmUudmFsKCRicm93c2VyKTtcbiAgICAgICAgLy8gQmluZCB0aGVzZSBMb2NhdGlvblNlcnZpY2UgZnVuY3Rpb25zIHRvICRsb2NhdGlvblxuICAgICAgICBjb3JlLmNyZWF0ZVByb3h5RnVuY3Rpb25zKF9sb2MsIHRoaXMsIF9sb2MsIFtcInJlcGxhY2VcIiwgXCJwYXRoXCIsIFwic2VhcmNoXCIsIFwiaGFzaFwiXSk7XG4gICAgICAgIC8vIEJpbmQgdGhlc2UgTG9jYXRpb25Db25maWcgZnVuY3Rpb25zIHRvICRsb2NhdGlvblxuICAgICAgICBjb3JlLmNyZWF0ZVByb3h5RnVuY3Rpb25zKF9sb2MsIHRoaXMsIF9sb2MsIFsncG9ydCcsICdwcm90b2NvbCcsICdob3N0J10pO1xuICAgICAgICAvLyBCaW5kIHRoZXNlIExvY2F0aW9uQ29uZmlnIGZ1bmN0aW9ucyB0byAkYnJvd3NlclxuICAgICAgICBjb3JlLmNyZWF0ZVByb3h5RnVuY3Rpb25zKF9icm93c2VyLCB0aGlzLCBfYnJvd3NlciwgWydiYXNlSHJlZiddKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGx5cyBuZzEtc3BlY2lmaWMgcGF0aCBwYXJhbWV0ZXIgZW5jb2RpbmdcbiAgICAgKlxuICAgICAqIFRoZSBBbmd1bGFyIDEgYCRsb2NhdGlvbmAgc2VydmljZSBpcyBhIGJpdCB3ZWlyZC5cbiAgICAgKiBJdCBkb2Vzbid0IGFsbG93IHNsYXNoZXMgdG8gYmUgZW5jb2RlZC9kZWNvZGVkIGJpLWRpcmVjdGlvbmFsbHkuXG4gICAgICpcbiAgICAgKiBTZWUgdGhlIHdyaXRldXAgYXQgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXItdWkvdWktcm91dGVyL2lzc3Vlcy8yNTk4XG4gICAgICpcbiAgICAgKiBUaGlzIGNvZGUgcGF0Y2hlcyB0aGUgYHBhdGhgIHBhcmFtZXRlciB0eXBlIHNvIGl0IGVuY29kZWQvZGVjb2RlcyBzbGFzaGVzIGFzIH4yRlxuICAgICAqXG4gICAgICogQHBhcmFtIHJvdXRlclxuICAgICAqL1xuICAgIE5nMUxvY2F0aW9uU2VydmljZXMubW9ua2V5UGF0Y2hQYXRoUGFyYW1ldGVyVHlwZSA9IGZ1bmN0aW9uIChyb3V0ZXIpIHtcbiAgICAgICAgdmFyIHBhdGhUeXBlID0gcm91dGVyLnVybE1hdGNoZXJGYWN0b3J5LnR5cGUoJ3BhdGgnKTtcbiAgICAgICAgcGF0aFR5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHZhbCQkMSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbCQkMSAhPSBudWxsID8gdmFsJCQxLnRvU3RyaW5nKCkucmVwbGFjZSgvKH58XFwvKS9nLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gKHsgJ34nOiAnfn4nLCAnLyc6ICd+MkYnIH1bbV0pOyB9KSA6IHZhbCQkMTtcbiAgICAgICAgfTtcbiAgICAgICAgcGF0aFR5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHZhbCQkMSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbCQkMSAhPSBudWxsID8gdmFsJCQxLnRvU3RyaW5nKCkucmVwbGFjZSgvKH5+fH4yRikvZywgZnVuY3Rpb24gKG0pIHsgcmV0dXJuICh7ICd+fic6ICd+JywgJ34yRic6ICcvJyB9W21dKTsgfSkgOiB2YWwkJDE7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gTmcxTG9jYXRpb25TZXJ2aWNlcztcbn0oKSk7XG5cbi8qKiBAbW9kdWxlIHVybCAqLyAvKiogKi9cbi8qKlxuICogTWFuYWdlcyBydWxlcyBmb3IgY2xpZW50LXNpZGUgVVJMXG4gKlxuICogIyMjIERlcHJlY2F0aW9uIHdhcm5pbmc6XG4gKiBUaGlzIGNsYXNzIGlzIG5vdyBjb25zaWRlcmVkIHRvIGJlIGFuIGludGVybmFsIEFQSVxuICogVXNlIHRoZSBbW1VybFNlcnZpY2VdXSBpbnN0ZWFkLlxuICogRm9yIGNvbmZpZ3VyaW5nIFVSTCBydWxlcywgdXNlIHRoZSBbW1VybFJ1bGVzQXBpXV0gd2hpY2ggY2FuIGJlIGZvdW5kIGFzIFtbVXJsU2VydmljZS5ydWxlc11dLlxuICpcbiAqIFRoaXMgY2xhc3MgbWFuYWdlcyB0aGUgcm91dGVyIHJ1bGVzIGZvciB3aGF0IHRvIGRvIHdoZW4gdGhlIFVSTCBjaGFuZ2VzLlxuICpcbiAqIFRoaXMgcHJvdmlkZXIgcmVtYWlucyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xudmFyIFVybFJvdXRlclByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgZnVuY3Rpb24gVXJsUm91dGVyUHJvdmlkZXIocm91dGVyKSB7XG4gICAgICAgIHRoaXMuX3JvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgdGhpcy5fdXJsUm91dGVyID0gcm91dGVyLnVybFJvdXRlcjtcbiAgICB9XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBVcmxSb3V0ZXJQcm92aWRlci5wcm90b3R5cGUuJGdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVybFJvdXRlciA9IHRoaXMuX3VybFJvdXRlcjtcbiAgICAgICAgdXJsUm91dGVyLnVwZGF0ZSh0cnVlKTtcbiAgICAgICAgaWYgKCF1cmxSb3V0ZXIuaW50ZXJjZXB0RGVmZXJyZWQpXG4gICAgICAgICAgICB1cmxSb3V0ZXIubGlzdGVuKCk7XG4gICAgICAgIHJldHVybiB1cmxSb3V0ZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSB1cmwgaGFuZGxlciBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIFJlZ2lzdGVycyBhIGxvdyBsZXZlbCB1cmwgaGFuZGxlciAoYSBgcnVsZWApLlxuICAgICAqIEEgcnVsZSBkZXRlY3RzIHNwZWNpZmljIFVSTCBwYXR0ZXJucyBhbmQgcmV0dXJucyBhIHJlZGlyZWN0LCBvciBwZXJmb3JtcyBzb21lIGFjdGlvbi5cbiAgICAgKlxuICAgICAqIElmIGEgcnVsZSByZXR1cm5zIGEgc3RyaW5nLCB0aGUgVVJMIGlzIHJlcGxhY2VkIHdpdGggdGhlIHN0cmluZywgYW5kIGFsbCBydWxlcyBhcmUgZmlyZWQgYWdhaW4uXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiB2YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyLnJvdXRlciddKTtcbiAgICAgKlxuICAgICAqIGFwcC5jb25maWcoZnVuY3Rpb24gKCR1cmxSb3V0ZXJQcm92aWRlcikge1xuICAgICAqICAgLy8gSGVyZSdzIGFuIGV4YW1wbGUgb2YgaG93IHlvdSBtaWdodCBhbGxvdyBjYXNlIGluc2Vuc2l0aXZlIHVybHNcbiAgICAgKiAgICR1cmxSb3V0ZXJQcm92aWRlci5ydWxlKGZ1bmN0aW9uICgkaW5qZWN0b3IsICRsb2NhdGlvbikge1xuICAgICAqICAgICB2YXIgcGF0aCA9ICRsb2NhdGlvbi5wYXRoKCksXG4gICAgICogICAgICAgICBub3JtYWxpemVkID0gcGF0aC50b0xvd2VyQ2FzZSgpO1xuICAgICAqXG4gICAgICogICAgIGlmIChwYXRoICE9PSBub3JtYWxpemVkKSB7XG4gICAgICogICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgICogICAgIH1cbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHJ1bGVGblxuICAgICAqIEhhbmRsZXIgZnVuY3Rpb24gdGhhdCB0YWtlcyBgJGluamVjdG9yYCBhbmQgYCRsb2NhdGlvbmAgc2VydmljZXMgYXMgYXJndW1lbnRzLlxuICAgICAqIFlvdSBjYW4gdXNlIHRoZW0gdG8gZGV0ZWN0IGEgdXJsIGFuZCByZXR1cm4gYSBkaWZmZXJlbnQgdXJsIGFzIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybiBbW1VybFJvdXRlclByb3ZpZGVyXV0gKGB0aGlzYClcbiAgICAgKi9cbiAgICBVcmxSb3V0ZXJQcm92aWRlci5wcm90b3R5cGUucnVsZSA9IGZ1bmN0aW9uIChydWxlRm4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFjb3JlLmlzRnVuY3Rpb24ocnVsZUZuKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIidydWxlJyBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHZhciBtYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBydWxlRm4oY29yZS5zZXJ2aWNlcy4kaW5qZWN0b3IsIF90aGlzLl9yb3V0ZXIubG9jYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJ1bGUgPSBuZXcgY29yZS5CYXNlVXJsUnVsZShtYXRjaCwgY29yZS5pZGVudGl0eSk7XG4gICAgICAgIHRoaXMuX3VybFJvdXRlci5ydWxlKHJ1bGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIHBhdGggb3IgYmVoYXZpb3IgdG8gdXNlIHdoZW4gbm8gdXJsIGNhbiBiZSBtYXRjaGVkLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlci5yb3V0ZXInXSk7XG4gICAgICpcbiAgICAgKiBhcHAuY29uZmlnKGZ1bmN0aW9uICgkdXJsUm91dGVyUHJvdmlkZXIpIHtcbiAgICAgKiAgIC8vIGlmIHRoZSBwYXRoIGRvZXNuJ3QgbWF0Y2ggYW55IG9mIHRoZSB1cmxzIHlvdSBjb25maWd1cmVkXG4gICAgICogICAvLyBvdGhlcndpc2Ugd2lsbCB0YWtlIGNhcmUgb2Ygcm91dGluZyB0aGUgdXNlciB0byB0aGVcbiAgICAgKiAgIC8vIHNwZWNpZmllZCB1cmxcbiAgICAgKiAgICR1cmxSb3V0ZXJQcm92aWRlci5vdGhlcndpc2UoJy9pbmRleCcpO1xuICAgICAqXG4gICAgICogICAvLyBFeGFtcGxlIG9mIHVzaW5nIGZ1bmN0aW9uIHJ1bGUgYXMgcGFyYW1cbiAgICAgKiAgICR1cmxSb3V0ZXJQcm92aWRlci5vdGhlcndpc2UoZnVuY3Rpb24gKCRpbmplY3RvciwgJGxvY2F0aW9uKSB7XG4gICAgICogICAgIHJldHVybiAnL2EvdmFsaWQvdXJsJztcbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHJ1bGVcbiAgICAgKiBUaGUgdXJsIHBhdGggeW91IHdhbnQgdG8gcmVkaXJlY3QgdG8gb3IgYSBmdW5jdGlvbiBydWxlIHRoYXQgcmV0dXJucyB0aGUgdXJsIHBhdGggb3IgcGVyZm9ybXMgYSBgJHN0YXRlLmdvKClgLlxuICAgICAqIFRoZSBmdW5jdGlvbiB2ZXJzaW9uIGlzIHBhc3NlZCB0d28gcGFyYW1zOiBgJGluamVjdG9yYCBhbmQgYCRsb2NhdGlvbmAgc2VydmljZXMsIGFuZCBzaG91bGQgcmV0dXJuIGEgdXJsIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gYCR1cmxSb3V0ZXJQcm92aWRlcmAgLSBgJHVybFJvdXRlclByb3ZpZGVyYCBpbnN0YW5jZVxuICAgICAqL1xuICAgIFVybFJvdXRlclByb3ZpZGVyLnByb3RvdHlwZS5vdGhlcndpc2UgPSBmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdXJsUm91dGVyID0gdGhpcy5fdXJsUm91dGVyO1xuICAgICAgICBpZiAoY29yZS5pc1N0cmluZyhydWxlKSkge1xuICAgICAgICAgICAgdXJsUm91dGVyLm90aGVyd2lzZShydWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb3JlLmlzRnVuY3Rpb24ocnVsZSkpIHtcbiAgICAgICAgICAgIHVybFJvdXRlci5vdGhlcndpc2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gcnVsZShjb3JlLnNlcnZpY2VzLiRpbmplY3RvciwgX3RoaXMuX3JvdXRlci5sb2NhdGlvblNlcnZpY2UpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIidydWxlJyBtdXN0IGJlIGEgc3RyaW5nIG9yIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgaGFuZGxlciBmb3IgYSBnaXZlbiB1cmwgbWF0Y2hpbmcuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgaGFuZGxlciBpcyBhIHN0cmluZywgaXQgaXNcbiAgICAgKiB0cmVhdGVkIGFzIGEgcmVkaXJlY3QsIGFuZCBpcyBpbnRlcnBvbGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBzeW50YXggb2YgbWF0Y2hcbiAgICAgKiAoaS5lLiBsaWtlIGBTdHJpbmcucmVwbGFjZSgpYCBmb3IgYFJlZ0V4cGAsIG9yIGxpa2UgYSBgVXJsTWF0Y2hlcmAgcGF0dGVybiBvdGhlcndpc2UpLlxuICAgICAqXG4gICAgICogSWYgdGhlIGhhbmRsZXIgaXMgYSBmdW5jdGlvbiwgaXQgaXMgaW5qZWN0YWJsZS5cbiAgICAgKiBJdCBnZXRzIGludm9rZWQgaWYgYCRsb2NhdGlvbmAgbWF0Y2hlcy5cbiAgICAgKiBZb3UgaGF2ZSB0aGUgb3B0aW9uIG9mIGluamVjdCB0aGUgbWF0Y2ggb2JqZWN0IGFzIGAkbWF0Y2hgLlxuICAgICAqXG4gICAgICogVGhlIGhhbmRsZXIgY2FuIHJldHVyblxuICAgICAqXG4gICAgICogLSAqKmZhbHN5KiogdG8gaW5kaWNhdGUgdGhhdCB0aGUgcnVsZSBkaWRuJ3QgbWF0Y2ggYWZ0ZXIgYWxsLCB0aGVuIGAkdXJsUm91dGVyYFxuICAgICAqICAgd2lsbCBjb250aW51ZSB0cnlpbmcgdG8gZmluZCBhbm90aGVyIG9uZSB0aGF0IG1hdGNoZXMuXG4gICAgICogLSAqKnN0cmluZyoqIHdoaWNoIGlzIHRyZWF0ZWQgYXMgYSByZWRpcmVjdCBhbmQgcGFzc2VkIHRvIGAkbG9jYXRpb24udXJsKClgXG4gICAgICogLSAqKnZvaWQqKiBvciBhbnkgKip0cnV0aHkqKiB2YWx1ZSB0ZWxscyBgJHVybFJvdXRlcmAgdGhhdCB0aGUgdXJsIHdhcyBoYW5kbGVkLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlci5yb3V0ZXInXSk7XG4gICAgICpcbiAgICAgKiBhcHAuY29uZmlnKGZ1bmN0aW9uICgkdXJsUm91dGVyUHJvdmlkZXIpIHtcbiAgICAgKiAgICR1cmxSb3V0ZXJQcm92aWRlci53aGVuKCRzdGF0ZS51cmwsIGZ1bmN0aW9uICgkbWF0Y2gsICRzdGF0ZVBhcmFtcykge1xuICAgICAqICAgICBpZiAoJHN0YXRlLiRjdXJyZW50Lm5hdmlnYWJsZSAhPT0gc3RhdGUgfHxcbiAgICAgKiAgICAgICAgICFlcXVhbEZvcktleXMoJG1hdGNoLCAkc3RhdGVQYXJhbXMpIHtcbiAgICAgKiAgICAgICRzdGF0ZS50cmFuc2l0aW9uVG8oc3RhdGUsICRtYXRjaCwgZmFsc2UpO1xuICAgICAqICAgICB9XG4gICAgICogICB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aGF0IEEgcGF0dGVybiBzdHJpbmcgdG8gbWF0Y2gsIGNvbXBpbGVkIGFzIGEgW1tVcmxNYXRjaGVyXV0uXG4gICAgICogQHBhcmFtIGhhbmRsZXIgVGhlIHBhdGggKG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHBhdGgpIHRoYXQgeW91IHdhbnQgdG8gcmVkaXJlY3QgeW91ciB1c2VyIHRvLlxuICAgICAqIEBwYXJhbSBydWxlQ2FsbGJhY2sgW29wdGlvbmFsXSBBIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGBydWxlYCByZWdpc3RlcmVkIHdpdGggW1tVcmxNYXRjaGVyLnJ1bGVdXVxuICAgICAqXG4gICAgICogTm90ZTogdGhlIGhhbmRsZXIgbWF5IGFsc28gaW52b2tlIGFyYml0cmFyeSBjb2RlLCBzdWNoIGFzIGAkc3RhdGUuZ28oKWBcbiAgICAgKi9cbiAgICBVcmxSb3V0ZXJQcm92aWRlci5wcm90b3R5cGUud2hlbiA9IGZ1bmN0aW9uICh3aGF0LCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChjb3JlLmlzQXJyYXkoaGFuZGxlcikgfHwgY29yZS5pc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICBoYW5kbGVyID0gVXJsUm91dGVyUHJvdmlkZXIuaW5qZWN0YWJsZUhhbmRsZXIodGhpcy5fcm91dGVyLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cmxSb3V0ZXIud2hlbih3aGF0LCBoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBcbiAgICBVcmxSb3V0ZXJQcm92aWRlci5pbmplY3RhYmxlSGFuZGxlciA9IGZ1bmN0aW9uIChyb3V0ZXIsIGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvcmUuc2VydmljZXMuJGluamVjdG9yLmludm9rZShoYW5kbGVyLCBudWxsLCB7ICRtYXRjaDogbWF0Y2gsICRzdGF0ZVBhcmFtczogcm91dGVyLmdsb2JhbHMucGFyYW1zIH0pO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgbW9uaXRvcmluZyBvZiB0aGUgVVJMLlxuICAgICAqXG4gICAgICogQ2FsbCB0aGlzIG1ldGhvZCBiZWZvcmUgVUktUm91dGVyIGhhcyBib290c3RyYXBwZWQuXG4gICAgICogSXQgd2lsbCBzdG9wIFVJLVJvdXRlciBmcm9tIHBlcmZvcm1pbmcgdGhlIGluaXRpYWwgdXJsIHN5bmMuXG4gICAgICpcbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gcGVyZm9ybSBzb21lIGFzeW5jaHJvbm91cyBpbml0aWFsaXphdGlvbiBiZWZvcmUgdGhlIHJvdXRlciBzdGFydHMuXG4gICAgICogT25jZSB0aGUgaW5pdGlhbGl6YXRpb24gaXMgY29tcGxldGUsIGNhbGwgW1tsaXN0ZW5dXSB0byB0ZWxsIFVJLVJvdXRlciB0byBzdGFydCB3YXRjaGluZyBhbmQgc3luY2hyb25pemluZyB0aGUgVVJMLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlciddKTtcbiAgICAgKlxuICAgICAqIGFwcC5jb25maWcoZnVuY3Rpb24gKCR1cmxSb3V0ZXJQcm92aWRlcikge1xuICAgICAqICAgLy8gUHJldmVudCAkdXJsUm91dGVyIGZyb20gYXV0b21hdGljYWxseSBpbnRlcmNlcHRpbmcgVVJMIGNoYW5nZXM7XG4gICAgICogICAkdXJsUm91dGVyUHJvdmlkZXIuZGVmZXJJbnRlcmNlcHQoKTtcbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogYXBwLnJ1bihmdW5jdGlvbiAoTXlTZXJ2aWNlLCAkdXJsUm91dGVyLCAkaHR0cCkge1xuICAgICAqICAgJGh0dHAuZ2V0KFwiL3N0dWZmXCIpLnRoZW4oZnVuY3Rpb24ocmVzcCkge1xuICAgICAqICAgICBNeVNlcnZpY2UuZG9TdHVmZihyZXNwLmRhdGEpO1xuICAgICAqICAgICAkdXJsUm91dGVyLmxpc3RlbigpO1xuICAgICAqICAgICAkdXJsUm91dGVyLnN5bmMoKTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGRlZmVyIEluZGljYXRlcyB3aGV0aGVyIHRvIGRlZmVyIGxvY2F0aW9uIGNoYW5nZSBpbnRlcmNlcHRpb24uXG4gICAgICogICAgICAgIFBhc3Npbmcgbm8gcGFyYW1ldGVyIGlzIGVxdWl2YWxlbnQgdG8gYHRydWVgLlxuICAgICAqL1xuICAgIFVybFJvdXRlclByb3ZpZGVyLnByb3RvdHlwZS5kZWZlckludGVyY2VwdCA9IGZ1bmN0aW9uIChkZWZlcikge1xuICAgICAgICB0aGlzLl91cmxSb3V0ZXIuZGVmZXJJbnRlcmNlcHQoZGVmZXIpO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIFVybFJvdXRlclByb3ZpZGVyO1xufSgpKTtcblxuLyoqXG4gKiAjIEFuZ3VsYXIgMSB0eXBlc1xuICpcbiAqIFVJLVJvdXRlciBjb3JlIHByb3ZpZGVzIHZhcmlvdXMgVHlwZXNjcmlwdCB0eXBlcyB3aGljaCB5b3UgY2FuIHVzZSBmb3IgY29kZSBjb21wbGV0aW9uIGFuZCB2YWxpZGF0aW5nIHBhcmFtZXRlciB2YWx1ZXMsIGV0Yy5cbiAqIFRoZSBjdXN0b21pemF0aW9ucyB0byB0aGUgY29yZSB0eXBlcyBmb3IgQW5ndWxhciBVSS1Sb3V0ZXIgYXJlIGRvY3VtZW50ZWQgaGVyZS5cbiAqXG4gKiBUaGUgb3B0aW9uYWwgW1skcmVzb2x2ZV1dIHNlcnZpY2UgaXMgYWxzbyBkb2N1bWVudGVkIGhlcmUuXG4gKlxuICogQG1vZHVsZSBuZzFcbiAqIEBwcmVmZXJyZWRcbiAqL1xuLyoqIGZvciB0eXBlZG9jICovXG5uZy5tb2R1bGUoXCJ1aS5yb3V0ZXIuYW5ndWxhcjFcIiwgW10pO1xudmFyIG1vZF9pbml0ID0gbmcubW9kdWxlKCd1aS5yb3V0ZXIuaW5pdCcsIFtdKTtcbnZhciBtb2RfdXRpbCA9IG5nLm1vZHVsZSgndWkucm91dGVyLnV0aWwnLCBbJ25nJywgJ3VpLnJvdXRlci5pbml0J10pO1xudmFyIG1vZF9ydHIgPSBuZy5tb2R1bGUoJ3VpLnJvdXRlci5yb3V0ZXInLCBbJ3VpLnJvdXRlci51dGlsJ10pO1xudmFyIG1vZF9zdGF0ZSA9IG5nLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJywgWyd1aS5yb3V0ZXIucm91dGVyJywgJ3VpLnJvdXRlci51dGlsJywgJ3VpLnJvdXRlci5hbmd1bGFyMSddKTtcbnZhciBtb2RfbWFpbiA9IG5nLm1vZHVsZSgndWkucm91dGVyJywgWyd1aS5yb3V0ZXIuaW5pdCcsICd1aS5yb3V0ZXIuc3RhdGUnLCAndWkucm91dGVyLmFuZ3VsYXIxJ10pO1xudmFyIG1vZF9jbXB0ID0gbmcubW9kdWxlKCd1aS5yb3V0ZXIuY29tcGF0JywgWyd1aS5yb3V0ZXInXSk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmVcbnZhciByb3V0ZXIgPSBudWxsO1xuJHVpUm91dGVyLiRpbmplY3QgPSBbJyRsb2NhdGlvblByb3ZpZGVyJ107XG4vKiogVGhpcyBhbmd1bGFyIDEgcHJvdmlkZXIgaW5zdGFudGlhdGVzIGEgUm91dGVyIGFuZCBleHBvc2VzIGl0cyBzZXJ2aWNlcyB2aWEgdGhlIGFuZ3VsYXIgaW5qZWN0b3IgKi9cbmZ1bmN0aW9uICR1aVJvdXRlcigkbG9jYXRpb25Qcm92aWRlcikge1xuICAgIC8vIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgUm91dGVyIHdoZW4gdGhlICR1aVJvdXRlclByb3ZpZGVyIGlzIGluaXRpYWxpemVkXG4gICAgcm91dGVyID0gdGhpcy5yb3V0ZXIgPSBuZXcgY29yZS5VSVJvdXRlcigpO1xuICAgIHJvdXRlci5zdGF0ZVByb3ZpZGVyID0gbmV3IFN0YXRlUHJvdmlkZXIocm91dGVyLnN0YXRlUmVnaXN0cnksIHJvdXRlci5zdGF0ZVNlcnZpY2UpO1xuICAgIC8vIEFwcGx5IG5nMSBzcGVjaWZpYyBTdGF0ZUJ1aWxkZXIgY29kZSBmb3IgYHZpZXdzYCwgYHJlc29sdmVgLCBhbmQgYG9uRXhpdC9SZXRhaW4vRW50ZXJgIHByb3BlcnRpZXNcbiAgICByb3V0ZXIuc3RhdGVSZWdpc3RyeS5kZWNvcmF0b3IoXCJ2aWV3c1wiLCBuZzFWaWV3c0J1aWxkZXIpO1xuICAgIHJvdXRlci5zdGF0ZVJlZ2lzdHJ5LmRlY29yYXRvcihcIm9uRXhpdFwiLCBnZXRTdGF0ZUhvb2tCdWlsZGVyKFwib25FeGl0XCIpKTtcbiAgICByb3V0ZXIuc3RhdGVSZWdpc3RyeS5kZWNvcmF0b3IoXCJvblJldGFpblwiLCBnZXRTdGF0ZUhvb2tCdWlsZGVyKFwib25SZXRhaW5cIikpO1xuICAgIHJvdXRlci5zdGF0ZVJlZ2lzdHJ5LmRlY29yYXRvcihcIm9uRW50ZXJcIiwgZ2V0U3RhdGVIb29rQnVpbGRlcihcIm9uRW50ZXJcIikpO1xuICAgIHJvdXRlci52aWV3U2VydmljZS5fcGx1Z2luYXBpLl92aWV3Q29uZmlnRmFjdG9yeSgnbmcxJywgZ2V0TmcxVmlld0NvbmZpZ0ZhY3RvcnkoKSk7XG4gICAgdmFyIG5nMUxvY2F0aW9uU2VydmljZSA9IHJvdXRlci5sb2NhdGlvblNlcnZpY2UgPSByb3V0ZXIubG9jYXRpb25Db25maWcgPSBuZXcgTmcxTG9jYXRpb25TZXJ2aWNlcygkbG9jYXRpb25Qcm92aWRlcik7XG4gICAgTmcxTG9jYXRpb25TZXJ2aWNlcy5tb25rZXlQYXRjaFBhdGhQYXJhbWV0ZXJUeXBlKHJvdXRlcik7XG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdDogYWxzbyBleHBvc2Ugcm91dGVyIGluc3RhbmNlIGFzICR1aVJvdXRlclByb3ZpZGVyLnJvdXRlclxuICAgIHJvdXRlclsncm91dGVyJ10gPSByb3V0ZXI7XG4gICAgcm91dGVyWyckZ2V0J10gPSAkZ2V0O1xuICAgICRnZXQuJGluamVjdCA9IFsnJGxvY2F0aW9uJywgJyRicm93c2VyJywgJyRzbmlmZmVyJywgJyRyb290U2NvcGUnLCAnJGh0dHAnLCAnJHRlbXBsYXRlQ2FjaGUnXTtcbiAgICBmdW5jdGlvbiAkZ2V0KCRsb2NhdGlvbiwgJGJyb3dzZXIsICRzbmlmZmVyLCAkcm9vdFNjb3BlLCAkaHR0cCwgJHRlbXBsYXRlQ2FjaGUpIHtcbiAgICAgICAgbmcxTG9jYXRpb25TZXJ2aWNlLl9ydW50aW1lU2VydmljZXMoJHJvb3RTY29wZSwgJGxvY2F0aW9uLCAkc25pZmZlciwgJGJyb3dzZXIpO1xuICAgICAgICBkZWxldGUgcm91dGVyWydyb3V0ZXInXTtcbiAgICAgICAgZGVsZXRlIHJvdXRlclsnJGdldCddO1xuICAgICAgICByZXR1cm4gcm91dGVyO1xuICAgIH1cbiAgICByZXR1cm4gcm91dGVyO1xufVxudmFyIGdldFByb3ZpZGVyRm9yID0gZnVuY3Rpb24gKHNlcnZpY2VOYW1lKSB7IHJldHVybiBbJyR1aVJvdXRlclByb3ZpZGVyJywgZnVuY3Rpb24gKCR1cnApIHtcbiAgICAgICAgdmFyIHNlcnZpY2UgPSAkdXJwLnJvdXRlcltzZXJ2aWNlTmFtZV07XG4gICAgICAgIHNlcnZpY2VbXCIkZ2V0XCJdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VydmljZTsgfTtcbiAgICAgICAgcmV0dXJuIHNlcnZpY2U7XG4gICAgfV07IH07XG4vLyBUaGlzIGVmZmVjdGl2ZWx5IGNhbGxzICRnZXQoKSBvbiBgJHVpUm91dGVyUHJvdmlkZXJgIHRvIHRyaWdnZXIgaW5pdCAod2hlbiBuZyBlbnRlcnMgcnVudGltZSlcbnJ1bkJsb2NrLiRpbmplY3QgPSBbJyRpbmplY3RvcicsICckcScsICckdWlSb3V0ZXInXTtcbmZ1bmN0aW9uIHJ1bkJsb2NrKCRpbmplY3RvciwgJHEsICR1aVJvdXRlcikge1xuICAgIGNvcmUuc2VydmljZXMuJGluamVjdG9yID0gJGluamVjdG9yO1xuICAgIGNvcmUuc2VydmljZXMuJHEgPSAkcTtcbiAgICAvLyBUaGUgJGluamVjdG9yIGlzIG5vdyBhdmFpbGFibGUuXG4gICAgLy8gRmluZCBhbnkgcmVzb2x2YWJsZXMgdGhhdCBoYWQgZGVwZW5kZW5jeSBhbm5vdGF0aW9uIGRlZmVycmVkXG4gICAgJHVpUm91dGVyLnN0YXRlUmVnaXN0cnkuZ2V0KClcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC4kJHN0YXRlKCkucmVzb2x2YWJsZXM7IH0pXG4gICAgICAgIC5yZWR1Y2UoY29yZS51bm5lc3RSLCBbXSlcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5kZXBzID09PSBcImRlZmVycmVkXCI7IH0pXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChyZXNvbHZhYmxlKSB7IHJldHVybiByZXNvbHZhYmxlLmRlcHMgPSAkaW5qZWN0b3IuYW5ub3RhdGUocmVzb2x2YWJsZS5yZXNvbHZlRm4sICRpbmplY3Rvci5zdHJpY3REaSk7IH0pO1xufVxuLy8gJHVybFJvdXRlciBzZXJ2aWNlIGFuZCAkdXJsUm91dGVyUHJvdmlkZXJcbnZhciBnZXRVcmxSb3V0ZXJQcm92aWRlciA9IGZ1bmN0aW9uICh1aVJvdXRlcikge1xuICAgIHJldHVybiB1aVJvdXRlci51cmxSb3V0ZXJQcm92aWRlciA9IG5ldyBVcmxSb3V0ZXJQcm92aWRlcih1aVJvdXRlcik7XG59O1xuLy8gJHN0YXRlIHNlcnZpY2UgYW5kICRzdGF0ZVByb3ZpZGVyXG4vLyAkdXJsUm91dGVyIHNlcnZpY2UgYW5kICR1cmxSb3V0ZXJQcm92aWRlclxudmFyIGdldFN0YXRlUHJvdmlkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvcmUuZXh0ZW5kKHJvdXRlci5zdGF0ZVByb3ZpZGVyLCB7ICRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvdXRlci5zdGF0ZVNlcnZpY2U7IH0gfSk7XG59O1xud2F0Y2hEaWdlc3RzLiRpbmplY3QgPSBbJyRyb290U2NvcGUnXTtcbmZ1bmN0aW9uIHdhdGNoRGlnZXN0cygkcm9vdFNjb3BlKSB7XG4gICAgJHJvb3RTY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyBjb3JlLnRyYWNlLmFwcHJveGltYXRlRGlnZXN0cysrOyB9KTtcbn1cbm1vZF9pbml0LnByb3ZpZGVyKFwiJHVpUm91dGVyXCIsICR1aVJvdXRlcik7XG5tb2RfcnRyLnByb3ZpZGVyKCckdXJsUm91dGVyJywgWyckdWlSb3V0ZXJQcm92aWRlcicsIGdldFVybFJvdXRlclByb3ZpZGVyXSk7XG5tb2RfdXRpbC5wcm92aWRlcignJHVybFNlcnZpY2UnLCBnZXRQcm92aWRlckZvcigndXJsU2VydmljZScpKTtcbm1vZF91dGlsLnByb3ZpZGVyKCckdXJsTWF0Y2hlckZhY3RvcnknLCBbJyR1aVJvdXRlclByb3ZpZGVyJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLnVybE1hdGNoZXJGYWN0b3J5OyB9XSk7XG5tb2RfdXRpbC5wcm92aWRlcignJHRlbXBsYXRlRmFjdG9yeScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBUZW1wbGF0ZUZhY3RvcnkoKTsgfSk7XG5tb2Rfc3RhdGUucHJvdmlkZXIoJyRzdGF0ZVJlZ2lzdHJ5JywgZ2V0UHJvdmlkZXJGb3IoJ3N0YXRlUmVnaXN0cnknKSk7XG5tb2Rfc3RhdGUucHJvdmlkZXIoJyR1aVJvdXRlckdsb2JhbHMnLCBnZXRQcm92aWRlckZvcignZ2xvYmFscycpKTtcbm1vZF9zdGF0ZS5wcm92aWRlcignJHRyYW5zaXRpb25zJywgZ2V0UHJvdmlkZXJGb3IoJ3RyYW5zaXRpb25TZXJ2aWNlJykpO1xubW9kX3N0YXRlLnByb3ZpZGVyKCckc3RhdGUnLCBbJyR1aVJvdXRlclByb3ZpZGVyJywgZ2V0U3RhdGVQcm92aWRlcl0pO1xubW9kX3N0YXRlLmZhY3RvcnkoJyRzdGF0ZVBhcmFtcycsIFsnJHVpUm91dGVyJywgZnVuY3Rpb24gKCR1aVJvdXRlcikgeyByZXR1cm4gJHVpUm91dGVyLmdsb2JhbHMucGFyYW1zOyB9XSk7XG5tb2RfbWFpbi5mYWN0b3J5KCckdmlldycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvdXRlci52aWV3U2VydmljZTsgfSk7XG5tb2RfbWFpbi5zZXJ2aWNlKFwiJHRyYWNlXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcmUudHJhY2U7IH0pO1xubW9kX21haW4ucnVuKHdhdGNoRGlnZXN0cyk7XG5tb2RfdXRpbC5ydW4oWyckdXJsTWF0Y2hlckZhY3RvcnknLCBmdW5jdGlvbiAoJHVybE1hdGNoZXJGYWN0b3J5KSB7IH1dKTtcbm1vZF9zdGF0ZS5ydW4oWyckc3RhdGUnLCBmdW5jdGlvbiAoJHN0YXRlKSB7IH1dKTtcbm1vZF9ydHIucnVuKFsnJHVybFJvdXRlcicsIGZ1bmN0aW9uICgkdXJsUm91dGVyKSB7IH1dKTtcbm1vZF9pbml0LnJ1bihydW5CbG9jayk7XG4vKiogQGhpZGRlbiBUT0RPOiBmaW5kIGEgcGxhY2UgdG8gbW92ZSB0aGlzICovXG52YXIgZ2V0TG9jYWxzID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIHZhciB0b2tlbnMgPSBjdHguZ2V0VG9rZW5zKCkuZmlsdGVyKGNvcmUuaXNTdHJpbmcpO1xuICAgIHZhciB0dXBsZXMgPSB0b2tlbnMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHJlc29sdmFibGUgPSBjdHguZ2V0UmVzb2x2YWJsZShrZXkpO1xuICAgICAgICB2YXIgd2FpdFBvbGljeSA9IGN0eC5nZXRQb2xpY3kocmVzb2x2YWJsZSkuYXN5bmM7XG4gICAgICAgIHJldHVybiBba2V5LCB3YWl0UG9saWN5ID09PSAnTk9XQUlUJyA/IHJlc29sdmFibGUucHJvbWlzZSA6IHJlc29sdmFibGUuZGF0YV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHR1cGxlcy5yZWR1Y2UoY29yZS5hcHBseVBhaXJzLCB7fSk7XG59O1xuXG4vKipcbiAqICMgQW5ndWxhciAxIGluamVjdGFibGUgc2VydmljZXNcbiAqXG4gKiBUaGlzIGlzIGEgbGlzdCBvZiB0aGUgb2JqZWN0cyB3aGljaCBjYW4gYmUgaW5qZWN0ZWQgdXNpbmcgYW5ndWxhcidzIGluamVjdG9yLlxuICpcbiAqIFRoZXJlIGFyZSB0aHJlZSBkaWZmZXJlbnQga2luZCBvZiBpbmplY3RhYmxlIG9iamVjdHM6XG4gKlxuICogIyMgKipQcm92aWRlcioqIG9iamVjdHNcbiAqICMjIyMgaW5qZWN0YWJsZSBpbnRvIGEgYC5jb25maWcoKWAgYmxvY2sgZHVyaW5nIGNvbmZpZ3RpbWVcbiAqXG4gKiAtIFtbJHVpUm91dGVyUHJvdmlkZXJdXTogVGhlIFVJLVJvdXRlciBpbnN0YW5jZVxuICogLSBbWyRzdGF0ZVByb3ZpZGVyXV06IFN0YXRlIHJlZ2lzdHJhdGlvblxuICogLSBbWyR0cmFuc2l0aW9uc1Byb3ZpZGVyXV06IFRyYW5zaXRpb24gaG9va3NcbiAqIC0gW1skdXJsU2VydmljZVByb3ZpZGVyXV06IEFsbCBVUkwgcmVsYXRlZCBwdWJsaWMgQVBJc1xuICpcbiAqIC0gW1skdWlWaWV3U2Nyb2xsUHJvdmlkZXJdXTogRGlzYWJsZSB1aS1yb3V0ZXIgdmlldyBzY3JvbGxpbmdcbiAqIC0gW1skdXJsUm91dGVyUHJvdmlkZXJdXTogKGRlcHJlY2F0ZWQpIFVybCBtYXRjaGluZyBydWxlc1xuICogLSBbWyR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyXV06IChkZXByZWNhdGVkKSBVcmwgcGFyc2luZyBjb25maWdcbiAqXG4gKiAjIyAqKlNlcnZpY2UqKiBvYmplY3RzXG4gKiAjIyMjIGluamVjdGFibGUgZ2xvYmFsbHkgZHVyaW5nIHJ1bnRpbWVcbiAqXG4gKiAtIFtbJHVpUm91dGVyXV06IFRoZSBVSS1Sb3V0ZXIgaW5zdGFuY2VcbiAqIC0gW1skdHJhY2VdXTogRW5hYmxlIHRyYW5zaXRpb24gdHJhY2UvZGVidWdcbiAqIC0gW1skdHJhbnNpdGlvbnNdXTogVHJhbnNpdGlvbiBob29rc1xuICogLSBbWyRzdGF0ZV1dOiBJbXBlcmF0aXZlIHN0YXRlIHJlbGF0ZWQgQVBJc1xuICogLSBbWyRzdGF0ZVJlZ2lzdHJ5XV06IFN0YXRlIHJlZ2lzdHJhdGlvblxuICogLSBbWyR1cmxTZXJ2aWNlXV06IEFsbCBVUkwgcmVsYXRlZCBwdWJsaWMgQVBJc1xuICogLSBbWyR1aVJvdXRlckdsb2JhbHNdXTogR2xvYmFsIHZhcmlhYmxlc1xuICogLSBbWyR1aVZpZXdTY3JvbGxdXTogU2Nyb2xsIGFuIGVsZW1lbnQgaW50byB2aWV3XG4gKlxuICogLSBbWyRzdGF0ZVBhcmFtc11dOiAoZGVwcmVjYXRlZCkgR2xvYmFsIHN0YXRlIHBhcmFtIHZhbHVlc1xuICogLSBbWyR1cmxSb3V0ZXJdXTogKGRlcHJlY2F0ZWQpIFVSTCBzeW5jaHJvbml6YXRpb25cbiAqIC0gW1skdXJsTWF0Y2hlckZhY3RvcnldXTogKGRlcHJlY2F0ZWQpIFVSTCBwYXJzaW5nIGNvbmZpZ1xuICpcbiAqICMjICoqUGVyLVRyYW5zaXRpb24qKiBvYmplY3RzXG4gKlxuICogLSBUaGVzZSBraW5kIG9mIG9iamVjdHMgYXJlIGluamVjdGFibGUgaW50bzpcbiAqICAgLSBSZXNvbHZlcyAoW1tOZzFTdGF0ZURlY2xhcmF0aW9uLnJlc29sdmVdXSksXG4gKiAgIC0gVHJhbnNpdGlvbiBIb29rcyAoW1tUcmFuc2l0aW9uU2VydmljZS5vblN0YXJ0XV0sIGV0YyksXG4gKiAgIC0gUm91dGVkIENvbnRyb2xsZXJzIChbW05nMVZpZXdEZWNsYXJhdGlvbi5jb250cm9sbGVyXV0pXG4gKlxuICogIyMjIyBEaWZmZXJlbnQgaW5zdGFuY2VzIGFyZSBpbmplY3RlZCBiYXNlZCBvbiB0aGUgW1tUcmFuc2l0aW9uXV1cbiAqXG4gKiAtIFtbJHRyYW5zaXRpb24kXV06IFRoZSBjdXJyZW50IFRyYW5zaXRpb24gb2JqZWN0XG4gKiAtIFtbJHN0YXRlUGFyYW1zXV06IFN0YXRlIHBhcmFtIHZhbHVlcyBmb3IgcGVuZGluZyBUcmFuc2l0aW9uIChkZXByZWNhdGVkKVxuICogLSBBbnkgcmVzb2x2ZSBkYXRhIGRlZmluZWQgdXNpbmcgW1tOZzFTdGF0ZURlY2xhcmF0aW9uLnJlc29sdmVdXVxuICpcbiAqIEBuZzFhcGlcbiAqIEBwcmVmZXJyZWRcbiAqIEBtb2R1bGUgaW5qZWN0YWJsZXNcbiAqLyAvKiogKi9cbi8qKlxuICogVGhlIGN1cnJlbnQgKG9yIHBlbmRpbmcpIFN0YXRlIFBhcmFtZXRlcnNcbiAqXG4gKiBBbiBpbmplY3RhYmxlIGdsb2JhbCAqKlNlcnZpY2UgT2JqZWN0Kiogd2hpY2ggaG9sZHMgdGhlIHN0YXRlIHBhcmFtZXRlcnMgZm9yIHRoZSBsYXRlc3QgKipTVUNDRVNTRlVMKiogdHJhbnNpdGlvbi5cbiAqXG4gKiBUaGUgdmFsdWVzIGFyZSBub3QgdXBkYXRlZCB1bnRpbCAqYWZ0ZXIqIGEgYFRyYW5zaXRpb25gIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZXMuXG4gKlxuICogKipBbHNvOioqIGFuIGluamVjdGFibGUgKipQZXItVHJhbnNpdGlvbiBPYmplY3QqKiBvYmplY3Qgd2hpY2ggaG9sZHMgdGhlIHBlbmRpbmcgc3RhdGUgcGFyYW1ldGVycyBmb3IgdGhlIHBlbmRpbmcgYFRyYW5zaXRpb25gIGN1cnJlbnRseSBydW5uaW5nLlxuICpcbiAqICMjIyBEZXByZWNhdGlvbiB3YXJuaW5nOlxuICpcbiAqIFRoZSB2YWx1ZSBpbmplY3RlZCBmb3IgYCRzdGF0ZVBhcmFtc2AgaXMgZGlmZmVyZW50IGRlcGVuZGluZyBvbiB3aGVyZSBpdCBpcyBpbmplY3RlZC5cbiAqXG4gKiAtIFdoZW4gaW5qZWN0ZWQgaW50byBhbiBhbmd1bGFyIHNlcnZpY2UsIHRoZSBvYmplY3QgaW5qZWN0ZWQgaXMgdGhlIGdsb2JhbCAqKlNlcnZpY2UgT2JqZWN0Kiogd2l0aCB0aGUgcGFyYW1ldGVyIHZhbHVlcyBmb3IgdGhlIGxhdGVzdCBzdWNjZXNzZnVsIGBUcmFuc2l0aW9uYC5cbiAqIC0gV2hlbiBpbmplY3RlZCBpbnRvIHRyYW5zaXRpb24gaG9va3MsIHJlc29sdmVzLCBvciB2aWV3IGNvbnRyb2xsZXJzLCB0aGUgb2JqZWN0IGlzIHRoZSAqKlBlci1UcmFuc2l0aW9uIE9iamVjdCoqIHdpdGggdGhlIHBhcmFtZXRlciB2YWx1ZXMgZm9yIHRoZSBydW5uaW5nIGBUcmFuc2l0aW9uYC5cbiAqXG4gKiBCZWNhdXNlIG9mIHRoZXNlIGNvbmZ1c2luZyBkZXRhaWxzLCB0aGlzIHNlcnZpY2UgaXMgZGVwcmVjYXRlZC5cbiAqXG4gKiAjIyMgSW5zdGVhZCBvZiB1c2luZyB0aGUgZ2xvYmFsIGAkc3RhdGVQYXJhbXNgIHNlcnZpY2Ugb2JqZWN0LFxuICogaW5qZWN0IFtbJHVpUm91dGVyR2xvYmFsc11dIGFuZCB1c2UgW1tVSVJvdXRlckdsb2JhbHMucGFyYW1zXV1cbiAqXG4gKiBgYGBqc1xuICogTXlTZXJ2aWNlLiRpbmplY3QgPSBbJyR1aVJvdXRlckdsb2JhbHMnXTtcbiAqIGZ1bmN0aW9uIE15U2VydmljZSgkdWlSb3V0ZXJHbG9iYWxzKSB7XG4gKiAgIHJldHVybiB7XG4gKiAgICAgcGFyYW1WYWx1ZXM6IGZ1bmN0aW9uICgpIHtcbiAqICAgICAgIHJldHVybiAkdWlSb3V0ZXJHbG9iYWxzLnBhcmFtcztcbiAqICAgICB9XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqICMjIyBJbnN0ZWFkIG9mIHVzaW5nIHRoZSBwZXItdHJhbnNpdGlvbiBgJHN0YXRlUGFyYW1zYCBvYmplY3QsXG4gKiBpbmplY3QgdGhlIGN1cnJlbnQgYFRyYW5zaXRpb25gIChhcyBbWyR0cmFuc2l0aW9uJF1dKSBhbmQgdXNlIFtbVHJhbnNpdGlvbi5wYXJhbXNdXVxuICpcbiAqIGBgYGpzXG4gKiBNeUNvbnRyb2xsZXIuJGluamVjdCA9IFsnJHRyYW5zaXRpb24kJ107XG4gKiBmdW5jdGlvbiBNeUNvbnRyb2xsZXIoJHRyYW5zaXRpb24kKSB7XG4gKiAgIHZhciB1c2VybmFtZSA9ICR0cmFuc2l0aW9uJC5wYXJhbXMoKS51c2VybmFtZTtcbiAqICAgLy8gLi4gZG8gc29tZXRoaW5nIHdpdGggdXNlcm5hbWVcbiAqIH1cbiAqIGBgYFxuICpcbiAqIC0tLVxuICpcbiAqIFRoaXMgb2JqZWN0IGNhbiBiZSBpbmplY3RlZCBpbnRvIG90aGVyIHNlcnZpY2VzLlxuICpcbiAqICMjIyMgRGVwcmVjYXRlZCBFeGFtcGxlOlxuICogYGBganNcbiAqIFNvbWVTZXJ2aWNlLiRpbmplY3QgPSBbJyRodHRwJywgJyRzdGF0ZVBhcmFtcyddO1xuICogZnVuY3Rpb24gU29tZVNlcnZpY2UoJGh0dHAsICRzdGF0ZVBhcmFtcykge1xuICogICByZXR1cm4ge1xuICogICAgIGdldFVzZXI6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuICRodHRwLmdldCgnL2FwaS91c2Vycy8nICsgJHN0YXRlUGFyYW1zLnVzZXJuYW1lKTtcbiAqICAgICB9XG4gKiAgIH1cbiAqIH07XG4gKiBhbmd1bGFyLnNlcnZpY2UoJ1NvbWVTZXJ2aWNlJywgU29tZVNlcnZpY2UpO1xuICogYGBgXG4gKiBAZGVwcmVjYXRlZFxuICovXG5cbi8qKlxuICogIyBBbmd1bGFyIDEgRGlyZWN0aXZlc1xuICpcbiAqIFRoZXNlIGFyZSB0aGUgZGlyZWN0aXZlcyBpbmNsdWRlZCBpbiBVSS1Sb3V0ZXIgZm9yIEFuZ3VsYXIgMS5cbiAqIFRoZXNlIGRpcmVjdGl2ZXMgYXJlIHVzZWQgaW4gdGVtcGxhdGVzIHRvIGNyZWF0ZSB2aWV3cG9ydHMgYW5kIGxpbmsvbmF2aWdhdGUgdG8gc3RhdGVzLlxuICpcbiAqIEBuZzFhcGlcbiAqIEBwcmVmZXJyZWRcbiAqIEBtb2R1bGUgZGlyZWN0aXZlc1xuICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIHBhcnNlU3RhdGVSZWYocmVmKSB7XG4gICAgdmFyIHBhcmFtc09ubHkgPSByZWYubWF0Y2goL15cXHMqKHtbXn1dKn0pXFxzKiQvKSwgcGFyc2VkO1xuICAgIGlmIChwYXJhbXNPbmx5KVxuICAgICAgICByZWYgPSAnKCcgKyBwYXJhbXNPbmx5WzFdICsgJyknO1xuICAgIHBhcnNlZCA9IHJlZi5yZXBsYWNlKC9cXG4vZywgXCIgXCIpLm1hdGNoKC9eXFxzKihbXihdKj8pXFxzKihcXCgoLiopXFwpKT9cXHMqJC8pO1xuICAgIGlmICghcGFyc2VkIHx8IHBhcnNlZC5sZW5ndGggIT09IDQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdGUgcmVmICdcIiArIHJlZiArIFwiJ1wiKTtcbiAgICByZXR1cm4geyBzdGF0ZTogcGFyc2VkWzFdIHx8IG51bGwsIHBhcmFtRXhwcjogcGFyc2VkWzNdIHx8IG51bGwgfTtcbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBzdGF0ZUNvbnRleHQoZWwpIHtcbiAgICB2YXIgJHVpVmlldyA9IGVsLnBhcmVudCgpLmluaGVyaXRlZERhdGEoJyR1aVZpZXcnKTtcbiAgICB2YXIgcGF0aCA9IGNvcmUucGFyc2UoJyRjZmcucGF0aCcpKCR1aVZpZXcpO1xuICAgIHJldHVybiBwYXRoID8gY29yZS50YWlsKHBhdGgpLnN0YXRlLm5hbWUgOiB1bmRlZmluZWQ7XG59XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc2VkRGVmKCRzdGF0ZSwgJGVsZW1lbnQsIGRlZikge1xuICAgIHZhciB1aVN0YXRlID0gZGVmLnVpU3RhdGUgfHwgJHN0YXRlLmN1cnJlbnQubmFtZTtcbiAgICB2YXIgdWlTdGF0ZU9wdHMgPSBjb3JlLmV4dGVuZChkZWZhdWx0T3B0cygkZWxlbWVudCwgJHN0YXRlKSwgZGVmLnVpU3RhdGVPcHRzIHx8IHt9KTtcbiAgICB2YXIgaHJlZiA9ICRzdGF0ZS5ocmVmKHVpU3RhdGUsIGRlZi51aVN0YXRlUGFyYW1zLCB1aVN0YXRlT3B0cyk7XG4gICAgcmV0dXJuIHsgdWlTdGF0ZTogdWlTdGF0ZSwgdWlTdGF0ZVBhcmFtczogZGVmLnVpU3RhdGVQYXJhbXMsIHVpU3RhdGVPcHRzOiB1aVN0YXRlT3B0cywgaHJlZjogaHJlZiB9O1xufVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGdldFR5cGVJbmZvKGVsKSB7XG4gICAgLy8gU1ZHQUVsZW1lbnQgZG9lcyBub3QgdXNlIHRoZSBocmVmIGF0dHJpYnV0ZSwgYnV0IHJhdGhlciB0aGUgJ3hsaW5rSHJlZicgYXR0cmlidXRlLlxuICAgIHZhciBpc1N2ZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlbC5wcm9wKCdocmVmJykpID09PSAnW29iamVjdCBTVkdBbmltYXRlZFN0cmluZ10nO1xuICAgIHZhciBpc0Zvcm0gPSBlbFswXS5ub2RlTmFtZSA9PT0gXCJGT1JNXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXR0cjogaXNGb3JtID8gXCJhY3Rpb25cIiA6IChpc1N2ZyA/ICd4bGluazpocmVmJyA6ICdocmVmJyksXG4gICAgICAgIGlzQW5jaG9yOiBlbC5wcm9wKFwidGFnTmFtZVwiKS50b1VwcGVyQ2FzZSgpID09PSBcIkFcIixcbiAgICAgICAgY2xpY2thYmxlOiAhaXNGb3JtXG4gICAgfTtcbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBjbGlja0hvb2soZWwsICRzdGF0ZSwgJHRpbWVvdXQsIHR5cGUsIGdldERlZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgYnV0dG9uID0gZS53aGljaCB8fCBlLmJ1dHRvbiwgdGFyZ2V0ID0gZ2V0RGVmKCk7XG4gICAgICAgIGlmICghKGJ1dHRvbiA+IDEgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCBlLnNoaWZ0S2V5IHx8IGVsLmF0dHIoJ3RhcmdldCcpKSkge1xuICAgICAgICAgICAgLy8gSEFDSzogVGhpcyBpcyB0byBhbGxvdyBuZy1jbGlja3MgdG8gYmUgcHJvY2Vzc2VkIGJlZm9yZSB0aGUgdHJhbnNpdGlvbiBpcyBpbml0aWF0ZWQ6XG4gICAgICAgICAgICB2YXIgdHJhbnNpdGlvbiA9ICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAkc3RhdGUuZ28odGFyZ2V0LnVpU3RhdGUsIHRhcmdldC51aVN0YXRlUGFyYW1zLCB0YXJnZXQudWlTdGF0ZU9wdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAvLyBpZiB0aGUgc3RhdGUgaGFzIG5vIFVSTCwgaWdub3JlIG9uZSBwcmV2ZW50RGVmYXVsdCBmcm9tIHRoZSA8YT4gZGlyZWN0aXZlLlxuICAgICAgICAgICAgdmFyIGlnbm9yZVByZXZlbnREZWZhdWx0Q291bnQgPSB0eXBlLmlzQW5jaG9yICYmICF0YXJnZXQuaHJlZiA/IDEgOiAwO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWdub3JlUHJldmVudERlZmF1bHRDb3VudC0tIDw9IDApXG4gICAgICAgICAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbCh0cmFuc2l0aW9uKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRPcHRzKGVsLCAkc3RhdGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWxhdGl2ZTogc3RhdGVDb250ZXh0KGVsKSB8fCAkc3RhdGUuJGN1cnJlbnQsXG4gICAgICAgIGluaGVyaXQ6IHRydWUsXG4gICAgICAgIHNvdXJjZTogXCJzcmVmXCJcbiAgICB9O1xufVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGJpbmRFdmVudHMoZWxlbWVudCwgc2NvcGUsIGhvb2tGbiwgdWlTdGF0ZU9wdHMpIHtcbiAgICB2YXIgZXZlbnRzO1xuICAgIGlmICh1aVN0YXRlT3B0cykge1xuICAgICAgICBldmVudHMgPSB1aVN0YXRlT3B0cy5ldmVudHM7XG4gICAgfVxuICAgIGlmICghY29yZS5pc0FycmF5KGV2ZW50cykpIHtcbiAgICAgICAgZXZlbnRzID0gWydjbGljayddO1xuICAgIH1cbiAgICB2YXIgb24gPSBlbGVtZW50Lm9uID8gJ29uJyA6ICdiaW5kJztcbiAgICBmb3IgKHZhciBfaSA9IDAsIGV2ZW50c18xID0gZXZlbnRzOyBfaSA8IGV2ZW50c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgZXZlbnRfMSA9IGV2ZW50c18xW19pXTtcbiAgICAgICAgZWxlbWVudFtvbl0oZXZlbnRfMSwgaG9va0ZuKTtcbiAgICB9XG4gICAgc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9mZiA9IGVsZW1lbnQub2ZmID8gJ29mZicgOiAndW5iaW5kJztcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBldmVudHNfMiA9IGV2ZW50czsgX2kgPCBldmVudHNfMi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBldmVudF8yID0gZXZlbnRzXzJbX2ldO1xuICAgICAgICAgICAgZWxlbWVudFtvZmZdKGV2ZW50XzIsIGhvb2tGbik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogYHVpLXNyZWZgOiBBIGRpcmVjdGl2ZSBmb3IgbGlua2luZyB0byBhIHN0YXRlXG4gKlxuICogQSBkaXJlY3RpdmUgd2hpY2ggbGlua3MgdG8gYSBzdGF0ZSAoYW5kIG9wdGlvbmFsbHksIHBhcmFtZXRlcnMpLlxuICogV2hlbiBjbGlja2VkLCB0aGlzIGRpcmVjdGl2ZSBhY3RpdmF0ZXMgdGhlIGxpbmtlZCBzdGF0ZSB3aXRoIHRoZSBzdXBwbGllZCBwYXJhbWV0ZXIgdmFsdWVzLlxuICpcbiAqICMjIyBMaW5rZWQgU3RhdGVcbiAqIFRoZSBhdHRyaWJ1dGUgdmFsdWUgb2YgdGhlIGB1aS1zcmVmYCBpcyB0aGUgbmFtZSBvZiB0aGUgc3RhdGUgdG8gbGluayB0by5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBUaGlzIHdpbGwgYWN0aXZhdGUgdGhlIGBob21lYCBzdGF0ZSB3aGVuIHRoZSBsaW5rIGlzIGNsaWNrZWQuXG4gKiBgYGBodG1sXG4gKiA8YSB1aS1zcmVmPVwiaG9tZVwiPkhvbWU8L2E+XG4gKiBgYGBcbiAqXG4gKiAjIyMgUmVsYXRpdmUgTGlua3NcbiAqIFlvdSBjYW4gYWxzbyB1c2UgcmVsYXRpdmUgc3RhdGUgcGF0aHMgd2l0aGluIGB1aS1zcmVmYCwganVzdCBsaWtlIGEgcmVsYXRpdmUgcGF0aCBwYXNzZWQgdG8gYCRzdGF0ZS5nbygpYCAoW1tTdGF0ZVNlcnZpY2UuZ29dXSkuXG4gKiBZb3UganVzdCBuZWVkIHRvIGJlIGF3YXJlIHRoYXQgdGhlIHBhdGggaXMgcmVsYXRpdmUgdG8gdGhlIHN0YXRlIHRoYXQgKmNyZWF0ZWQqIHRoZSBsaW5rLlxuICogVGhpcyBhbGxvd3MgYSBzdGF0ZSB0byBjcmVhdGUgYSByZWxhdGl2ZSBgdWktc3JlZmAgd2hpY2ggYWx3YXlzIHRhcmdldHMgdGhlIHNhbWUgZGVzdGluYXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogQm90aCB0aGVzZSBsaW5rcyBhcmUgcmVsYXRpdmUgdG8gdGhlIHBhcmVudCBzdGF0ZSwgZXZlbiB3aGVuIGEgY2hpbGQgc3RhdGUgaXMgY3VycmVudGx5IGFjdGl2ZS5cbiAqIGBgYGh0bWxcbiAqIDxhIHVpLXNyZWY9XCIuY2hpbGQxXCI+Y2hpbGQgMSBzdGF0ZTwvYT5cbiAqIDxhIHVpLXNyZWY9XCIuY2hpbGQyXCI+Y2hpbGQgMiBzdGF0ZTwvYT5cbiAqIGBgYFxuICpcbiAqIFRoaXMgbGluayBhY3RpdmF0ZXMgdGhlIHBhcmVudCBzdGF0ZS5cbiAqIGBgYGh0bWxcbiAqIDxhIHVpLXNyZWY9XCJeXCI+UmV0dXJuPC9hPlxuICogYGBgXG4gKlxuICogIyMjIGhyZWZzXG4gKiBJZiB0aGUgbGlua2VkIHN0YXRlIGhhcyBhIFVSTCwgdGhlIGRpcmVjdGl2ZSB3aWxsIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGUgYW5kXG4gKiB1cGRhdGUgdGhlIGBocmVmYCBhdHRyaWJ1dGUgKHVzaW5nIHRoZSBbW1N0YXRlU2VydmljZS5ocmVmXV0gIG1ldGhvZCkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogQXNzdW1pbmcgdGhlIGB1c2Vyc2Agc3RhdGUgaGFzIGEgdXJsIG9mIGAvdXNlcnMvYFxuICogYGBgaHRtbFxuICogPGEgdWktc3JlZj1cInVzZXJzXCIgaHJlZj1cIi91c2Vycy9cIj5Vc2VyczwvYT5cbiAqIGBgYFxuICpcbiAqICMjIyBQYXJhbWV0ZXIgVmFsdWVzXG4gKiBJbiBhZGRpdGlvbiB0byB0aGUgc3RhdGUgbmFtZSwgYSBgdWktc3JlZmAgY2FuIGluY2x1ZGUgcGFyYW1ldGVyIHZhbHVlcyB3aGljaCBhcmUgYXBwbGllZCB3aGVuIGFjdGl2YXRpbmcgdGhlIHN0YXRlLlxuICogUGFyYW0gdmFsdWVzIGNhbiBiZSBwcm92aWRlZCBpbiB0aGUgYHVpLXNyZWZgIHZhbHVlIGFmdGVyIHRoZSBzdGF0ZSBuYW1lLCBlbmNsb3NlZCBieSBwYXJlbnRoZXNlcy5cbiAqIFRoZSBjb250ZW50IGluc2lkZSB0aGUgcGFyZW50aGVzZXMgaXMgYW4gZXhwcmVzc2lvbiwgZXZhbHVhdGVkIHRvIHRoZSBwYXJhbWV0ZXIgdmFsdWVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIFRoaXMgZXhhbXBsZSByZW5kZXJzIGEgbGlzdCBvZiBsaW5rcyB0byB1c2Vycy5cbiAqIFRoZSBzdGF0ZSdzIGB1c2VySWRgIHBhcmFtZXRlciB2YWx1ZSBjb21lcyBmcm9tIGVhY2ggdXNlcidzIGB1c2VyLmlkYCBwcm9wZXJ0eS5cbiAqIGBgYGh0bWxcbiAqIDxsaSBuZy1yZXBlYXQ9XCJ1c2VyIGluIHVzZXJzXCI+XG4gKiAgIDxhIHVpLXNyZWY9XCJ1c2Vycy5kZXRhaWwoeyB1c2VySWQ6IHVzZXIuaWQgfSlcIj57eyB1c2VyLmRpc3BsYXlOYW1lIH19PC9hPlxuICogPC9saT5cbiAqIGBgYFxuICpcbiAqIE5vdGU6XG4gKiBUaGUgcGFyYW1ldGVyIHZhbHVlcyBleHByZXNzaW9uIGlzIGAkd2F0Y2hgZWQgZm9yIHVwZGF0ZXMuXG4gKlxuICogIyMjIFRyYW5zaXRpb24gT3B0aW9uc1xuICogWW91IGNhbiBzcGVjaWZ5IFtbVHJhbnNpdGlvbk9wdGlvbnNdXSB0byBwYXNzIHRvIFtbU3RhdGVTZXJ2aWNlLmdvXV0gYnkgdXNpbmcgdGhlIGB1aS1zcmVmLW9wdHNgIGF0dHJpYnV0ZS5cbiAqIE9wdGlvbnMgYXJlIHJlc3RyaWN0ZWQgdG8gYGxvY2F0aW9uYCwgYGluaGVyaXRgLCBhbmQgYHJlbG9hZGAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogYGBgaHRtbFxuICogPGEgdWktc3JlZj1cImhvbWVcIiB1aS1zcmVmLW9wdHM9XCJ7IHJlbG9hZDogdHJ1ZSB9XCI+SG9tZTwvYT5cbiAqIGBgYFxuICpcbiAqICMjIyBPdGhlciBET00gRXZlbnRzXG4gKlxuICogWW91IGNhbiBhbHNvIGN1c3RvbWl6ZSB3aGljaCBET00gZXZlbnRzIHRvIHJlc3BvbmQgdG8gKGluc3RlYWQgb2YgYGNsaWNrYCkgYnlcbiAqIHByb3ZpZGluZyBhbiBgZXZlbnRzYCBhcnJheSBpbiB0aGUgYHVpLXNyZWYtb3B0c2AgYXR0cmlidXRlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGh0bWxcbiAqIDxpbnB1dCB0eXBlPVwidGV4dFwiIHVpLXNyZWY9XCJjb250YWN0c1wiIHVpLXNyZWYtb3B0cz1cInsgZXZlbnRzOiBbJ2NoYW5nZScsICdibHVyJ10gfVwiPlxuICogYGBgXG4gKlxuICogIyMjIEhpZ2hsaWdodGluZyB0aGUgYWN0aXZlIGxpbmtcbiAqIFRoaXMgZGlyZWN0aXZlIGNhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggW1t1aVNyZWZBY3RpdmVdXSB0byBoaWdobGlnaHQgdGhlIGFjdGl2ZSBsaW5rLlxuICpcbiAqICMjIyBFeGFtcGxlc1xuICogSWYgeW91IGhhdmUgdGhlIGZvbGxvd2luZyB0ZW1wbGF0ZTpcbiAqXG4gKiBgYGBodG1sXG4gKiA8YSB1aS1zcmVmPVwiaG9tZVwiPkhvbWU8L2E+XG4gKiA8YSB1aS1zcmVmPVwiYWJvdXRcIj5BYm91dDwvYT5cbiAqIDxhIHVpLXNyZWY9XCJ7cGFnZTogMn1cIj5OZXh0IHBhZ2U8L2E+XG4gKlxuICogPHVsPlxuICogICAgIDxsaSBuZy1yZXBlYXQ9XCJjb250YWN0IGluIGNvbnRhY3RzXCI+XG4gKiAgICAgICAgIDxhIHVpLXNyZWY9XCJjb250YWN0cy5kZXRhaWwoeyBpZDogY29udGFjdC5pZCB9KVwiPnt7IGNvbnRhY3QubmFtZSB9fTwvYT5cbiAqICAgICA8L2xpPlxuICogPC91bD5cbiAqIGBgYFxuICpcbiAqIFRoZW4gKGFzc3VtaW5nIHRoZSBjdXJyZW50IHN0YXRlIGlzIGBjb250YWN0c2ApIHRoZSByZW5kZXJlZCBodG1sIGluY2x1ZGluZyBocmVmcyB3b3VsZCBiZTpcbiAqXG4gKiBgYGBodG1sXG4gKiA8YSBocmVmPVwiIy9ob21lXCIgdWktc3JlZj1cImhvbWVcIj5Ib21lPC9hPlxuICogPGEgaHJlZj1cIiMvYWJvdXRcIiB1aS1zcmVmPVwiYWJvdXRcIj5BYm91dDwvYT5cbiAqIDxhIGhyZWY9XCIjL2NvbnRhY3RzP3BhZ2U9MlwiIHVpLXNyZWY9XCJ7cGFnZTogMn1cIj5OZXh0IHBhZ2U8L2E+XG4gKlxuICogPHVsPlxuICogICAgIDxsaSBuZy1yZXBlYXQ9XCJjb250YWN0IGluIGNvbnRhY3RzXCI+XG4gKiAgICAgICAgIDxhIGhyZWY9XCIjL2NvbnRhY3RzLzFcIiB1aS1zcmVmPVwiY29udGFjdHMuZGV0YWlsKHsgaWQ6IGNvbnRhY3QuaWQgfSlcIj5Kb2U8L2E+XG4gKiAgICAgPC9saT5cbiAqICAgICA8bGkgbmctcmVwZWF0PVwiY29udGFjdCBpbiBjb250YWN0c1wiPlxuICogICAgICAgICA8YSBocmVmPVwiIy9jb250YWN0cy8yXCIgdWktc3JlZj1cImNvbnRhY3RzLmRldGFpbCh7IGlkOiBjb250YWN0LmlkIH0pXCI+QWxpY2U8L2E+XG4gKiAgICAgPC9saT5cbiAqICAgICA8bGkgbmctcmVwZWF0PVwiY29udGFjdCBpbiBjb250YWN0c1wiPlxuICogICAgICAgICA8YSBocmVmPVwiIy9jb250YWN0cy8zXCIgdWktc3JlZj1cImNvbnRhY3RzLmRldGFpbCh7IGlkOiBjb250YWN0LmlkIH0pXCI+Qm9iPC9hPlxuICogICAgIDwvbGk+XG4gKiA8L3VsPlxuICpcbiAqIDxhIGhyZWY9XCIjL2hvbWVcIiB1aS1zcmVmPVwiaG9tZVwiIHVpLXNyZWYtb3B0cz1cIntyZWxvYWQ6IHRydWV9XCI+SG9tZTwvYT5cbiAqIGBgYFxuICpcbiAqICMjIyBOb3Rlc1xuICpcbiAqIC0gWW91IGNhbiB1c2UgYHVpLXNyZWZgIHRvIGNoYW5nZSAqKm9ubHkgdGhlIHBhcmFtZXRlciB2YWx1ZXMqKiBieSBvbWl0dGluZyB0aGUgc3RhdGUgbmFtZSBhbmQgcGFyZW50aGVzZXMuXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBTZXRzIHRoZSBgbGFuZ2AgcGFyYW1ldGVyIHRvIGBlbmAgYW5kIHJlbWFpbnMgb24gdGhlIHNhbWUgc3RhdGUuXG4gKlxuICogYGBgaHRtbFxuICogPGEgdWktc3JlZj1cInsgbGFuZzogJ2VuJyB9XCI+RW5nbGlzaDwvYT5cbiAqIGBgYFxuICpcbiAqIC0gQSBtaWRkbGUtY2xpY2ssIHJpZ2h0LWNsaWNrLCBvciBjdHJsLWNsaWNrIGlzIGhhbmRsZWQgKG5hdGl2ZWx5KSBieSB0aGUgYnJvd3NlciB0byBvcGVuIHRoZSBocmVmIGluIGEgbmV3IHdpbmRvdywgZm9yIGV4YW1wbGUuXG4gKlxuICogLSBVbmxpa2UgdGhlIHBhcmFtZXRlciB2YWx1ZXMgZXhwcmVzc2lvbiwgdGhlIHN0YXRlIG5hbWUgaXMgbm90IGAkd2F0Y2hgZWQgKGZvciBwZXJmb3JtYW5jZSByZWFzb25zKS5cbiAqIElmIHlvdSBuZWVkIHRvIGR5bmFtaWNhbGx5IHVwZGF0ZSB0aGUgc3RhdGUgYmVpbmcgbGlua2VkIHRvLCB1c2UgdGhlIGZ1bGx5IGR5bmFtaWMgW1t1aVN0YXRlXV0gZGlyZWN0aXZlLlxuICovXG52YXIgdWlTcmVmO1xudWlTcmVmID0gWyckdWlSb3V0ZXInLCAnJHRpbWVvdXQnLFxuICAgIGZ1bmN0aW9uICRTdGF0ZVJlZkRpcmVjdGl2ZSgkdWlSb3V0ZXIsICR0aW1lb3V0KSB7XG4gICAgICAgIHZhciAkc3RhdGUgPSAkdWlSb3V0ZXIuc3RhdGVTZXJ2aWNlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgICAgICAgIHJlcXVpcmU6IFsnP151aVNyZWZBY3RpdmUnLCAnP151aVNyZWZBY3RpdmVFcSddLFxuICAgICAgICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgdWlTcmVmQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBnZXRUeXBlSW5mbyhlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgYWN0aXZlID0gdWlTcmVmQWN0aXZlWzFdIHx8IHVpU3JlZkFjdGl2ZVswXTtcbiAgICAgICAgICAgICAgICB2YXIgdW5saW5rSW5mb0ZuID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgaG9va0ZuO1xuICAgICAgICAgICAgICAgIHZhciByYXdEZWYgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgZ2V0RGVmID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvY2Vzc2VkRGVmKCRzdGF0ZSwgZWxlbWVudCwgcmF3RGVmKTsgfTtcbiAgICAgICAgICAgICAgICB2YXIgcmVmID0gcGFyc2VTdGF0ZVJlZihhdHRycy51aVNyZWYpO1xuICAgICAgICAgICAgICAgIHJhd0RlZi51aVN0YXRlID0gcmVmLnN0YXRlO1xuICAgICAgICAgICAgICAgIHJhd0RlZi51aVN0YXRlT3B0cyA9IGF0dHJzLnVpU3JlZk9wdHMgPyBzY29wZS4kZXZhbChhdHRycy51aVNyZWZPcHRzKSA6IHt9O1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZiA9IGdldERlZigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodW5saW5rSW5mb0ZuKVxuICAgICAgICAgICAgICAgICAgICAgICAgdW5saW5rSW5mb0ZuKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmUpXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmxpbmtJbmZvRm4gPSBhY3RpdmUuJCRhZGRTdGF0ZUluZm8oZGVmLnVpU3RhdGUsIGRlZi51aVN0YXRlUGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi5ocmVmICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRycy4kc2V0KHR5cGUuYXR0ciwgZGVmLmhyZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVmLnBhcmFtRXhwcikge1xuICAgICAgICAgICAgICAgICAgICBzY29wZS4kd2F0Y2gocmVmLnBhcmFtRXhwciwgZnVuY3Rpb24gKHZhbCQkMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmF3RGVmLnVpU3RhdGVQYXJhbXMgPSBjb3JlLmV4dGVuZCh7fSwgdmFsJCQxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmF3RGVmLnVpU3RhdGVQYXJhbXMgPSBjb3JlLmV4dGVuZCh7fSwgc2NvcGUuJGV2YWwocmVmLnBhcmFtRXhwcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgJHVpUm91dGVyLnN0YXRlUmVnaXN0cnkub25TdGF0ZXNDaGFuZ2VkKHVwZGF0ZSkpO1xuICAgICAgICAgICAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCAkdWlSb3V0ZXIudHJhbnNpdGlvblNlcnZpY2Uub25TdWNjZXNzKHt9LCB1cGRhdGUpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGUuY2xpY2thYmxlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaG9va0ZuID0gY2xpY2tIb29rKGVsZW1lbnQsICRzdGF0ZSwgJHRpbWVvdXQsIHR5cGUsIGdldERlZik7XG4gICAgICAgICAgICAgICAgYmluZEV2ZW50cyhlbGVtZW50LCBzY29wZSwgaG9va0ZuLCByYXdEZWYudWlTdGF0ZU9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1dO1xuLyoqXG4gKiBgdWktc3RhdGVgOiBBIGZ1bGx5IGR5bmFtaWMgZGlyZWN0aXZlIGZvciBsaW5raW5nIHRvIGEgc3RhdGVcbiAqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCBsaW5rcyB0byBhIHN0YXRlIChhbmQgb3B0aW9uYWxseSwgcGFyYW1ldGVycykuXG4gKiBXaGVuIGNsaWNrZWQsIHRoaXMgZGlyZWN0aXZlIGFjdGl2YXRlcyB0aGUgbGlua2VkIHN0YXRlIHdpdGggdGhlIHN1cHBsaWVkIHBhcmFtZXRlciB2YWx1ZXMuXG4gKlxuICogKipUaGlzIGRpcmVjdGl2ZSBpcyB2ZXJ5IHNpbWlsYXIgdG8gW1t1aVNyZWZdXSwgYnV0IGl0IGAkb2JzZXJ2ZWBzIGFuZCBgJHdhdGNoYGVzL2V2YWx1YXRlcyBhbGwgaXRzIGlucHV0cy4qKlxuICpcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIGxpbmtzIHRvIGEgc3RhdGUgKGFuZCBvcHRpb25hbGx5LCBwYXJhbWV0ZXJzKS5cbiAqIFdoZW4gY2xpY2tlZCwgdGhpcyBkaXJlY3RpdmUgYWN0aXZhdGVzIHRoZSBsaW5rZWQgc3RhdGUgd2l0aCB0aGUgc3VwcGxpZWQgcGFyYW1ldGVyIHZhbHVlcy5cbiAqXG4gKiAjIyMgTGlua2VkIFN0YXRlXG4gKiBUaGUgYXR0cmlidXRlIHZhbHVlIG9mIGB1aS1zdGF0ZWAgaXMgYW4gZXhwcmVzc2lvbiB3aGljaCBpcyBgJHdhdGNoYGVkIGFuZCBldmFsdWF0ZWQgYXMgdGhlIHN0YXRlIHRvIGxpbmsgdG8uXG4gKiAqKlRoaXMgaXMgaW4gY29udHJhc3Qgd2l0aCBgdWktc3JlZmAsIHdoaWNoIHRha2VzIGEgc3RhdGUgbmFtZSBhcyBhIHN0cmluZyBsaXRlcmFsLioqXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogQ3JlYXRlIGEgbGlzdCBvZiBsaW5rcy5cbiAqIGBgYGh0bWxcbiAqIDxsaSBuZy1yZXBlYXQ9XCJsaW5rIGluIG5hdmxpbmtzXCI+XG4gKiAgIDxhIHVpLXN0YXRlPVwibGluay5zdGF0ZVwiPnt7IGxpbmsuZGlzcGxheU5hbWUgfX08L2E+XG4gKiA8L2xpPlxuICogYGBgXG4gKlxuICogIyMjIFJlbGF0aXZlIExpbmtzXG4gKiBJZiB0aGUgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gYSByZWxhdGl2ZSBwYXRoLCBpdCBpcyBwcm9jZXNzZWQgbGlrZSBbW3VpU3JlZl1dLlxuICogWW91IGp1c3QgbmVlZCB0byBiZSBhd2FyZSB0aGF0IHRoZSBwYXRoIGlzIHJlbGF0aXZlIHRvIHRoZSBzdGF0ZSB0aGF0ICpjcmVhdGVkKiB0aGUgbGluay5cbiAqIFRoaXMgYWxsb3dzIGEgc3RhdGUgdG8gY3JlYXRlIHJlbGF0aXZlIGB1aS1zdGF0ZWAgd2hpY2ggYWx3YXlzIHRhcmdldHMgdGhlIHNhbWUgZGVzdGluYXRpb24uXG4gKlxuICogIyMjIGhyZWZzXG4gKiBJZiB0aGUgbGlua2VkIHN0YXRlIGhhcyBhIFVSTCwgdGhlIGRpcmVjdGl2ZSB3aWxsIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGUgYW5kXG4gKiB1cGRhdGUgdGhlIGBocmVmYCBhdHRyaWJ1dGUgKHVzaW5nIHRoZSBbW1N0YXRlU2VydmljZS5ocmVmXV0gIG1ldGhvZCkuXG4gKlxuICogIyMjIFBhcmFtZXRlciBWYWx1ZXNcbiAqIEluIGFkZGl0aW9uIHRvIHRoZSBzdGF0ZSBuYW1lIGV4cHJlc3Npb24sIGEgYHVpLXN0YXRlYCBjYW4gaW5jbHVkZSBwYXJhbWV0ZXIgdmFsdWVzIHdoaWNoIGFyZSBhcHBsaWVkIHdoZW4gYWN0aXZhdGluZyB0aGUgc3RhdGUuXG4gKiBQYXJhbSB2YWx1ZXMgc2hvdWxkIGJlIHByb3ZpZGVkIHVzaW5nIHRoZSBgdWktc3RhdGUtcGFyYW1zYCBhdHRyaWJ1dGUuXG4gKiBUaGUgYHVpLXN0YXRlLXBhcmFtc2AgYXR0cmlidXRlIHZhbHVlIGlzIGAkd2F0Y2hgZWQgYW5kIGV2YWx1YXRlZCBhcyBhbiBleHByZXNzaW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIFRoaXMgZXhhbXBsZSByZW5kZXJzIGEgbGlzdCBvZiBsaW5rcyB3aXRoIHBhcmFtIHZhbHVlcy5cbiAqIFRoZSBzdGF0ZSdzIGB1c2VySWRgIHBhcmFtZXRlciB2YWx1ZSBjb21lcyBmcm9tIGVhY2ggdXNlcidzIGB1c2VyLmlkYCBwcm9wZXJ0eS5cbiAqIGBgYGh0bWxcbiAqIDxsaSBuZy1yZXBlYXQ9XCJsaW5rIGluIG5hdmxpbmtzXCI+XG4gKiAgIDxhIHVpLXN0YXRlPVwibGluay5zdGF0ZVwiIHVpLXN0YXRlLXBhcmFtcz1cImxpbmsucGFyYW1zXCI+e3sgbGluay5kaXNwbGF5TmFtZSB9fTwvYT5cbiAqIDwvbGk+XG4gKiBgYGBcbiAqXG4gKiAjIyMgVHJhbnNpdGlvbiBPcHRpb25zXG4gKiBZb3UgY2FuIHNwZWNpZnkgW1tUcmFuc2l0aW9uT3B0aW9uc11dIHRvIHBhc3MgdG8gW1tTdGF0ZVNlcnZpY2UuZ29dXSBieSB1c2luZyB0aGUgYHVpLXN0YXRlLW9wdHNgIGF0dHJpYnV0ZS5cbiAqIE9wdGlvbnMgYXJlIHJlc3RyaWN0ZWQgdG8gYGxvY2F0aW9uYCwgYGluaGVyaXRgLCBhbmQgYHJlbG9hZGAuXG4gKiBUaGUgdmFsdWUgb2YgdGhlIGB1aS1zdGF0ZS1vcHRzYCBpcyBgJHdhdGNoYGVkIGFuZCBldmFsdWF0ZWQgYXMgYW4gZXhwcmVzc2lvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8YSB1aS1zdGF0ZT1cInJldHVybnRvLnN0YXRlXCIgdWktc3RhdGUtb3B0cz1cInsgcmVsb2FkOiB0cnVlIH1cIj5Ib21lPC9hPlxuICogYGBgXG4gKlxuICogIyMjIE90aGVyIERPTSBFdmVudHNcbiAqXG4gKiBZb3UgY2FuIGFsc28gY3VzdG9taXplIHdoaWNoIERPTSBldmVudHMgdG8gcmVzcG9uZCB0byAoaW5zdGVhZCBvZiBgY2xpY2tgKSBieVxuICogcHJvdmlkaW5nIGFuIGBldmVudHNgIGFycmF5IGluIHRoZSBgdWktc3RhdGUtb3B0c2AgYXR0cmlidXRlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGh0bWxcbiAqIDxpbnB1dCB0eXBlPVwidGV4dFwiIHVpLXN0YXRlPVwiY29udGFjdHNcIiB1aS1zdGF0ZS1vcHRzPVwieyBldmVudHM6IFsnY2hhbmdlJywgJ2JsdXInXSB9XCI+XG4gKiBgYGBcbiAqXG4gKiAjIyMgSGlnaGxpZ2h0aW5nIHRoZSBhY3RpdmUgbGlua1xuICogVGhpcyBkaXJlY3RpdmUgY2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBbW3VpU3JlZkFjdGl2ZV1dIHRvIGhpZ2hsaWdodCB0aGUgYWN0aXZlIGxpbmsuXG4gKlxuICogIyMjIE5vdGVzXG4gKlxuICogLSBZb3UgY2FuIHVzZSBgdWktcGFyYW1zYCB0byBjaGFuZ2UgKipvbmx5IHRoZSBwYXJhbWV0ZXIgdmFsdWVzKiogYnkgb21pdHRpbmcgdGhlIHN0YXRlIG5hbWUgYW5kIHN1cHBseWluZyBvbmx5IGB1aS1zdGF0ZS1wYXJhbXNgLlxuICogICBIb3dldmVyLCBpdCBtaWdodCBiZSBzaW1wbGVyIHRvIHVzZSBbW3VpU3JlZl1dIHBhcmFtZXRlci1vbmx5IGxpbmtzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIFNldHMgdGhlIGBsYW5nYCBwYXJhbWV0ZXIgdG8gYGVuYCBhbmQgcmVtYWlucyBvbiB0aGUgc2FtZSBzdGF0ZS5cbiAqXG4gKiBgYGBodG1sXG4gKiA8YSB1aS1zdGF0ZT1cIlwiIHVpLXN0YXRlLXBhcmFtcz1cInsgbGFuZzogJ2VuJyB9XCI+RW5nbGlzaDwvYT5cbiAqIGBgYFxuICpcbiAqIC0gQSBtaWRkbGUtY2xpY2ssIHJpZ2h0LWNsaWNrLCBvciBjdHJsLWNsaWNrIGlzIGhhbmRsZWQgKG5hdGl2ZWx5KSBieSB0aGUgYnJvd3NlciB0byBvcGVuIHRoZSBocmVmIGluIGEgbmV3IHdpbmRvdywgZm9yIGV4YW1wbGUuXG4gKiBgYGBcbiAqL1xudmFyIHVpU3RhdGU7XG51aVN0YXRlID0gWyckdWlSb3V0ZXInLCAnJHRpbWVvdXQnLFxuICAgIGZ1bmN0aW9uICRTdGF0ZVJlZkR5bmFtaWNEaXJlY3RpdmUoJHVpUm91dGVyLCAkdGltZW91dCkge1xuICAgICAgICB2YXIgJHN0YXRlID0gJHVpUm91dGVyLnN0YXRlU2VydmljZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICAgICAgICByZXF1aXJlOiBbJz9edWlTcmVmQWN0aXZlJywgJz9edWlTcmVmQWN0aXZlRXEnXSxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMsIHVpU3JlZkFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZ2V0VHlwZUluZm8oZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2ZSA9IHVpU3JlZkFjdGl2ZVsxXSB8fCB1aVNyZWZBY3RpdmVbMF07XG4gICAgICAgICAgICAgICAgdmFyIHVubGlua0luZm9GbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGhvb2tGbjtcbiAgICAgICAgICAgICAgICB2YXIgcmF3RGVmID0ge307XG4gICAgICAgICAgICAgICAgdmFyIGdldERlZiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb2Nlc3NlZERlZigkc3RhdGUsIGVsZW1lbnQsIHJhd0RlZik7IH07XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0QXR0cnMgPSBbJ3VpU3RhdGUnLCAndWlTdGF0ZVBhcmFtcycsICd1aVN0YXRlT3B0cyddO1xuICAgICAgICAgICAgICAgIHZhciB3YXRjaERlcmVnRm5zID0gaW5wdXRBdHRycy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgYXR0cikgeyByZXR1cm4gKGFjY1thdHRyXSA9IGNvcmUubm9vcCwgYWNjKTsgfSwge30pO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZiA9IGdldERlZigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodW5saW5rSW5mb0ZuKVxuICAgICAgICAgICAgICAgICAgICAgICAgdW5saW5rSW5mb0ZuKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmUpXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmxpbmtJbmZvRm4gPSBhY3RpdmUuJCRhZGRTdGF0ZUluZm8oZGVmLnVpU3RhdGUsIGRlZi51aVN0YXRlUGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi5ocmVmICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRycy4kc2V0KHR5cGUuYXR0ciwgZGVmLmhyZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnB1dEF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhd0RlZltmaWVsZF0gPSBhdHRyc1tmaWVsZF0gPyBzY29wZS4kZXZhbChhdHRyc1tmaWVsZF0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuJG9ic2VydmUoZmllbGQsIGZ1bmN0aW9uIChleHByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXRjaERlcmVnRm5zW2ZpZWxkXSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2hEZXJlZ0Zuc1tmaWVsZF0gPSBzY29wZS4kd2F0Y2goZXhwciwgZnVuY3Rpb24gKG5ld3ZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd0RlZltmaWVsZF0gPSBuZXd2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsICR1aVJvdXRlci5zdGF0ZVJlZ2lzdHJ5Lm9uU3RhdGVzQ2hhbmdlZCh1cGRhdGUpKTtcbiAgICAgICAgICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgJHVpUm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLm9uU3VjY2Vzcyh7fSwgdXBkYXRlKSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlLmNsaWNrYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGhvb2tGbiA9IGNsaWNrSG9vayhlbGVtZW50LCAkc3RhdGUsICR0aW1lb3V0LCB0eXBlLCBnZXREZWYpO1xuICAgICAgICAgICAgICAgIGJpbmRFdmVudHMoZWxlbWVudCwgc2NvcGUsIGhvb2tGbiwgcmF3RGVmLnVpU3RhdGVPcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XTtcbi8qKlxuICogYHVpLXNyZWYtYWN0aXZlYCBhbmQgYHVpLXNyZWYtYWN0aXZlLWVxYDogQSBkaXJlY3RpdmUgdGhhdCBhZGRzIGEgQ1NTIGNsYXNzIHdoZW4gYSBgdWktc3JlZmAgaXMgYWN0aXZlXG4gKlxuICogQSBkaXJlY3RpdmUgd29ya2luZyBhbG9uZ3NpZGUgW1t1aVNyZWZdXSBhbmQgW1t1aVN0YXRlXV0gdG8gYWRkIGNsYXNzZXMgdG8gYW4gZWxlbWVudCB3aGVuIHRoZVxuICogcmVsYXRlZCBkaXJlY3RpdmUncyBzdGF0ZSBpcyBhY3RpdmUgKGFuZCByZW1vdmUgdGhlbSB3aGVuIGl0IGlzIGluYWN0aXZlKS5cbiAqXG4gKiBUaGUgcHJpbWFyeSB1c2UtY2FzZSBpcyB0byBoaWdobGlnaHQgdGhlIGFjdGl2ZSBsaW5rIGluIG5hdmlnYXRpb24gbWVudXMsXG4gKiBkaXN0aW5ndWlzaGluZyBpdCBmcm9tIHRoZSBpbmFjdGl2ZSBtZW51IGl0ZW1zLlxuICpcbiAqICMjIyBMaW5raW5nIHRvIGEgYHVpLXNyZWZgIG9yIGB1aS1zdGF0ZWBcbiAqIGB1aS1zcmVmLWFjdGl2ZWAgY2FuIGxpdmUgb24gdGhlIHNhbWUgZWxlbWVudCBhcyBgdWktc3JlZmAvYHVpLXN0YXRlYCwgb3IgaXQgY2FuIGJlIG9uIGEgcGFyZW50IGVsZW1lbnQuXG4gKiBJZiBhIGB1aS1zcmVmLWFjdGl2ZWAgaXMgYSBwYXJlbnQgdG8gbW9yZSB0aGFuIG9uZSBgdWktc3JlZmAvYHVpLXN0YXRlYCwgaXQgd2lsbCBhcHBseSB0aGUgQ1NTIGNsYXNzIHdoZW4gKiphbnkgb2YgdGhlIGxpbmtzIGFyZSBhY3RpdmUqKi5cbiAqXG4gKiAjIyMgTWF0Y2hpbmdcbiAqXG4gKiBUaGUgYHVpLXNyZWYtYWN0aXZlYCBkaXJlY3RpdmUgYXBwbGllcyB0aGUgQ1NTIGNsYXNzIHdoZW4gdGhlIGB1aS1zcmVmYC9gdWktc3RhdGVgJ3MgdGFyZ2V0IHN0YXRlICoqb3IgYW55IGNoaWxkIHN0YXRlIGlzIGFjdGl2ZSoqLlxuICogVGhpcyBpcyBhIFwiZnV6enkgbWF0Y2hcIiB3aGljaCB1c2VzIFtbU3RhdGVTZXJ2aWNlLmluY2x1ZGVzXV0uXG4gKlxuICogVGhlIGB1aS1zcmVmLWFjdGl2ZS1lcWAgZGlyZWN0aXZlIGFwcGxpZXMgdGhlIENTUyBjbGFzcyB3aGVuIHRoZSBgdWktc3JlZmAvYHVpLXN0YXRlYCdzIHRhcmdldCBzdGF0ZSBpcyBkaXJlY3RseSBhY3RpdmUgKG5vdCB3aGVuIGNoaWxkIHN0YXRlcyBhcmUgYWN0aXZlKS5cbiAqIFRoaXMgaXMgYW4gXCJleGFjdCBtYXRjaFwiIHdoaWNoIHVzZXMgW1tTdGF0ZVNlcnZpY2UuaXNdXS5cbiAqXG4gKiAjIyMgUGFyYW1ldGVyIHZhbHVlc1xuICogSWYgdGhlIGB1aS1zcmVmYC9gdWktc3RhdGVgIGluY2x1ZGVzIHBhcmFtZXRlciB2YWx1ZXMsIHRoZSBjdXJyZW50IHBhcmFtZXRlciB2YWx1ZXMgbXVzdCBtYXRjaCB0aGUgbGluaydzIHZhbHVlcyBmb3IgdGhlIGxpbmsgdG8gYmUgaGlnaGxpZ2h0ZWQuXG4gKiBUaGlzIGFsbG93cyBhIGxpc3Qgb2YgbGlua3MgdG8gdGhlIHNhbWUgc3RhdGUgd2l0aCBkaWZmZXJlbnQgcGFyYW1ldGVycyB0byBiZSByZW5kZXJlZCwgYW5kIHRoZSBjb3JyZWN0IG9uZSBoaWdobGlnaHRlZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8bGkgbmctcmVwZWF0PVwidXNlciBpbiB1c2Vyc1wiIHVpLXNyZWYtYWN0aXZlPVwiYWN0aXZlXCI+XG4gKiAgIDxhIHVpLXNyZWY9XCJ1c2VyLmRldGFpbHMoeyB1c2VySWQ6IHVzZXIuaWQgfSlcIj57eyB1c2VyLmxhc3ROYW1lIH19PC9hPlxuICogPC9saT5cbiAqIGBgYFxuICpcbiAqICMjIyBFeGFtcGxlc1xuICpcbiAqIEdpdmVuIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGU6XG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8dWw+XG4gKiAgIDxsaSB1aS1zcmVmLWFjdGl2ZT1cImFjdGl2ZVwiIGNsYXNzPVwiaXRlbVwiPlxuICogICAgIDxhIGhyZWYgdWktc3JlZj1cImFwcC51c2VyKHt1c2VyOiAnYmlsYm9iYWdnaW5zJ30pXCI+QGJpbGJvYmFnZ2luczwvYT5cbiAqICAgPC9saT5cbiAqIDwvdWw+XG4gKiBgYGBcbiAqXG4gKiBXaGVuIHRoZSBhcHAgc3RhdGUgaXMgYGFwcC51c2VyYCAob3IgYW55IGNoaWxkIHN0YXRlKSxcbiAqIGFuZCBjb250YWlucyB0aGUgc3RhdGUgcGFyYW1ldGVyIFwidXNlclwiIHdpdGggdmFsdWUgXCJiaWxib2JhZ2dpbnNcIixcbiAqIHRoZSByZXN1bHRpbmcgSFRNTCB3aWxsIGFwcGVhciBhcyAobm90ZSB0aGUgJ2FjdGl2ZScgY2xhc3MpOlxuICpcbiAqIGBgYGh0bWxcbiAqIDx1bD5cbiAqICAgPGxpIHVpLXNyZWYtYWN0aXZlPVwiYWN0aXZlXCIgY2xhc3M9XCJpdGVtIGFjdGl2ZVwiPlxuICogICAgIDxhIHVpLXNyZWY9XCJhcHAudXNlcih7dXNlcjogJ2JpbGJvYmFnZ2lucyd9KVwiIGhyZWY9XCIvdXNlcnMvYmlsYm9iYWdnaW5zXCI+QGJpbGJvYmFnZ2luczwvYT5cbiAqICAgPC9saT5cbiAqIDwvdWw+XG4gKiBgYGBcbiAqXG4gKiAjIyMgR2xvYiBtb2RlXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gcGFzcyBgdWktc3JlZi1hY3RpdmVgIGFuIGV4cHJlc3Npb24gdGhhdCBldmFsdWF0ZXMgdG8gYW4gb2JqZWN0LlxuICogVGhlIG9iamVjdHMga2V5cyByZXByZXNlbnQgYWN0aXZlIGNsYXNzIG5hbWVzIGFuZCB2YWx1ZXMgcmVwcmVzZW50IHRoZSByZXNwZWN0aXZlIHN0YXRlIG5hbWVzL2dsb2JzLlxuICogYHVpLXNyZWYtYWN0aXZlYCB3aWxsIG1hdGNoIGlmIHRoZSBjdXJyZW50IGFjdGl2ZSBzdGF0ZSAqKmluY2x1ZGVzKiogYW55IG9mXG4gKiB0aGUgc3BlY2lmaWVkIHN0YXRlIG5hbWVzL2dsb2JzLCBldmVuIHRoZSBhYnN0cmFjdCBvbmVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIEdpdmVuIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUsIHdpdGggXCJhZG1pblwiIGJlaW5nIGFuIGFic3RyYWN0IHN0YXRlOlxuICogYGBgaHRtbFxuICogPGRpdiB1aS1zcmVmLWFjdGl2ZT1cInsnYWN0aXZlJzogJ2FkbWluLioqJ31cIj5cbiAqICAgPGEgdWktc3JlZi1hY3RpdmU9XCJhY3RpdmVcIiB1aS1zcmVmPVwiYWRtaW4ucm9sZXNcIj5Sb2xlczwvYT5cbiAqIDwvZGl2PlxuICogYGBgXG4gKlxuICogV2hlbiB0aGUgY3VycmVudCBzdGF0ZSBpcyBcImFkbWluLnJvbGVzXCIgdGhlIFwiYWN0aXZlXCIgY2xhc3Mgd2lsbCBiZSBhcHBsaWVkIHRvIGJvdGggdGhlIDxkaXY+IGFuZCA8YT4gZWxlbWVudHMuXG4gKiBJdCBpcyBpbXBvcnRhbnQgdG8gbm90ZSB0aGF0IHRoZSBzdGF0ZSBuYW1lcy9nbG9icyBwYXNzZWQgdG8gYHVpLXNyZWYtYWN0aXZlYCBvdmVycmlkZSBhbnkgc3RhdGUgcHJvdmlkZWQgYnkgYSBsaW5rZWQgYHVpLXNyZWZgLlxuICpcbiAqICMjIyBOb3RlczpcbiAqXG4gKiAtIFRoZSBjbGFzcyBuYW1lIGlzIGludGVycG9sYXRlZCAqKm9uY2UqKiBkdXJpbmcgdGhlIGRpcmVjdGl2ZXMgbGluayB0aW1lIChhbnkgZnVydGhlciBjaGFuZ2VzIHRvIHRoZVxuICogaW50ZXJwb2xhdGVkIHZhbHVlIGFyZSBpZ25vcmVkKS5cbiAqXG4gKiAtIE11bHRpcGxlIGNsYXNzZXMgbWF5IGJlIHNwZWNpZmllZCBpbiBhIHNwYWNlLXNlcGFyYXRlZCBmb3JtYXQ6IGB1aS1zcmVmLWFjdGl2ZT0nY2xhc3MxIGNsYXNzMiBjbGFzczMnYFxuICovXG52YXIgdWlTcmVmQWN0aXZlO1xudWlTcmVmQWN0aXZlID0gWyckc3RhdGUnLCAnJHN0YXRlUGFyYW1zJywgJyRpbnRlcnBvbGF0ZScsICckdWlSb3V0ZXInLFxuICAgIGZ1bmN0aW9uICRTdGF0ZVJlZkFjdGl2ZURpcmVjdGl2ZSgkc3RhdGUsICRzdGF0ZVBhcmFtcywgJGludGVycG9sYXRlLCAkdWlSb3V0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiBcIkFcIixcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IFsnJHNjb3BlJywgJyRlbGVtZW50JywgJyRhdHRycycsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCRzY29wZSwgJGVsZW1lbnQsICRhdHRycykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGVzID0gW10sIGFjdGl2ZUVxQ2xhc3MsIHVpU3JlZkFjdGl2ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgcHJvYmFibHkgaXNuJ3QgbXVjaCBwb2ludCBpbiAkb2JzZXJ2aW5nIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gdWlTcmVmQWN0aXZlIGFuZCB1aVNyZWZBY3RpdmVFcSBzaGFyZSB0aGUgc2FtZSBkaXJlY3RpdmUgb2JqZWN0IHdpdGggc29tZVxuICAgICAgICAgICAgICAgICAgICAvLyBzbGlnaHQgZGlmZmVyZW5jZSBpbiBsb2dpYyByb3V0aW5nXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUVxQ2xhc3MgPSAkaW50ZXJwb2xhdGUoJGF0dHJzLnVpU3JlZkFjdGl2ZUVxIHx8ICcnLCBmYWxzZSkoJHNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpU3JlZkFjdGl2ZSA9ICRzY29wZS4kZXZhbCgkYXR0cnMudWlTcmVmQWN0aXZlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZy4gdWlTcmVmQWN0aXZlIGlzIG5vdCBhIHZhbGlkIGV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsIGJhY2sgdG8gdXNpbmcgJGludGVycG9sYXRlIGJlbG93XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdWlTcmVmQWN0aXZlID0gdWlTcmVmQWN0aXZlIHx8ICRpbnRlcnBvbGF0ZSgkYXR0cnMudWlTcmVmQWN0aXZlIHx8ICcnLCBmYWxzZSkoJHNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvcmUuaXNPYmplY3QodWlTcmVmQWN0aXZlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29yZS5mb3JFYWNoKHVpU3JlZkFjdGl2ZSwgZnVuY3Rpb24gKHN0YXRlT3JOYW1lLCBhY3RpdmVDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3JlLmlzU3RyaW5nKHN0YXRlT3JOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVmID0gcGFyc2VTdGF0ZVJlZihzdGF0ZU9yTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFN0YXRlKHJlZi5zdGF0ZSwgJHNjb3BlLiRldmFsKHJlZi5wYXJhbUV4cHIpLCBhY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgdWlTcmVmIHRvIGNvbW11bmljYXRlIHdpdGggdWlTcmVmQWN0aXZlW0VxdWFsc11cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kJGFkZFN0YXRlSW5mbyA9IGZ1bmN0aW9uIChuZXdTdGF0ZSwgbmV3UGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBhbHJlYWR5IGdvdCBhbiBleHBsaWNpdCBzdGF0ZSBwcm92aWRlZCBieSB1aS1zcmVmLWFjdGl2ZSwgc28gd2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNoYWRvdyB0aGUgb25lIHRoYXQgY29tZXMgZnJvbSB1aS1zcmVmXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29yZS5pc09iamVjdCh1aVNyZWZBY3RpdmUpICYmIHN0YXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlcmVnaXN0ZXIgPSBhZGRTdGF0ZShuZXdTdGF0ZSwgbmV3UGFyYW1zLCB1aVNyZWZBY3RpdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVyZWdpc3RlcjtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlQWZ0ZXJUcmFuc2l0aW9uKHRyYW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFucy5wcm9taXNlLnRoZW4odXBkYXRlLCBjb3JlLm5vb3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS4kb24oJyRzdGF0ZUNoYW5nZVN1Y2Nlc3MnLCB1cGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsICR1aVJvdXRlci50cmFuc2l0aW9uU2VydmljZS5vblN0YXJ0KHt9LCB1cGRhdGVBZnRlclRyYW5zaXRpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCR1aVJvdXRlci5nbG9iYWxzLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUFmdGVyVHJhbnNpdGlvbigkdWlSb3V0ZXIuZ2xvYmFscy50cmFuc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBhZGRTdGF0ZShzdGF0ZU5hbWUsIHN0YXRlUGFyYW1zLCBhY3RpdmVDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gJHN0YXRlLmdldChzdGF0ZU5hbWUsIHN0YXRlQ29udGV4dCgkZWxlbWVudCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUgfHwgeyBuYW1lOiBzdGF0ZU5hbWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHN0YXRlUGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUNsYXNzOiBhY3RpdmVDbGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlcy5wdXNoKHN0YXRlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlU3RhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZS5yZW1vdmVGcm9tKHN0YXRlcykoc3RhdGVJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHJvdXRlIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcGxpdENsYXNzZXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0ci5zcGxpdCgvXFxzLykuZmlsdGVyKGNvcmUuaWRlbnRpdHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZXRDbGFzc2VzID0gZnVuY3Rpb24gKHN0YXRlTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZUxpc3QubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmFjdGl2ZUNsYXNzOyB9KS5tYXAoc3BsaXRDbGFzc2VzKS5yZWR1Y2UoY29yZS51bm5lc3RSLCBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFsbENsYXNzZXMgPSBnZXRDbGFzc2VzKHN0YXRlcykuY29uY2F0KHNwbGl0Q2xhc3NlcyhhY3RpdmVFcUNsYXNzKSkucmVkdWNlKGNvcmUudW5pcVIsIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmdXp6eUNsYXNzZXMgPSBnZXRDbGFzc2VzKHN0YXRlcy5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuICRzdGF0ZS5pbmNsdWRlcyh4LnN0YXRlLm5hbWUsIHgucGFyYW1zKTsgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4YWN0bHlNYXRjaGVzQW55ID0gISFzdGF0ZXMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiAkc3RhdGUuaXMoeC5zdGF0ZS5uYW1lLCB4LnBhcmFtcyk7IH0pLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleGFjdENsYXNzZXMgPSBleGFjdGx5TWF0Y2hlc0FueSA/IHNwbGl0Q2xhc3NlcyhhY3RpdmVFcUNsYXNzKSA6IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkZENsYXNzZXMgPSBmdXp6eUNsYXNzZXMuY29uY2F0KGV4YWN0Q2xhc3NlcykucmVkdWNlKGNvcmUudW5pcVIsIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVDbGFzc2VzID0gYWxsQ2xhc3Nlcy5maWx0ZXIoZnVuY3Rpb24gKGNscykgeyByZXR1cm4gIWNvcmUuaW5BcnJheShhZGRDbGFzc2VzLCBjbHMpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS4kZXZhbEFzeW5jKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkgeyByZXR1cm4gJGVsZW1lbnQuYWRkQ2xhc3MoY2xhc3NOYW1lKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHsgcmV0dXJuICRlbGVtZW50LnJlbW92ZUNsYXNzKGNsYXNzTmFtZSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XTtcbm5nLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJylcbiAgICAuZGlyZWN0aXZlKCd1aVNyZWYnLCB1aVNyZWYpXG4gICAgLmRpcmVjdGl2ZSgndWlTcmVmQWN0aXZlJywgdWlTcmVmQWN0aXZlKVxuICAgIC5kaXJlY3RpdmUoJ3VpU3JlZkFjdGl2ZUVxJywgdWlTcmVmQWN0aXZlKVxuICAgIC5kaXJlY3RpdmUoJ3VpU3RhdGUnLCB1aVN0YXRlKTtcblxuLyoqIEBtb2R1bGUgbmcxICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuLyoqXG4gKiBgaXNTdGF0ZWAgRmlsdGVyOiB0cnV0aHkgaWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdGhlIHBhcmFtZXRlclxuICpcbiAqIFRyYW5zbGF0ZXMgdG8gW1tTdGF0ZVNlcnZpY2UuaXNdXSBgJHN0YXRlLmlzKFwic3RhdGVOYW1lXCIpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8ZGl2IG5nLWlmPVwiJ3N0YXRlTmFtZScgfCBpc1N0YXRlXCI+c2hvdyBpZiBzdGF0ZSBpcyAnc3RhdGVOYW1lJzwvZGl2PlxuICogYGBgXG4gKi9cbiRJc1N0YXRlRmlsdGVyLiRpbmplY3QgPSBbJyRzdGF0ZSddO1xuZnVuY3Rpb24gJElzU3RhdGVGaWx0ZXIoJHN0YXRlKSB7XG4gICAgdmFyIGlzRmlsdGVyID0gZnVuY3Rpb24gKHN0YXRlLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICRzdGF0ZS5pcyhzdGF0ZSwgcGFyYW1zLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGlzRmlsdGVyLiRzdGF0ZWZ1bCA9IHRydWU7XG4gICAgcmV0dXJuIGlzRmlsdGVyO1xufVxuLyoqXG4gKiBgaW5jbHVkZWRCeVN0YXRlYCBGaWx0ZXI6IHRydXRoeSBpZiB0aGUgY3VycmVudCBzdGF0ZSBpbmNsdWRlcyB0aGUgcGFyYW1ldGVyXG4gKlxuICogVHJhbnNsYXRlcyB0byBbW1N0YXRlU2VydmljZS5pbmNsdWRlc11dYCAkc3RhdGUuaXMoXCJmdWxsT3JQYXJ0aWFsU3RhdGVOYW1lXCIpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8ZGl2IG5nLWlmPVwiJ2Z1bGxPclBhcnRpYWxTdGF0ZU5hbWUnIHwgaW5jbHVkZWRCeVN0YXRlXCI+c2hvdyBpZiBzdGF0ZSBpbmNsdWRlcyAnZnVsbE9yUGFydGlhbFN0YXRlTmFtZSc8L2Rpdj5cbiAqIGBgYFxuICovXG4kSW5jbHVkZWRCeVN0YXRlRmlsdGVyLiRpbmplY3QgPSBbJyRzdGF0ZSddO1xuZnVuY3Rpb24gJEluY2x1ZGVkQnlTdGF0ZUZpbHRlcigkc3RhdGUpIHtcbiAgICB2YXIgaW5jbHVkZXNGaWx0ZXIgPSBmdW5jdGlvbiAoc3RhdGUsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gJHN0YXRlLmluY2x1ZGVzKHN0YXRlLCBwYXJhbXMsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgaW5jbHVkZXNGaWx0ZXIuJHN0YXRlZnVsID0gdHJ1ZTtcbiAgICByZXR1cm4gaW5jbHVkZXNGaWx0ZXI7XG59XG5uZy5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpXG4gICAgLmZpbHRlcignaXNTdGF0ZScsICRJc1N0YXRlRmlsdGVyKVxuICAgIC5maWx0ZXIoJ2luY2x1ZGVkQnlTdGF0ZScsICRJbmNsdWRlZEJ5U3RhdGVGaWx0ZXIpO1xuXG4vKipcbiAqIEBuZzFhcGlcbiAqIEBtb2R1bGUgZGlyZWN0aXZlc1xuICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuLyoqXG4gKiBgdWktdmlld2A6IEEgdmlld3BvcnQgZGlyZWN0aXZlIHdoaWNoIGlzIGZpbGxlZCBpbiBieSBhIHZpZXcgZnJvbSB0aGUgYWN0aXZlIHN0YXRlLlxuICpcbiAqICMjIyBBdHRyaWJ1dGVzXG4gKlxuICogLSBgbmFtZWA6IChPcHRpb25hbCkgQSB2aWV3IG5hbWUuXG4gKiAgIFRoZSBuYW1lIHNob3VsZCBiZSB1bmlxdWUgYW1vbmdzdCB0aGUgb3RoZXIgdmlld3MgaW4gdGhlIHNhbWUgc3RhdGUuXG4gKiAgIFlvdSBjYW4gaGF2ZSB2aWV3cyBvZiB0aGUgc2FtZSBuYW1lIHRoYXQgbGl2ZSBpbiBkaWZmZXJlbnQgc3RhdGVzLlxuICogICBUaGUgdWktdmlldyBjYW4gYmUgdGFyZ2V0ZWQgaW4gYSBWaWV3IHVzaW5nIHRoZSBuYW1lIChbW05nMVN0YXRlRGVjbGFyYXRpb24udmlld3NdXSkuXG4gKlxuICogLSBgYXV0b3Njcm9sbGA6IGFuIGV4cHJlc3Npb24uIFdoZW4gaXQgZXZhbHVhdGVzIHRvIHRydWUsIHRoZSBgdWktdmlld2Agd2lsbCBiZSBzY3JvbGxlZCBpbnRvIHZpZXcgd2hlbiBpdCBpcyBhY3RpdmF0ZWQuXG4gKiAgIFVzZXMgW1skdWlWaWV3U2Nyb2xsXV0gdG8gZG8gdGhlIHNjcm9sbGluZy5cbiAqXG4gKiAtIGBvbmxvYWRgOiBFeHByZXNzaW9uIHRvIGV2YWx1YXRlIHdoZW5ldmVyIHRoZSB2aWV3IHVwZGF0ZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogQSB2aWV3IGNhbiBiZSB1bm5hbWVkIG9yIG5hbWVkLlxuICogYGBgaHRtbFxuICogPCEtLSBVbm5hbWVkIC0tPlxuICogPGRpdiB1aS12aWV3PjwvZGl2PlxuICpcbiAqIDwhLS0gTmFtZWQgLS0+XG4gKiA8ZGl2IHVpLXZpZXc9XCJ2aWV3TmFtZVwiPjwvZGl2PlxuICpcbiAqIDwhLS0gTmFtZWQgKGRpZmZlcmVudCBzdHlsZSkgLS0+XG4gKiA8dWktdmlldyBuYW1lPVwidmlld05hbWVcIj48L3VpLXZpZXc+XG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIG9ubHkgaGF2ZSBvbmUgdW5uYW1lZCB2aWV3IHdpdGhpbiBhbnkgdGVtcGxhdGUgKG9yIHJvb3QgaHRtbCkuIElmIHlvdSBhcmUgb25seSB1c2luZyBhXG4gKiBzaW5nbGUgdmlldyBhbmQgaXQgaXMgdW5uYW1lZCB0aGVuIHlvdSBjYW4gcG9wdWxhdGUgaXQgbGlrZSBzbzpcbiAqXG4gKiBgYGBodG1sXG4gKiA8ZGl2IHVpLXZpZXc+PC9kaXY+XG4gKiAkc3RhdGVQcm92aWRlci5zdGF0ZShcImhvbWVcIiwge1xuICogICB0ZW1wbGF0ZTogXCI8aDE+SEVMTE8hPC9oMT5cIlxuICogfSlcbiAqIGBgYFxuICpcbiAqIFRoZSBhYm92ZSBpcyBhIGNvbnZlbmllbnQgc2hvcnRjdXQgZXF1aXZhbGVudCB0byBzcGVjaWZ5aW5nIHlvdXIgdmlldyBleHBsaWNpdGx5IHdpdGggdGhlXG4gKiBbW05nMVN0YXRlRGVjbGFyYXRpb24udmlld3NdXSBjb25maWcgcHJvcGVydHksIGJ5IG5hbWUsIGluIHRoaXMgY2FzZSBhbiBlbXB0eSBuYW1lOlxuICpcbiAqIGBgYGpzXG4gKiAkc3RhdGVQcm92aWRlci5zdGF0ZShcImhvbWVcIiwge1xuICogICB2aWV3czoge1xuICogICAgIFwiXCI6IHtcbiAqICAgICAgIHRlbXBsYXRlOiBcIjxoMT5IRUxMTyE8L2gxPlwiXG4gKiAgICAgfVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKlxuICogQnV0IHR5cGljYWxseSB5b3UnbGwgb25seSB1c2UgdGhlIHZpZXdzIHByb3BlcnR5IGlmIHlvdSBuYW1lIHlvdXIgdmlldyBvciBoYXZlIG1vcmUgdGhhbiBvbmUgdmlld1xuICogaW4gdGhlIHNhbWUgdGVtcGxhdGUuIFRoZXJlJ3Mgbm90IHJlYWxseSBhIGNvbXBlbGxpbmcgcmVhc29uIHRvIG5hbWUgYSB2aWV3IGlmIGl0cyB0aGUgb25seSBvbmUsXG4gKiBidXQgeW91IGNvdWxkIGlmIHlvdSB3YW50ZWQsIGxpa2Ugc286XG4gKlxuICogYGBgaHRtbFxuICogPGRpdiB1aS12aWV3PVwibWFpblwiPjwvZGl2PlxuICogYGBgXG4gKlxuICogYGBganNcbiAqICRzdGF0ZVByb3ZpZGVyLnN0YXRlKFwiaG9tZVwiLCB7XG4gKiAgIHZpZXdzOiB7XG4gKiAgICAgXCJtYWluXCI6IHtcbiAqICAgICAgIHRlbXBsYXRlOiBcIjxoMT5IRUxMTyE8L2gxPlwiXG4gKiAgICAgfVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKlxuICogUmVhbGx5IHRob3VnaCwgeW91J2xsIHVzZSB2aWV3cyB0byBzZXQgdXAgbXVsdGlwbGUgdmlld3M6XG4gKlxuICogYGBgaHRtbFxuICogPGRpdiB1aS12aWV3PjwvZGl2PlxuICogPGRpdiB1aS12aWV3PVwiY2hhcnRcIj48L2Rpdj5cbiAqIDxkaXYgdWktdmlldz1cImRhdGFcIj48L2Rpdj5cbiAqIGBgYFxuICpcbiAqIGBgYGpzXG4gKiAkc3RhdGVQcm92aWRlci5zdGF0ZShcImhvbWVcIiwge1xuICogICB2aWV3czoge1xuICogICAgIFwiXCI6IHtcbiAqICAgICAgIHRlbXBsYXRlOiBcIjxoMT5IRUxMTyE8L2gxPlwiXG4gKiAgICAgfSxcbiAqICAgICBcImNoYXJ0XCI6IHtcbiAqICAgICAgIHRlbXBsYXRlOiBcIjxjaGFydF90aGluZy8+XCJcbiAqICAgICB9LFxuICogICAgIFwiZGF0YVwiOiB7XG4gKiAgICAgICB0ZW1wbGF0ZTogXCI8ZGF0YV90aGluZy8+XCJcbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiAjIyMjIEV4YW1wbGVzIGZvciBgYXV0b3Njcm9sbGA6XG4gKiBgYGBodG1sXG4gKiA8IS0tIElmIGF1dG9zY3JvbGwgcHJlc2VudCB3aXRoIG5vIGV4cHJlc3Npb24sXG4gKiAgICAgIHRoZW4gc2Nyb2xsIHVpLXZpZXcgaW50byB2aWV3IC0tPlxuICogPHVpLXZpZXcgYXV0b3Njcm9sbC8+XG4gKlxuICogPCEtLSBJZiBhdXRvc2Nyb2xsIHByZXNlbnQgd2l0aCB2YWxpZCBleHByZXNzaW9uLFxuICogICAgICB0aGVuIHNjcm9sbCB1aS12aWV3IGludG8gdmlldyBpZiBleHByZXNzaW9uIGV2YWx1YXRlcyB0byB0cnVlIC0tPlxuICogPHVpLXZpZXcgYXV0b3Njcm9sbD0ndHJ1ZScvPlxuICogPHVpLXZpZXcgYXV0b3Njcm9sbD0nZmFsc2UnLz5cbiAqIDx1aS12aWV3IGF1dG9zY3JvbGw9J3Njb3BlVmFyaWFibGUnLz5cbiAqIGBgYFxuICpcbiAqIFJlc29sdmUgZGF0YTpcbiAqXG4gKiBUaGUgcmVzb2x2ZWQgZGF0YSBmcm9tIHRoZSBzdGF0ZSdzIGByZXNvbHZlYCBibG9jayBpcyBwbGFjZWQgb24gdGhlIHNjb3BlIGFzIGAkcmVzb2x2ZWAgKHRoaXNcbiAqIGNhbiBiZSBjdXN0b21pemVkIHVzaW5nIFtbTmcxVmlld0RlY2xhcmF0aW9uLnJlc29sdmVBc11dKS4gIFRoaXMgY2FuIGJlIHRoZW4gYWNjZXNzZWQgZnJvbSB0aGUgdGVtcGxhdGUuXG4gKlxuICogTm90ZSB0aGF0IHdoZW4gYGNvbnRyb2xsZXJBc2AgaXMgYmVpbmcgdXNlZCwgYCRyZXNvbHZlYCBpcyBzZXQgb24gdGhlIGNvbnRyb2xsZXIgaW5zdGFuY2UgKmFmdGVyKiB0aGVcbiAqIGNvbnRyb2xsZXIgaXMgaW5zdGFudGlhdGVkLiAgVGhlIGAkb25Jbml0KClgIGhvb2sgY2FuIGJlIHVzZWQgdG8gcGVyZm9ybSBpbml0aWFsaXphdGlvbiBjb2RlIHdoaWNoXG4gKiBkZXBlbmRzIG9uIGAkcmVzb2x2ZWAgZGF0YS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBqc1xuICogJHN0YXRlUHJvdmlkZXIuc3RhdGUoJ2hvbWUnLCB7XG4gKiAgIHRlbXBsYXRlOiAnPG15LWNvbXBvbmVudCB1c2VyPVwiJHJlc29sdmUudXNlclwiPjwvbXktY29tcG9uZW50PicsXG4gKiAgIHJlc29sdmU6IHtcbiAqICAgICB1c2VyOiBmdW5jdGlvbihVc2VyU2VydmljZSkgeyByZXR1cm4gVXNlclNlcnZpY2UuZmV0Y2hVc2VyKCk7IH1cbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqL1xudmFyIHVpVmlldztcbnVpVmlldyA9IFsnJHZpZXcnLCAnJGFuaW1hdGUnLCAnJHVpVmlld1Njcm9sbCcsICckaW50ZXJwb2xhdGUnLCAnJHEnLFxuICAgIGZ1bmN0aW9uICRWaWV3RGlyZWN0aXZlKCR2aWV3LCAkYW5pbWF0ZSwgJHVpVmlld1Njcm9sbCwgJGludGVycG9sYXRlLCAkcSkge1xuICAgICAgICBmdW5jdGlvbiBnZXRSZW5kZXJlcihhdHRycywgc2NvcGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChlbGVtZW50LCB0YXJnZXQsIGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZy52ZXJzaW9uLm1pbm9yID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGFuaW1hdGUuZW50ZXIoZWxlbWVudCwgbnVsbCwgdGFyZ2V0KS50aGVuKGNiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRhbmltYXRlLmVudGVyKGVsZW1lbnQsIG51bGwsIHRhcmdldCwgY2IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsZWF2ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZy52ZXJzaW9uLm1pbm9yID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGFuaW1hdGUubGVhdmUoZWxlbWVudCkudGhlbihjYik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkYW5pbWF0ZS5sZWF2ZShlbGVtZW50LCBjYik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvbmZpZ3NFcXVhbChjb25maWcxLCBjb25maWcyKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnMSA9PT0gY29uZmlnMjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcm9vdERhdGEgPSB7XG4gICAgICAgICAgICAkY2ZnOiB7IHZpZXdEZWNsOiB7ICRjb250ZXh0OiAkdmlldy5fcGx1Z2luYXBpLl9yb290Vmlld0NvbnRleHQoKSB9IH0sXG4gICAgICAgICAgICAkdWlWaWV3OiB7fVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZGlyZWN0aXZlID0ge1xuICAgICAgICAgICAgY291bnQ6IDAsXG4gICAgICAgICAgICByZXN0cmljdDogJ0VDQScsXG4gICAgICAgICAgICB0ZXJtaW5hbDogdHJ1ZSxcbiAgICAgICAgICAgIHByaW9yaXR5OiA0MDAsXG4gICAgICAgICAgICB0cmFuc2NsdWRlOiAnZWxlbWVudCcsXG4gICAgICAgICAgICBjb21waWxlOiBmdW5jdGlvbiAodEVsZW1lbnQsIHRBdHRycywgJHRyYW5zY2x1ZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNjb3BlLCAkZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzRWwsIGN1cnJlbnRFbCwgY3VycmVudFNjb3BlLCB1bnJlZ2lzdGVyLCBvbmxvYWRFeHAgPSBhdHRyc1snb25sb2FkJ10gfHwgJycsIGF1dG9TY3JvbGxFeHAgPSBhdHRyc1snYXV0b3Njcm9sbCddLCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGF0dHJzLCBzY29wZSksIHZpZXdDb25maWcgPSB1bmRlZmluZWQsIGluaGVyaXRlZCA9ICRlbGVtZW50LmluaGVyaXRlZERhdGEoJyR1aVZpZXcnKSB8fCByb290RGF0YSwgbmFtZSA9ICRpbnRlcnBvbGF0ZShhdHRyc1sndWlWaWV3J10gfHwgYXR0cnNbJ25hbWUnXSB8fCAnJykoc2NvcGUpIHx8ICckZGVmYXVsdCc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RpdmVVSVZpZXcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdHlwZTogJ25nMScsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogZGlyZWN0aXZlLmNvdW50KyssXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnFuOiBpbmhlcml0ZWQuJHVpVmlldy5mcW4gPyBpbmhlcml0ZWQuJHVpVmlldy5mcW4gKyBcIi5cIiArIG5hbWUgOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnVXBkYXRlZDogY29uZmlnVXBkYXRlZENhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNyZWF0aW9uQ29udGV4dCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJvbVBhcmVudFRhZ0NvbmZpZyA9IGNvcmUucGFyc2UoJyRjZmcudmlld0RlY2wuJGNvbnRleHQnKShpbmhlcml0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IDx1aS12aWV3IG5hbWU9XCJmb29cIj48dWktdmlldyBuYW1lPVwiYmFyXCI+PC91aS12aWV3PjwvdWktdmlldz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXItdWkvdWktcm91dGVyL2lzc3Vlcy8zMzU1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyb21QYXJlbnRUYWcgPSBjb3JlLnBhcnNlKCckdWlWaWV3LmNyZWF0aW9uQ29udGV4dCcpKGluaGVyaXRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyb21QYXJlbnRUYWdDb25maWcgfHwgZnJvbVBhcmVudFRhZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29yZS50cmFjZS50cmFjZVVJVmlld0V2ZW50KFwiTGlua2luZ1wiLCBhY3RpdmVVSVZpZXcpO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjb25maWdVcGRhdGVkQ2FsbGJhY2soY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnICYmICEoY29uZmlnIGluc3RhbmNlb2YgTmcxVmlld0NvbmZpZykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZ3NFcXVhbCh2aWV3Q29uZmlnLCBjb25maWcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUudHJhY2UudHJhY2VVSVZpZXdDb25maWdVcGRhdGVkKGFjdGl2ZVVJVmlldywgY29uZmlnICYmIGNvbmZpZy52aWV3RGVjbCAmJiBjb25maWcudmlld0RlY2wuJGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlld0NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZpZXcoY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkZWxlbWVudC5kYXRhKCckdWlWaWV3JywgeyAkdWlWaWV3OiBhY3RpdmVVSVZpZXcgfSk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZpZXcoKTtcbiAgICAgICAgICAgICAgICAgICAgdW5yZWdpc3RlciA9ICR2aWV3LnJlZ2lzdGVyVUlWaWV3KGFjdGl2ZVVJVmlldyk7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLiRvbihcIiRkZXN0cm95XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUudHJhY2UudHJhY2VVSVZpZXdFdmVudChcIkRlc3Ryb3lpbmcvVW5yZWdpc3RlcmluZ1wiLCBhY3RpdmVVSVZpZXcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5yZWdpc3RlcigpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY2xlYW51cExhc3RWaWV3KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlLnRyYWNlLnRyYWNlVUlWaWV3RXZlbnQoXCJSZW1vdmluZyAocHJldmlvdXMpIGVsXCIsIHByZXZpb3VzRWwuZGF0YSgnJHVpVmlldycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0VsLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzRWwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUudHJhY2UudHJhY2VVSVZpZXdFdmVudChcIkRlc3Ryb3lpbmcgc2NvcGVcIiwgYWN0aXZlVUlWaWV3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2NvcGUuJGRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2NvcGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRFbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdmlld0RhdGFfMSA9IGN1cnJlbnRFbC5kYXRhKCckdWlWaWV3QW5pbScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUudHJhY2UudHJhY2VVSVZpZXdFdmVudChcIkFuaW1hdGUgb3V0XCIsIF92aWV3RGF0YV8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlci5sZWF2ZShjdXJyZW50RWwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdEYXRhXzEuJCRhbmltTGVhdmUucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0VsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0VsID0gY3VycmVudEVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRFbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlVmlldyhjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdTY29wZSA9IHNjb3BlLiRuZXcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbmltRW50ZXIgPSAkcS5kZWZlcigpLCBhbmltTGVhdmUgPSAkcS5kZWZlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyICR1aVZpZXdEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRjZmc6IGNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdWlWaWV3OiBhY3RpdmVVSVZpZXcsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyICR1aVZpZXdBbmltID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRhbmltRW50ZXI6IGFuaW1FbnRlci5wcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRhbmltTGVhdmU6IGFuaW1MZWF2ZS5wcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQkYW5pbUxlYXZlOiBhbmltTGVhdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBuZ2RvYyBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgdWkucm91dGVyLnN0YXRlLmRpcmVjdGl2ZTp1aS12aWV3IyR2aWV3Q29udGVudExvYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBldmVudE9mIHVpLnJvdXRlci5zdGF0ZS5kaXJlY3RpdmU6dWktdmlld1xuICAgICAgICAgICAgICAgICAgICAgICAgICogQGV2ZW50VHlwZSBlbWl0cyBvbiB1aS12aWV3IGRpcmVjdGl2ZSBzY29wZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogRmlyZWQgb25jZSB0aGUgdmlldyAqKmJlZ2lucyBsb2FkaW5nKiosICpiZWZvcmUqIHRoZSBET00gaXMgcmVuZGVyZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IEV2ZW50IG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3TmFtZSBOYW1lIG9mIHRoZSB2aWV3LlxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTY29wZS4kZW1pdCgnJHZpZXdDb250ZW50TG9hZGluZycsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsb25lZCA9ICR0cmFuc2NsdWRlKG5ld1Njb3BlLCBmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZS5kYXRhKCckdWlWaWV3QW5pbScsICR1aVZpZXdBbmltKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZS5kYXRhKCckdWlWaWV3JywgJHVpVmlld0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLmVudGVyKGNsb25lLCAkZWxlbWVudCwgZnVuY3Rpb24gb25VSVZpZXdFbnRlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbUVudGVyLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTY29wZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29wZS4kZW1pdCgnJHZpZXdDb250ZW50QW5pbWF0aW9uRW5kZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvcmUuaXNEZWZpbmVkKGF1dG9TY3JvbGxFeHApICYmICFhdXRvU2Nyb2xsRXhwIHx8IHNjb3BlLiRldmFsKGF1dG9TY3JvbGxFeHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdWlWaWV3U2Nyb2xsKGNsb25lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFudXBMYXN0VmlldygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RWwgPSBjbG9uZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2NvcGUgPSBuZXdTY29wZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQG5nZG9jIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuZGlyZWN0aXZlOnVpLXZpZXcjJHZpZXdDb250ZW50TG9hZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXZlbnRPZiB1aS5yb3V0ZXIuc3RhdGUuZGlyZWN0aXZlOnVpLXZpZXdcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBldmVudFR5cGUgZW1pdHMgb24gdWktdmlldyBkaXJlY3RpdmUgc2NvcGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogRmlyZWQgb25jZSB0aGUgdmlldyBpcyAqKmxvYWRlZCoqLCAqYWZ0ZXIqIHRoZSBET00gaXMgcmVuZGVyZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IEV2ZW50IG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjb3BlLiRlbWl0KCckdmlld0NvbnRlbnRMb2FkZWQnLCBjb25maWcgfHwgdmlld0NvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2NvcGUuJGV2YWwob25sb2FkRXhwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBkaXJlY3RpdmU7XG4gICAgfV07XG4kVmlld0RpcmVjdGl2ZUZpbGwuJGluamVjdCA9IFsnJGNvbXBpbGUnLCAnJGNvbnRyb2xsZXInLCAnJHRyYW5zaXRpb25zJywgJyR2aWV3JywgJyRxJywgJyR0aW1lb3V0J107XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gJFZpZXdEaXJlY3RpdmVGaWxsKCRjb21waWxlLCAkY29udHJvbGxlciwgJHRyYW5zaXRpb25zLCAkdmlldywgJHEsICR0aW1lb3V0KSB7XG4gICAgdmFyIGdldENvbnRyb2xsZXJBcyA9IGNvcmUucGFyc2UoJ3ZpZXdEZWNsLmNvbnRyb2xsZXJBcycpO1xuICAgIHZhciBnZXRSZXNvbHZlQXMgPSBjb3JlLnBhcnNlKCd2aWV3RGVjbC5yZXNvbHZlQXMnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZXN0cmljdDogJ0VDQScsXG4gICAgICAgIHByaW9yaXR5OiAtNDAwLFxuICAgICAgICBjb21waWxlOiBmdW5jdGlvbiAodEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBpbml0aWFsID0gdEVsZW1lbnQuaHRtbCgpO1xuICAgICAgICAgICAgdEVsZW1lbnQuZW1wdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoc2NvcGUsICRlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSAkZWxlbWVudC5kYXRhKCckdWlWaWV3Jyk7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICRlbGVtZW50Lmh0bWwoaW5pdGlhbCk7XG4gICAgICAgICAgICAgICAgICAgICRjb21waWxlKCRlbGVtZW50LmNvbnRlbnRzKCkpKHNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2ZnID0gZGF0YS4kY2ZnIHx8IHsgdmlld0RlY2w6IHt9LCBnZXRUZW1wbGF0ZTogY29yZS5ub29wIH07XG4gICAgICAgICAgICAgICAgdmFyIHJlc29sdmVDdHggPSBjZmcucGF0aCAmJiBuZXcgY29yZS5SZXNvbHZlQ29udGV4dChjZmcucGF0aCk7XG4gICAgICAgICAgICAgICAgJGVsZW1lbnQuaHRtbChjZmcuZ2V0VGVtcGxhdGUoJGVsZW1lbnQsIHJlc29sdmVDdHgpIHx8IGluaXRpYWwpO1xuICAgICAgICAgICAgICAgIGNvcmUudHJhY2UudHJhY2VVSVZpZXdGaWxsKGRhdGEuJHVpVmlldywgJGVsZW1lbnQuaHRtbCgpKTtcbiAgICAgICAgICAgICAgICB2YXIgbGluayA9ICRjb21waWxlKCRlbGVtZW50LmNvbnRlbnRzKCkpO1xuICAgICAgICAgICAgICAgIHZhciBjb250cm9sbGVyID0gY2ZnLmNvbnRyb2xsZXI7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xsZXJBcyA9IGdldENvbnRyb2xsZXJBcyhjZmcpO1xuICAgICAgICAgICAgICAgIHZhciByZXNvbHZlQXMgPSBnZXRSZXNvbHZlQXMoY2ZnKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxzID0gcmVzb2x2ZUN0eCAmJiBnZXRMb2NhbHMocmVzb2x2ZUN0eCk7XG4gICAgICAgICAgICAgICAgc2NvcGVbcmVzb2x2ZUFzXSA9IGxvY2FscztcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbGxlckluc3RhbmNlID0gJGNvbnRyb2xsZXIoY29udHJvbGxlciwgY29yZS5leHRlbmQoe30sIGxvY2FscywgeyAkc2NvcGU6IHNjb3BlLCAkZWxlbWVudDogJGVsZW1lbnQgfSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlckFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZVtjb250cm9sbGVyQXNdID0gY29udHJvbGxlckluc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVbY29udHJvbGxlckFzXVtyZXNvbHZlQXNdID0gbG9jYWxzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFVzZSAkdmlldyBzZXJ2aWNlIGFzIGEgY2VudHJhbCBwb2ludCBmb3IgcmVnaXN0ZXJpbmcgY29tcG9uZW50LWxldmVsIGhvb2tzXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZW4sIHdoZW4gYSBjb21wb25lbnQgaXMgY3JlYXRlZCwgdGVsbCB0aGUgJHZpZXcgc2VydmljZSwgc28gaXQgY2FuIGludm9rZSBob29rc1xuICAgICAgICAgICAgICAgICAgICAvLyAkdmlldy5jb21wb25lbnRMb2FkZWQoY29udHJvbGxlckluc3RhbmNlLCB7ICRzY29wZTogc2NvcGUsICRlbGVtZW50OiAkZWxlbWVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2NvcGUuJG9uKCckZGVzdHJveScsICgpID0+ICR2aWV3LmNvbXBvbmVudFVubG9hZGVkKGNvbnRyb2xsZXJJbnN0YW5jZSwgeyAkc2NvcGU6IHNjb3BlLCAkZWxlbWVudDogJGVsZW1lbnQgfSkpO1xuICAgICAgICAgICAgICAgICAgICAkZWxlbWVudC5kYXRhKCckbmdDb250cm9sbGVyQ29udHJvbGxlcicsIGNvbnRyb2xsZXJJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICRlbGVtZW50LmNoaWxkcmVuKCkuZGF0YSgnJG5nQ29udHJvbGxlckNvbnRyb2xsZXInLCBjb250cm9sbGVySW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICByZWdpc3RlckNvbnRyb2xsZXJDYWxsYmFja3MoJHEsICR0cmFuc2l0aW9ucywgY29udHJvbGxlckluc3RhbmNlLCBzY29wZSwgY2ZnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIGNvbXBvbmVudCB0byBhcHBlYXIgaW4gdGhlIERPTVxuICAgICAgICAgICAgICAgIGlmIChjb3JlLmlzU3RyaW5nKGNmZy52aWV3RGVjbC5jb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbXBfMSA9IGNmZy52aWV3RGVjbC5jb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZWJvYk5hbWUgPSBjb3JlLmtlYm9iU3RyaW5nKGNtcF8xKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhZ1JlZ2V4cF8xID0gbmV3IFJlZ0V4cChcIl4oeC18ZGF0YS0pP1wiICsga2Vib2JOYW1lICsgXCIkXCIsIFwiaVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdldENvbXBvbmVudENvbnRyb2xsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aXZlRWwgPSBbXS5zbGljZS5jYWxsKCRlbGVtZW50WzBdLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbCAmJiBlbC50YWdOYW1lICYmIHRhZ1JlZ2V4cF8xLmV4ZWMoZWwudGFnTmFtZSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZUVsICYmIG5nLmVsZW1lbnQoZGlyZWN0aXZlRWwpLmRhdGEoXCIkXCIgKyBjbXBfMSArIFwiQ29udHJvbGxlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlcmVnaXN0ZXJXYXRjaF8xID0gc2NvcGUuJHdhdGNoKGdldENvbXBvbmVudENvbnRyb2xsZXIsIGZ1bmN0aW9uIChjdHJsSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3RybEluc3RhbmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyQ29udHJvbGxlckNhbGxiYWNrcygkcSwgJHRyYW5zaXRpb25zLCBjdHJsSW5zdGFuY2UsIHNjb3BlLCBjZmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVyZWdpc3RlcldhdGNoXzEoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpbmsoc2NvcGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vKiogQGhpZGRlbiAqL1xudmFyIGhhc0NvbXBvbmVudEltcGwgPSB0eXBlb2YgbmcubW9kdWxlKCd1aS5yb3V0ZXInKVsnY29tcG9uZW50J10gPT09ICdmdW5jdGlvbic7XG4vKiogQGhpZGRlbiBpbmNyZW1lbnRpbmcgaWQgKi9cbnZhciBfdWlDYW5FeGl0SWQgPSAwO1xuLyoqIEBoaWRkZW4gVE9ETzogbW92ZSB0aGVzZSBjYWxsYmFja3MgdG8gJHZpZXcgYW5kL29yIGAvaG9va3MvY29tcG9uZW50cy50c2Agb3Igc29tZXRoaW5nICovXG5mdW5jdGlvbiByZWdpc3RlckNvbnRyb2xsZXJDYWxsYmFja3MoJHEsICR0cmFuc2l0aW9ucywgY29udHJvbGxlckluc3RhbmNlLCAkc2NvcGUsIGNmZykge1xuICAgIC8vIENhbGwgJG9uSW5pdCgpIEFTQVBcbiAgICBpZiAoY29yZS5pc0Z1bmN0aW9uKGNvbnRyb2xsZXJJbnN0YW5jZS4kb25Jbml0KSAmJiAhKGNmZy52aWV3RGVjbC5jb21wb25lbnQgJiYgaGFzQ29tcG9uZW50SW1wbCkpIHtcbiAgICAgICAgY29udHJvbGxlckluc3RhbmNlLiRvbkluaXQoKTtcbiAgICB9XG4gICAgdmFyIHZpZXdTdGF0ZSA9IGNvcmUudGFpbChjZmcucGF0aCkuc3RhdGUuc2VsZjtcbiAgICB2YXIgaG9va09wdGlvbnMgPSB7IGJpbmQ6IGNvbnRyb2xsZXJJbnN0YW5jZSB9O1xuICAgIC8vIEFkZCBjb21wb25lbnQtbGV2ZWwgaG9vayBmb3Igb25QYXJhbXNDaGFuZ2VcbiAgICBpZiAoY29yZS5pc0Z1bmN0aW9uKGNvbnRyb2xsZXJJbnN0YW5jZS51aU9uUGFyYW1zQ2hhbmdlZCkpIHtcbiAgICAgICAgdmFyIHJlc29sdmVDb250ZXh0ID0gbmV3IGNvcmUuUmVzb2x2ZUNvbnRleHQoY2ZnLnBhdGgpO1xuICAgICAgICB2YXIgdmlld0NyZWF0aW9uVHJhbnNfMSA9IHJlc29sdmVDb250ZXh0LmdldFJlc29sdmFibGUoJyR0cmFuc2l0aW9uJCcpLmRhdGE7XG4gICAgICAgIC8vIEZpcmUgY2FsbGJhY2sgb24gYW55IHN1Y2Nlc3NmdWwgdHJhbnNpdGlvblxuICAgICAgICB2YXIgcGFyYW1zVXBkYXRlZCA9IGZ1bmN0aW9uICgkdHJhbnNpdGlvbiQpIHtcbiAgICAgICAgICAgIC8vIEV4aXQgZWFybHkgaWYgdGhlICR0cmFuc2l0aW9uJCBpcyB0aGUgc2FtZSBhcyB0aGUgdmlldyB3YXMgY3JlYXRlZCB3aXRoaW4uXG4gICAgICAgICAgICAvLyBFeGl0IGVhcmx5IGlmIHRoZSAkdHJhbnNpdGlvbiQgd2lsbCBleGl0IHRoZSBzdGF0ZSB0aGUgdmlldyBpcyBmb3IuXG4gICAgICAgICAgICBpZiAoJHRyYW5zaXRpb24kID09PSB2aWV3Q3JlYXRpb25UcmFuc18xIHx8ICR0cmFuc2l0aW9uJC5leGl0aW5nKCkuaW5kZXhPZih2aWV3U3RhdGUpICE9PSAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgdG9QYXJhbXMgPSAkdHJhbnNpdGlvbiQucGFyYW1zKFwidG9cIik7XG4gICAgICAgICAgICB2YXIgZnJvbVBhcmFtcyA9ICR0cmFuc2l0aW9uJC5wYXJhbXMoXCJmcm9tXCIpO1xuICAgICAgICAgICAgdmFyIHRvU2NoZW1hID0gJHRyYW5zaXRpb24kLnRyZWVDaGFuZ2VzKCkudG8ubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnBhcmFtU2NoZW1hOyB9KS5yZWR1Y2UoY29yZS51bm5lc3RSLCBbXSk7XG4gICAgICAgICAgICB2YXIgZnJvbVNjaGVtYSA9ICR0cmFuc2l0aW9uJC50cmVlQ2hhbmdlcygpLmZyb20ubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnBhcmFtU2NoZW1hOyB9KS5yZWR1Y2UoY29yZS51bm5lc3RSLCBbXSk7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSB0byBwYXJhbXMgdGhhdCBoYXZlIGRpZmZlcmVudCB2YWx1ZXMgdGhhbiB0aGUgZnJvbSBwYXJhbXNcbiAgICAgICAgICAgIHZhciBjaGFuZ2VkVG9QYXJhbXMgPSB0b1NjaGVtYS5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IGZyb21TY2hlbWEuaW5kZXhPZihwYXJhbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkeCA9PT0gLTEgfHwgIWZyb21TY2hlbWFbaWR4XS50eXBlLmVxdWFscyh0b1BhcmFtc1twYXJhbS5pZF0sIGZyb21QYXJhbXNbcGFyYW0uaWRdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gT25seSB0cmlnZ2VyIGNhbGxiYWNrIGlmIGEgdG8gcGFyYW0gaGFzIGNoYW5nZWQgb3IgaXMgbmV3XG4gICAgICAgICAgICBpZiAoY2hhbmdlZFRvUGFyYW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkS2V5c18xID0gY2hhbmdlZFRvUGFyYW1zLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5pZDsgfSk7XG4gICAgICAgICAgICAgICAgLy8gRmlsdGVyIHRoZSBwYXJhbXMgdG8gb25seSBjaGFuZ2VkL25ldyB0byBwYXJhbXMuICBgJHRyYW5zaXRpb24kLnBhcmFtcygpYCBtYXkgYmUgdXNlZCB0byBnZXQgYWxsIHBhcmFtcy5cbiAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWVzID0gY29yZS5maWx0ZXIodG9QYXJhbXMsIGZ1bmN0aW9uICh2YWwkJDEsIGtleSkgeyByZXR1cm4gY2hhbmdlZEtleXNfMS5pbmRleE9mKGtleSkgIT09IC0xOyB9KTtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVySW5zdGFuY2UudWlPblBhcmFtc0NoYW5nZWQobmV3VmFsdWVzLCAkdHJhbnNpdGlvbiQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsICR0cmFuc2l0aW9ucy5vblN1Y2Nlc3Moe30sIHBhcmFtc1VwZGF0ZWQsIGhvb2tPcHRpb25zKSk7XG4gICAgfVxuICAgIC8vIEFkZCBjb21wb25lbnQtbGV2ZWwgaG9vayBmb3IgdWlDYW5FeGl0XG4gICAgaWYgKGNvcmUuaXNGdW5jdGlvbihjb250cm9sbGVySW5zdGFuY2UudWlDYW5FeGl0KSkge1xuICAgICAgICB2YXIgaWRfMSA9IF91aUNhbkV4aXRJZCsrO1xuICAgICAgICB2YXIgY2FjaGVQcm9wXzEgPSAnX3VpQ2FuRXhpdElkcyc7XG4gICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBhIHJlZGlyZWN0IHRyYW5zaXRpb24gYWxyZWFkeSBhbnN3ZXJlZCB0cnV0aHlcbiAgICAgICAgdmFyIHByZXZUcnV0aHlBbnN3ZXJfMSA9IGZ1bmN0aW9uICh0cmFucykge1xuICAgICAgICAgICAgcmV0dXJuICEhdHJhbnMgJiYgKHRyYW5zW2NhY2hlUHJvcF8xXSAmJiB0cmFuc1tjYWNoZVByb3BfMV1baWRfMV0gPT09IHRydWUgfHwgcHJldlRydXRoeUFuc3dlcl8xKHRyYW5zLnJlZGlyZWN0ZWRGcm9tKCkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSWYgYSB1c2VyIGFuc3dlcmVkIHllcywgYnV0IHRoZSB0cmFuc2l0aW9uIHdhcyBsYXRlciByZWRpcmVjdGVkLCBkb24ndCBhbHNvIGFzayBmb3IgdGhlIG5ldyByZWRpcmVjdCB0cmFuc2l0aW9uXG4gICAgICAgIHZhciB3cmFwcGVkSG9vayA9IGZ1bmN0aW9uICh0cmFucykge1xuICAgICAgICAgICAgdmFyIHByb21pc2UsIGlkcyA9IHRyYW5zW2NhY2hlUHJvcF8xXSA9IHRyYW5zW2NhY2hlUHJvcF8xXSB8fCB7fTtcbiAgICAgICAgICAgIGlmICghcHJldlRydXRoeUFuc3dlcl8xKHRyYW5zKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSAkcS53aGVuKGNvbnRyb2xsZXJJbnN0YW5jZS51aUNhbkV4aXQodHJhbnMpKTtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHZhbCQkMSkgeyByZXR1cm4gaWRzW2lkXzFdID0gKHZhbCQkMSAhPT0gZmFsc2UpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY3JpdGVyaWEgPSB7IGV4aXRpbmc6IHZpZXdTdGF0ZS5uYW1lIH07XG4gICAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgJHRyYW5zaXRpb25zLm9uQmVmb3JlKGNyaXRlcmlhLCB3cmFwcGVkSG9vaywgaG9va09wdGlvbnMpKTtcbiAgICB9XG59XG5uZy5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpLmRpcmVjdGl2ZSgndWlWaWV3JywgdWlWaWV3KTtcbm5nLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJykuZGlyZWN0aXZlKCd1aVZpZXcnLCAkVmlld0RpcmVjdGl2ZUZpbGwpO1xuXG4vKiogQG1vZHVsZSBuZzEgKi8gLyoqICovXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gJFZpZXdTY3JvbGxQcm92aWRlcigpIHtcbiAgICB2YXIgdXNlQW5jaG9yU2Nyb2xsID0gZmFsc2U7XG4gICAgdGhpcy51c2VBbmNob3JTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHVzZUFuY2hvclNjcm9sbCA9IHRydWU7XG4gICAgfTtcbiAgICB0aGlzLiRnZXQgPSBbJyRhbmNob3JTY3JvbGwnLCAnJHRpbWVvdXQnLCBmdW5jdGlvbiAoJGFuY2hvclNjcm9sbCwgJHRpbWVvdXQpIHtcbiAgICAgICAgICAgIGlmICh1c2VBbmNob3JTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJGFuY2hvclNjcm9sbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoJGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAkZWxlbWVudFswXS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgICAgIH0sIDAsIGZhbHNlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1dO1xufVxubmcubW9kdWxlKCd1aS5yb3V0ZXIuc3RhdGUnKS5wcm92aWRlcignJHVpVmlld1Njcm9sbCcsICRWaWV3U2Nyb2xsUHJvdmlkZXIpO1xuXG4vKipcbiAqIE1haW4gZW50cnkgcG9pbnQgZm9yIGFuZ3VsYXIgMS54IGJ1aWxkXG4gKiBAbW9kdWxlIG5nMVxuICovIC8qKiAqL1xudmFyIGluZGV4ID0gXCJ1aS5yb3V0ZXJcIjtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gaW5kZXg7XG5leHBvcnRzLmNvcmUgPSBjb3JlO1xuZXhwb3J0cy53YXRjaERpZ2VzdHMgPSB3YXRjaERpZ2VzdHM7XG5leHBvcnRzLmdldExvY2FscyA9IGdldExvY2FscztcbmV4cG9ydHMuZ2V0TmcxVmlld0NvbmZpZ0ZhY3RvcnkgPSBnZXROZzFWaWV3Q29uZmlnRmFjdG9yeTtcbmV4cG9ydHMubmcxVmlld3NCdWlsZGVyID0gbmcxVmlld3NCdWlsZGVyO1xuZXhwb3J0cy5OZzFWaWV3Q29uZmlnID0gTmcxVmlld0NvbmZpZztcbmV4cG9ydHMuU3RhdGVQcm92aWRlciA9IFN0YXRlUHJvdmlkZXI7XG5leHBvcnRzLlVybFJvdXRlclByb3ZpZGVyID0gVXJsUm91dGVyUHJvdmlkZXI7XG5PYmplY3Qua2V5cyhjb3JlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgZXhwb3J0c1trZXldID0gY29yZVtrZXldOyB9KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVpLXJvdXRlci1hbmd1bGFyanMuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2FuZ3VsYXJqcy9yZWxlYXNlL3VpLXJvdXRlci1hbmd1bGFyanMuanNcbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///53\n")},,function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL3N0eWxlL2luZGV4LnNjc3M/OTMwYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2Fzc2V0cy9zdHlsZS9pbmRleC5zY3NzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///55\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Service = function () {\n    Service.$inject = [\"$http\", \"$q\", \"$rootScope\"];\n    function Service($http, $q, $rootScope) {\n        \"ngInject\";\n\n        _classCallCheck(this, Service);\n\n        this._$http = $http;\n        this._$q = $q;\n        this._$rootScope = $rootScope;\n    }\n\n    _createClass(Service, [{\n        key: 'get',\n        value: function get(url, params) {\n            return this._requst.apply(this, ['get'].concat(Array.prototype.slice.call(arguments)));\n        }\n    }, {\n        key: 'post',\n        value: function post(url, data, config) {\n            return this._requst.apply(this, ['post'].concat(Array.prototype.slice.call(arguments)));\n        }\n    }, {\n        key: 'delete',\n        value: function _delete(url, params) {\n            return this._requst.apply(this, ['delete'].concat(Array.prototype.slice.call(arguments)));\n        }\n    }, {\n        key: 'put',\n        value: function put(url, data, config) {\n            return this._requst.apply(this, ['put'].concat(Array.prototype.slice.call(arguments)));\n        }\n\n        /**\n         * API请求函数\n         * @param {*} method \n         * @param {*} url \n         * @param {*} data \n         * @param {*} config \n         */\n\n    }, {\n        key: '_requst',\n        value: function _requst(method, url, data, config) {\n            var deferred = this._$q.defer();\n            var request = void 0;\n            url = \"/api\" + url;\n            // url = env === 'dev' ? \"/m2m\" + url : url;\n            console.log(url);\n            if (method === 'get' || method === 'delete') {\n                request = this._$http[method](url, { params: data });\n            } else {\n                request = this._$http[method](url, data, config);\n            }\n            request.success(function (data) {\n                if (data.resultCode == '200') {\n                    deferred.resolve(data);\n                } else {\n\n                    deferred.reject(data);\n                }\n            }).error(function (data) {\n                deferred.reject(data);\n            });\n\n            return deferred.promise;\n        }\n    }, {\n        key: 'getEvn',\n        value: function getEvn() {\n            return env === 'dev' ? \"/m2m\" : '';\n        }\n\n        /**\n         * For Testing\n         */\n\n    }, {\n        key: 'getMock',\n        value: function getMock(url, params) {\n            return this._requstMock.apply(this, ['get'].concat(Array.prototype.slice.call(arguments)));\n        }\n    }, {\n        key: 'postMock',\n        value: function postMock(url, data, config) {\n            return this._requstMock.apply(this, ['post'].concat(Array.prototype.slice.call(arguments)));\n        }\n    }, {\n        key: '_requstMock',\n        value: function _requstMock(method, url, data, config) {\n            var _this = this;\n\n            var deferred = this._$q.defer();\n            var request = void 0;\n            if (method === 'get' || method === 'delete') {\n                request = this._$http[method](url, { params: data });\n            } else {\n                request = this._$http[method](url, data, config);\n            }\n            request.success(function (data) {\n                if (data.resultCode == '200') {\n                    deferred.resolve(data);\n                } else {\n                    deferred.promise.catch(function (data) {\n                        _this._ctgNotification(data);\n                    });\n                    deferred.reject(data);\n                }\n            }).error(function (data) {\n                deferred.reject(data);\n            });\n\n            return deferred.promise;\n        }\n    }, {\n        key: '_isString',\n        value: function _isString(obj) {\n            return Object.prototype.toString.call(obj) === \"[object String]\";\n        }\n    }]);\n\n    return Service;\n}();\n\nexports.default = Service;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0L3V0aWxzL3F1ZXJ5X2hlbHBlci5zZXJ2aWNlLmpzPzczNjMiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoJGh0dHAsICRxLCAkcm9vdFNjb3BlKSB7XG4gICAgICAgIFwibmdJbmplY3RcIjtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuXyRodHRwID0gJGh0dHA7XG4gICAgICAgIHRoaXMuXyRxID0gJHE7XG4gICAgICAgIHRoaXMuXyRyb290U2NvcGUgPSAkcm9vdFNjb3BlO1xuICAgIH1cblxuICAgIGdldCh1cmwsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVxdXN0KCdnZXQnLCAuLi5hcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHBvc3QodXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVzdCgncG9zdCcsIC4uLmFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgZGVsZXRlKHVybCwgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXF1c3QoJ2RlbGV0ZScsIC4uLmFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcHV0KHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXF1c3QoJ3B1dCcsIC4uLmFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQVBJ6K+35rGC5Ye95pWwXG4gICAgICogQHBhcmFtIHsqfSBtZXRob2QgXG4gICAgICogQHBhcmFtIHsqfSB1cmwgXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFxuICAgICAqIEBwYXJhbSB7Kn0gY29uZmlnIFxuICAgICAqL1xuICAgIF9yZXF1c3QobWV0aG9kLCB1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IHRoaXMuXyRxLmRlZmVyKCk7XG4gICAgICAgIGxldCByZXF1ZXN0O1xuICAgICAgICB1cmwgPSBcIi9hcGlcIiArIHVybDtcbiAgICAgICAgLy8gdXJsID0gZW52ID09PSAnZGV2JyA/IFwiL20ybVwiICsgdXJsIDogdXJsO1xuICAgICAgICBjb25zb2xlLmxvZyh1cmwpO1xuICAgICAgICBpZihtZXRob2QgPT09ICdnZXQnIHx8IG1ldGhvZCA9PT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAgIHJlcXVlc3QgPSB0aGlzLl8kaHR0cFttZXRob2RdKHVybCwgeyBwYXJhbXM6IGRhdGEgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0ID0gdGhpcy5fJGh0dHBbbWV0aG9kXSh1cmwsIGRhdGEsIGNvbmZpZyk7ICBcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0LnN1Y2Nlc3MoZGF0YSA9PiB7XG4gICAgICAgICAgICBpZiAoZGF0YS5yZXN1bHRDb2RlID09ICcyMDAnKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmVycm9yKGRhdGEgPT4ge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGRhdGEpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9XG5cblxuICAgIGdldEV2bigpIHtcbiAgICAgICAgcmV0dXJuIGVudiA9PT0gJ2RldicgPyBcIi9tMm1cIiA6ICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvciBUZXN0aW5nXG4gICAgICovXG4gICAgZ2V0TW9jayh1cmwsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVxdXN0TW9jaygnZ2V0JywgLi4uYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBwb3N0TW9jayh1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVxdXN0TW9jaygncG9zdCcsIC4uLmFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgX3JlcXVzdE1vY2sobWV0aG9kLCB1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IHRoaXMuXyRxLmRlZmVyKCk7XG4gICAgICAgIGxldCByZXF1ZXN0O1xuICAgICAgICBpZihtZXRob2QgPT09ICdnZXQnIHx8IG1ldGhvZCA9PT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAgIHJlcXVlc3QgPSB0aGlzLl8kaHR0cFttZXRob2RdKHVybCwgeyBwYXJhbXM6IGRhdGEgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0ID0gdGhpcy5fJGh0dHBbbWV0aG9kXSh1cmwsIGRhdGEsIGNvbmZpZyk7ICBcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0LnN1Y2Nlc3MoZGF0YSA9PiB7XG4gICAgICAgICAgICBpZiAoZGF0YS5yZXN1bHRDb2RlID09ICcyMDAnKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucHJvbWlzZS5jYXRjaChkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3RnTm90aWZpY2F0aW9uKGRhdGEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuZXJyb3IoZGF0YSA9PiB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZGF0YSk7XG4gICAgICAgIH0pOyBcblxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9XG5cbiAgICBfaXNTdHJpbmcob2JqKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IFN0cmluZ11cIjsgXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTZXJ2aWNlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zY3JpcHQvdXRpbHMvcXVlcnlfaGVscGVyLnNlcnZpY2UuanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQVRBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQWVBO0FBQ0E7QUFDQTtBQWJBOztBQWdCQTtBQUNBO0FBQ0E7QUFkQTs7QUFpQkE7QUFDQTtBQUNBO0FBZkE7O0FBa0JBO0FBQ0E7QUFDQTtBQWhCQTs7Ozs7Ozs7Ozs7QUE0QkE7QUFDQTtBQUNBO0FBbkJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFzQkE7QUFDQTtBQUNBO0FBbkJBOzs7Ozs7O0FBMkJBO0FBQ0E7QUFDQTtBQXRCQTs7QUF5QkE7QUFDQTtBQUNBO0FBdkJBOztBQTBCQTtBQUNBO0FBQ0E7QUF6QkE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7O0FBNkJBO0FBQ0E7QUFDQTtBQTNCQTs7OztBQWdDQTs7O0FBR0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///56\n")},function(module,exports,__webpack_require__){eval('var map = {\n\t"./pages/list_view/list.module.index.js": 105\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) // check for number or string\n\t\tthrow new Error("Cannot find module \'" + req + "\'.");\n\treturn id;\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 57;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0IFxcLm1vZHVsZS5pbmRleC5qcyQ/NWRhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbWFwID0ge1xuXHRcIi4vcGFnZXMvbGlzdF92aWV3L2xpc3QubW9kdWxlLmluZGV4LmpzXCI6IDEwNVxufTtcbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyh3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSk7XG59O1xuZnVuY3Rpb24gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkge1xuXHR2YXIgaWQgPSBtYXBbcmVxXTtcblx0aWYoIShpZCArIDEpKSAvLyBjaGVjayBmb3IgbnVtYmVyIG9yIHN0cmluZ1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIicuXCIpO1xuXHRyZXR1cm4gaWQ7XG59O1xud2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59O1xud2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG53ZWJwYWNrQ29udGV4dC5pZCA9IDU3O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3NjcmlwdCBcXC5tb2R1bGUuaW5kZXguanMkXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///57\n')},function(module,exports,__webpack_require__){eval('var map = {\n\t"./header/header.index.js": 99,\n\t"./nav/nav.index.js": 102\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) // check for number or string\n\t\tthrow new Error("Cannot find module \'" + req + "\'.");\n\treturn id;\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 58;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0L2NvbXBvbmVudHMgXFwuaW5kZXguanMkP2ZhZGMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIG1hcCA9IHtcblx0XCIuL2hlYWRlci9oZWFkZXIuaW5kZXguanNcIjogOTksXG5cdFwiLi9uYXYvbmF2LmluZGV4LmpzXCI6IDEwMlxufTtcbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyh3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSk7XG59O1xuZnVuY3Rpb24gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkge1xuXHR2YXIgaWQgPSBtYXBbcmVxXTtcblx0aWYoIShpZCArIDEpKSAvLyBjaGVjayBmb3IgbnVtYmVyIG9yIHN0cmluZ1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIicuXCIpO1xuXHRyZXR1cm4gaWQ7XG59O1xud2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59O1xud2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG53ZWJwYWNrQ29udGV4dC5pZCA9IDU4O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3NjcmlwdC9jb21wb25lbnRzIFxcLmluZGV4LmpzJFxuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///58\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/** @module hooks */ /** */\nvar transition_1 = __webpack_require__(/*! ../transition/transition */ 18);\nvar router_1 = __webpack_require__(/*! ../router */ 33);\nfunction addCoreResolvables(trans) {\n    trans.addResolvable({ token: router_1.UIRouter, deps: [], resolveFn: function () { return trans.router; }, data: trans.router }, "");\n    trans.addResolvable({ token: transition_1.Transition, deps: [], resolveFn: function () { return trans; }, data: trans }, "");\n    trans.addResolvable({ token: \'$transition$\', deps: [], resolveFn: function () { return trans; }, data: trans }, "");\n    trans.addResolvable({ token: \'$stateParams\', deps: [], resolveFn: function () { return trans.params(); }, data: trans.params() }, "");\n    trans.entering().forEach(function (state) {\n        trans.addResolvable({ token: \'$state$\', deps: [], resolveFn: function () { return state; }, data: state }, state);\n    });\n}\nexports.registerAddCoreResolvables = function (transitionService) {\n    return transitionService.onCreate({}, addCoreResolvables);\n};\n//# sourceMappingURL=coreResolvables.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9jb3JlUmVzb2x2YWJsZXMuanM/N2NiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBAbW9kdWxlIGhvb2tzICovIC8qKiAqL1xudmFyIHRyYW5zaXRpb25fMSA9IHJlcXVpcmUoXCIuLi90cmFuc2l0aW9uL3RyYW5zaXRpb25cIik7XG52YXIgcm91dGVyXzEgPSByZXF1aXJlKFwiLi4vcm91dGVyXCIpO1xuZnVuY3Rpb24gYWRkQ29yZVJlc29sdmFibGVzKHRyYW5zKSB7XG4gICAgdHJhbnMuYWRkUmVzb2x2YWJsZSh7IHRva2VuOiByb3V0ZXJfMS5VSVJvdXRlciwgZGVwczogW10sIHJlc29sdmVGbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJhbnMucm91dGVyOyB9LCBkYXRhOiB0cmFucy5yb3V0ZXIgfSwgXCJcIik7XG4gICAgdHJhbnMuYWRkUmVzb2x2YWJsZSh7IHRva2VuOiB0cmFuc2l0aW9uXzEuVHJhbnNpdGlvbiwgZGVwczogW10sIHJlc29sdmVGbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJhbnM7IH0sIGRhdGE6IHRyYW5zIH0sIFwiXCIpO1xuICAgIHRyYW5zLmFkZFJlc29sdmFibGUoeyB0b2tlbjogJyR0cmFuc2l0aW9uJCcsIGRlcHM6IFtdLCByZXNvbHZlRm46IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zOyB9LCBkYXRhOiB0cmFucyB9LCBcIlwiKTtcbiAgICB0cmFucy5hZGRSZXNvbHZhYmxlKHsgdG9rZW46ICckc3RhdGVQYXJhbXMnLCBkZXBzOiBbXSwgcmVzb2x2ZUZuOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cmFucy5wYXJhbXMoKTsgfSwgZGF0YTogdHJhbnMucGFyYW1zKCkgfSwgXCJcIik7XG4gICAgdHJhbnMuZW50ZXJpbmcoKS5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB0cmFucy5hZGRSZXNvbHZhYmxlKHsgdG9rZW46ICckc3RhdGUkJywgZGVwczogW10sIHJlc29sdmVGbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RhdGU7IH0sIGRhdGE6IHN0YXRlIH0sIHN0YXRlKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucmVnaXN0ZXJBZGRDb3JlUmVzb2x2YWJsZXMgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25DcmVhdGUoe30sIGFkZENvcmVSZXNvbHZhYmxlcyk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29yZVJlc29sdmFibGVzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvY29yZVJlc29sdmFibGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///59\n')},function(module,exports,__webpack_require__){"use strict";eval("\n/** @module hooks */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar trace_1 = __webpack_require__(/*! ../common/trace */ 7);\nvar rejectFactory_1 = __webpack_require__(/*! ../transition/rejectFactory */ 12);\n/**\n * A [[TransitionHookFn]] that skips a transition if it should be ignored\n *\n * This hook is invoked at the end of the onBefore phase.\n *\n * If the transition should be ignored (because no parameter or states changed)\n * then the transition is ignored and not processed.\n */\nfunction ignoredHook(trans) {\n    var ignoredReason = trans._ignoredReason();\n    if (!ignoredReason)\n        return;\n    trace_1.trace.traceTransitionIgnored(trans);\n    var pending = trans.router.globals.transition;\n    // The user clicked a link going back to the *current state* ('A')\n    // However, there is also a pending transition in flight (to 'B')\n    // Abort the transition to 'B' because the user now wants to be back at 'A'.\n    if (ignoredReason === 'SameAsCurrent' && pending) {\n        pending.abort();\n    }\n    return rejectFactory_1.Rejection.ignored().toPromise();\n}\nexports.registerIgnoredTransitionHook = function (transitionService) {\n    return transitionService.onBefore({}, ignoredHook, { priority: -9999 });\n};\n//# sourceMappingURL=ignoredTransition.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9pZ25vcmVkVHJhbnNpdGlvbi5qcz9jMzgzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqIEBtb2R1bGUgaG9va3MgKi8gLyoqICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHJhY2VfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vdHJhY2VcIik7XG52YXIgcmVqZWN0RmFjdG9yeV8xID0gcmVxdWlyZShcIi4uL3RyYW5zaXRpb24vcmVqZWN0RmFjdG9yeVwiKTtcbi8qKlxuICogQSBbW1RyYW5zaXRpb25Ib29rRm5dXSB0aGF0IHNraXBzIGEgdHJhbnNpdGlvbiBpZiBpdCBzaG91bGQgYmUgaWdub3JlZFxuICpcbiAqIFRoaXMgaG9vayBpcyBpbnZva2VkIGF0IHRoZSBlbmQgb2YgdGhlIG9uQmVmb3JlIHBoYXNlLlxuICpcbiAqIElmIHRoZSB0cmFuc2l0aW9uIHNob3VsZCBiZSBpZ25vcmVkIChiZWNhdXNlIG5vIHBhcmFtZXRlciBvciBzdGF0ZXMgY2hhbmdlZClcbiAqIHRoZW4gdGhlIHRyYW5zaXRpb24gaXMgaWdub3JlZCBhbmQgbm90IHByb2Nlc3NlZC5cbiAqL1xuZnVuY3Rpb24gaWdub3JlZEhvb2sodHJhbnMpIHtcbiAgICB2YXIgaWdub3JlZFJlYXNvbiA9IHRyYW5zLl9pZ25vcmVkUmVhc29uKCk7XG4gICAgaWYgKCFpZ25vcmVkUmVhc29uKVxuICAgICAgICByZXR1cm47XG4gICAgdHJhY2VfMS50cmFjZS50cmFjZVRyYW5zaXRpb25JZ25vcmVkKHRyYW5zKTtcbiAgICB2YXIgcGVuZGluZyA9IHRyYW5zLnJvdXRlci5nbG9iYWxzLnRyYW5zaXRpb247XG4gICAgLy8gVGhlIHVzZXIgY2xpY2tlZCBhIGxpbmsgZ29pbmcgYmFjayB0byB0aGUgKmN1cnJlbnQgc3RhdGUqICgnQScpXG4gICAgLy8gSG93ZXZlciwgdGhlcmUgaXMgYWxzbyBhIHBlbmRpbmcgdHJhbnNpdGlvbiBpbiBmbGlnaHQgKHRvICdCJylcbiAgICAvLyBBYm9ydCB0aGUgdHJhbnNpdGlvbiB0byAnQicgYmVjYXVzZSB0aGUgdXNlciBub3cgd2FudHMgdG8gYmUgYmFjayBhdCAnQScuXG4gICAgaWYgKGlnbm9yZWRSZWFzb24gPT09ICdTYW1lQXNDdXJyZW50JyAmJiBwZW5kaW5nKSB7XG4gICAgICAgIHBlbmRpbmcuYWJvcnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24uaWdub3JlZCgpLnRvUHJvbWlzZSgpO1xufVxuZXhwb3J0cy5yZWdpc3Rlcklnbm9yZWRUcmFuc2l0aW9uSG9vayA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uU2VydmljZSkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uU2VydmljZS5vbkJlZm9yZSh7fSwgaWdub3JlZEhvb2ssIHsgcHJpb3JpdHk6IC05OTk5IH0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlnbm9yZWRUcmFuc2l0aW9uLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvaWdub3JlZFRyYW5zaXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///60\n")},function(module,exports,__webpack_require__){"use strict";eval('\n/** @module hooks */ /** */\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * A [[TransitionHookFn]] that rejects the Transition if it is invalid\n *\n * This hook is invoked at the end of the onBefore phase.\n * If the transition is invalid (for example, param values do not validate)\n * then the transition is rejected.\n */\nfunction invalidTransitionHook(trans) {\n    if (!trans.valid()) {\n        throw new Error(trans.error());\n    }\n}\nexports.registerInvalidTransitionHook = function (transitionService) {\n    return transitionService.onBefore({}, invalidTransitionHook, { priority: -10000 });\n};\n//# sourceMappingURL=invalidTransition.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9pbnZhbGlkVHJhbnNpdGlvbi5qcz9lZDc3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqIEBtb2R1bGUgaG9va3MgKi8gLyoqICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gdGhhdCByZWplY3RzIHRoZSBUcmFuc2l0aW9uIGlmIGl0IGlzIGludmFsaWRcbiAqXG4gKiBUaGlzIGhvb2sgaXMgaW52b2tlZCBhdCB0aGUgZW5kIG9mIHRoZSBvbkJlZm9yZSBwaGFzZS5cbiAqIElmIHRoZSB0cmFuc2l0aW9uIGlzIGludmFsaWQgKGZvciBleGFtcGxlLCBwYXJhbSB2YWx1ZXMgZG8gbm90IHZhbGlkYXRlKVxuICogdGhlbiB0aGUgdHJhbnNpdGlvbiBpcyByZWplY3RlZC5cbiAqL1xuZnVuY3Rpb24gaW52YWxpZFRyYW5zaXRpb25Ib29rKHRyYW5zKSB7XG4gICAgaWYgKCF0cmFucy52YWxpZCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0cmFucy5lcnJvcigpKTtcbiAgICB9XG59XG5leHBvcnRzLnJlZ2lzdGVySW52YWxpZFRyYW5zaXRpb25Ib29rID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uQmVmb3JlKHt9LCBpbnZhbGlkVHJhbnNpdGlvbkhvb2ssIHsgcHJpb3JpdHk6IC0xMDAwMCB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnZhbGlkVHJhbnNpdGlvbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL2ludmFsaWRUcmFuc2l0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///61\n')},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A factory which creates an onEnter, onExit or onRetain transition hook function\n *\n * The returned function invokes the (for instance) state.onEnter hook when the\n * state is being entered.\n *\n * @hidden\n */\nfunction makeEnterExitRetainHook(hookName) {\n    return function (transition, state) {\n        var _state = state.$$state();\n        var hookFn = _state[hookName];\n        return hookFn(transition, state);\n    };\n}\n/**\n * The [[TransitionStateHookFn]] for onExit\n *\n * When the state is being exited, the state's .onExit function is invoked.\n *\n * Registered using `transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);`\n *\n * See: [[IHookRegistry.onExit]]\n */\nvar onExitHook = makeEnterExitRetainHook('onExit');\nexports.registerOnExitHook = function (transitionService) {\n    return transitionService.onExit({ exiting: function (state) { return !!state.onExit; } }, onExitHook);\n};\n/**\n * The [[TransitionStateHookFn]] for onRetain\n *\n * When the state was already entered, and is not being exited or re-entered, the state's .onRetain function is invoked.\n *\n * Registered using `transitionService.onRetain({ retained: (state) => !!state.onRetain }, onRetainHook);`\n *\n * See: [[IHookRegistry.onRetain]]\n */\nvar onRetainHook = makeEnterExitRetainHook('onRetain');\nexports.registerOnRetainHook = function (transitionService) {\n    return transitionService.onRetain({ retained: function (state) { return !!state.onRetain; } }, onRetainHook);\n};\n/**\n * The [[TransitionStateHookFn]] for onEnter\n *\n * When the state is being entered, the state's .onEnter function is invoked.\n *\n * Registered using `transitionService.onEnter({ entering: (state) => !!state.onEnter }, onEnterHook);`\n *\n * See: [[IHookRegistry.onEnter]]\n */\nvar onEnterHook = makeEnterExitRetainHook('onEnter');\nexports.registerOnEnterHook = function (transitionService) {\n    return transitionService.onEnter({ entering: function (state) { return !!state.onEnter; } }, onEnterHook);\n};\n//# sourceMappingURL=onEnterExitRetain.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9vbkVudGVyRXhpdFJldGFpbi5qcz85ODNkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBBIGZhY3Rvcnkgd2hpY2ggY3JlYXRlcyBhbiBvbkVudGVyLCBvbkV4aXQgb3Igb25SZXRhaW4gdHJhbnNpdGlvbiBob29rIGZ1bmN0aW9uXG4gKlxuICogVGhlIHJldHVybmVkIGZ1bmN0aW9uIGludm9rZXMgdGhlIChmb3IgaW5zdGFuY2UpIHN0YXRlLm9uRW50ZXIgaG9vayB3aGVuIHRoZVxuICogc3RhdGUgaXMgYmVpbmcgZW50ZXJlZC5cbiAqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIG1ha2VFbnRlckV4aXRSZXRhaW5Ib29rKGhvb2tOYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0cmFuc2l0aW9uLCBzdGF0ZSkge1xuICAgICAgICB2YXIgX3N0YXRlID0gc3RhdGUuJCRzdGF0ZSgpO1xuICAgICAgICB2YXIgaG9va0ZuID0gX3N0YXRlW2hvb2tOYW1lXTtcbiAgICAgICAgcmV0dXJuIGhvb2tGbih0cmFuc2l0aW9uLCBzdGF0ZSk7XG4gICAgfTtcbn1cbi8qKlxuICogVGhlIFtbVHJhbnNpdGlvblN0YXRlSG9va0ZuXV0gZm9yIG9uRXhpdFxuICpcbiAqIFdoZW4gdGhlIHN0YXRlIGlzIGJlaW5nIGV4aXRlZCwgdGhlIHN0YXRlJ3MgLm9uRXhpdCBmdW5jdGlvbiBpcyBpbnZva2VkLlxuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uRXhpdCh7IGV4aXRpbmc6IChzdGF0ZSkgPT4gISFzdGF0ZS5vbkV4aXQgfSwgb25FeGl0SG9vayk7YFxuICpcbiAqIFNlZTogW1tJSG9va1JlZ2lzdHJ5Lm9uRXhpdF1dXG4gKi9cbnZhciBvbkV4aXRIb29rID0gbWFrZUVudGVyRXhpdFJldGFpbkhvb2soJ29uRXhpdCcpO1xuZXhwb3J0cy5yZWdpc3Rlck9uRXhpdEhvb2sgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25FeGl0KHsgZXhpdGluZzogZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiAhIXN0YXRlLm9uRXhpdDsgfSB9LCBvbkV4aXRIb29rKTtcbn07XG4vKipcbiAqIFRoZSBbW1RyYW5zaXRpb25TdGF0ZUhvb2tGbl1dIGZvciBvblJldGFpblxuICpcbiAqIFdoZW4gdGhlIHN0YXRlIHdhcyBhbHJlYWR5IGVudGVyZWQsIGFuZCBpcyBub3QgYmVpbmcgZXhpdGVkIG9yIHJlLWVudGVyZWQsIHRoZSBzdGF0ZSdzIC5vblJldGFpbiBmdW5jdGlvbiBpcyBpbnZva2VkLlxuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uUmV0YWluKHsgcmV0YWluZWQ6IChzdGF0ZSkgPT4gISFzdGF0ZS5vblJldGFpbiB9LCBvblJldGFpbkhvb2spO2BcbiAqXG4gKiBTZWU6IFtbSUhvb2tSZWdpc3RyeS5vblJldGFpbl1dXG4gKi9cbnZhciBvblJldGFpbkhvb2sgPSBtYWtlRW50ZXJFeGl0UmV0YWluSG9vaygnb25SZXRhaW4nKTtcbmV4cG9ydHMucmVnaXN0ZXJPblJldGFpbkhvb2sgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25SZXRhaW4oeyByZXRhaW5lZDogZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiAhIXN0YXRlLm9uUmV0YWluOyB9IH0sIG9uUmV0YWluSG9vayk7XG59O1xuLyoqXG4gKiBUaGUgW1tUcmFuc2l0aW9uU3RhdGVIb29rRm5dXSBmb3Igb25FbnRlclxuICpcbiAqIFdoZW4gdGhlIHN0YXRlIGlzIGJlaW5nIGVudGVyZWQsIHRoZSBzdGF0ZSdzIC5vbkVudGVyIGZ1bmN0aW9uIGlzIGludm9rZWQuXG4gKlxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25FbnRlcih7IGVudGVyaW5nOiAoc3RhdGUpID0+ICEhc3RhdGUub25FbnRlciB9LCBvbkVudGVySG9vayk7YFxuICpcbiAqIFNlZTogW1tJSG9va1JlZ2lzdHJ5Lm9uRW50ZXJdXVxuICovXG52YXIgb25FbnRlckhvb2sgPSBtYWtlRW50ZXJFeGl0UmV0YWluSG9vaygnb25FbnRlcicpO1xuZXhwb3J0cy5yZWdpc3Rlck9uRW50ZXJIb29rID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uRW50ZXIoeyBlbnRlcmluZzogZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiAhIXN0YXRlLm9uRW50ZXI7IH0gfSwgb25FbnRlckhvb2spO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uRW50ZXJFeGl0UmV0YWluLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3Mvb25FbnRlckV4aXRSZXRhaW4uanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///62\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module hooks */ /** */\nvar predicates_1 = __webpack_require__(/*! ../common/predicates */ 1);\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ 3);\nvar targetState_1 = __webpack_require__(/*! ../state/targetState */ 9);\n/**\n * A [[TransitionHookFn]] that redirects to a different state or params\n *\n * Registered using `transitionService.onStart({ to: (state) => !!state.redirectTo }, redirectHook);`\n *\n * See [[StateDeclaration.redirectTo]]\n */\nvar redirectToHook = function (trans) {\n    var redirect = trans.to().redirectTo;\n    if (!redirect)\n        return;\n    var $state = trans.router.stateService;\n    function handleResult(result) {\n        if (!result)\n            return;\n        if (result instanceof targetState_1.TargetState)\n            return result;\n        if (predicates_1.isString(result))\n            return $state.target(result, trans.params(), trans.options());\n        if (result['state'] || result['params'])\n            return $state.target(result['state'] || trans.to(), result['params'] || trans.params(), trans.options());\n    }\n    if (predicates_1.isFunction(redirect)) {\n        return coreservices_1.services.$q.when(redirect(trans)).then(handleResult);\n    }\n    return handleResult(redirect);\n};\nexports.registerRedirectToHook = function (transitionService) {\n    return transitionService.onStart({ to: function (state) { return !!state.redirectTo; } }, redirectToHook);\n};\n//# sourceMappingURL=redirectTo.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9yZWRpcmVjdFRvLmpzPzE2NjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogQG1vZHVsZSBob29rcyAqLyAvKiogKi9cbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgY29yZXNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvcmVzZXJ2aWNlc1wiKTtcbnZhciB0YXJnZXRTdGF0ZV8xID0gcmVxdWlyZShcIi4uL3N0YXRlL3RhcmdldFN0YXRlXCIpO1xuLyoqXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHRoYXQgcmVkaXJlY3RzIHRvIGEgZGlmZmVyZW50IHN0YXRlIG9yIHBhcmFtc1xuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uU3RhcnQoeyB0bzogKHN0YXRlKSA9PiAhIXN0YXRlLnJlZGlyZWN0VG8gfSwgcmVkaXJlY3RIb29rKTtgXG4gKlxuICogU2VlIFtbU3RhdGVEZWNsYXJhdGlvbi5yZWRpcmVjdFRvXV1cbiAqL1xudmFyIHJlZGlyZWN0VG9Ib29rID0gZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgdmFyIHJlZGlyZWN0ID0gdHJhbnMudG8oKS5yZWRpcmVjdFRvO1xuICAgIGlmICghcmVkaXJlY3QpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgJHN0YXRlID0gdHJhbnMucm91dGVyLnN0YXRlU2VydmljZTtcbiAgICBmdW5jdGlvbiBoYW5kbGVSZXN1bHQocmVzdWx0KSB7XG4gICAgICAgIGlmICghcmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgdGFyZ2V0U3RhdGVfMS5UYXJnZXRTdGF0ZSlcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcocmVzdWx0KSlcbiAgICAgICAgICAgIHJldHVybiAkc3RhdGUudGFyZ2V0KHJlc3VsdCwgdHJhbnMucGFyYW1zKCksIHRyYW5zLm9wdGlvbnMoKSk7XG4gICAgICAgIGlmIChyZXN1bHRbJ3N0YXRlJ10gfHwgcmVzdWx0WydwYXJhbXMnXSlcbiAgICAgICAgICAgIHJldHVybiAkc3RhdGUudGFyZ2V0KHJlc3VsdFsnc3RhdGUnXSB8fCB0cmFucy50bygpLCByZXN1bHRbJ3BhcmFtcyddIHx8IHRyYW5zLnBhcmFtcygpLCB0cmFucy5vcHRpb25zKCkpO1xuICAgIH1cbiAgICBpZiAocHJlZGljYXRlc18xLmlzRnVuY3Rpb24ocmVkaXJlY3QpKSB7XG4gICAgICAgIHJldHVybiBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS53aGVuKHJlZGlyZWN0KHRyYW5zKSkudGhlbihoYW5kbGVSZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlUmVzdWx0KHJlZGlyZWN0KTtcbn07XG5leHBvcnRzLnJlZ2lzdGVyUmVkaXJlY3RUb0hvb2sgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25TdGFydCh7IHRvOiBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuICEhc3RhdGUucmVkaXJlY3RUbzsgfSB9LCByZWRpcmVjdFRvSG9vayk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkaXJlY3RUby5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL3JlZGlyZWN0VG8uanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///63\n")},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/** @module hooks */\n/** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar resolveContext_1 = __webpack_require__(/*! ../resolve/resolveContext */ 17);\nvar hof_1 = __webpack_require__(/*! ../common/hof */ 2);\n/**\n * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path\n *\n * Registered using `transitionService.onStart({}, eagerResolvePath);`\n *\n * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nvar eagerResolvePath = function (trans) {\n    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n        .resolvePath("EAGER", trans)\n        .then(common_1.noop);\n};\nexports.registerEagerResolvePath = function (transitionService) {\n    return transitionService.onStart({}, eagerResolvePath, { priority: 1000 });\n};\n/**\n * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path\n *\n * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState);`\n *\n * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nvar lazyResolveState = function (trans, state) {\n    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n        .subContext(state.$$state())\n        .resolvePath("LAZY", trans)\n        .then(common_1.noop);\n};\nexports.registerLazyResolveState = function (transitionService) {\n    return transitionService.onEnter({ entering: hof_1.val(true) }, lazyResolveState, { priority: 1000 });\n};\n//# sourceMappingURL=resolve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9yZXNvbHZlLmpzPzUyYTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogQG1vZHVsZSBob29rcyAqL1xuLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciByZXNvbHZlQ29udGV4dF8xID0gcmVxdWlyZShcIi4uL3Jlc29sdmUvcmVzb2x2ZUNvbnRleHRcIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbi8qKlxuICogQSBbW1RyYW5zaXRpb25Ib29rRm5dXSB3aGljaCByZXNvbHZlcyBhbGwgRUFHRVIgUmVzb2x2YWJsZXMgaW4gdGhlIFRvIFBhdGhcbiAqXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vblN0YXJ0KHt9LCBlYWdlclJlc29sdmVQYXRoKTtgXG4gKlxuICogV2hlbiBhIFRyYW5zaXRpb24gc3RhcnRzLCB0aGlzIGhvb2sgcmVzb2x2ZXMgYWxsIHRoZSBFQUdFUiBSZXNvbHZhYmxlcywgd2hpY2ggdGhlIHRyYW5zaXRpb24gdGhlbiB3YWl0cyBmb3IuXG4gKlxuICogU2VlIFtbU3RhdGVEZWNsYXJhdGlvbi5yZXNvbHZlXV1cbiAqL1xudmFyIGVhZ2VyUmVzb2x2ZVBhdGggPSBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICByZXR1cm4gbmV3IHJlc29sdmVDb250ZXh0XzEuUmVzb2x2ZUNvbnRleHQodHJhbnMudHJlZUNoYW5nZXMoKS50bylcbiAgICAgICAgLnJlc29sdmVQYXRoKFwiRUFHRVJcIiwgdHJhbnMpXG4gICAgICAgIC50aGVuKGNvbW1vbl8xLm5vb3ApO1xufTtcbmV4cG9ydHMucmVnaXN0ZXJFYWdlclJlc29sdmVQYXRoID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uU3RhcnQoe30sIGVhZ2VyUmVzb2x2ZVBhdGgsIHsgcHJpb3JpdHk6IDEwMDAgfSk7XG59O1xuLyoqXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHdoaWNoIHJlc29sdmVzIGFsbCBMQVpZIFJlc29sdmFibGVzIGZvciB0aGUgc3RhdGUgKGFuZCBhbGwgaXRzIGFuY2VzdG9ycykgaW4gdGhlIFRvIFBhdGhcbiAqXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vbkVudGVyKHsgZW50ZXJpbmc6ICgpID0+IHRydWUgfSwgbGF6eVJlc29sdmVTdGF0ZSk7YFxuICpcbiAqIFdoZW4gYSBTdGF0ZSBpcyBiZWluZyBlbnRlcmVkLCB0aGlzIGhvb2sgcmVzb2x2ZXMgYWxsIHRoZSBSZXNvbHZhYmxlcyBmb3IgdGhpcyBzdGF0ZSwgd2hpY2ggdGhlIHRyYW5zaXRpb24gdGhlbiB3YWl0cyBmb3IuXG4gKlxuICogU2VlIFtbU3RhdGVEZWNsYXJhdGlvbi5yZXNvbHZlXV1cbiAqL1xudmFyIGxhenlSZXNvbHZlU3RhdGUgPSBmdW5jdGlvbiAodHJhbnMsIHN0YXRlKSB7XG4gICAgcmV0dXJuIG5ldyByZXNvbHZlQ29udGV4dF8xLlJlc29sdmVDb250ZXh0KHRyYW5zLnRyZWVDaGFuZ2VzKCkudG8pXG4gICAgICAgIC5zdWJDb250ZXh0KHN0YXRlLiQkc3RhdGUoKSlcbiAgICAgICAgLnJlc29sdmVQYXRoKFwiTEFaWVwiLCB0cmFucylcbiAgICAgICAgLnRoZW4oY29tbW9uXzEubm9vcCk7XG59O1xuZXhwb3J0cy5yZWdpc3RlckxhenlSZXNvbHZlU3RhdGUgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25FbnRlcih7IGVudGVyaW5nOiBob2ZfMS52YWwodHJ1ZSkgfSwgbGF6eVJlc29sdmVTdGF0ZSwgeyBwcmlvcml0eTogMTAwMCB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvcmVzb2x2ZS5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///64\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\n/**\n * A [[TransitionHookFn]] which updates global UI-Router state\n *\n * Registered using `transitionService.onBefore({}, updateGlobalState);`\n *\n * Before a [[Transition]] starts, updates the global value of "the current transition" ([[Globals.transition]]).\n * After a successful [[Transition]], updates the global values of "the current state"\n * ([[Globals.current]] and [[Globals.$current]]) and "the current param values" ([[Globals.params]]).\n *\n * See also the deprecated properties:\n * [[StateService.transition]], [[StateService.current]], [[StateService.params]]\n */\nvar updateGlobalState = function (trans) {\n    var globals = trans.router.globals;\n    var transitionSuccessful = function () {\n        globals.successfulTransitions.enqueue(trans);\n        globals.$current = trans.$to();\n        globals.current = globals.$current.self;\n        common_1.copy(trans.params(), globals.params);\n    };\n    var clearCurrentTransition = function () {\n        // Do not clear globals.transition if a different transition has started in the meantime\n        if (globals.transition === trans)\n            globals.transition = null;\n    };\n    trans.onSuccess({}, transitionSuccessful, { priority: 10000 });\n    trans.promise.then(clearCurrentTransition, clearCurrentTransition);\n};\nexports.registerUpdateGlobalState = function (transitionService) {\n    return transitionService.onCreate({}, updateGlobalState);\n};\n//# sourceMappingURL=updateGlobals.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy91cGRhdGVHbG9iYWxzLmpzPzhlNzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbi8qKlxuICogQSBbW1RyYW5zaXRpb25Ib29rRm5dXSB3aGljaCB1cGRhdGVzIGdsb2JhbCBVSS1Sb3V0ZXIgc3RhdGVcbiAqXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vbkJlZm9yZSh7fSwgdXBkYXRlR2xvYmFsU3RhdGUpO2BcbiAqXG4gKiBCZWZvcmUgYSBbW1RyYW5zaXRpb25dXSBzdGFydHMsIHVwZGF0ZXMgdGhlIGdsb2JhbCB2YWx1ZSBvZiBcInRoZSBjdXJyZW50IHRyYW5zaXRpb25cIiAoW1tHbG9iYWxzLnRyYW5zaXRpb25dXSkuXG4gKiBBZnRlciBhIHN1Y2Nlc3NmdWwgW1tUcmFuc2l0aW9uXV0sIHVwZGF0ZXMgdGhlIGdsb2JhbCB2YWx1ZXMgb2YgXCJ0aGUgY3VycmVudCBzdGF0ZVwiXG4gKiAoW1tHbG9iYWxzLmN1cnJlbnRdXSBhbmQgW1tHbG9iYWxzLiRjdXJyZW50XV0pIGFuZCBcInRoZSBjdXJyZW50IHBhcmFtIHZhbHVlc1wiIChbW0dsb2JhbHMucGFyYW1zXV0pLlxuICpcbiAqIFNlZSBhbHNvIHRoZSBkZXByZWNhdGVkIHByb3BlcnRpZXM6XG4gKiBbW1N0YXRlU2VydmljZS50cmFuc2l0aW9uXV0sIFtbU3RhdGVTZXJ2aWNlLmN1cnJlbnRdXSwgW1tTdGF0ZVNlcnZpY2UucGFyYW1zXV1cbiAqL1xudmFyIHVwZGF0ZUdsb2JhbFN0YXRlID0gZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgdmFyIGdsb2JhbHMgPSB0cmFucy5yb3V0ZXIuZ2xvYmFscztcbiAgICB2YXIgdHJhbnNpdGlvblN1Y2Nlc3NmdWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGdsb2JhbHMuc3VjY2Vzc2Z1bFRyYW5zaXRpb25zLmVucXVldWUodHJhbnMpO1xuICAgICAgICBnbG9iYWxzLiRjdXJyZW50ID0gdHJhbnMuJHRvKCk7XG4gICAgICAgIGdsb2JhbHMuY3VycmVudCA9IGdsb2JhbHMuJGN1cnJlbnQuc2VsZjtcbiAgICAgICAgY29tbW9uXzEuY29weSh0cmFucy5wYXJhbXMoKSwgZ2xvYmFscy5wYXJhbXMpO1xuICAgIH07XG4gICAgdmFyIGNsZWFyQ3VycmVudFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIERvIG5vdCBjbGVhciBnbG9iYWxzLnRyYW5zaXRpb24gaWYgYSBkaWZmZXJlbnQgdHJhbnNpdGlvbiBoYXMgc3RhcnRlZCBpbiB0aGUgbWVhbnRpbWVcbiAgICAgICAgaWYgKGdsb2JhbHMudHJhbnNpdGlvbiA9PT0gdHJhbnMpXG4gICAgICAgICAgICBnbG9iYWxzLnRyYW5zaXRpb24gPSBudWxsO1xuICAgIH07XG4gICAgdHJhbnMub25TdWNjZXNzKHt9LCB0cmFuc2l0aW9uU3VjY2Vzc2Z1bCwgeyBwcmlvcml0eTogMTAwMDAgfSk7XG4gICAgdHJhbnMucHJvbWlzZS50aGVuKGNsZWFyQ3VycmVudFRyYW5zaXRpb24sIGNsZWFyQ3VycmVudFRyYW5zaXRpb24pO1xufTtcbmV4cG9ydHMucmVnaXN0ZXJVcGRhdGVHbG9iYWxTdGF0ZSA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uU2VydmljZSkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uU2VydmljZS5vbkNyZWF0ZSh7fSwgdXBkYXRlR2xvYmFsU3RhdGUpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVwZGF0ZUdsb2JhbHMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy91cGRhdGVHbG9iYWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///65\n')},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A [[TransitionHookFn]] which updates the URL after a successful transition\n *\n * Registered using `transitionService.onSuccess({}, updateUrl);`\n */\nvar updateUrl = function (transition) {\n    var options = transition.options();\n    var $state = transition.router.stateService;\n    var $urlRouter = transition.router.urlRouter;\n    // Dont update the url in these situations:\n    // The transition was triggered by a URL sync (options.source === 'url')\n    // The user doesn't want the url to update (options.location === false)\n    // The destination state, and all parents have no navigable url\n    if (options.source !== 'url' && options.location && $state.$current.navigable) {\n        var urlOptions = { replace: options.location === 'replace' };\n        $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions);\n    }\n    $urlRouter.update(true);\n};\nexports.registerUpdateUrl = function (transitionService) {\n    return transitionService.onSuccess({}, updateUrl, { priority: 9999 });\n};\n//# sourceMappingURL=url.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy91cmwuanM/NjU0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQSBbW1RyYW5zaXRpb25Ib29rRm5dXSB3aGljaCB1cGRhdGVzIHRoZSBVUkwgYWZ0ZXIgYSBzdWNjZXNzZnVsIHRyYW5zaXRpb25cbiAqXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vblN1Y2Nlc3Moe30sIHVwZGF0ZVVybCk7YFxuICovXG52YXIgdXBkYXRlVXJsID0gZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRyYW5zaXRpb24ub3B0aW9ucygpO1xuICAgIHZhciAkc3RhdGUgPSB0cmFuc2l0aW9uLnJvdXRlci5zdGF0ZVNlcnZpY2U7XG4gICAgdmFyICR1cmxSb3V0ZXIgPSB0cmFuc2l0aW9uLnJvdXRlci51cmxSb3V0ZXI7XG4gICAgLy8gRG9udCB1cGRhdGUgdGhlIHVybCBpbiB0aGVzZSBzaXR1YXRpb25zOlxuICAgIC8vIFRoZSB0cmFuc2l0aW9uIHdhcyB0cmlnZ2VyZWQgYnkgYSBVUkwgc3luYyAob3B0aW9ucy5zb3VyY2UgPT09ICd1cmwnKVxuICAgIC8vIFRoZSB1c2VyIGRvZXNuJ3Qgd2FudCB0aGUgdXJsIHRvIHVwZGF0ZSAob3B0aW9ucy5sb2NhdGlvbiA9PT0gZmFsc2UpXG4gICAgLy8gVGhlIGRlc3RpbmF0aW9uIHN0YXRlLCBhbmQgYWxsIHBhcmVudHMgaGF2ZSBubyBuYXZpZ2FibGUgdXJsXG4gICAgaWYgKG9wdGlvbnMuc291cmNlICE9PSAndXJsJyAmJiBvcHRpb25zLmxvY2F0aW9uICYmICRzdGF0ZS4kY3VycmVudC5uYXZpZ2FibGUpIHtcbiAgICAgICAgdmFyIHVybE9wdGlvbnMgPSB7IHJlcGxhY2U6IG9wdGlvbnMubG9jYXRpb24gPT09ICdyZXBsYWNlJyB9O1xuICAgICAgICAkdXJsUm91dGVyLnB1c2goJHN0YXRlLiRjdXJyZW50Lm5hdmlnYWJsZS51cmwsICRzdGF0ZS5wYXJhbXMsIHVybE9wdGlvbnMpO1xuICAgIH1cbiAgICAkdXJsUm91dGVyLnVwZGF0ZSh0cnVlKTtcbn07XG5leHBvcnRzLnJlZ2lzdGVyVXBkYXRlVXJsID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uU3VjY2Vzcyh7fSwgdXBkYXRlVXJsLCB7IHByaW9yaXR5OiA5OTk5IH0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL3VybC5qc1xuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///66\n")},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/** @module hooks */ /** for typedoc */\nvar common_1 = __webpack_require__(/*! ../common/common */ 0);\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ 3);\n/**\n * A [[TransitionHookFn]] which waits for the views to load\n *\n * Registered using `transitionService.onStart({}, loadEnteringViews);`\n *\n * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.\n * In angular 1, this includes loading the templates.\n */\nvar loadEnteringViews = function (transition) {\n    var $q = coreservices_1.services.$q;\n    var enteringViews = transition.views("entering");\n    if (!enteringViews.length)\n        return;\n    return $q.all(enteringViews.map(function (view) { return $q.when(view.load()); })).then(common_1.noop);\n};\nexports.registerLoadEnteringViews = function (transitionService) {\n    return transitionService.onFinish({}, loadEnteringViews);\n};\n/**\n * A [[TransitionHookFn]] which activates the new views when a transition is successful.\n *\n * Registered using `transitionService.onSuccess({}, activateViews);`\n *\n * After a transition is complete, this hook deactivates the old views from the previous state,\n * and activates the new views from the destination state.\n *\n * See [[ViewService]]\n */\nvar activateViews = function (transition) {\n    var enteringViews = transition.views("entering");\n    var exitingViews = transition.views("exiting");\n    if (!enteringViews.length && !exitingViews.length)\n        return;\n    var $view = transition.router.viewService;\n    exitingViews.forEach(function (vc) { return $view.deactivateViewConfig(vc); });\n    enteringViews.forEach(function (vc) { return $view.activateViewConfig(vc); });\n    $view.sync();\n};\nexports.registerActivateViews = function (transitionService) {\n    return transitionService.onSuccess({}, activateViews);\n};\n//# sourceMappingURL=views.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy92aWV3cy5qcz80YWFmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgaG9va3MgKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xuLyoqXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHdoaWNoIHdhaXRzIGZvciB0aGUgdmlld3MgdG8gbG9hZFxuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uU3RhcnQoe30sIGxvYWRFbnRlcmluZ1ZpZXdzKTtgXG4gKlxuICogQWxsb3dzIHRoZSB2aWV3cyB0byBkbyBhc3luYyB3b3JrIGluIFtbVmlld0NvbmZpZy5sb2FkXV0gYmVmb3JlIHRoZSB0cmFuc2l0aW9uIGNvbnRpbnVlcy5cbiAqIEluIGFuZ3VsYXIgMSwgdGhpcyBpbmNsdWRlcyBsb2FkaW5nIHRoZSB0ZW1wbGF0ZXMuXG4gKi9cbnZhciBsb2FkRW50ZXJpbmdWaWV3cyA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uKSB7XG4gICAgdmFyICRxID0gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHE7XG4gICAgdmFyIGVudGVyaW5nVmlld3MgPSB0cmFuc2l0aW9uLnZpZXdzKFwiZW50ZXJpbmdcIik7XG4gICAgaWYgKCFlbnRlcmluZ1ZpZXdzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgIHJldHVybiAkcS5hbGwoZW50ZXJpbmdWaWV3cy5tYXAoZnVuY3Rpb24gKHZpZXcpIHsgcmV0dXJuICRxLndoZW4odmlldy5sb2FkKCkpOyB9KSkudGhlbihjb21tb25fMS5ub29wKTtcbn07XG5leHBvcnRzLnJlZ2lzdGVyTG9hZEVudGVyaW5nVmlld3MgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25GaW5pc2goe30sIGxvYWRFbnRlcmluZ1ZpZXdzKTtcbn07XG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gd2hpY2ggYWN0aXZhdGVzIHRoZSBuZXcgdmlld3Mgd2hlbiBhIHRyYW5zaXRpb24gaXMgc3VjY2Vzc2Z1bC5cbiAqXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vblN1Y2Nlc3Moe30sIGFjdGl2YXRlVmlld3MpO2BcbiAqXG4gKiBBZnRlciBhIHRyYW5zaXRpb24gaXMgY29tcGxldGUsIHRoaXMgaG9vayBkZWFjdGl2YXRlcyB0aGUgb2xkIHZpZXdzIGZyb20gdGhlIHByZXZpb3VzIHN0YXRlLFxuICogYW5kIGFjdGl2YXRlcyB0aGUgbmV3IHZpZXdzIGZyb20gdGhlIGRlc3RpbmF0aW9uIHN0YXRlLlxuICpcbiAqIFNlZSBbW1ZpZXdTZXJ2aWNlXV1cbiAqL1xudmFyIGFjdGl2YXRlVmlld3MgPSBmdW5jdGlvbiAodHJhbnNpdGlvbikge1xuICAgIHZhciBlbnRlcmluZ1ZpZXdzID0gdHJhbnNpdGlvbi52aWV3cyhcImVudGVyaW5nXCIpO1xuICAgIHZhciBleGl0aW5nVmlld3MgPSB0cmFuc2l0aW9uLnZpZXdzKFwiZXhpdGluZ1wiKTtcbiAgICBpZiAoIWVudGVyaW5nVmlld3MubGVuZ3RoICYmICFleGl0aW5nVmlld3MubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyICR2aWV3ID0gdHJhbnNpdGlvbi5yb3V0ZXIudmlld1NlcnZpY2U7XG4gICAgZXhpdGluZ1ZpZXdzLmZvckVhY2goZnVuY3Rpb24gKHZjKSB7IHJldHVybiAkdmlldy5kZWFjdGl2YXRlVmlld0NvbmZpZyh2Yyk7IH0pO1xuICAgIGVudGVyaW5nVmlld3MuZm9yRWFjaChmdW5jdGlvbiAodmMpIHsgcmV0dXJuICR2aWV3LmFjdGl2YXRlVmlld0NvbmZpZyh2Yyk7IH0pO1xuICAgICR2aWV3LnN5bmMoKTtcbn07XG5leHBvcnRzLnJlZ2lzdGVyQWN0aXZhdGVWaWV3cyA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uU2VydmljZSkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uU2VydmljZS5vblN1Y2Nlc3Moe30sIGFjdGl2YXRlVmlld3MpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXdzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3Mvdmlld3MuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///67\n')},function(module,exports,__webpack_require__){"use strict";eval('\n/**\n * @coreapi\n * @module common\n */ /** */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, "__esModule", { value: true });\n__export(__webpack_require__(/*! ./common/index */ 5));\n__export(__webpack_require__(/*! ./params/index */ 70));\n__export(__webpack_require__(/*! ./path/index */ 71));\n__export(__webpack_require__(/*! ./resolve/index */ 72));\n__export(__webpack_require__(/*! ./state/index */ 73));\n__export(__webpack_require__(/*! ./transition/index */ 74));\n__export(__webpack_require__(/*! ./url/index */ 75));\n__export(__webpack_require__(/*! ./view/index */ 79));\n__export(__webpack_require__(/*! ./globals */ 28));\n__export(__webpack_require__(/*! ./router */ 33));\n__export(__webpack_require__(/*! ./vanilla */ 76));\n__export(__webpack_require__(/*! ./interface */ 69));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9pbmRleC5qcz8zZmM2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSBjb21tb25cbiAqLyAvKiogKi9cbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21tb24vaW5kZXhcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcGFyYW1zL2luZGV4XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3BhdGgvaW5kZXhcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcmVzb2x2ZS9pbmRleFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdGF0ZS9pbmRleFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi90cmFuc2l0aW9uL2luZGV4XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3VybC9pbmRleFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi92aWV3L2luZGV4XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2dsb2JhbHNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcm91dGVyXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3ZhbmlsbGFcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vaW50ZXJmYWNlXCIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///68\n')},function(module,exports,__webpack_require__){"use strict";eval('\n/**\n * # Core classes and interfaces\n *\n * The classes and interfaces that are core to ui-router and do not belong\n * to a more specific subsystem (such as resolve).\n *\n * @coreapi\n * @preferred\n * @module core\n */ /** for typedoc */\nObject.defineProperty(exports, "__esModule", { value: true });\n/** @internalapi */\nvar UIRouterPluginBase = /** @class */ (function () {\n    function UIRouterPluginBase() {\n    }\n    UIRouterPluginBase.prototype.dispose = function (router) { };\n    return UIRouterPluginBase;\n}());\nexports.UIRouterPluginBase = UIRouterPluginBase;\n//# sourceMappingURL=interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9pbnRlcmZhY2UuanM/ZTE4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIyBDb3JlIGNsYXNzZXMgYW5kIGludGVyZmFjZXNcbiAqXG4gKiBUaGUgY2xhc3NlcyBhbmQgaW50ZXJmYWNlcyB0aGF0IGFyZSBjb3JlIHRvIHVpLXJvdXRlciBhbmQgZG8gbm90IGJlbG9uZ1xuICogdG8gYSBtb3JlIHNwZWNpZmljIHN1YnN5c3RlbSAoc3VjaCBhcyByZXNvbHZlKS5cbiAqXG4gKiBAY29yZWFwaVxuICogQHByZWZlcnJlZFxuICogQG1vZHVsZSBjb3JlXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogQGludGVybmFsYXBpICovXG52YXIgVUlSb3V0ZXJQbHVnaW5CYXNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVJUm91dGVyUGx1Z2luQmFzZSgpIHtcbiAgICB9XG4gICAgVUlSb3V0ZXJQbHVnaW5CYXNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKHJvdXRlcikgeyB9O1xuICAgIHJldHVybiBVSVJvdXRlclBsdWdpbkJhc2U7XG59KCkpO1xuZXhwb3J0cy5VSVJvdXRlclBsdWdpbkJhc2UgPSBVSVJvdXRlclBsdWdpbkJhc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmZhY2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9pbnRlcmZhY2UuanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///69\n')},function(module,exports,__webpack_require__){"use strict";eval('\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, "__esModule", { value: true });\n__export(__webpack_require__(/*! ./param */ 8));\n__export(__webpack_require__(/*! ./paramTypes */ 30));\n__export(__webpack_require__(/*! ./stateParams */ 31));\n__export(__webpack_require__(/*! ./paramType */ 22));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9wYXJhbXMvaW5kZXguanM/Yjk2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9wYXJhbVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9wYXJhbVR5cGVzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3N0YXRlUGFyYW1zXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3BhcmFtVHlwZVwiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///70\n')},function(module,exports,__webpack_require__){"use strict";eval('\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, "__esModule", { value: true });\n/** @module path */ /** for typedoc */\n__export(__webpack_require__(/*! ./pathNode */ 23));\n__export(__webpack_require__(/*! ./pathFactory */ 16));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9wYXRoL2luZGV4LmpzP2RkOTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgcGF0aCAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3BhdGhOb2RlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3BhdGhGYWN0b3J5XCIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvcGF0aC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///71\n')},function(module,exports,__webpack_require__){"use strict";eval('\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, "__esModule", { value: true });\n/** @module resolve */ /** for typedoc */\n__export(__webpack_require__(/*! ./interface */ 32));\n__export(__webpack_require__(/*! ./resolvable */ 11));\n__export(__webpack_require__(/*! ./resolveContext */ 17));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9yZXNvbHZlL2luZGV4LmpzPzhhMjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgcmVzb2x2ZSAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2ludGVyZmFjZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9yZXNvbHZhYmxlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3Jlc29sdmVDb250ZXh0XCIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AdWlyb3V0ZXIvY29yZS9saWIvcmVzb2x2ZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///72\n')},function(module,exports,__webpack_require__){"use strict";eval('\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, "__esModule", { value: true });\n__export(__webpack_require__(/*! ./stateBuilder */ 34));\n__export(__webpack_require__(/*! ./stateObject */ 24));\n__export(__webpack_require__(/*! ./stateMatcher */ 35));\n__export(__webpack_require__(/*! ./stateQueueManager */ 36));\n__export(__webpack_require__(/*! ./stateRegistry */ 37));\n__export(__webpack_require__(/*! ./stateService */ 38));\n__export(__webpack_require__(/*! ./targetState */ 9));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9pbmRleC5qcz82Y2RlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3N0YXRlQnVpbGRlclwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdGF0ZU9iamVjdFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdGF0ZU1hdGNoZXJcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vc3RhdGVRdWV1ZU1hbmFnZXJcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vc3RhdGVSZWdpc3RyeVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdGF0ZVNlcnZpY2VcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdGFyZ2V0U3RhdGVcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///73\n')},function(module,exports,__webpack_require__){"use strict";eval('\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * # Transition subsystem\n *\n * This module contains APIs related to a Transition.\n *\n * See:\n * - [[TransitionService]]\n * - [[Transition]]\n * - [[HookFn]], [[TransitionHookFn]], [[TransitionStateHookFn]], [[HookMatchCriteria]], [[HookResult]]\n *\n * @coreapi\n * @preferred\n * @module transition\n */ /** for typedoc */\n__export(__webpack_require__(/*! ./interface */ 10));\n__export(__webpack_require__(/*! ./hookBuilder */ 39));\n__export(__webpack_require__(/*! ./hookRegistry */ 25));\n__export(__webpack_require__(/*! ./rejectFactory */ 12));\n__export(__webpack_require__(/*! ./transition */ 18));\n__export(__webpack_require__(/*! ./transitionHook */ 13));\n__export(__webpack_require__(/*! ./transitionEventType */ 40));\n__export(__webpack_require__(/*! ./transitionService */ 26));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL2luZGV4LmpzP2U2OTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiAjIFRyYW5zaXRpb24gc3Vic3lzdGVtXG4gKlxuICogVGhpcyBtb2R1bGUgY29udGFpbnMgQVBJcyByZWxhdGVkIHRvIGEgVHJhbnNpdGlvbi5cbiAqXG4gKiBTZWU6XG4gKiAtIFtbVHJhbnNpdGlvblNlcnZpY2VdXVxuICogLSBbW1RyYW5zaXRpb25dXVxuICogLSBbW0hvb2tGbl1dLCBbW1RyYW5zaXRpb25Ib29rRm5dXSwgW1tUcmFuc2l0aW9uU3RhdGVIb29rRm5dXSwgW1tIb29rTWF0Y2hDcml0ZXJpYV1dLCBbW0hvb2tSZXN1bHRdXVxuICpcbiAqIEBjb3JlYXBpXG4gKiBAcHJlZmVycmVkXG4gKiBAbW9kdWxlIHRyYW5zaXRpb25cbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2ludGVyZmFjZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9ob29rQnVpbGRlclwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9ob29rUmVnaXN0cnlcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcmVqZWN0RmFjdG9yeVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi90cmFuc2l0aW9uXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3RyYW5zaXRpb25Ib29rXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3RyYW5zaXRpb25FdmVudFR5cGVcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdHJhbnNpdGlvblNlcnZpY2VcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///74\n')},function(module,exports,__webpack_require__){"use strict";eval('\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, "__esModule", { value: true });\n__export(__webpack_require__(/*! ./urlMatcher */ 19));\n__export(__webpack_require__(/*! ./urlMatcherFactory */ 41));\n__export(__webpack_require__(/*! ./urlRouter */ 42));\n__export(__webpack_require__(/*! ./urlRule */ 43));\n__export(__webpack_require__(/*! ./urlService */ 44));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi91cmwvaW5kZXguanM/NDk0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi91cmxNYXRjaGVyXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3VybE1hdGNoZXJGYWN0b3J5XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3VybFJvdXRlclwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi91cmxSdWxlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3VybFNlcnZpY2VcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0B1aXJvdXRlci9jb3JlL2xpYi91cmwvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///75\n')},function(module,exports,__webpack_require__){"use strict";eval('\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\n__export(__webpack_require__(/*! ./vanilla/index */ 77));\n//# sourceMappingURL=vanilla.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhLmpzPzI1OTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxhcGlcbiAqIEBtb2R1bGUgdmFuaWxsYVxuICovXG4vKiogKi9cbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3ZhbmlsbGEvaW5kZXhcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFuaWxsYS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEuanNcbi8vIG1vZHVsZSBpZCA9IDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///76\n')},function(module,exports,__webpack_require__){"use strict";eval('\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, "__esModule", { value: true });\n__export(__webpack_require__(/*! ./q */ 51));\n__export(__webpack_require__(/*! ./injector */ 47));\n__export(__webpack_require__(/*! ./baseLocationService */ 20));\n__export(__webpack_require__(/*! ./hashLocationService */ 46));\n__export(__webpack_require__(/*! ./memoryLocationService */ 49));\n__export(__webpack_require__(/*! ./pushStateLocationService */ 50));\n__export(__webpack_require__(/*! ./memoryLocationConfig */ 48));\n__export(__webpack_require__(/*! ./browserLocationConfig */ 45));\n__export(__webpack_require__(/*! ./utils */ 27));\n__export(__webpack_require__(/*! ./plugins */ 78));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL2luZGV4LmpzPzgwNzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnQocmVxdWlyZShcIi4vcVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9pbmplY3RvclwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9iYXNlTG9jYXRpb25TZXJ2aWNlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2hhc2hMb2NhdGlvblNlcnZpY2VcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vbWVtb3J5TG9jYXRpb25TZXJ2aWNlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3B1c2hTdGF0ZUxvY2F0aW9uU2VydmljZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9tZW1vcnlMb2NhdGlvbkNvbmZpZ1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9icm93c2VyTG9jYXRpb25Db25maWdcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdXRpbHNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcGx1Z2luc1wiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///77\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar browserLocationConfig_1 = __webpack_require__(/*! ./browserLocationConfig */ 45);\nvar hashLocationService_1 = __webpack_require__(/*! ./hashLocationService */ 46);\nvar utils_1 = __webpack_require__(/*! ./utils */ 27);\nvar pushStateLocationService_1 = __webpack_require__(/*! ./pushStateLocationService */ 50);\nvar memoryLocationService_1 = __webpack_require__(/*! ./memoryLocationService */ 49);\nvar memoryLocationConfig_1 = __webpack_require__(/*! ./memoryLocationConfig */ 48);\nvar injector_1 = __webpack_require__(/*! ./injector */ 47);\nvar q_1 = __webpack_require__(/*! ./q */ 51);\nvar coreservices_1 = __webpack_require__(/*! ../common/coreservices */ 3);\nfunction servicesPlugin(router) {\n    coreservices_1.services.$injector = injector_1.$injector;\n    coreservices_1.services.$q = q_1.$q;\n    return { name: "vanilla.services", $q: q_1.$q, $injector: injector_1.$injector, dispose: function () { return null; } };\n}\nexports.servicesPlugin = servicesPlugin;\n/** A `UIRouterPlugin` uses the browser hash to get/set the current location */\nexports.hashLocationPlugin = utils_1.locationPluginFactory(\'vanilla.hashBangLocation\', false, hashLocationService_1.HashLocationService, browserLocationConfig_1.BrowserLocationConfig);\n/** A `UIRouterPlugin` that gets/sets the current location using the browser\'s `location` and `history` apis */\nexports.pushStateLocationPlugin = utils_1.locationPluginFactory("vanilla.pushStateLocation", true, pushStateLocationService_1.PushStateLocationService, browserLocationConfig_1.BrowserLocationConfig);\n/** A `UIRouterPlugin` that gets/sets the current location from an in-memory object */\nexports.memoryLocationPlugin = utils_1.locationPluginFactory("vanilla.memoryLocation", false, memoryLocationService_1.MemoryLocationService, memoryLocationConfig_1.MemoryLocationConfig);\n//# sourceMappingURL=plugins.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL3BsdWdpbnMuanM/YzhhZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGludGVybmFsYXBpXG4gKiBAbW9kdWxlIHZhbmlsbGFcbiAqL1xuLyoqICovXG52YXIgYnJvd3NlckxvY2F0aW9uQ29uZmlnXzEgPSByZXF1aXJlKFwiLi9icm93c2VyTG9jYXRpb25Db25maWdcIik7XG52YXIgaGFzaExvY2F0aW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4vaGFzaExvY2F0aW9uU2VydmljZVwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgcHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9wdXNoU3RhdGVMb2NhdGlvblNlcnZpY2VcIik7XG52YXIgbWVtb3J5TG9jYXRpb25TZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9tZW1vcnlMb2NhdGlvblNlcnZpY2VcIik7XG52YXIgbWVtb3J5TG9jYXRpb25Db25maWdfMSA9IHJlcXVpcmUoXCIuL21lbW9yeUxvY2F0aW9uQ29uZmlnXCIpO1xudmFyIGluamVjdG9yXzEgPSByZXF1aXJlKFwiLi9pbmplY3RvclwiKTtcbnZhciBxXzEgPSByZXF1aXJlKFwiLi9xXCIpO1xudmFyIGNvcmVzZXJ2aWNlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb3Jlc2VydmljZXNcIik7XG5mdW5jdGlvbiBzZXJ2aWNlc1BsdWdpbihyb3V0ZXIpIHtcbiAgICBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kaW5qZWN0b3IgPSBpbmplY3Rvcl8xLiRpbmplY3RvcjtcbiAgICBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcSA9IHFfMS4kcTtcbiAgICByZXR1cm4geyBuYW1lOiBcInZhbmlsbGEuc2VydmljZXNcIiwgJHE6IHFfMS4kcSwgJGluamVjdG9yOiBpbmplY3Rvcl8xLiRpbmplY3RvciwgZGlzcG9zZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSB9O1xufVxuZXhwb3J0cy5zZXJ2aWNlc1BsdWdpbiA9IHNlcnZpY2VzUGx1Z2luO1xuLyoqIEEgYFVJUm91dGVyUGx1Z2luYCB1c2VzIHRoZSBicm93c2VyIGhhc2ggdG8gZ2V0L3NldCB0aGUgY3VycmVudCBsb2NhdGlvbiAqL1xuZXhwb3J0cy5oYXNoTG9jYXRpb25QbHVnaW4gPSB1dGlsc18xLmxvY2F0aW9uUGx1Z2luRmFjdG9yeSgndmFuaWxsYS5oYXNoQmFuZ0xvY2F0aW9uJywgZmFsc2UsIGhhc2hMb2NhdGlvblNlcnZpY2VfMS5IYXNoTG9jYXRpb25TZXJ2aWNlLCBicm93c2VyTG9jYXRpb25Db25maWdfMS5Ccm93c2VyTG9jYXRpb25Db25maWcpO1xuLyoqIEEgYFVJUm91dGVyUGx1Z2luYCB0aGF0IGdldHMvc2V0cyB0aGUgY3VycmVudCBsb2NhdGlvbiB1c2luZyB0aGUgYnJvd3NlcidzIGBsb2NhdGlvbmAgYW5kIGBoaXN0b3J5YCBhcGlzICovXG5leHBvcnRzLnB1c2hTdGF0ZUxvY2F0aW9uUGx1Z2luID0gdXRpbHNfMS5sb2NhdGlvblBsdWdpbkZhY3RvcnkoXCJ2YW5pbGxhLnB1c2hTdGF0ZUxvY2F0aW9uXCIsIHRydWUsIHB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZV8xLlB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZSwgYnJvd3NlckxvY2F0aW9uQ29uZmlnXzEuQnJvd3NlckxvY2F0aW9uQ29uZmlnKTtcbi8qKiBBIGBVSVJvdXRlclBsdWdpbmAgdGhhdCBnZXRzL3NldHMgdGhlIGN1cnJlbnQgbG9jYXRpb24gZnJvbSBhbiBpbi1tZW1vcnkgb2JqZWN0ICovXG5leHBvcnRzLm1lbW9yeUxvY2F0aW9uUGx1Z2luID0gdXRpbHNfMS5sb2NhdGlvblBsdWdpbkZhY3RvcnkoXCJ2YW5pbGxhLm1lbW9yeUxvY2F0aW9uXCIsIGZhbHNlLCBtZW1vcnlMb2NhdGlvblNlcnZpY2VfMS5NZW1vcnlMb2NhdGlvblNlcnZpY2UsIG1lbW9yeUxvY2F0aW9uQ29uZmlnXzEuTWVtb3J5TG9jYXRpb25Db25maWcpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Z2lucy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvcGx1Z2lucy5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///78\n')},function(module,exports,__webpack_require__){"use strict";eval('\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, "__esModule", { value: true });\n__export(__webpack_require__(/*! ./view */ 52));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0B1aXJvdXRlci9jb3JlL2xpYi92aWV3L2luZGV4LmpzPzVhYjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnQocmVxdWlyZShcIi4vdmlld1wiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQHVpcm91dGVyL2NvcmUvbGliL3ZpZXcvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///79\n')},,,,function(module,exports){eval('// removed by extract-text-webpack-plugin\nmodule.exports = {"elem-inline":"elem-inline--yTDtM","elemInline":"elem-inline--yTDtM","elem-block":"elem-block--8G6X-","elemBlock":"elem-block--8G6X-","fund-section":"fund-section--2rNmw","fundSection":"fund-section--2rNmw","fund-list":"fund-list--BKtUH","fundList":"fund-list--BKtUH","fund-group":"fund-group--tVFlf","fundGroup":"fund-group--tVFlf","fund-name":"fund-name--2bEqX","fundName":"fund-name--2bEqX","avg-net":"avg-net--kBxVm","avgNet":"avg-net--kBxVm","fund-unit":"fund-unit--3pxw3","fundUnit":"fund-unit--3pxw3","buyNum":"buyNum--BhGay","select-options":"select-options--2A-lK","selectOptions":"select-options--2A-lK","add":"add--2eIAc","delete":"delete--1IuN2"};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0L3BhZ2VzL2xpc3Rfdmlldy9saXN0LnNjc3M/YmUwYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJlbGVtLWlubGluZVwiOlwiZWxlbS1pbmxpbmUtLXlURHRNXCIsXCJlbGVtSW5saW5lXCI6XCJlbGVtLWlubGluZS0teVREdE1cIixcImVsZW0tYmxvY2tcIjpcImVsZW0tYmxvY2stLThHNlgtXCIsXCJlbGVtQmxvY2tcIjpcImVsZW0tYmxvY2stLThHNlgtXCIsXCJmdW5kLXNlY3Rpb25cIjpcImZ1bmQtc2VjdGlvbi0tMnJObXdcIixcImZ1bmRTZWN0aW9uXCI6XCJmdW5kLXNlY3Rpb24tLTJyTm13XCIsXCJmdW5kLWxpc3RcIjpcImZ1bmQtbGlzdC0tQkt0VUhcIixcImZ1bmRMaXN0XCI6XCJmdW5kLWxpc3QtLUJLdFVIXCIsXCJmdW5kLWdyb3VwXCI6XCJmdW5kLWdyb3VwLS10VkZsZlwiLFwiZnVuZEdyb3VwXCI6XCJmdW5kLWdyb3VwLS10VkZsZlwiLFwiZnVuZC1uYW1lXCI6XCJmdW5kLW5hbWUtLTJiRXFYXCIsXCJmdW5kTmFtZVwiOlwiZnVuZC1uYW1lLS0yYkVxWFwiLFwiYXZnLW5ldFwiOlwiYXZnLW5ldC0ta0J4Vm1cIixcImF2Z05ldFwiOlwiYXZnLW5ldC0ta0J4Vm1cIixcImZ1bmQtdW5pdFwiOlwiZnVuZC11bml0LS0zcHh3M1wiLFwiZnVuZFVuaXRcIjpcImZ1bmQtdW5pdC0tM3B4dzNcIixcImJ1eU51bVwiOlwiYnV5TnVtLS1CaEdheVwiLFwic2VsZWN0LW9wdGlvbnNcIjpcInNlbGVjdC1vcHRpb25zLS0yQS1sS1wiLFwic2VsZWN0T3B0aW9uc1wiOlwic2VsZWN0LW9wdGlvbnMtLTJBLWxLXCIsXCJhZGRcIjpcImFkZC0tMmVJQWNcIixcImRlbGV0ZVwiOlwiZGVsZXRlLS0xSXVOMlwifTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zY3JpcHQvcGFnZXMvbGlzdF92aWV3L2xpc3Quc2Nzc1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///83\n')},,,,,,,,,,,,,,function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/**\n * header\n */\n\nvar Controller = function Controller() {\n    "ngInject";\n\n    _classCallCheck(this, Controller);\n};\n\nexports.default = Controller;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3NjcmlwdC9jb21wb25lbnRzL2hlYWRlci9oZWFkZXIuY29udHJvbGxlci5qcz9jOWE5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogaGVhZGVyXG4gKi9cblxuY2xhc3MgQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIFwibmdJbmplY3RcIlxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29udHJvbGxlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3NjcmlwdC9jb21wb25lbnRzL2hlYWRlci9oZWFkZXIuY29udHJvbGxlci5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7OztBQUlBO0FBRUE7QUFDQTtBQUZBO0FBRUE7QUFDQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///97\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _headerController = __webpack_require__(/*! ./header.controller.js */ 97);\n\nvar _headerController2 = _interopRequireDefault(_headerController);\n\nvar _headerView = __webpack_require__(/*! ./header.view.html */ 107);\n\nvar _headerView2 = _interopRequireDefault(_headerView);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar Directive = function () {\n    function Directive() {\n        _classCallCheck(this, Directive);\n\n        return {\n            restrict: \'E\',\n            replace: true,\n            controller: _headerController2.default,\n            templateUrl: _headerView2.default\n        };\n    }\n\n    _createClass(Directive, null, [{\n        key: \'factory\',\n        value: function factory() {\n            return new Directive();\n        }\n    }]);\n\n    return Directive;\n}();\n\nexports.default = Directive;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3NjcmlwdC9jb21wb25lbnRzL2hlYWRlci9oZWFkZXIuZGlyZWN0aXZlLmpzPzY2M2YiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGN0cmwgZnJvbSAnLi9oZWFkZXIuY29udHJvbGxlci5qcyc7XG5pbXBvcnQgdHBsIGZyb20gJy4vaGVhZGVyLnZpZXcuaHRtbCc7XG5cbmNsYXNzIERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IGN0cmwsXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogdHBsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEaXJlY3RpdmUoKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERpcmVjdGl2ZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3NjcmlwdC9jb21wb25lbnRzL2hlYWRlci9oZWFkZXIuZGlyZWN0aXZlLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7Ozs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBR0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///98\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _headerDirective = __webpack_require__(/*! ./header.directive.js */ 98);\n\nvar _headerDirective2 = _interopRequireDefault(_headerDirective);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nangular.module('demo-app').directive('demoHeader', _headerDirective2.default.factory);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3NjcmlwdC9jb21wb25lbnRzL2hlYWRlci9oZWFkZXIuaW5kZXguanM/NzdjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaGVhZGVyRGlyZWN0aXZlIGZyb20gJy4vaGVhZGVyLmRpcmVjdGl2ZS5qcyc7XG5cbmFuZ3VsYXIubW9kdWxlKCdkZW1vLWFwcCcpXG4gICAgLmRpcmVjdGl2ZSgnZGVtb0hlYWRlcicsIGhlYWRlckRpcmVjdGl2ZS5mYWN0b3J5KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3NjcmlwdC9jb21wb25lbnRzL2hlYWRlci9oZWFkZXIuaW5kZXguanMiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTs7Ozs7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///99\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/**\n * nav\n */\n\nvar Controller = function Controller() {\n    "ngInject";\n\n    _classCallCheck(this, Controller);\n};\n\nexports.default = Controller;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9zY3JpcHQvY29tcG9uZW50cy9uYXYvbmF2LmNvbnRyb2xsZXIuanM/YjI5MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIG5hdlxuICovXG5cbmNsYXNzIENvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBcIm5nSW5qZWN0XCJcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbnRyb2xsZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9zY3JpcHQvY29tcG9uZW50cy9uYXYvbmF2LmNvbnRyb2xsZXIuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFJQTtBQUVBO0FBQ0E7QUFGQTtBQUVBO0FBQ0E7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///100\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _navController = __webpack_require__(/*! ./nav.controller.js */ 100);\n\nvar _navController2 = _interopRequireDefault(_navController);\n\nvar _navView = __webpack_require__(/*! ./nav.view.html */ 108);\n\nvar _navView2 = _interopRequireDefault(_navView);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar Directive = function () {\n    function Directive() {\n        _classCallCheck(this, Directive);\n\n        return {\n            restrict: \'E\',\n            replace: true,\n            controller: _navController2.default,\n            templateUrl: _navView2.default\n        };\n    }\n\n    _createClass(Directive, null, [{\n        key: \'factory\',\n        value: function factory() {\n            return new Directive();\n        }\n    }]);\n\n    return Directive;\n}();\n\nexports.default = Directive;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9zY3JpcHQvY29tcG9uZW50cy9uYXYvbmF2LmRpcmVjdGl2ZS5qcz8zMDI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjdHJsIGZyb20gJy4vbmF2LmNvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHRwbCBmcm9tICcuL25hdi52aWV3Lmh0bWwnO1xuXG5jbGFzcyBEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBjdHJsLFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IHRwbFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGZhY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGlyZWN0aXZlKCk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEaXJlY3RpdmU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9zY3JpcHQvY29tcG9uZW50cy9uYXYvbmF2LmRpcmVjdGl2ZS5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7Ozs7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUdBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///101\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _navDirective = __webpack_require__(/*! ./nav.directive.js */ 101);\n\nvar _navDirective2 = _interopRequireDefault(_navDirective);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nangular.module('demo-app').directive('demoNav', _navDirective2.default.factory);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9zY3JpcHQvY29tcG9uZW50cy9uYXYvbmF2LmluZGV4LmpzPzAyOTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG5hdkRpcmVjdGl2ZSBmcm9tICcuL25hdi5kaXJlY3RpdmUuanMnO1xuXG5hbmd1bGFyLm1vZHVsZSgnZGVtby1hcHAnKVxuICAgIC5kaXJlY3RpdmUoJ2RlbW9OYXYnLCBuYXZEaXJlY3RpdmUuZmFjdG9yeSlcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3NjcmlwdC9jb21wb25lbnRzL25hdi9uYXYuaW5kZXguanMiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTs7Ozs7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///102\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _angular = __webpack_require__(/*! angular */ 14);\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nvar _angularjs = __webpack_require__(/*! @uirouter/angularjs */ 53);\n\nvar _angularjs2 = _interopRequireDefault(_angularjs);\n\n__webpack_require__(/*! ../assets/style/index.scss */ 55);\n\nvar _query_helperService = __webpack_require__(/*! ./../script/utils/query_helper.service.js */ 56);\n\nvar _query_helperService2 = _interopRequireDefault(_query_helperService);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar app = _angular2.default.module('demo-app', [_angularjs2.default]).service('QueryHelper', _query_helperService2.default);\n\n/**\n * require.context();\n * https://webpack.js.org/guides/dependency-management/#require-context\n */\n\n/**\n * 应用模块加载\n */\nvar modules = __webpack_require__(/*! ./../script */ 57);\n\n/**\n * modules('./xxx.module.index.js') === require('./xxx.module.index.js')\n */\nmodules.keys().forEach(modules);\n\n/**\n * 公共组件加载\n */\nvar components = __webpack_require__(/*! ./../script/components/ */ 58);\ncomponents.keys().forEach(components);\n\n// let utils = require.context('./../script/utils/', true, /\\.index.js$/);\n// components.keys().forEach(utils);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9zY3JpcHQvaW5kZXguanM/OTczOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYW5ndWxhciBmcm9tICdhbmd1bGFyJztcbmltcG9ydCB1aXJvdXRlciBmcm9tICdAdWlyb3V0ZXIvYW5ndWxhcmpzJztcblxuaW1wb3J0ICcuLi9hc3NldHMvc3R5bGUvaW5kZXguc2Nzcyc7XG5cbmltcG9ydCBxdWVyeV9oZWxwZXIgZnJvbSAnLi8uLi9zY3JpcHQvdXRpbHMvcXVlcnlfaGVscGVyLnNlcnZpY2UuanMnO1xuY29uc3QgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2RlbW8tYXBwJywgW3Vpcm91dGVyXSlcbiAgICAuc2VydmljZSgnUXVlcnlIZWxwZXInLCBxdWVyeV9oZWxwZXIpO1xuXG4vKipcbiAqIHJlcXVpcmUuY29udGV4dCgpO1xuICogaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9ndWlkZXMvZGVwZW5kZW5jeS1tYW5hZ2VtZW50LyNyZXF1aXJlLWNvbnRleHRcbiAqL1xuXG4vKipcbiAqIOW6lOeUqOaooeWdl+WKoOi9vVxuICovXG5jb25zdCBtb2R1bGVzID0gcmVxdWlyZS5jb250ZXh0KCcuLy4uL3NjcmlwdCcsIHRydWUsIC9cXC5tb2R1bGUuaW5kZXguanMkLyk7XG5cbi8qKlxuICogbW9kdWxlcygnLi94eHgubW9kdWxlLmluZGV4LmpzJykgPT09IHJlcXVpcmUoJy4veHh4Lm1vZHVsZS5pbmRleC5qcycpXG4gKi9cbm1vZHVsZXMua2V5cygpLmZvckVhY2gobW9kdWxlcyk7XG5cbi8qKlxuICog5YWs5YWx57uE5Lu25Yqg6L29XG4gKi9cbmxldCBjb21wb25lbnRzID0gcmVxdWlyZS5jb250ZXh0KCcuLy4uL3NjcmlwdC9jb21wb25lbnRzLycsIHRydWUsIC9cXC5pbmRleC5qcyQvKTtcbmNvbXBvbmVudHMua2V5cygpLmZvckVhY2goY29tcG9uZW50cyk7XG5cbi8vIGxldCB1dGlscyA9IHJlcXVpcmUuY29udGV4dCgnLi8uLi9zY3JpcHQvdXRpbHMvJywgdHJ1ZSwgL1xcLmluZGV4LmpzJC8pO1xuLy8gY29tcG9uZW50cy5rZXlzKCkuZm9yRWFjaCh1dGlscyk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9zY3JpcHQvaW5kZXguanMiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBQUE7QUFDQTtBQUVBOzs7OztBQUtBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///103\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * list page\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _list = __webpack_require__(/*! ./list.scss */ 83);\n\nvar _list2 = _interopRequireDefault(_list);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar Controller = function () {\n    Controller.$inject = ["$scope", "ListService"];\n    function Controller($scope, ListService) {\n        // 通过ng-annotate\n        "ngInject";\n\n        _classCallCheck(this, Controller);\n\n        this._scope = $scope;\n        this.style = _list2.default;\n        this.ListService = ListService;\n\n        this.edaFundList = [];\n    }\n\n    /**\n     * 加载Eda计划\n     */\n\n\n    _createClass(Controller, [{\n        key: "loadEdaFundList",\n        value: function loadEdaFundList() {\n            console.log("load Eda fund.....");\n            this.ListService.qryEdaFundList().then(function (data) {\n                console.log("data is %j", data);\n            });\n        }\n    }]);\n\n    return Controller;\n}();\n\nexports.default = Controller;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdC9wYWdlcy9saXN0X3ZpZXcvbGlzdC5jb250cm9sbGVyLmpzPzVjZTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBsaXN0IHBhZ2VcbiAqL1xuXG5pbXBvcnQgc3R5bGUgZnJvbSAnLi9saXN0LnNjc3MnO1xuXG5jbGFzcyBDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcigkc2NvcGUsIExpc3RTZXJ2aWNlKSB7XG4gICAgICAgIC8vIOmAmui/h25nLWFubm90YXRlXG4gICAgICAgIFwibmdJbmplY3RcIjsgXG4gICAgICAgIHRoaXMuX3Njb3BlID0gJHNjb3BlO1xuICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICAgIHRoaXMuTGlzdFNlcnZpY2UgPSBMaXN0U2VydmljZTtcblxuICAgICAgICB0aGlzLmVkYUZ1bmRMaXN0ID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5Yqg6L29RWRh6K6h5YiSXG4gICAgICovXG4gICAgbG9hZEVkYUZ1bmRMaXN0KCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcImxvYWQgRWRhIGZ1bmQuLi4uLlwiKTtcbiAgICAgICAgdGhpcy5MaXN0U2VydmljZS5xcnlFZGFGdW5kTGlzdCgpLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImRhdGEgaXMgJWpcIiwgZGF0YSk7XG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb250cm9sbGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zY3JpcHQvcGFnZXMvbGlzdF92aWV3L2xpc3QuY29udHJvbGxlci5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7O0FBRkE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQVhBOztBQUVBO0FBQ0E7QUFIQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUF1QkE7QUFDQTtBQUNBO0FBbEJBO0FBQ0E7QUFDQTs7Ozs7QUF3QkE7OztBQUdBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///104\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _listView = __webpack_require__(/*! ./list.view.html */ 109);\n\nvar _listView2 = _interopRequireDefault(_listView);\n\nvar _listController = __webpack_require__(/*! ./list.controller.js */ 104);\n\nvar _listController2 = _interopRequireDefault(_listController);\n\nvar _listService = __webpack_require__(/*! ./list.service.js */ 106);\n\nvar _listService2 = _interopRequireDefault(_listService);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar app = angular.module('demo-app').config([\"$stateProvider\", \"$urlRouterProvider\", function ($stateProvider, $urlRouterProvider) {\n    \"ngInject\";\n\n    $stateProvider.state('list', {\n        url: '/list',\n        templateUrl: _listView2.default,\n        controller: _listController2.default,\n        controllerAs: 'vm'\n    });\n\n    $urlRouterProvider.otherwise('/list');\n}]).service('ListService', _listService2.default); /**\n                                                   * 列表页\n                                                   */\n\nexports.default = app.name;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdC9wYWdlcy9saXN0X3ZpZXcvbGlzdC5tb2R1bGUuaW5kZXguanM/ZGYyMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIOWIl+ihqOmhtVxuICovXG5cbmltcG9ydCBsaXN0VGVtcGxhdGUgZnJvbSAnLi9saXN0LnZpZXcuaHRtbCc7XG5pbXBvcnQgbGlzdEN0cmwgZnJvbSAnLi9saXN0LmNvbnRyb2xsZXIuanMnO1xuaW1wb3J0IGxpc3RTZXJ2aWNlIGZyb20gJy4vbGlzdC5zZXJ2aWNlLmpzJztcblxuY29uc3QgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2RlbW8tYXBwJylcbiAgICAuY29uZmlnKCgkc3RhdGVQcm92aWRlciwgJHVybFJvdXRlclByb3ZpZGVyKSA9PiB7XG4gICAgICAgIFwibmdJbmplY3RcIjtcbiAgICAgICAgJHN0YXRlUHJvdmlkZXIuc3RhdGUoJ2xpc3QnLCB7XG4gICAgICAgICAgICB1cmw6ICcvbGlzdCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogbGlzdFRlbXBsYXRlLFxuICAgICAgICAgICAgY29udHJvbGxlcjogbGlzdEN0cmwsXG4gICAgICAgICAgICBjb250cm9sbGVyQXM6ICd2bSdcbiAgICAgICAgfSlcblxuICAgICAgICAkdXJsUm91dGVyUHJvdmlkZXIub3RoZXJ3aXNlKCcvbGlzdCcpO1xuICAgIH0pXG4gICAgLnNlcnZpY2UoJ0xpc3RTZXJ2aWNlJywgbGlzdFNlcnZpY2UpO1xuXG5leHBvcnQgZGVmYXVsdCBhcHAubmFtZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2NyaXB0L3BhZ2VzL2xpc3Rfdmlldy9saXN0Lm1vZHVsZS5pbmRleC5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFQQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUVBOzs7O0FBZUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///105\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar Service = function () {\n    Service.$inject = ["QueryHelper"];\n    function Service(QueryHelper) {\n        \'ngInject\';\n\n        _classCallCheck(this, Service);\n\n        this._QueryHelper = QueryHelper;\n    }\n\n    // api 请求测试\n\n\n    _createClass(Service, [{\n        key: \'qryEdaFundList\',\n        value: function qryEdaFundList() {\n            return this._QueryHelper.get(\'/eda/fundList\');\n        }\n    }]);\n\n    return Service;\n}();\n\nexports.default = Service;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdC9wYWdlcy9saXN0X3ZpZXcvbGlzdC5zZXJ2aWNlLmpzPzNhMjQiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoUXVlcnlIZWxwZXIpIHtcbiAgICAgICAgJ25nSW5qZWN0J1xuICAgICAgICB0aGlzLl9RdWVyeUhlbHBlciA9IFF1ZXJ5SGVscGVyO1xuICAgIH1cblxuICAgIC8vIGFwaSDor7fmsYLmtYvor5VcbiAgICBxcnlFZGFGdW5kTGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX1F1ZXJ5SGVscGVyLmdldCgnL2VkYS9mdW5kTGlzdCcpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2VydmljZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2NyaXB0L3BhZ2VzL2xpc3Rfdmlldy9saXN0LnNlcnZpY2UuanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQVRBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFDQTs7Ozs7O0FBbUJBO0FBQ0E7QUFDQTtBQWhCQTs7OztBQXFCQTs7O0FBR0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///106\n')},function(module,exports){eval('var path = \'/script/components/header/header.view.html\';\nvar html = "<div class=\\"jumbotron\\">\\n    <div class=\\"container\\">\\n        <h1>Hello, world!</h1>\\n        <p>This is a template for a simple marketing or informational website. It includes a large callout called a jumbotron\\n            and three supporting pieces of content. Use it as a starting point to create something more unique.</p>\\n        <p>\\n            <div class=\\"dropdown\\">\\n                <button type=\\"button\\" class=\\"btn dropdown-toggle\\" id=\\"dropdownMenu1\\" data-toggle=\\"dropdown\\">\\n                    选择计算策略\\n                    <span class=\\"caret\\"></span>\\n                </button>\\n                <button type=\\"button\\" class=\\"btn btn-primary\\" data-toggle=\\"modal\\" data-target=\\"#myModal\\">计算补仓信息</button>\\n                <ul class=\\"dropdown-menu\\" role=\\"menu\\" aria-labelledby=\\"dropdownMenu1\\">\\n                    <li role=\\"presentation\\">\\n                        <a role=\\"menuitem\\" tabindex=\\"-1\\" href=\\"#\\">阶梯计算</a>\\n                    </li>\\n                    <li role=\\"presentation\\">\\n                        <a role=\\"menuitem\\" tabindex=\\"-1\\" href=\\"#\\">平均值计算</a>\\n                    </li>\\n                </ul>\\n            </div>\\n        </p>\\n    </div>\\n</div>";\nwindow.angular.module(\'ng\').run([\'$templateCache\', function(c) { c.put(path, html) }]);\nmodule.exports = path;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdC9jb21wb25lbnRzL2hlYWRlci9oZWFkZXIudmlldy5odG1sP2QyMzciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHBhdGggPSAnL3NjcmlwdC9jb21wb25lbnRzL2hlYWRlci9oZWFkZXIudmlldy5odG1sJztcbnZhciBodG1sID0gXCI8ZGl2IGNsYXNzPVxcXCJqdW1ib3Ryb25cXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb250YWluZXJcXFwiPlxcbiAgICAgICAgPGgxPkhlbGxvLCB3b3JsZCE8L2gxPlxcbiAgICAgICAgPHA+VGhpcyBpcyBhIHRlbXBsYXRlIGZvciBhIHNpbXBsZSBtYXJrZXRpbmcgb3IgaW5mb3JtYXRpb25hbCB3ZWJzaXRlLiBJdCBpbmNsdWRlcyBhIGxhcmdlIGNhbGxvdXQgY2FsbGVkIGEganVtYm90cm9uXFxuICAgICAgICAgICAgYW5kIHRocmVlIHN1cHBvcnRpbmcgcGllY2VzIG9mIGNvbnRlbnQuIFVzZSBpdCBhcyBhIHN0YXJ0aW5nIHBvaW50IHRvIGNyZWF0ZSBzb21ldGhpbmcgbW9yZSB1bmlxdWUuPC9wPlxcbiAgICAgICAgPHA+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZHJvcGRvd25cXFwiPlxcbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBkcm9wZG93bi10b2dnbGVcXFwiIGlkPVxcXCJkcm9wZG93bk1lbnUxXFxcIiBkYXRhLXRvZ2dsZT1cXFwiZHJvcGRvd25cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAg6YCJ5oup6K6h566X562W55WlXFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiY2FyZXRcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1wcmltYXJ5XFxcIiBkYXRhLXRvZ2dsZT1cXFwibW9kYWxcXFwiIGRhdGEtdGFyZ2V0PVxcXCIjbXlNb2RhbFxcXCI+6K6h566X6KGl5LuT5L+h5oGvPC9idXR0b24+XFxuICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwiZHJvcGRvd24tbWVudVxcXCIgcm9sZT1cXFwibWVudVxcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJkcm9wZG93bk1lbnUxXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxsaSByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIHJvbGU9XFxcIm1lbnVpdGVtXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiIGhyZWY9XFxcIiNcXFwiPumYtuair+iuoeeulzwvYT5cXG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICAgICAgICA8bGkgcm9sZT1cXFwicHJlc2VudGF0aW9uXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YSByb2xlPVxcXCJtZW51aXRlbVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIiBocmVmPVxcXCIjXFxcIj7lubPlnYflgLzorqHnrpc8L2E+XFxuICAgICAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9wPlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cIjtcbndpbmRvdy5hbmd1bGFyLm1vZHVsZSgnbmcnKS5ydW4oWyckdGVtcGxhdGVDYWNoZScsIGZ1bmN0aW9uKGMpIHsgYy5wdXQocGF0aCwgaHRtbCkgfV0pO1xubW9kdWxlLmV4cG9ydHMgPSBwYXRoO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3NjcmlwdC9jb21wb25lbnRzL2hlYWRlci9oZWFkZXIudmlldy5odG1sXG4vLyBtb2R1bGUgaWQgPSAxMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///107\n')},function(module,exports){eval('var path = \'/script/components/nav/nav.view.html\';\nvar html = "<nav class=\\"navbar navbar-inverse navbar-fixed-top\\">\\n    <div class=\\"container-fluid\\">\\n    \x3c!-- Brand and toggle get grouped for better mobile display --\x3e\\n    <div class=\\"navbar-header\\">\\n    <button type=\\"button\\" class=\\"navbar-toggle collapsed\\" data-toggle=\\"collapse\\" data-target=\\"#bs-example-navbar-collapse-1\\" aria-expanded=\\"false\\">\\n        <span class=\\"sr-only\\">Toggle navigation</span>\\n        <span class=\\"icon-bar\\"></span>\\n        <span class=\\"icon-bar\\"></span>\\n        <span class=\\"icon-bar\\"></span>\\n    </button>\\n    <a class=\\"navbar-brand\\" href=\\"#\\">Eda Plan</a>\\n    </div>\\n</nav>";\nwindow.angular.module(\'ng\').run([\'$templateCache\', function(c) { c.put(path, html) }]);\nmodule.exports = path;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdC9jb21wb25lbnRzL25hdi9uYXYudmlldy5odG1sPzFhOWEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHBhdGggPSAnL3NjcmlwdC9jb21wb25lbnRzL25hdi9uYXYudmlldy5odG1sJztcbnZhciBodG1sID0gXCI8bmF2IGNsYXNzPVxcXCJuYXZiYXIgbmF2YmFyLWludmVyc2UgbmF2YmFyLWZpeGVkLXRvcFxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbnRhaW5lci1mbHVpZFxcXCI+XFxuICAgIDwhLS0gQnJhbmQgYW5kIHRvZ2dsZSBnZXQgZ3JvdXBlZCBmb3IgYmV0dGVyIG1vYmlsZSBkaXNwbGF5IC0tPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJuYXZiYXItaGVhZGVyXFxcIj5cXG4gICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJuYXZiYXItdG9nZ2xlIGNvbGxhcHNlZFxcXCIgZGF0YS10b2dnbGU9XFxcImNvbGxhcHNlXFxcIiBkYXRhLXRhcmdldD1cXFwiI2JzLWV4YW1wbGUtbmF2YmFyLWNvbGxhcHNlLTFcXFwiIGFyaWEtZXhwYW5kZWQ9XFxcImZhbHNlXFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzci1vbmx5XFxcIj5Ub2dnbGUgbmF2aWdhdGlvbjwvc3Bhbj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uLWJhclxcXCI+PC9zcGFuPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb24tYmFyXFxcIj48L3NwYW4+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaWNvbi1iYXJcXFwiPjwvc3Bhbj5cXG4gICAgPC9idXR0b24+XFxuICAgIDxhIGNsYXNzPVxcXCJuYXZiYXItYnJhbmRcXFwiIGhyZWY9XFxcIiNcXFwiPkVkYSBQbGFuPC9hPlxcbiAgICA8L2Rpdj5cXG48L25hdj5cIjtcbndpbmRvdy5hbmd1bGFyLm1vZHVsZSgnbmcnKS5ydW4oWyckdGVtcGxhdGVDYWNoZScsIGZ1bmN0aW9uKGMpIHsgYy5wdXQocGF0aCwgaHRtbCkgfV0pO1xubW9kdWxlLmV4cG9ydHMgPSBwYXRoO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3NjcmlwdC9jb21wb25lbnRzL25hdi9uYXYudmlldy5odG1sXG4vLyBtb2R1bGUgaWQgPSAxMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///108\n')},function(module,exports){eval('var path = \'/script/pages/list_view/list.view.html\';\nvar html = "<div class=\\"container\\">\\n    <div class=\\"row\\" >\\n        <div class=\\"col-md-6 col-sm-6\\">\\n            <div class=\\"{{vm.style.fundSection}}\\">\\n                <h4 class=\\"{{vm.style.elemInline}}\\">已买入计划内部分：</h4>\\n                <div class=\\"dropdown {{vm.style.elemInline}}\\">\\n                    <button type=\\"button\\" class=\\"btn dropdown-toggle\\" id=\\"dropdownMenu\\" \\n                            data-toggle=\\"dropdown\\" ng-click=\\"vm.loadEdaFundList()\\">\\n                        选择Eda计划\\n                        <span class=\\"caret\\"></span>\\n                    </button>\\n                    <button type=\\"button\\" class=\\"btn btn-primary btn-sm\\" >确定</button>\\n                    <ul class=\\"dropdown-menu\\" role=\\"menu\\" aria-labelledby=\\"dropdownMenu\\">\\n                        <li role=\\"presentation\\">\\n                            <a role=\\"menuitem\\" tabindex=\\"-1\\" href=\\"#\\">Java</a>\\n                        </li>\\n                        <li role=\\"presentation\\">\\n                            <a role=\\"menuitem\\" tabindex=\\"-1\\" href=\\"#\\">数据挖掘</a>\\n                        </li>\\n                    </ul>\\n                </div>\\n            </div>\\n            <div class=\\"{{vm.style.fundList}}\\">\\n                <div class=\\"form-group {{vm.style.fundGroup}}\\">\\n                    <p class=\\"fund-title text-justify\\">\\n                        <label class=\\"{{vm.style.fundName}}\\">中证环保 \\n                            <span>(000671)</span>\\n                            <span class=\\"{{vm.style.avgNet}}\\">平均净值：1.678</span>\\n                        </label>\\n                    </p>\\n                    <div class=\\"form-inline {{vm.style.fundUnit}}\\">\\n                        <div class=\\"form-group\\">\\n                            <label for=\\"buyNet\\">1. 买入净值：</label>\\n                            <input type=\\"text\\" class=\\"form-control input-sm\\" id=\\"buyNet\\" placeholder=\\"买入净值\\">\\n                            <div class=\\"{{vm.style.buyNum}}\\">\\n                                <input type=\\"text\\" class=\\"form-control input-sm\\" placeholder=\\"100\\"> <span>份</span>\\n                            </div>\\n                        </div>\\n                        <div class=\\"{{vm.style.selectOptions}}\\">\\n                            <a class=\\"{{vm.style.add}}\\" href=\\"#\\"></a>\\n                            <a class=\\"{{vm.style.delete}}\\" href=\\"#\\"></a>\\n                        </div>\\n                    </div>\\n                    <div class=\\"form-inline {{vm.style.fundUnit}}\\">\\n                        <div class=\\"form-group\\">\\n                            <label for=\\"buyNet\\">1. 买入净值：</label>\\n                            <input type=\\"text\\" class=\\"form-control\\" id=\\"buyNet\\" placeholder=\\"买入净值\\">\\n                        </div>\\n                        <button type=\\"button\\" class=\\"btn btn-default\\">\\n                            <span class=\\"glyphicon glyphicon-plus\\"></span>\\n                        </button>\\n                        <button type=\\"button\\" class=\\"btn btn-default\\">\\n                            <span class=\\"glyphicon glyphicon-minus\\"></span>\\n                        </button>\\n                    </div>       \\n                </div>\\n                <div class=\\"form-group {{vm.style.fundGroup}}\\">\\n                    <p class=\\"fund-title text-justify\\">\\n                        <label class=\\"{{vm.style.fundName}}\\">中证环保 \\n                            <span>(000671)</span>\\n                            <span class=\\"{{vm.style.avgNet}}\\">平均净值：1.678</span>\\n                        </label>\\n                    </p>\\n                    <div class=\\"form-inline {{vm.style.fundUnit}}\\">\\n                        <div class=\\"form-group\\">\\n                            <label for=\\"buyNet\\">1. 买入净值：</label>\\n                            <input type=\\"text\\" class=\\"form-control\\" id=\\"buyNet\\" placeholder=\\"买入净值\\">\\n                        </div>\\n                        <button type=\\"button\\" class=\\"btn btn-default\\">\\n                            <span class=\\"glyphicon glyphicon-plus\\"></span>\\n                        </button>\\n                        <button type=\\"button\\" class=\\"btn btn-default\\">\\n                            <span class=\\"glyphicon glyphicon-minus\\"></span>\\n                        </button>\\n                    </div>\\n                    <div class=\\"form-inline {{vm.style.fundUnit}}\\">\\n                        <div class=\\"form-group\\">\\n                            <label for=\\"buyNet\\">1. 买入净值：</label>\\n                            <input type=\\"text\\" class=\\"form-control\\" id=\\"buyNet\\" placeholder=\\"买入净值\\">\\n                        </div>\\n                        <button type=\\"button\\" class=\\"btn btn-default\\">\\n                            <span class=\\"glyphicon glyphicon-plus\\"></span>\\n                        </button>\\n                        <button type=\\"button\\" class=\\"btn btn-default\\">\\n                            <span class=\\"glyphicon glyphicon-minus\\"></span>\\n                        </button>\\n                    </div>\\n                </div>\\n            </div>\\n        </div>\\n        <div class=\\"col-md-6 col-sm-6\\">\\n            <div class=\\"{{vm.style.fundSection}}\\">\\n                <h4 class=\\"{{vm.style.elemInline}}\\">已卖出计划内部分：</h4>\\n                <div class=\\"dropdown {{vm.style.elemInline}}\\">\\n                    <button type=\\"button\\" class=\\"btn dropdown-toggle\\" id=\\"dropdownMenu1\\" \\n                            data-toggle=\\"dropdown\\">\\n                        选择Eda计划\\n                        <span class=\\"caret\\"></span>\\n                    </button>\\n                    <button type=\\"button\\" class=\\"btn btn-primary\\">确定</button>\\n                    <ul class=\\"dropdown-menu\\" role=\\"menu\\" aria-labelledby=\\"dropdownMenu1\\">\\n                        <li role=\\"presentation\\">\\n                            <a role=\\"menuitem\\" tabindex=\\"-1\\" href=\\"#\\">Java</a>\\n                        </li>\\n                        <li role=\\"presentation\\">\\n                            <a role=\\"menuitem\\" tabindex=\\"-1\\" href=\\"#\\">数据挖掘</a>\\n                        </li>\\n                    </ul>\\n                </div>\\n            </div>\\n            <div class=\\"{{vm.style.fundList}}\\">\\n                <div class=\\"form-group {{vm.style.fundGroup}}\\">\\n                    <p class=\\"fund-title text-justify\\">\\n                        <label class=\\"{{vm.style.fundName}}\\">中证环保 \\n                            <span>(000671)</span>\\n                            <span class=\\"{{vm.style.avgNet}}\\">平均净值：1.678</span>\\n                        </label>\\n                    </p>\\n                    <div class=\\"form-inline {{vm.style.fundUnit}}\\">\\n                        <div class=\\"form-group\\">\\n                            <label for=\\"buyNet\\">1. 买入净值：</label>\\n                            <input type=\\"text\\" class=\\"form-control\\" id=\\"buyNet\\" placeholder=\\"买入净值\\">\\n                        </div>\\n                        <button type=\\"button\\" class=\\"btn btn-default\\">\\n                            <span class=\\"glyphicon glyphicon-plus\\"></span>\\n                        </button>\\n                        <button type=\\"button\\" class=\\"btn btn-default\\">\\n                            <span class=\\"glyphicon glyphicon-minus\\"></span>\\n                        </button>\\n                    </div>\\n                    <div class=\\"form-inline {{vm.style.fundUnit}}\\">\\n                        <div class=\\"form-group\\">\\n                            <label for=\\"buyNet\\">1. 买入净值：</label>\\n                            <input type=\\"text\\" class=\\"form-control\\" id=\\"buyNet\\" placeholder=\\"买入净值\\">\\n                        </div>\\n                        <button type=\\"button\\" class=\\"btn btn-default\\">\\n                            <span class=\\"glyphicon glyphicon-plus\\"></span>\\n                        </button>\\n                        <button type=\\"button\\" class=\\"btn btn-default\\">\\n                            <span class=\\"glyphicon glyphicon-minus\\"></span>\\n                        </button>\\n                    </div>       \\n                </div>\\n                <div class=\\"form-group {{vm.style.fundGroup}}\\">\\n                    <p class=\\"fund-title text-justify\\">\\n                        <label class=\\"{{vm.style.fundName}}\\">中证环保 \\n                            <span>(000671)</span>\\n                            <span class=\\"{{vm.style.avgNet}}\\">平均净值：1.678</span>\\n                        </label>\\n                    </p>\\n                    <div class=\\"form-inline {{vm.style.fundUnit}}\\">\\n                        <div class=\\"form-group\\">\\n                            <label for=\\"buyNet\\">1. 买入净值：</label>\\n                            <input type=\\"text\\" class=\\"form-control\\" id=\\"buyNet\\" placeholder=\\"买入净值\\">\\n                        </div>\\n                        <button type=\\"button\\" class=\\"btn btn-default\\">\\n                            <span class=\\"glyphicon glyphicon-plus\\"></span>\\n                        </button>\\n                        <button type=\\"button\\" class=\\"btn btn-default\\">\\n                            <span class=\\"glyphicon glyphicon-minus\\"></span>\\n                        </button>\\n                    </div>\\n                    <div class=\\"form-inline {{vm.style.fundUnit}}\\">\\n                        <div class=\\"form-group\\">\\n                            <label for=\\"buyNet\\">1. 买入净值：</label>\\n                            <input type=\\"text\\" class=\\"form-control\\" id=\\"buyNet\\" placeholder=\\"买入净值\\">\\n                        </div>\\n                        <button type=\\"button\\" class=\\"btn btn-default\\">\\n                            <span class=\\"glyphicon glyphicon-plus\\"></span>\\n                        </button>\\n                        <button type=\\"button\\" class=\\"btn btn-default\\">\\n                            <span class=\\"glyphicon glyphicon-minus\\"></span>\\n                        </button>\\n                    </div>\\n                </div>\\n            </div>\\n        </div>\\n    </div>\\n    \\n    <hr>\\n\\n    <footer>\\n        <p>&copy; 2016 Company, Inc.</p>\\n    </footer>\\n</div>";\nwindow.angular.module(\'ng\').run([\'$templateCache\', function(c) { c.put(path, html) }]);\nmodule.exports = path;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdC9wYWdlcy9saXN0X3ZpZXcvbGlzdC52aWV3Lmh0bWw/YzJmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcGF0aCA9ICcvc2NyaXB0L3BhZ2VzL2xpc3Rfdmlldy9saXN0LnZpZXcuaHRtbCc7XG52YXIgaHRtbCA9IFwiPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIiA+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtNiBjb2wtc20tNlxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwie3t2bS5zdHlsZS5mdW5kU2VjdGlvbn19XFxcIj5cXG4gICAgICAgICAgICAgICAgPGg0IGNsYXNzPVxcXCJ7e3ZtLnN0eWxlLmVsZW1JbmxpbmV9fVxcXCI+5bey5Lmw5YWl6K6h5YiS5YaF6YOo5YiG77yaPC9oND5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZHJvcGRvd24ge3t2bS5zdHlsZS5lbGVtSW5saW5lfX1cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gZHJvcGRvd24tdG9nZ2xlXFxcIiBpZD1cXFwiZHJvcGRvd25NZW51XFxcIiBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS10b2dnbGU9XFxcImRyb3Bkb3duXFxcIiBuZy1jbGljaz1cXFwidm0ubG9hZEVkYUZ1bmRMaXN0KClcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIOmAieaLqUVkYeiuoeWIklxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJjYXJldFxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeSBidG4tc21cXFwiID7noa7lrpo8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwiZHJvcGRvd24tbWVudVxcXCIgcm9sZT1cXFwibWVudVxcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJkcm9wZG93bk1lbnVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaSByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSByb2xlPVxcXCJtZW51aXRlbVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIiBocmVmPVxcXCIjXFxcIj5KYXZhPC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIHJvbGU9XFxcIm1lbnVpdGVtXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiIGhyZWY9XFxcIiNcXFwiPuaVsOaNruaMluaOmDwvYT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwie3t2bS5zdHlsZS5mdW5kTGlzdH19XFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cCB7e3ZtLnN0eWxlLmZ1bmRHcm91cH19XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXCJmdW5kLXRpdGxlIHRleHQtanVzdGlmeVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJ7e3ZtLnN0eWxlLmZ1bmROYW1lfX1cXFwiPuS4reivgeeOr+S/nSBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+KDAwMDY3MSk8L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ7e3ZtLnN0eWxlLmF2Z05ldH19XFxcIj7lubPlnYflh4DlgLzvvJoxLjY3ODwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgPC9wPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1pbmxpbmUge3t2bS5zdHlsZS5mdW5kVW5pdH19XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwiYnV5TmV0XFxcIj4xLiDkubDlhaXlh4DlgLzvvJo8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbCBpbnB1dC1zbVxcXCIgaWQ9XFxcImJ1eU5ldFxcXCIgcGxhY2Vob2xkZXI9XFxcIuS5sOWFpeWHgOWAvFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInt7dm0uc3R5bGUuYnV5TnVtfX1cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgaW5wdXQtc21cXFwiIHBsYWNlaG9sZGVyPVxcXCIxMDBcXFwiPiA8c3Bhbj7ku708L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInt7dm0uc3R5bGUuc2VsZWN0T3B0aW9uc319XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcInt7dm0uc3R5bGUuYWRkfX1cXFwiIGhyZWY9XFxcIiNcXFwiPjwvYT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcInt7dm0uc3R5bGUuZGVsZXRlfX1cXFwiIGhyZWY9XFxcIiNcXFwiPjwvYT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1pbmxpbmUge3t2bS5zdHlsZS5mdW5kVW5pdH19XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwiYnV5TmV0XFxcIj4xLiDkubDlhaXlh4DlgLzvvJo8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgaWQ9XFxcImJ1eU5ldFxcXCIgcGxhY2Vob2xkZXI9XFxcIuS5sOWFpeWHgOWAvFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1wbHVzXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1taW51c1xcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+ICAgICAgIFxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cCB7e3ZtLnN0eWxlLmZ1bmRHcm91cH19XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXCJmdW5kLXRpdGxlIHRleHQtanVzdGlmeVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJ7e3ZtLnN0eWxlLmZ1bmROYW1lfX1cXFwiPuS4reivgeeOr+S/nSBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+KDAwMDY3MSk8L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ7e3ZtLnN0eWxlLmF2Z05ldH19XFxcIj7lubPlnYflh4DlgLzvvJoxLjY3ODwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgPC9wPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1pbmxpbmUge3t2bS5zdHlsZS5mdW5kVW5pdH19XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwiYnV5TmV0XFxcIj4xLiDkubDlhaXlh4DlgLzvvJo8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgaWQ9XFxcImJ1eU5ldFxcXCIgcGxhY2Vob2xkZXI9XFxcIuS5sOWFpeWHgOWAvFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1wbHVzXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1taW51c1xcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWlubGluZSB7e3ZtLnN0eWxlLmZ1bmRVbml0fX1cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJidXlOZXRcXFwiPjEuIOS5sOWFpeWHgOWAvO+8mjwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBpZD1cXFwiYnV5TmV0XFxcIiBwbGFjZWhvbGRlcj1cXFwi5Lmw5YWl5YeA5YC8XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLXBsdXNcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLW1pbnVzXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC02IGNvbC1zbS02XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ7e3ZtLnN0eWxlLmZ1bmRTZWN0aW9ufX1cXFwiPlxcbiAgICAgICAgICAgICAgICA8aDQgY2xhc3M9XFxcInt7dm0uc3R5bGUuZWxlbUlubGluZX19XFxcIj7lt7LljZblh7rorqHliJLlhoXpg6jliIbvvJo8L2g0PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkcm9wZG93biB7e3ZtLnN0eWxlLmVsZW1JbmxpbmV9fVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBkcm9wZG93bi10b2dnbGVcXFwiIGlkPVxcXCJkcm9wZG93bk1lbnUxXFxcIiBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS10b2dnbGU9XFxcImRyb3Bkb3duXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICDpgInmi6lFZGHorqHliJJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiY2FyZXRcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXByaW1hcnlcXFwiPuehruWumjwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJkcm9wZG93bi1tZW51XFxcIiByb2xlPVxcXCJtZW51XFxcIiBhcmlhLWxhYmVsbGVkYnk9XFxcImRyb3Bkb3duTWVudTFcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaSByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSByb2xlPVxcXCJtZW51aXRlbVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIiBocmVmPVxcXCIjXFxcIj5KYXZhPC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIHJvbGU9XFxcIm1lbnVpdGVtXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiIGhyZWY9XFxcIiNcXFwiPuaVsOaNruaMluaOmDwvYT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwie3t2bS5zdHlsZS5mdW5kTGlzdH19XFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cCB7e3ZtLnN0eWxlLmZ1bmRHcm91cH19XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXCJmdW5kLXRpdGxlIHRleHQtanVzdGlmeVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJ7e3ZtLnN0eWxlLmZ1bmROYW1lfX1cXFwiPuS4reivgeeOr+S/nSBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+KDAwMDY3MSk8L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ7e3ZtLnN0eWxlLmF2Z05ldH19XFxcIj7lubPlnYflh4DlgLzvvJoxLjY3ODwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgPC9wPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1pbmxpbmUge3t2bS5zdHlsZS5mdW5kVW5pdH19XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwiYnV5TmV0XFxcIj4xLiDkubDlhaXlh4DlgLzvvJo8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgaWQ9XFxcImJ1eU5ldFxcXCIgcGxhY2Vob2xkZXI9XFxcIuS5sOWFpeWHgOWAvFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1wbHVzXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1taW51c1xcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWlubGluZSB7e3ZtLnN0eWxlLmZ1bmRVbml0fX1cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJidXlOZXRcXFwiPjEuIOS5sOWFpeWHgOWAvO+8mjwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBpZD1cXFwiYnV5TmV0XFxcIiBwbGFjZWhvbGRlcj1cXFwi5Lmw5YWl5YeA5YC8XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLXBsdXNcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLW1pbnVzXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwIHt7dm0uc3R5bGUuZnVuZEdyb3VwfX1cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcImZ1bmQtdGl0bGUgdGV4dC1qdXN0aWZ5XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcInt7dm0uc3R5bGUuZnVuZE5hbWV9fVxcXCI+5Lit6K+B546v5L+dIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj4oMDAwNjcxKTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInt7dm0uc3R5bGUuYXZnTmV0fX1cXFwiPuW5s+Wdh+WHgOWAvO+8mjEuNjc4PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICA8L3A+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWlubGluZSB7e3ZtLnN0eWxlLmZ1bmRVbml0fX1cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJidXlOZXRcXFwiPjEuIOS5sOWFpeWHgOWAvO+8mjwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBpZD1cXFwiYnV5TmV0XFxcIiBwbGFjZWhvbGRlcj1cXFwi5Lmw5YWl5YeA5YC8XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLXBsdXNcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLW1pbnVzXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvcm0taW5saW5lIHt7dm0uc3R5bGUuZnVuZFVuaXR9fVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImJ1eU5ldFxcXCI+MS4g5Lmw5YWl5YeA5YC877yaPC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIGlkPVxcXCJidXlOZXRcXFwiIHBsYWNlaG9sZGVyPVxcXCLkubDlhaXlh4DlgLxcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tcGx1c1xcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tbWludXNcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgXFxuICAgIDxocj5cXG5cXG4gICAgPGZvb3Rlcj5cXG4gICAgICAgIDxwPiZjb3B5OyAyMDE2IENvbXBhbnksIEluYy48L3A+XFxuICAgIDwvZm9vdGVyPlxcbjwvZGl2PlwiO1xud2luZG93LmFuZ3VsYXIubW9kdWxlKCduZycpLnJ1bihbJyR0ZW1wbGF0ZUNhY2hlJywgZnVuY3Rpb24oYykgeyBjLnB1dChwYXRoLCBodG1sKSB9XSk7XG5tb2R1bGUuZXhwb3J0cyA9IHBhdGg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc2NyaXB0L3BhZ2VzL2xpc3Rfdmlldy9saXN0LnZpZXcuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///109\n')},function(module,exports){eval('var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1,eval)("this");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === "object")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcz8zNjk4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///110\n')}],[103]);